/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabric";
exports.ids = ["vendor-chunks/fabric"];
exports.modules = {

/***/ "(ssr)/./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ var fabric = fabric || {\n    version: \"5.3.0\"\n};\nif (true) {\n    exports.fabric = fabric;\n} else {}\n/* _AMD_END_ */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {} else {\n    // assume we're running under node.js when document/window are not present\n    var jsdom = __webpack_require__(/*! jsdom */ \"(ssr)/./node_modules/jsdom/lib/api.js\");\n    var virtualWindow = new jsdom.JSDOM(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n            FetchExternalResources: [\n                \"img\"\n            ]\n        },\n        resources: \"usable\"\n    }).window;\n    fabric.document = virtualWindow.document;\n    fabric.jsdomImplForWrapper = (__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"(ssr)/./node_modules/jsdom/lib/jsdom/living/generated/utils.js\").implForWrapper);\n    fabric.nodeCanvas = (__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"(ssr)/./node_modules/jsdom/lib/jsdom/utils.js\").Canvas);\n    fabric.window = virtualWindow;\n    DOMParser = fabric.window.DOMParser;\n}\n/**\n * True when in environment that supports touch events\n * @type boolean\n */ fabric.isTouchSupported = \"ontouchstart\" in fabric.window || \"ontouchstart\" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;\n/**\n * True when in environment that's probably Node.js\n * @type boolean\n */ fabric.isLikelyNode = typeof Buffer !== \"undefined\" && \"undefined\" === \"undefined\";\n/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */ fabric.SHARED_ATTRIBUTES = [\n    \"display\",\n    \"transform\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"opacity\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-linecap\",\n    \"stroke-dashoffset\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"id\",\n    \"paint-order\",\n    \"vector-effect\",\n    \"instantiated_by_use\",\n    \"clip-path\"\n];\n/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */ fabric.DPI = 96;\nfabric.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)\";\nfabric.commaWsp = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\";\nfabric.rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;\nfabric.reNonWord = /[ \\n\\.,;!\\?\\-]/;\nfabric.fontPaths = {};\nfabric.iMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nfabric.svgNS = \"http://www.w3.org/2000/svg\";\n/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.perfLimitSizeTotal = 2097152;\n/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.maxCacheSideLimit = 4096;\n/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.minCacheSideLimit = 256;\n/**\n * Cache Object for widths of chars in text rendering.\n */ fabric.charWidthsCache = {};\n/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */ fabric.textureSize = 2048;\n/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */ fabric.disableStyleCopyPaste = false;\n/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */ fabric.enableGLFiltering = true;\n/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */ fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;\n/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */ fabric.browserShadowBlurConstant = 1;\n/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.arcToSegmentsCache = {};\n/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.boundsOfCurveCache = {};\n/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */ fabric.cachesBoundsOfCurve = true;\n/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */ fabric.forceGLPutImageData = false;\nfabric.initFilterBackend = function() {\n    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {\n        console.log(\"max texture size: \" + fabric.maxTextureSize);\n        return new fabric.WebglFilterBackend({\n            tileSize: fabric.textureSize\n        });\n    } else if (fabric.Canvas2dFilterBackend) {\n        return new fabric.Canvas2dFilterBackend();\n    }\n};\nif (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\n(function() {\n    /**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */ function _removeEventListener(eventName, handler) {\n        if (!this.__eventListeners[eventName]) {\n            return;\n        }\n        var eventListener = this.__eventListeners[eventName];\n        if (handler) {\n            eventListener[eventListener.indexOf(handler)] = false;\n        } else {\n            fabric.util.array.fill(eventListener, false);\n        }\n    }\n    /**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ function on(eventName, handler) {\n        if (!this.__eventListeners) {\n            this.__eventListeners = {};\n        }\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                this.on(prop, eventName[prop]);\n            }\n        } else {\n            if (!this.__eventListeners[eventName]) {\n                this.__eventListeners[eventName] = [];\n            }\n            this.__eventListeners[eventName].push(handler);\n        }\n        return this;\n    }\n    function _once(eventName, handler) {\n        var _handler = (function() {\n            handler.apply(this, arguments);\n            this.off(eventName, _handler);\n        }).bind(this);\n        this.on(eventName, _handler);\n    }\n    function once(eventName, handler) {\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                _once.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _once.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */ function off(eventName, handler) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        // remove all key/value pairs (event name -> event handler)\n        if (arguments.length === 0) {\n            for(eventName in this.__eventListeners){\n                _removeEventListener.call(this, eventName);\n            }\n        } else if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            for(var prop in eventName){\n                _removeEventListener.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _removeEventListener.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */ function fire(eventName, options) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        var listenersForEvent = this.__eventListeners[eventName];\n        if (!listenersForEvent) {\n            return this;\n        }\n        for(var i = 0, len = listenersForEvent.length; i < len; i++){\n            listenersForEvent[i] && listenersForEvent[i].call(this, options || {});\n        }\n        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\n            return value !== false;\n        });\n        return this;\n    }\n    /**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */ fabric.Observable = {\n        fire: fire,\n        on: on,\n        once: once,\n        off: off\n    };\n})();\n/**\n * @namespace fabric.Collection\n */ fabric.Collection = {\n    _objects: [],\n    /**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ add: function() {\n        this._objects.push.apply(this._objects, arguments);\n        if (this._onObjectAdded) {\n            for(var i = 0, length = arguments.length; i < length; i++){\n                this._onObjectAdded(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ insertAt: function(object, index, nonSplicing) {\n        var objects = this._objects;\n        if (nonSplicing) {\n            objects[index] = object;\n        } else {\n            objects.splice(index, 0, object);\n        }\n        this._onObjectAdded && this._onObjectAdded(object);\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ remove: function() {\n        var objects = this._objects, index, somethingRemoved = false;\n        for(var i = 0, length = arguments.length; i < length; i++){\n            index = objects.indexOf(arguments[i]);\n            // only call onObjectRemoved if an object was actually removed\n            if (index !== -1) {\n                somethingRemoved = true;\n                objects.splice(index, 1);\n                this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */ forEachObject: function(callback, context) {\n        var objects = this.getObjects();\n        for(var i = 0, len = objects.length; i < len; i++){\n            callback.call(context, objects[i], i, objects);\n        }\n        return this;\n    },\n    /**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */ getObjects: function(type) {\n        if (typeof type === \"undefined\") {\n            return this._objects.concat();\n        }\n        return this._objects.filter(function(o) {\n            return o.type === type;\n        });\n    },\n    /**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */ item: function(index) {\n        return this._objects[index];\n    },\n    /**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */ isEmpty: function() {\n        return this._objects.length === 0;\n    },\n    /**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */ size: function() {\n        return this._objects.length;\n    },\n    /**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */ contains: function(object, deep) {\n        if (this._objects.indexOf(object) > -1) {\n            return true;\n        } else if (deep) {\n            return this._objects.some(function(obj) {\n                return typeof obj.contains === \"function\" && obj.contains(object, true);\n            });\n        }\n        return false;\n    },\n    /**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */ complexity: function() {\n        return this._objects.reduce(function(memo, current) {\n            memo += current.complexity ? current.complexity() : 0;\n            return memo;\n        }, 0);\n    }\n};\n/**\n * @namespace fabric.CommonMethods\n */ fabric.CommonMethods = {\n    /**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */ _setOptions: function(options) {\n        for(var prop in options){\n            this.set(prop, options[prop]);\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */ _initGradient: function(filler, property) {\n        if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {\n            this.set(property, new fabric.Gradient(filler));\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */ _initPattern: function(filler, property, callback) {\n        if (filler && filler.source && !(filler instanceof fabric.Pattern)) {\n            this.set(property, new fabric.Pattern(filler, callback));\n        } else {\n            callback && callback();\n        }\n    },\n    /**\n   * @private\n   */ _setObject: function(obj) {\n        for(var prop in obj){\n            this._set(prop, obj[prop]);\n        }\n    },\n    /**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ set: function(key, value) {\n        if (typeof key === \"object\") {\n            this._setObject(key);\n        } else {\n            this._set(key, value);\n        }\n        return this;\n    },\n    _set: function(key, value) {\n        this[key] = value;\n    },\n    /**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ toggle: function(property) {\n        var value = this.get(property);\n        if (typeof value === \"boolean\") {\n            this.set(property, !value);\n        }\n        return this;\n    },\n    /**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */ get: function(property) {\n        return this[property];\n    }\n};\n(function(global) {\n    var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;\n    /**\n   * @namespace fabric.util\n   */ fabric.util = {\n        /**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ cos: function(angle) {\n            if (angle === 0) {\n                return 1;\n            }\n            if (angle < 0) {\n                // cos(a) = cos(-a)\n                angle = -angle;\n            }\n            var angleSlice = angle / PiBy2;\n            switch(angleSlice){\n                case 1:\n                case 3:\n                    return 0;\n                case 2:\n                    return -1;\n            }\n            return Math.cos(angle);\n        },\n        /**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ sin: function(angle) {\n            if (angle === 0) {\n                return 0;\n            }\n            var angleSlice = angle / PiBy2, sign = 1;\n            if (angle < 0) {\n                // sin(-a) = -sin(a)\n                sign = -1;\n            }\n            switch(angleSlice){\n                case 1:\n                    return sign;\n                case 2:\n                    return 0;\n                case 3:\n                    return -sign;\n            }\n            return Math.sin(angle);\n        },\n        /**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */ removeFromArray: function(array, value) {\n            var idx = array.indexOf(value);\n            if (idx !== -1) {\n                array.splice(idx, 1);\n            }\n            return array;\n        },\n        /**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */ getRandomInt: function(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        /**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */ degreesToRadians: function(degrees) {\n            return degrees * PiBy180;\n        },\n        /**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */ radiansToDegrees: function(radians) {\n            return radians / PiBy180;\n        },\n        /**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */ rotatePoint: function(point, origin, radians) {\n            var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);\n            return new fabric.Point(v.x, v.y).addEquals(origin);\n        },\n        /**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */ rotateVector: function(vector, radians) {\n            var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;\n            return {\n                x: rx,\n                y: ry\n            };\n        },\n        /**\n     * Creates a vetor from points represented as a point\n     * @static\n     * @memberOf fabric.util\n     *\n     * @typedef {Object} Point\n     * @property {number} x\n     * @property {number} y\n     *\n     * @param {Point} from\n     * @param {Point} to\n     * @returns {Point} vector\n     */ createVector: function(from, to) {\n            return new fabric.Point(to.x - from.x, to.y - from.y);\n        },\n        /**\n     * Calculates angle between 2 vectors using dot product\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} a\n     * @param {Point} b\n     * @returns the angle in radian between the vectors\n     */ calcAngleBetweenVectors: function(a, b) {\n            return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} v\n     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`\n     */ getHatVector: function(v) {\n            return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} A\n     * @param {Point} B\n     * @param {Point} C\n     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle\n     */ getBisector: function(A, B, C) {\n            var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);\n            var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);\n            //  check if alpha is relative to AB->BC\n            var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);\n            var phi = alpha * (ro === 0 ? 1 : -1) / 2;\n            return {\n                vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),\n                angle: alpha\n            };\n        },\n        /**\n     * Project stroke width on points returning 2 projections for each point as follows:\n     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.\n     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.\n     * - `round`: same as `bevel`\n     * Used to calculate object's bounding box\n     * @static\n     * @memberOf fabric.util\n     * @param {Point[]} points\n     * @param {Object} options\n     * @param {number} options.strokeWidth\n     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin\n     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n     * @param {boolean} options.strokeUniform\n     * @param {number} options.scaleX\n     * @param {number} options.scaleY\n     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points\n     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points\n     */ projectStrokeOnPoints: function(points, options, openPath) {\n            var coords = [], s = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1), getStrokeHatVector = function(v) {\n                var scalar = s / Math.hypot(v.x, v.y);\n                return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);\n            };\n            if (points.length <= 1) {\n                return coords;\n            }\n            points.forEach(function(p, index) {\n                var A = new fabric.Point(p.x, p.y), B, C;\n                if (index === 0) {\n                    C = points[index + 1];\n                    B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];\n                } else if (index === points.length - 1) {\n                    B = points[index - 1];\n                    C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];\n                } else {\n                    B = points[index - 1];\n                    C = points[index + 1];\n                }\n                var bisector = fabric.util.getBisector(A, B, C), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;\n                if (options.strokeLineJoin === \"miter\") {\n                    scalar = -s / Math.sin(alpha / 2);\n                    miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                    if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {\n                        coords.push(A.add(miterVector));\n                        coords.push(A.subtract(miterVector));\n                        return;\n                    }\n                }\n                scalar = -s * Math.SQRT2;\n                miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                coords.push(A.add(miterVector));\n                coords.push(A.subtract(miterVector));\n            });\n            return coords;\n        },\n        /**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */ transformPoint: function(p, t, ignoreOffset) {\n            if (ignoreOffset) {\n                return new fabric.Point(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);\n            }\n            return new fabric.Point(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);\n        },\n        /**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */ makeBoundingBoxFromPoints: function(points, transform) {\n            if (transform) {\n                for(var i = 0; i < points.length; i++){\n                    points[i] = fabric.util.transformPoint(points[i], transform);\n                }\n            }\n            var xPoints = [\n                points[0].x,\n                points[1].x,\n                points[2].x,\n                points[3].x\n            ], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [\n                points[0].y,\n                points[1].y,\n                points[2].y,\n                points[3].y\n            ], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */ invertTransform: function(t) {\n            var a = 1 / (t[0] * t[3] - t[1] * t[2]), r = [\n                a * t[3],\n                -a * t[1],\n                -a * t[2],\n                a * t[0]\n            ], o = fabric.util.transformPoint({\n                x: t[4],\n                y: t[5]\n            }, r, true);\n            r[4] = -o.x;\n            r[5] = -o.y;\n            return r;\n        },\n        /**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */ toFixed: function(number, fractionDigits) {\n            return parseFloat(Number(number).toFixed(fractionDigits));\n        },\n        /**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */ parseUnit: function(value, fontSize) {\n            var unit = /\\D{0,2}$/.exec(value), number = parseFloat(value);\n            if (!fontSize) {\n                fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            }\n            switch(unit[0]){\n                case \"mm\":\n                    return number * fabric.DPI / 25.4;\n                case \"cm\":\n                    return number * fabric.DPI / 2.54;\n                case \"in\":\n                    return number * fabric.DPI;\n                case \"pt\":\n                    return number * fabric.DPI / 72; // or * 4 / 3\n                case \"pc\":\n                    return number * fabric.DPI / 72 * 12; // or * 16\n                case \"em\":\n                    return number * fontSize;\n                default:\n                    return number;\n            }\n        },\n        /**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */ falseFunction: function() {\n            return false;\n        },\n        /**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */ getKlass: function(type, namespace) {\n            // capitalize first letter only\n            type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\n            return fabric.util.resolveNamespace(namespace)[type];\n        },\n        /**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */ getSvgAttributes: function(type) {\n            var attributes = [\n                \"instantiated_by_use\",\n                \"style\",\n                \"id\",\n                \"class\"\n            ];\n            switch(type){\n                case \"linearGradient\":\n                    attributes = attributes.concat([\n                        \"x1\",\n                        \"y1\",\n                        \"x2\",\n                        \"y2\",\n                        \"gradientUnits\",\n                        \"gradientTransform\"\n                    ]);\n                    break;\n                case \"radialGradient\":\n                    attributes = attributes.concat([\n                        \"gradientUnits\",\n                        \"gradientTransform\",\n                        \"cx\",\n                        \"cy\",\n                        \"r\",\n                        \"fx\",\n                        \"fy\",\n                        \"fr\"\n                    ]);\n                    break;\n                case \"stop\":\n                    attributes = attributes.concat([\n                        \"offset\",\n                        \"stop-color\",\n                        \"stop-opacity\"\n                    ]);\n                    break;\n            }\n            return attributes;\n        },\n        /**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */ resolveNamespace: function(namespace) {\n            if (!namespace) {\n                return fabric;\n            }\n            var parts = namespace.split(\".\"), len = parts.length, i, obj = global || fabric.window;\n            for(i = 0; i < len; ++i){\n                obj = obj[parts[i]];\n            }\n            return obj;\n        },\n        /**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */ loadImage: function(url, callback, context, crossOrigin) {\n            if (!url) {\n                callback && callback.call(context, url);\n                return;\n            }\n            var img = fabric.util.createImage();\n            /** @ignore */ var onLoadCallback = function() {\n                callback && callback.call(context, img, false);\n                img = img.onload = img.onerror = null;\n            };\n            img.onload = onLoadCallback;\n            /** @ignore */ img.onerror = function() {\n                fabric.log(\"Error loading \" + img.src);\n                callback && callback.call(context, null, true);\n                img = img.onload = img.onerror = null;\n            };\n            // data-urls appear to be buggy with crossOrigin\n            // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n            // see https://code.google.com/p/chromium/issues/detail?id=315152\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n            // crossOrigin null is the same as not set.\n            if (url.indexOf(\"data\") !== 0 && crossOrigin !== undefined && crossOrigin !== null) {\n                img.crossOrigin = crossOrigin;\n            }\n            // IE10 / IE11-Fix: SVG contents from data: URI\n            // will only be available if the IMG is present\n            // in the DOM (and visible)\n            if (url.substring(0, 14) === \"data:image/svg\") {\n                img.onload = null;\n                fabric.util.loadImageInDom(img, onLoadCallback);\n            }\n            img.src = url;\n        },\n        /**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */ loadImageInDom: function(img, onLoadCallback) {\n            var div = fabric.document.createElement(\"div\");\n            div.style.width = div.style.height = \"1px\";\n            div.style.left = div.style.top = \"-100%\";\n            div.style.position = \"absolute\";\n            div.appendChild(img);\n            fabric.document.querySelector(\"body\").appendChild(div);\n            /**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */ img.onload = function() {\n                onLoadCallback();\n                div.parentNode.removeChild(div);\n                div = null;\n            };\n        },\n        /**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */ enlivenObjects: function(objects, callback, namespace, reviver) {\n            objects = objects || [];\n            var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;\n            function onLoaded() {\n                if (++numLoadedObjects === numTotalObjects) {\n                    callback && callback(enlivenedObjects.filter(function(obj) {\n                        // filter out undefined objects (objects that gave error)\n                        return obj;\n                    }));\n                }\n            }\n            if (!numTotalObjects) {\n                callback && callback(enlivenedObjects);\n                return;\n            }\n            objects.forEach(function(o, index) {\n                // if sparse array\n                if (!o || !o.type) {\n                    onLoaded();\n                    return;\n                }\n                var klass = fabric.util.getKlass(o.type, namespace);\n                klass.fromObject(o, function(obj, error) {\n                    error || (enlivenedObjects[index] = obj);\n                    reviver && reviver(o, obj, error);\n                    onLoaded();\n                });\n            });\n        },\n        /**\n     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`\n     * @see {@link fabric.Object.ENLIVEN_PROPS}\n     * @param {Object} object\n     * @param {Object} [context] assign enlived props to this object (pass null to skip this)\n     * @param {(objects:fabric.Object[]) => void} callback\n     */ enlivenObjectEnlivables: function(object, context, callback) {\n            var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function(key) {\n                return !!object[key];\n            });\n            fabric.util.enlivenObjects(enlivenProps.map(function(key) {\n                return object[key];\n            }), function(enlivedProps) {\n                var objects = {};\n                enlivenProps.forEach(function(key, index) {\n                    objects[key] = enlivedProps[index];\n                    context && (context[key] = enlivedProps[index]);\n                });\n                callback && callback(objects);\n            });\n        },\n        /**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */ enlivenPatterns: function(patterns, callback) {\n            patterns = patterns || [];\n            function onLoaded() {\n                if (++numLoadedPatterns === numPatterns) {\n                    callback && callback(enlivenedPatterns);\n                }\n            }\n            var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;\n            if (!numPatterns) {\n                callback && callback(enlivenedPatterns);\n                return;\n            }\n            patterns.forEach(function(p, index) {\n                if (p && p.source) {\n                    new fabric.Pattern(p, function(pattern) {\n                        enlivenedPatterns[index] = pattern;\n                        onLoaded();\n                    });\n                } else {\n                    enlivenedPatterns[index] = p;\n                    onLoaded();\n                }\n            });\n        },\n        /**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */ groupSVGElements: function(elements, options, path) {\n            var object;\n            if (elements && elements.length === 1) {\n                if (typeof path !== \"undefined\") {\n                    elements[0].sourcePath = path;\n                }\n                return elements[0];\n            }\n            if (options) {\n                if (options.width && options.height) {\n                    options.centerPoint = {\n                        x: options.width / 2,\n                        y: options.height / 2\n                    };\n                } else {\n                    delete options.width;\n                    delete options.height;\n                }\n            }\n            object = new fabric.Group(elements, options);\n            if (typeof path !== \"undefined\") {\n                object.sourcePath = path;\n            }\n            return object;\n        },\n        /**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */ populateWithProperties: function(source, destination, properties) {\n            if (properties && Array.isArray(properties)) {\n                for(var i = 0, len = properties.length; i < len; i++){\n                    if (properties[i] in source) {\n                        destination[properties[i]] = source[properties[i]];\n                    }\n                }\n            }\n        },\n        /**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ createCanvasElement: function() {\n            return fabric.document.createElement(\"canvas\");\n        },\n        /**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ copyCanvasElement: function(canvas) {\n            var newCanvas = fabric.util.createCanvasElement();\n            newCanvas.width = canvas.width;\n            newCanvas.height = canvas.height;\n            newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            return newCanvas;\n        },\n        /**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */ toDataURL: function(canvasEl, format, quality) {\n            return canvasEl.toDataURL(\"image/\" + format, quality);\n        },\n        /**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */ createImage: function() {\n            return fabric.document.createElement(\"img\");\n        },\n        /**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */ multiplyTransformMatrices: function(a, b, is2x2) {\n            // Matrix multiply a * b\n            return [\n                a[0] * b[0] + a[2] * b[1],\n                a[1] * b[0] + a[3] * b[1],\n                a[0] * b[2] + a[2] * b[3],\n                a[1] * b[2] + a[3] * b[3],\n                is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n                is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\n            ];\n        },\n        /**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */ qrDecompose: function(a) {\n            var angle = atan2(a[1], a[0]), denom = pow(a[0], 2) + pow(a[1], 2), scaleX = sqrt(denom), scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX, skewX = atan2(a[0] * a[2] + a[1] * a[3], denom);\n            return {\n                angle: angle / PiBy180,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                skewX: skewX / PiBy180,\n                skewY: 0,\n                translateX: a[4],\n                translateY: a[5]\n            };\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */ calcRotateMatrix: function(options) {\n            if (!options.angle) {\n                return fabric.iMatrix.concat();\n            }\n            var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);\n            return [\n                cos,\n                sin,\n                -sin,\n                cos,\n                0,\n                0\n            ];\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewY]\n     * @return {Number[]} transform matrix\n     */ calcDimensionsMatrix: function(options) {\n            var scaleX = typeof options.scaleX === \"undefined\" ? 1 : options.scaleX, scaleY = typeof options.scaleY === \"undefined\" ? 1 : options.scaleY, scaleMatrix = [\n                options.flipX ? -scaleX : scaleX,\n                0,\n                0,\n                options.flipY ? -scaleY : scaleY,\n                0,\n                0\n            ], multiply = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;\n            if (options.skewX) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    0,\n                    Math.tan(degreesToRadians(options.skewX)),\n                    1\n                ], true);\n            }\n            if (options.skewY) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    Math.tan(degreesToRadians(options.skewY)),\n                    0,\n                    1\n                ], true);\n            }\n            return scaleMatrix;\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */ composeMatrix: function(options) {\n            var matrix = [\n                1,\n                0,\n                0,\n                1,\n                options.translateX || 0,\n                options.translateY || 0\n            ], multiply = fabric.util.multiplyTransformMatrices;\n            if (options.angle) {\n                matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));\n            }\n            if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {\n                matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));\n            }\n            return matrix;\n        },\n        /**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */ resetObjectTransform: function(target) {\n            target.scaleX = 1;\n            target.scaleY = 1;\n            target.skewX = 0;\n            target.skewY = 0;\n            target.flipX = false;\n            target.flipY = false;\n            target.rotate(0);\n        },\n        /**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */ saveObjectTransform: function(target) {\n            return {\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                angle: target.angle,\n                left: target.left,\n                flipX: target.flipX,\n                flipY: target.flipY,\n                top: target.top\n            };\n        },\n        /**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */ isTransparent: function(ctx, x, y, tolerance) {\n            // If tolerance is > 0 adjust start coords to take into account.\n            // If moves off Canvas fix to 0\n            if (tolerance > 0) {\n                if (x > tolerance) {\n                    x -= tolerance;\n                } else {\n                    x = 0;\n                }\n                if (y > tolerance) {\n                    y -= tolerance;\n                } else {\n                    y = 0;\n                }\n            }\n            var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;\n            // Split image data - for tolerance > 1, pixelDataSize = 4;\n            for(i = 3; i < l; i += 4){\n                temp = imageData.data[i];\n                _isTransparent = temp <= 0;\n                if (_isTransparent === false) {\n                    break; // Stop if colour found\n                }\n            }\n            imageData = null;\n            return _isTransparent;\n        },\n        /**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */ parsePreserveAspectRatioAttribute: function(attribute) {\n            var meetOrSlice = \"meet\", alignX = \"Mid\", alignY = \"Mid\", aspectRatioAttrs = attribute.split(\" \"), align;\n            if (aspectRatioAttrs && aspectRatioAttrs.length) {\n                meetOrSlice = aspectRatioAttrs.pop();\n                if (meetOrSlice !== \"meet\" && meetOrSlice !== \"slice\") {\n                    align = meetOrSlice;\n                    meetOrSlice = \"meet\";\n                } else if (aspectRatioAttrs.length) {\n                    align = aspectRatioAttrs.pop();\n                }\n            }\n            //divide align in alignX and alignY\n            alignX = align !== \"none\" ? align.slice(1, 4) : \"none\";\n            alignY = align !== \"none\" ? align.slice(5, 8) : \"none\";\n            return {\n                meetOrSlice: meetOrSlice,\n                alignX: alignX,\n                alignY: alignY\n            };\n        },\n        /**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */ clearFabricFontCache: function(fontFamily) {\n            fontFamily = (fontFamily || \"\").toLowerCase();\n            if (!fontFamily) {\n                fabric.charWidthsCache = {};\n            } else if (fabric.charWidthsCache[fontFamily]) {\n                delete fabric.charWidthsCache[fontFamily];\n            }\n        },\n        /**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */ limitDimsByArea: function(ar, maximumArea) {\n            var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);\n            return {\n                x: Math.floor(roughWidth),\n                y: perfLimitSizeY\n            };\n        },\n        capValue: function(min, value, max) {\n            return Math.max(min, Math.min(value, max));\n        },\n        /**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */ findScaleToFit: function(source, destination) {\n            return Math.min(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */ findScaleToCover: function(source, destination) {\n            return Math.max(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */ matrixToSVG: function(transform) {\n            return \"matrix(\" + transform.map(function(value) {\n                return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\";\n        },\n        /**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ removeTransformFromObject: function(object, transform) {\n            var inverted = fabric.util.invertTransform(transform), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());\n            fabric.util.applyTransformToObject(object, finalTransform);\n        },\n        /**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ addTransformToObject: function(object, transform) {\n            fabric.util.applyTransformToObject(object, fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix()));\n        },\n        /**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ applyTransformToObject: function(object, transform) {\n            var options = fabric.util.qrDecompose(transform), center = new fabric.Point(options.translateX, options.translateY);\n            object.flipX = false;\n            object.flipY = false;\n            object.set(\"scaleX\", options.scaleX);\n            object.set(\"scaleY\", options.scaleY);\n            object.skewX = options.skewX;\n            object.skewY = options.skewY;\n            object.angle = options.angle;\n            object.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */ sizeAfterTransform: function(width, height, options) {\n            var dimX = width / 2, dimY = height / 2, points = [\n                {\n                    x: -dimX,\n                    y: -dimY\n                },\n                {\n                    x: dimX,\n                    y: -dimY\n                },\n                {\n                    x: -dimX,\n                    y: dimY\n                },\n                {\n                    x: dimX,\n                    y: dimY\n                }\n            ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);\n            return {\n                x: bbox.width,\n                y: bbox.height\n            };\n        },\n        /**\n     * Merges 2 clip paths into one visually equal clip path\n     *\n     * **IMPORTANT**:\\\n     * Does **NOT** clone the arguments, clone them proir if necessary.\n     *\n     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n     *\n     * In order to handle the `inverted` property we follow logic described in the following cases:\\\n     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n     *\n     * @memberOf fabric.util\n     * @param {fabric.Object} c1\n     * @param {fabric.Object} c2\n     * @returns {fabric.Object} merged clip path\n     */ mergeClipPaths: function(c1, c2) {\n            var a = c1, b = c2;\n            if (a.inverted && !b.inverted) {\n                //  case (2)\n                a = c2;\n                b = c1;\n            }\n            //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n            fabric.util.applyTransformToObject(b, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(a.calcTransformMatrix()), b.calcTransformMatrix()));\n            //  assign the `inverted` prop to the wrapping group\n            var inverted = a.inverted && b.inverted;\n            if (inverted) {\n                //  case (1)\n                a.inverted = b.inverted = false;\n            }\n            return new fabric.Group([\n                a\n            ], {\n                clipPath: b,\n                inverted: inverted\n            });\n        },\n        /**\n     * @memberOf fabric.util\n     * @param {Object} prevStyle first style to compare\n     * @param {Object} thisStyle second style to compare\n     * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties\n     * @return {boolean} true if the style changed\n     */ hasStyleChanged: function(prevStyle, thisStyle, forTextSpans) {\n            forTextSpans = forTextSpans || false;\n            return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor || prevStyle.deltaY !== thisStyle.deltaY || forTextSpans && (prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough);\n        },\n        /**\n     * Returns the array form of a text object's inline styles property with styles grouped in ranges\n     * rather than per character. This format is less verbose, and is better suited for storage\n     * so it is used in serialization (not during runtime).\n     * @memberOf fabric.util\n     * @param {object} styles per character styles for a text object\n     * @param {String} text the text string that the styles are applied to\n     * @return {{start: number, end: number, style: object}[]}\n     */ stylesToArray: function(styles, text) {\n            // clone style structure to prevent mutation\n            var styles = fabric.util.object.clone(styles, true), textLines = text.split(\"\\n\"), charIndex = -1, prevStyle = {}, stylesArray = [];\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                if (!styles[i]) {\n                    //no styles exist for this line, so add the line's length to the charIndex total\n                    charIndex += textLines[i].length;\n                    continue;\n                }\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    var thisStyle = styles[i][c];\n                    //check if style exists for this character\n                    if (thisStyle && Object.keys(thisStyle).length > 0) {\n                        var styleChanged = fabric.util.hasStyleChanged(prevStyle, thisStyle, true);\n                        if (styleChanged) {\n                            stylesArray.push({\n                                start: charIndex,\n                                end: charIndex + 1,\n                                style: thisStyle\n                            });\n                        } else {\n                            //if style is the same as previous character, increase end index\n                            stylesArray[stylesArray.length - 1].end++;\n                        }\n                    }\n                    prevStyle = thisStyle || {};\n                }\n            }\n            return stylesArray;\n        },\n        /**\n     * Returns the object form of the styles property with styles that are assigned per\n     * character rather than grouped by range. This format is more verbose, and is\n     * only used during runtime (not for serialization/storage)\n     * @memberOf fabric.util\n     * @param {Array} styles the serialized form of a text object's styles\n     * @param {String} text the text string that the styles are applied to\n     * @return {Object}\n     */ stylesFromArray: function(styles, text) {\n            if (!Array.isArray(styles)) {\n                return styles;\n            }\n            var textLines = text.split(\"\\n\"), charIndex = -1, styleIndex = 0, stylesObject = {};\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    //check if there's a style collection that includes the current character\n                    if (styles[styleIndex] && styles[styleIndex].start <= charIndex && charIndex < styles[styleIndex].end) {\n                        //create object for line index if it doesn't exist\n                        stylesObject[i] = stylesObject[i] || {};\n                        //assign a style at this character's index\n                        stylesObject[i][c] = Object.assign({}, styles[styleIndex].style);\n                        //if character is at the end of the current style collection, move to the next\n                        if (charIndex === styles[styleIndex].end - 1) {\n                            styleIndex++;\n                        }\n                    }\n                }\n            }\n            return stylesObject;\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    var _join = Array.prototype.join, commandLengths = {\n        m: 2,\n        l: 2,\n        h: 1,\n        v: 1,\n        c: 6,\n        s: 4,\n        q: 4,\n        t: 2,\n        a: 7\n    }, repeatedCommands = {\n        m: \"l\",\n        M: \"L\"\n    };\n    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\n        var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);\n        return [\n            \"C\",\n            cp1X,\n            cp1Y,\n            cp2X,\n            cp2Y,\n            toX,\n            toY\n        ];\n    }\n    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */ function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\n        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;\n        if (pl < 0) {\n            var s = Math.sqrt(1 - pl / (rx2 * ry2));\n            rx *= s;\n            ry *= s;\n        } else {\n            root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));\n        }\n        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\n        if (sweep === 0 && dtheta > 0) {\n            dtheta -= 2 * PI;\n        } else if (sweep === 1 && dtheta < 0) {\n            dtheta += 2 * PI;\n        }\n        // Convert into cubic bezier segments <= 90deg\n        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;\n        for(var i = 0; i < segments; i++){\n            result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\n            fromX = result[i][5];\n            fromY = result[i][6];\n            mTheta = th3;\n            th3 += mDelta;\n        }\n        return result;\n    }\n    /*\n   * Private\n   */ function calcVectorAngle(ux, uy, vx, vy) {\n        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);\n        if (tb >= ta) {\n            return tb - ta;\n        } else {\n            return 2 * Math.PI - (ta - tb);\n        }\n    }\n    /**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n    // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\n    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var argsString;\n        if (fabric.cachesBoundsOfCurve) {\n            argsString = _join.call(arguments);\n            if (fabric.boundsOfCurveCache[argsString]) {\n                return fabric.boundsOfCurveCache[argsString];\n            }\n        }\n        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n        for(var i = 0; i < 2; ++i){\n            if (i > 0) {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            if (b2ac < 0) {\n                continue;\n            }\n            sqrtb2ac = sqrt(b2ac);\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        var result = [\n            {\n                x: min.apply(null, bounds[0]),\n                y: min.apply(null, bounds[1])\n            },\n            {\n                x: max.apply(null, bounds[0]),\n                y: max.apply(null, bounds[1])\n            }\n        ];\n        if (fabric.cachesBoundsOfCurve) {\n            fabric.boundsOfCurveCache[argsString] = result;\n        }\n        return result;\n    }\n    /**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */ function fromArcToBeziers(fx, fy, coords) {\n        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\n        for(var i = 0, len = segsNorm.length; i < len; i++){\n            segsNorm[i][1] += fx;\n            segsNorm[i][2] += fy;\n            segsNorm[i][3] += fx;\n            segsNorm[i][4] += fy;\n            segsNorm[i][5] += fx;\n            segsNorm[i][6] += fy;\n        }\n        return segsNorm;\n    }\n    ;\n    /**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */ function makePathSimpler(path) {\n        // x and y represent the last point of the path. the previous command point.\n        // we add them to each relative command to make it an absolute comment.\n        // we also swap the v V h H with L, because are easier to transform.\n        var x = 0, y = 0, len = path.length, // x1 and y1 represent the last point of the subpath. the subpath is started with\n        // m or M command. When a z or Z command is drawn, x and y need to be resetted to\n        // the last x1 and y1.\n        x1 = 0, y1 = 0, current, i, converted, // previous will host the letter of the previous command, to handle S and T.\n        // controlX and controlY will host the previous reflected control point\n        destinationPath = [], previous, controlX, controlY;\n        for(i = 0; i < len; ++i){\n            converted = false;\n            current = path[i].slice(0);\n            switch(current[0]){\n                case \"l\":\n                    current[0] = \"L\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"L\":\n                    x = current[1];\n                    y = current[2];\n                    break;\n                case \"h\":\n                    current[1] += x;\n                // falls through\n                case \"H\":\n                    current[0] = \"L\";\n                    current[2] = y;\n                    x = current[1];\n                    break;\n                case \"v\":\n                    current[1] += y;\n                // falls through\n                case \"V\":\n                    current[0] = \"L\";\n                    y = current[1];\n                    current[1] = x;\n                    current[2] = y;\n                    break;\n                case \"m\":\n                    current[0] = \"M\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"M\":\n                    x = current[1];\n                    y = current[2];\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"c\":\n                    current[0] = \"C\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                    current[5] += x;\n                    current[6] += y;\n                // falls through\n                case \"C\":\n                    controlX = current[3];\n                    controlY = current[4];\n                    x = current[5];\n                    y = current[6];\n                    break;\n                case \"s\":\n                    current[0] = \"S\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"S\":\n                    // would be sScC but since we are swapping sSc for C, we check just that.\n                    if (previous === \"C\") {\n                        // calculate reflection of previous control points\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a C, c, S, or s,\n                        // the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    x = current[3];\n                    y = current[4];\n                    current[0] = \"C\";\n                    current[5] = current[3];\n                    current[6] = current[4];\n                    current[3] = current[1];\n                    current[4] = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    // current[3] and current[4] are NOW the second control point.\n                    // we keep it for the next reflection.\n                    controlX = current[3];\n                    controlY = current[4];\n                    break;\n                case \"q\":\n                    current[0] = \"Q\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"Q\":\n                    controlX = current[1];\n                    controlY = current[2];\n                    x = current[3];\n                    y = current[4];\n                    break;\n                case \"t\":\n                    current[0] = \"T\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"T\":\n                    if (previous === \"Q\") {\n                        // calculate reflection of previous control point\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a Q, q, T or t,\n                        // assume the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    current[0] = \"Q\";\n                    x = current[1];\n                    y = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    current[3] = x;\n                    current[4] = y;\n                    break;\n                case \"a\":\n                    current[0] = \"A\";\n                    current[6] += x;\n                    current[7] += y;\n                // falls through\n                case \"A\":\n                    converted = true;\n                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));\n                    x = current[6];\n                    y = current[7];\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = x1;\n                    y = y1;\n                    break;\n                default:\n            }\n            if (!converted) {\n                destinationPath.push(current);\n            }\n            previous = current[0];\n        }\n        return destinationPath;\n    }\n    ;\n    /**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */ function calcLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    // functions for the Cubic beizer\n    // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\n    function CB1(t) {\n        return t * t * t;\n    }\n    function CB2(t) {\n        return 3 * t * t * (1 - t);\n    }\n    function CB3(t) {\n        return 3 * t * (1 - t) * (1 - t);\n    }\n    function CB4(t) {\n        return (1 - t) * (1 - t) * (1 - t);\n    }\n    function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);\n            return {\n                x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,\n                y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4\n            };\n        };\n    }\n    function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    function QB1(t) {\n        return t * t;\n    }\n    function QB2(t) {\n        return 2 * t * (1 - t);\n    }\n    function QB3(t) {\n        return (1 - t) * (1 - t);\n    }\n    function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);\n            return {\n                x: p3x * c1 + p2x * c2 + p1x * c3,\n                y: p3y * c1 + p2y * c2 + p1y * c3\n            };\n        };\n    }\n    function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    // this will run over a path segment ( a cubic or quadratic segment) and approximate it\n    // with 100 segemnts. This will good enough to calculate the length of the curve\n    function pathIterator(iterator, x1, y1) {\n        var tempP = {\n            x: x1,\n            y: y1\n        }, p, tmpLen = 0, perc;\n        for(perc = 1; perc <= 100; perc += 1){\n            p = iterator(perc / 100);\n            tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            tempP = p;\n        }\n        return tmpLen;\n    }\n    /**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */ function findPercentageForDistance(segInfo, distance) {\n        var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = {\n            x: segInfo.x,\n            y: segInfo.y\n        }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;\n        // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n        // the path\n        while(tmpLen < distance && nextStep > 0.0001){\n            p = iterator(perc);\n            lastPerc = perc;\n            nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            // compare tmpLen each cycle with distance, decide next perc to test.\n            if (nextLen + tmpLen > distance) {\n                // we discard this step and we make smaller steps.\n                perc -= nextStep;\n                nextStep /= 2;\n            } else {\n                tempP = p;\n                perc += nextStep;\n                tmpLen += nextLen;\n            }\n        }\n        p.angle = angleFinder(lastPerc);\n        return p;\n    }\n    /**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */ function getPathSegmentsInfo(path) {\n        var totalLength = 0, len = path.length, current, //x2 and y2 are the coords of segment start\n        //x1 and y1 are the coords of the current point\n        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;\n        for(var i = 0; i < len; i++){\n            current = path[i];\n            tempInfo = {\n                x: x1,\n                y: y1,\n                command: current[0]\n            };\n            switch(current[0]){\n                case \"M\":\n                    tempInfo.length = 0;\n                    x2 = x1 = current[1];\n                    y2 = y1 = current[2];\n                    break;\n                case \"L\":\n                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"C\":\n                    iterator = getPointOnCubicBezierIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    angleFinder = getTangentCubicIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[5];\n                    y1 = current[6];\n                    break;\n                case \"Q\":\n                    iterator = getPointOnQuadraticBezierIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    angleFinder = getTangentQuadraticIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[3];\n                    y1 = current[4];\n                    break;\n                case \"Z\":\n                case \"z\":\n                    // we add those in order to ease calculations later\n                    tempInfo.destX = x2;\n                    tempInfo.destY = y2;\n                    tempInfo.length = calcLineLength(x1, y1, x2, y2);\n                    x1 = x2;\n                    y1 = y2;\n                    break;\n            }\n            totalLength += tempInfo.length;\n            info.push(tempInfo);\n        }\n        info.push({\n            length: totalLength,\n            x: x1,\n            y: y1\n        });\n        return info;\n    }\n    function getPointOnPath(path, distance, infos) {\n        if (!infos) {\n            infos = getPathSegmentsInfo(path);\n        }\n        var i = 0;\n        while(distance - infos[i].length > 0 && i < infos.length - 2){\n            distance -= infos[i].length;\n            i++;\n        }\n        // var distance = infos[infos.length - 1] * perc;\n        var segInfo = infos[i], segPercent = distance / segInfo.length, command = segInfo.command, segment = path[i], info;\n        switch(command){\n            case \"M\":\n                return {\n                    x: segInfo.x,\n                    y: segInfo.y,\n                    angle: 0\n                };\n            case \"Z\":\n            case \"z\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segInfo.destX, segInfo.destY), segPercent);\n                info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);\n                return info;\n            case \"L\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segment[1], segment[2]), segPercent);\n                info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);\n                return info;\n            case \"C\":\n                return findPercentageForDistance(segInfo, distance);\n            case \"Q\":\n                return findPercentageForDistance(segInfo, distance);\n        }\n    }\n    /**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */ function parsePath(pathString) {\n        var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = \"[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*\", rNumberCommaWsp = \"(\" + rNumber + \")\" + fabric.commaWsp, rFlagCommaWsp = \"([01])\" + fabric.commaWsp + \"?\", rArcSeq = rNumberCommaWsp + \"?\" + rNumberCommaWsp + \"?\" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + \"?(\" + rNumber + \")\", regArcArgumentSequence = new RegExp(rArcSeq, \"g\"), match, coordsStr, // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\n        path;\n        if (!pathString || !pathString.match) {\n            return result;\n        }\n        path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n        for(var i = 0, coordsParsed, len = path.length; i < len; i++){\n            currentPath = path[i];\n            coordsStr = currentPath.slice(1).trim();\n            coords.length = 0;\n            var command = currentPath.charAt(0);\n            coordsParsed = [\n                command\n            ];\n            if (command.toLowerCase() === \"a\") {\n                // arcs have special flags that apparently don't require spaces so handle special\n                for(var args; args = regArcArgumentSequence.exec(coordsStr);){\n                    for(var j = 1; j < args.length; j++){\n                        coords.push(args[j]);\n                    }\n                }\n            } else {\n                while(match = re.exec(coordsStr)){\n                    coords.push(match[0]);\n                }\n            }\n            for(var j = 0, jlen = coords.length; j < jlen; j++){\n                parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    coordsParsed.push(parsed);\n                }\n            }\n            var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;\n            if (coordsParsed.length - 1 > commandLength) {\n                for(var k = 1, klen = coordsParsed.length; k < klen; k += commandLength){\n                    result.push([\n                        command\n                    ].concat(coordsParsed.slice(k, k + commandLength)));\n                    command = repeatedCommand;\n                }\n            } else {\n                result.push(coordsParsed);\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */ function getSmoothPathFromPoints(points, correction) {\n        var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;\n        correction = correction || 0;\n        if (manyPoints) {\n            multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;\n            multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;\n        }\n        path.push([\n            \"M\",\n            p1.x - multSignX * correction,\n            p1.y - multSignY * correction\n        ]);\n        for(i = 1; i < len; i++){\n            if (!p1.eq(p2)) {\n                var midPoint = p1.midPointFrom(p2);\n                // p1 is our bezier control point\n                // midpoint is our endpoint\n                // start point is p(i-1) value.\n                path.push([\n                    \"Q\",\n                    p1.x,\n                    p1.y,\n                    midPoint.x,\n                    midPoint.y\n                ]);\n            }\n            p1 = points[i];\n            if (i + 1 < points.length) {\n                p2 = points[i + 1];\n            }\n        }\n        if (manyPoints) {\n            multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;\n            multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;\n        }\n        path.push([\n            \"L\",\n            p1.x + multSignX * correction,\n            p1.y + multSignY * correction\n        ]);\n        return path;\n    }\n    /**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */ function transformPath(path, transform, pathOffset) {\n        if (pathOffset) {\n            transform = fabric.util.multiplyTransformMatrices(transform, [\n                1,\n                0,\n                0,\n                1,\n                -pathOffset.x,\n                -pathOffset.y\n            ]);\n        }\n        return path.map(function(pathSegment) {\n            var newSegment = pathSegment.slice(0), point = {};\n            for(var i = 1; i < pathSegment.length - 1; i += 2){\n                point.x = pathSegment[i];\n                point.y = pathSegment[i + 1];\n                point = fabric.util.transformPoint(point, transform);\n                newSegment[i] = point.x;\n                newSegment[i + 1] = point.y;\n            }\n            return newSegment;\n        });\n    }\n    /**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */ fabric.util.joinPath = function(pathData) {\n        return pathData.map(function(segment) {\n            return segment.join(\" \");\n        }).join(\" \");\n    };\n    fabric.util.parsePath = parsePath;\n    fabric.util.makePathSimpler = makePathSimpler;\n    fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;\n    fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;\n    fabric.util.getBoundsOfCurve = getBoundsOfCurve;\n    fabric.util.getPointOnPath = getPointOnPath;\n    fabric.util.transformPath = transformPath;\n})();\n(function() {\n    var slice = Array.prototype.slice;\n    /**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */ function invoke(array, method) {\n        var args = slice.call(arguments, 2), result = [];\n        for(var i = 0, len = array.length; i < len; i++){\n            result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\n        }\n        return result;\n    }\n    /**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function max(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 >= value2;\n        });\n    }\n    /**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function min(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 < value2;\n        });\n    }\n    /**\n   * @private\n   */ function fill(array, value) {\n        var k = array.length;\n        while(k--){\n            array[k] = value;\n        }\n        return array;\n    }\n    /**\n   * @private\n   */ function find(array, byProperty, condition) {\n        if (!array || array.length === 0) {\n            return;\n        }\n        var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];\n        if (byProperty) {\n            while(i--){\n                if (condition(array[i][byProperty], result)) {\n                    result = array[i][byProperty];\n                }\n            }\n        } else {\n            while(i--){\n                if (condition(array[i], result)) {\n                    result = array[i];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n   * @namespace fabric.util.array\n   */ fabric.util.array = {\n        fill: fill,\n        invoke: invoke,\n        min: min,\n        max: max\n    };\n})();\n(function() {\n    /**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */ function extend(destination, source, deep) {\n        // JScript DontEnum bug is not taken care of\n        // the deep clone is for internal use, is not meant to avoid\n        // javascript traps or cloning html element or self referenced objects.\n        if (deep) {\n            if (!fabric.isLikelyNode && source instanceof Element) {\n                // avoid cloning deep images, canvases,\n                destination = source;\n            } else if (source instanceof Array) {\n                destination = [];\n                for(var i = 0, len = source.length; i < len; i++){\n                    destination[i] = extend({}, source[i], deep);\n                }\n            } else if (source && typeof source === \"object\") {\n                for(var property in source){\n                    if (property === \"canvas\" || property === \"group\") {\n                        // we do not want to clone this props at all.\n                        // we want to keep the keys in the copy\n                        destination[property] = null;\n                    } else if (source.hasOwnProperty(property)) {\n                        destination[property] = extend({}, source[property], deep);\n                    }\n                }\n            } else {\n                // this sounds odd for an extend but is ok for recursive use\n                destination = source;\n            }\n        } else {\n            for(var property in source){\n                destination[property] = source[property];\n            }\n        }\n        return destination;\n    }\n    /**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\n    function clone(object, deep) {\n        return extend({}, object, deep);\n    }\n    /** @namespace fabric.util.object */ fabric.util.object = {\n        extend: extend,\n        clone: clone\n    };\n    fabric.util.object.extend(fabric.util, fabric.Observable);\n})();\n(function() {\n    /**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */ function camelize(string) {\n        return string.replace(/-+(.)?/g, function(match, character) {\n            return character ? character.toUpperCase() : \"\";\n        });\n    }\n    /**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */ function capitalize(string, firstLetterOnly) {\n        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\n    }\n    /**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */ function escapeXml(string) {\n        return string.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    /**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */ function graphemeSplit(textstring) {\n        var i = 0, chr, graphemes = [];\n        for(i = 0, chr; i < textstring.length; i++){\n            if ((chr = getWholeChar(textstring, i)) === false) {\n                continue;\n            }\n            graphemes.push(chr);\n        }\n        return graphemes;\n    }\n    // taken from mdn in the charAt doc page.\n    function getWholeChar(str, i) {\n        var code = str.charCodeAt(i);\n        if (isNaN(code)) {\n            return \"\"; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        // High surrogate (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 <= code && code <= 0xDBFF) {\n            if (str.length <= i + 1) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            var next = str.charCodeAt(i + 1);\n            if (0xDC00 > next || next > 0xDFFF) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            return str.charAt(i) + str.charAt(i + 1);\n        }\n        // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n        if (i === 0) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        var prev = str.charCodeAt(i - 1);\n        // (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 > prev || prev > 0xDBFF) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        // We can pass over low surrogates now as the second component\n        // in a pair which we have already processed\n        return false;\n    }\n    /**\n   * String utilities\n   * @namespace fabric.util.string\n   */ fabric.util.string = {\n        camelize: camelize,\n        capitalize: capitalize,\n        escapeXml: escapeXml,\n        graphemeSplit: graphemeSplit\n    };\n})();\n(function() {\n    var slice = Array.prototype.slice, emptyFunction = function() {}, IS_DONTENUM_BUGGY = function() {\n        for(var p in {\n            toString: 1\n        }){\n            if (p === \"toString\") {\n                return false;\n            }\n        }\n        return true;\n    }(), /** @ignore */ addMethods = function(klass, source, parent) {\n        for(var property in source){\n            if (property in klass.prototype && typeof klass.prototype[property] === \"function\" && (source[property] + \"\").indexOf(\"callSuper\") > -1) {\n                klass.prototype[property] = function(property) {\n                    return function() {\n                        var superclass = this.constructor.superclass;\n                        this.constructor.superclass = parent;\n                        var returnValue = source[property].apply(this, arguments);\n                        this.constructor.superclass = superclass;\n                        if (property !== \"initialize\") {\n                            return returnValue;\n                        }\n                    };\n                }(property);\n            } else {\n                klass.prototype[property] = source[property];\n            }\n            if (IS_DONTENUM_BUGGY) {\n                if (source.toString !== Object.prototype.toString) {\n                    klass.prototype.toString = source.toString;\n                }\n                if (source.valueOf !== Object.prototype.valueOf) {\n                    klass.prototype.valueOf = source.valueOf;\n                }\n            }\n        }\n    };\n    function Subclass() {}\n    function callSuper(methodName) {\n        var parentMethod = null, _this = this;\n        // climb prototype chain to find method not equal to callee's method\n        while(_this.constructor.superclass){\n            var superClassMethod = _this.constructor.superclass.prototype[methodName];\n            if (_this[methodName] !== superClassMethod) {\n                parentMethod = superClassMethod;\n                break;\n            }\n            // eslint-disable-next-line\n            _this = _this.constructor.superclass.prototype;\n        }\n        if (!parentMethod) {\n            return console.log(\"tried to callSuper \" + methodName + \", method not found in prototype chain\", this);\n        }\n        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);\n    }\n    /**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */ function createClass() {\n        var parent = null, properties = slice.call(arguments, 0);\n        if (typeof properties[0] === \"function\") {\n            parent = properties.shift();\n        }\n        function klass() {\n            this.initialize.apply(this, arguments);\n        }\n        klass.superclass = parent;\n        klass.subclasses = [];\n        if (parent) {\n            Subclass.prototype = parent.prototype;\n            klass.prototype = new Subclass();\n            parent.subclasses.push(klass);\n        }\n        for(var i = 0, length = properties.length; i < length; i++){\n            addMethods(klass, properties[i], parent);\n        }\n        if (!klass.prototype.initialize) {\n            klass.prototype.initialize = emptyFunction;\n        }\n        klass.prototype.constructor = klass;\n        klass.prototype.callSuper = callSuper;\n        return klass;\n    }\n    fabric.util.createClass = createClass;\n})();\n(function() {\n    // since ie11 can use addEventListener but they do not support options, i need to check\n    var couldUseAttachEvent = !!fabric.document.createElement(\"div\").attachEvent, touchEvents = [\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\"\n    ];\n    /**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.addListener = function(element, eventName, handler, options) {\n        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    /**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.removeListener = function(element, eventName, handler, options) {\n        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    function getTouchInfo(event) {\n        var touchProp = event.changedTouches;\n        if (touchProp && touchProp[0]) {\n            return touchProp[0];\n        }\n        return event;\n    }\n    fabric.util.getPointer = function(event) {\n        var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);\n        return {\n            x: _evt.clientX + scroll.left,\n            y: _evt.clientY + scroll.top\n        };\n    };\n    fabric.util.isTouchEvent = function(event) {\n        return touchEvents.indexOf(event.type) > -1 || event.pointerType === \"touch\";\n    };\n})();\n(function() {\n    /**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */ function setStyle(element, styles) {\n        var elementStyle = element.style;\n        if (!elementStyle) {\n            return element;\n        }\n        if (typeof styles === \"string\") {\n            element.style.cssText += \";\" + styles;\n            return styles.indexOf(\"opacity\") > -1 ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : element;\n        }\n        for(var property in styles){\n            if (property === \"opacity\") {\n                setOpacity(element, styles[property]);\n            } else {\n                var normalizedProperty = property === \"float\" || property === \"cssFloat\" ? typeof elementStyle.styleFloat === \"undefined\" ? \"cssFloat\" : \"styleFloat\" : property;\n                elementStyle.setProperty(normalizedProperty, styles[property]);\n            }\n        }\n        return element;\n    }\n    var parseEl = fabric.document.createElement(\"div\"), supportsOpacity = typeof parseEl.style.opacity === \"string\", supportsFilters = typeof parseEl.style.filter === \"string\", reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, /** @ignore */ setOpacity = function(element) {\n        return element;\n    };\n    if (supportsOpacity) {\n        /** @ignore */ setOpacity = function(element, value) {\n            element.style.opacity = value;\n            return element;\n        };\n    } else if (supportsFilters) {\n        /** @ignore */ setOpacity = function(element, value) {\n            var es = element.style;\n            if (element.currentStyle && !element.currentStyle.hasLayout) {\n                es.zoom = 1;\n            }\n            if (reOpacity.test(es.filter)) {\n                value = value >= 0.9999 ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n                es.filter = es.filter.replace(reOpacity, value);\n            } else {\n                es.filter += \" alpha(opacity=\" + value * 100 + \")\";\n            }\n            return element;\n        };\n    }\n    fabric.util.setStyle = setStyle;\n})();\n(function() {\n    var _slice = Array.prototype.slice;\n    /**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */ function getById(id) {\n        return typeof id === \"string\" ? fabric.document.getElementById(id) : id;\n    }\n    var sliceCanConvertNodelists, /**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */ toArray = function(arrayLike) {\n        return _slice.call(arrayLike, 0);\n    };\n    try {\n        sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\n    } catch (err) {}\n    if (!sliceCanConvertNodelists) {\n        toArray = function(arrayLike) {\n            var arr = new Array(arrayLike.length), i = arrayLike.length;\n            while(i--){\n                arr[i] = arrayLike[i];\n            }\n            return arr;\n        };\n    }\n    /**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */ function makeElement(tagName, attributes) {\n        var el = fabric.document.createElement(tagName);\n        for(var prop in attributes){\n            if (prop === \"class\") {\n                el.className = attributes[prop];\n            } else if (prop === \"for\") {\n                el.htmlFor = attributes[prop];\n            } else {\n                el.setAttribute(prop, attributes[prop]);\n            }\n        }\n        return el;\n    }\n    /**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */ function addClass(element, className) {\n        if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") === -1) {\n            element.className += (element.className ? \" \" : \"\") + className;\n        }\n    }\n    /**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */ function wrapElement(element, wrapper, attributes) {\n        if (typeof wrapper === \"string\") {\n            wrapper = makeElement(wrapper, attributes);\n        }\n        if (element.parentNode) {\n            element.parentNode.replaceChild(wrapper, element);\n        }\n        wrapper.appendChild(element);\n        return wrapper;\n    }\n    /**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */ function getScrollLeftTop(element) {\n        var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        // While loop checks (and then sets element to) .parentNode OR .host\n        //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n        //  but the .parentNode of a root ShadowDOM node will always be null, instead\n        //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\n        while(element && (element.parentNode || element.host)){\n            // Set element to element parent, or 'host' in case of ShadowDOM\n            element = element.parentNode || element.host;\n            if (element === fabric.document) {\n                left = body.scrollLeft || docElement.scrollLeft || 0;\n                top = body.scrollTop || docElement.scrollTop || 0;\n            } else {\n                left += element.scrollLeft || 0;\n                top += element.scrollTop || 0;\n            }\n            if (element.nodeType === 1 && element.style.position === \"fixed\") {\n                break;\n            }\n        }\n        return {\n            left: left,\n            top: top\n        };\n    }\n    /**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */ function getElementOffset(element) {\n        var docElem, doc = element && element.ownerDocument, box = {\n            left: 0,\n            top: 0\n        }, offset = {\n            left: 0,\n            top: 0\n        }, scrollLeftTop, offsetAttributes = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n        };\n        if (!doc) {\n            return offset;\n        }\n        for(var attr in offsetAttributes){\n            offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\n        }\n        docElem = doc.documentElement;\n        if (typeof element.getBoundingClientRect !== \"undefined\") {\n            box = element.getBoundingClientRect();\n        }\n        scrollLeftTop = getScrollLeftTop(element);\n        return {\n            left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\n            top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top\n        };\n    }\n    /**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */ var getElementStyle;\n    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\n        getElementStyle = function(element, attr) {\n            var style = fabric.document.defaultView.getComputedStyle(element, null);\n            return style ? style[attr] : undefined;\n        };\n    } else {\n        getElementStyle = function(element, attr) {\n            var value = element.style[attr];\n            if (!value && element.currentStyle) {\n                value = element.currentStyle[attr];\n            }\n            return value;\n        };\n    }\n    (function() {\n        var style = fabric.document.documentElement.style, selectProp = \"userSelect\" in style ? \"userSelect\" : \"MozUserSelect\" in style ? \"MozUserSelect\" : \"WebkitUserSelect\" in style ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in style ? \"KhtmlUserSelect\" : \"\";\n        /**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementUnselectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = fabric.util.falseFunction;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"none\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"on\";\n            }\n            return element;\n        }\n        /**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementSelectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = null;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"\";\n            }\n            return element;\n        }\n        fabric.util.makeElementUnselectable = makeElementUnselectable;\n        fabric.util.makeElementSelectable = makeElementSelectable;\n    })();\n    function getNodeCanvas(element) {\n        var impl = fabric.jsdomImplForWrapper(element);\n        return impl._canvas || impl._image;\n    }\n    ;\n    function cleanUpJsdomNode(element) {\n        if (!fabric.isLikelyNode) {\n            return;\n        }\n        var impl = fabric.jsdomImplForWrapper(element);\n        if (impl) {\n            impl._image = null;\n            impl._canvas = null;\n            // unsure if necessary\n            impl._currentSrc = null;\n            impl._attributes = null;\n            impl._classList = null;\n        }\n    }\n    function setImageSmoothing(ctx, value) {\n        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\n        ctx.imageSmoothingEnabled = value;\n    }\n    /**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */ fabric.util.setImageSmoothing = setImageSmoothing;\n    fabric.util.getById = getById;\n    fabric.util.toArray = toArray;\n    fabric.util.addClass = addClass;\n    fabric.util.makeElement = makeElement;\n    fabric.util.wrapElement = wrapElement;\n    fabric.util.getScrollLeftTop = getScrollLeftTop;\n    fabric.util.getElementOffset = getElementOffset;\n    fabric.util.getNodeCanvas = getNodeCanvas;\n    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;\n})();\n(function() {\n    function addParamToUrl(url, param) {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + param;\n    }\n    function emptyFn() {}\n    /**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */ function request(url, options) {\n        options || (options = {});\n        var method = options.method ? options.method.toUpperCase() : \"GET\", onComplete = options.onComplete || function() {}, xhr = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;\n        /** @ignore */ xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                onComplete(xhr);\n                xhr.onreadystatechange = emptyFn;\n            }\n        };\n        if (method === \"GET\") {\n            body = null;\n            if (typeof options.parameters === \"string\") {\n                url = addParamToUrl(url, options.parameters);\n            }\n        }\n        xhr.open(method, url, true);\n        if (method === \"POST\" || method === \"PUT\") {\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n        xhr.send(body);\n        return xhr;\n    }\n    fabric.util.request = request;\n})();\n/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */ fabric.log = console.log;\n/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */ fabric.warn = console.warn;\n(function() {\n    var extend = fabric.util.object.extend, clone = fabric.util.object.clone;\n    /**\n   * @typedef {Object} AnimationOptions\n   * Animation of a value or list of values.\n   * When using lists, think of something like this:\n   * fabric.util.animate({\n   *   startValue: [1, 2, 3],\n   *   endValue: [2, 4, 6],\n   *   onChange: function([a, b, c]) {\n   *     canvas.zoomToPoint({x: b, y: c}, a)\n   *     canvas.renderAll()\n   *   }\n   * });\n   * @example\n   * @property {Function} [onChange] Callback; invoked on every value change\n   * @property {Function} [onComplete] Callback; invoked when value change is completed\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }\n   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }\n   * @property {number | number[]} [startValue=0] Starting value\n   * @property {number | number[]} [endValue=100] Ending value\n   * @property {number | number[]} [byValue=100] Value to modify the property by\n   * @property {Function} [easing] Easing function\n   * @property {Number} [duration=500] Duration of change (in ms)\n   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.\n   *\n   * @typedef {() => void} CancelFunction\n   *\n   * @typedef {Object} AnimationCurrentState\n   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]\n   * @property {number} completionRate value in range [0, 1]\n   * @property {number} durationRate value in range [0, 1]\n   *\n   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext\n   */ /**\n   * Array holding all running animations\n   * @memberof fabric\n   * @type {AnimationContext[]}\n   */ var RUNNING_ANIMATIONS = [];\n    fabric.util.object.extend(RUNNING_ANIMATIONS, {\n        /**\n     * cancel all running animations at the next requestAnimFrame\n     * @returns {AnimationContext[]}\n     */ cancelAll: function() {\n            var animations = this.splice(0);\n            animations.forEach(function(animation) {\n                animation.cancel();\n            });\n            return animations;\n        },\n        /**\n     * cancel all running animations attached to canvas at the next requestAnimFrame\n     * @param {fabric.Canvas} canvas\n     * @returns {AnimationContext[]}\n     */ cancelByCanvas: function(canvas) {\n            if (!canvas) {\n                return [];\n            }\n            var cancelled = this.filter(function(animation) {\n                return typeof animation.target === \"object\" && animation.target.canvas === canvas;\n            });\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     * cancel all running animations for target at the next requestAnimFrame\n     * @param {*} target\n     * @returns {AnimationContext[]}\n     */ cancelByTarget: function(target) {\n            var cancelled = this.findAnimationsByTarget(target);\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {number}\n     */ findAnimationIndex: function(cancelFunc) {\n            return this.indexOf(this.findAnimation(cancelFunc));\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {AnimationContext | undefined} animation's options object\n     */ findAnimation: function(cancelFunc) {\n            return this.find(function(animation) {\n                return animation.cancel === cancelFunc;\n            });\n        },\n        /**\n     *\n     * @param {*} target the object that is assigned to the target property of the animation context\n     * @returns {AnimationContext[]} array of animation options object associated with target\n     */ findAnimationsByTarget: function(target) {\n            if (!target) {\n                return [];\n            }\n            return this.filter(function(animation) {\n                return animation.target === target;\n            });\n        }\n    });\n    function noop() {\n        return false;\n    }\n    function defaultEasing(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {AnimationOptions} [options] Animation options\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })\n   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })\n   * @returns {CancelFunction} cancel function\n   */ function animate(options) {\n        options || (options = {});\n        var cancel = false, context, removeFromRegistry = function() {\n            var index = fabric.runningAnimations.indexOf(context);\n            return index > -1 && fabric.runningAnimations.splice(index, 1)[0];\n        };\n        context = extend(clone(options), {\n            cancel: function() {\n                cancel = true;\n                return removeFromRegistry();\n            },\n            currentValue: \"startValue\" in options ? options.startValue : 0,\n            completionRate: 0,\n            durationRate: 0\n        });\n        fabric.runningAnimations.push(context);\n        requestAnimFrame(function(timestamp) {\n            var start = timestamp || +new Date(), duration = options.duration || 500, finish = start + duration, time, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, isMany = \"startValue\" in options ? options.startValue.length > 0 : false, startValue = \"startValue\" in options ? options.startValue : 0, endValue = \"endValue\" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i) {\n                return endValue[i] - startValue[i];\n            }) : endValue - startValue);\n            options.onStart && options.onStart();\n            (function tick(ticktime) {\n                time = ticktime || +new Date();\n                var currentTime = time > finish ? duration : time - start, timePerc = currentTime / duration, current = isMany ? startValue.map(function(_value, i) {\n                    return easing(currentTime, startValue[i], byValue[i], duration);\n                }) : easing(currentTime, startValue, byValue, duration), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);\n                //  update context\n                context.currentValue = isMany ? current.slice() : current;\n                context.completionRate = valuePerc;\n                context.durationRate = timePerc;\n                if (cancel) {\n                    return;\n                }\n                if (abort(current, valuePerc, timePerc)) {\n                    removeFromRegistry();\n                    return;\n                }\n                if (time > finish) {\n                    //  update context\n                    context.currentValue = isMany ? endValue.slice() : endValue;\n                    context.completionRate = 1;\n                    context.durationRate = 1;\n                    //  execute callbacks\n                    onChange(isMany ? endValue.slice() : endValue, 1, 1);\n                    onComplete(endValue, 1, 1);\n                    removeFromRegistry();\n                    return;\n                } else {\n                    onChange(current, valuePerc, timePerc);\n                    requestAnimFrame(tick);\n                }\n            })(start);\n        });\n        return context.cancel;\n    }\n    var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {\n        return fabric.window.setTimeout(callback, 1000 / 60);\n    };\n    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;\n    /**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */ function requestAnimFrame() {\n        return _requestAnimFrame.apply(fabric.window, arguments);\n    }\n    function cancelAnimFrame() {\n        return _cancelAnimFrame.apply(fabric.window, arguments);\n    }\n    fabric.util.animate = animate;\n    fabric.util.requestAnimFrame = requestAnimFrame;\n    fabric.util.cancelAnimFrame = cancelAnimFrame;\n    fabric.runningAnimations = RUNNING_ANIMATIONS;\n})();\n(function() {\n    // Calculate an in-between color. Returns a \"rgba()\" string.\n    // Credit: Edwin Martin <edwin@bitstorm.org>\n    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\n    function calculateColor(begin, end, pos) {\n        var color = \"rgba(\" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + \",\" + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + \",\" + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);\n        color += \",\" + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);\n        color += \")\";\n        return color;\n    }\n    /**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */ function animateColor(fromColor, toColor, duration, options) {\n        var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;\n        options = options || {};\n        return fabric.util.animate(fabric.util.object.extend(options, {\n            duration: duration || 500,\n            startValue: startColor,\n            endValue: endColor,\n            byValue: endColor,\n            easing: function(currentTime, startValue, byValue, duration) {\n                var posValue = options.colorEasing ? options.colorEasing(currentTime, duration) : 1 - Math.cos(currentTime / duration * (Math.PI / 2));\n                return calculateColor(startValue, byValue, posValue);\n            },\n            // has to take in account for color restoring;\n            onComplete: function(current, valuePerc, timePerc) {\n                if (originalOnComplete) {\n                    return originalOnComplete(calculateColor(endColor, endColor, 0), valuePerc, timePerc);\n                }\n            },\n            onChange: function(current, valuePerc, timePerc) {\n                if (originalOnChange) {\n                    if (Array.isArray(current)) {\n                        return originalOnChange(calculateColor(current, current, 0), valuePerc, timePerc);\n                    }\n                    originalOnChange(current, valuePerc, timePerc);\n                }\n            }\n        }));\n    }\n    fabric.util.animateColor = animateColor;\n})();\n(function() {\n    function normalize(a, c, p, s) {\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            //handle the 0/0 case:\n            if (c === 0 && a === 0) {\n                s = p / (2 * Math.PI) * Math.asin(1);\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n        }\n        return {\n            a: a,\n            c: c,\n            p: p,\n            s: s\n        };\n    }\n    function elastic(opts, t, d) {\n        return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);\n    }\n    /**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCubic(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    /**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCubic(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    /**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuart(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    }\n    /**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuart(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    /**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuart(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    /**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuint(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    }\n    /**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuint(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    /**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuint(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    /**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */ function easeInSine(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutSine(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    /**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutSine(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    /**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */ function easeInExpo(t, b, c, d) {\n        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    /**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutExpo(t, b, c, d) {\n        return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    /**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutExpo(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    /**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */ function easeInCirc(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    /**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCirc(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    /**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCirc(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    /**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return -elastic(opts, t, d) + b;\n    }\n    /**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;\n    }\n    /**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d / 2;\n        if (t === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var opts = normalize(a, c, p, s);\n        if (t < 1) {\n            return -0.5 * elastic(opts, t, d) + b;\n        }\n        return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;\n    }\n    /**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    /**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    /**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    /**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBounce(t, b, c, d) {\n        return c - easeOutBounce(d - t, 0, c, d) + b;\n    }\n    /**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBounce(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    }\n    /**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBounce(t, b, c, d) {\n        if (t < d / 2) {\n            return easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n        }\n        return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n    /**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */ fabric.util.ease = {\n        /**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */ easeInQuad: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        /**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */ easeOutQuad: function(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        /**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */ easeInOutQuad: function(t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        },\n        /**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */ easeInCubic: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOutCubic: easeOutCubic,\n        easeInOutCubic: easeInOutCubic,\n        easeInQuart: easeInQuart,\n        easeOutQuart: easeOutQuart,\n        easeInOutQuart: easeInOutQuart,\n        easeInQuint: easeInQuint,\n        easeOutQuint: easeOutQuint,\n        easeInOutQuint: easeInOutQuint,\n        easeInSine: easeInSine,\n        easeOutSine: easeOutSine,\n        easeInOutSine: easeInOutSine,\n        easeInExpo: easeInExpo,\n        easeOutExpo: easeOutExpo,\n        easeInOutExpo: easeInOutExpo,\n        easeInCirc: easeInCirc,\n        easeOutCirc: easeOutCirc,\n        easeInOutCirc: easeInOutCirc,\n        easeInElastic: easeInElastic,\n        easeOutElastic: easeOutElastic,\n        easeInOutElastic: easeInOutElastic,\n        easeInBack: easeInBack,\n        easeOutBack: easeOutBack,\n        easeInOutBack: easeInOutBack,\n        easeInBounce: easeInBounce,\n        easeOutBounce: easeOutBounce,\n        easeInOutBounce: easeInOutBounce\n    };\n})();\n(function(global) {\n    \"use strict\";\n    /**\n   * @name fabric\n   * @namespace\n   */ var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, parseUnit = fabric.util.parseUnit, multiplyTransformMatrices = fabric.util.multiplyTransformMatrices, svgValidTagNames = [\n        \"path\",\n        \"circle\",\n        \"polygon\",\n        \"polyline\",\n        \"ellipse\",\n        \"rect\",\n        \"line\",\n        \"image\",\n        \"text\"\n    ], svgViewBoxElements = [\n        \"symbol\",\n        \"image\",\n        \"marker\",\n        \"pattern\",\n        \"view\",\n        \"svg\"\n    ], svgInvalidAncestors = [\n        \"pattern\",\n        \"defs\",\n        \"symbol\",\n        \"metadata\",\n        \"clipPath\",\n        \"mask\",\n        \"desc\"\n    ], svgValidParents = [\n        \"symbol\",\n        \"g\",\n        \"a\",\n        \"svg\",\n        \"clipPath\",\n        \"defs\"\n    ], attributesMap = {\n        cx: \"left\",\n        x: \"left\",\n        r: \"radius\",\n        cy: \"top\",\n        y: \"top\",\n        display: \"visible\",\n        visibility: \"visible\",\n        transform: \"transformMatrix\",\n        \"fill-opacity\": \"fillOpacity\",\n        \"fill-rule\": \"fillRule\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        \"font-style\": \"fontStyle\",\n        \"font-weight\": \"fontWeight\",\n        \"letter-spacing\": \"charSpacing\",\n        \"paint-order\": \"paintFirst\",\n        \"stroke-dasharray\": \"strokeDashArray\",\n        \"stroke-dashoffset\": \"strokeDashOffset\",\n        \"stroke-linecap\": \"strokeLineCap\",\n        \"stroke-linejoin\": \"strokeLineJoin\",\n        \"stroke-miterlimit\": \"strokeMiterLimit\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        \"stroke-width\": \"strokeWidth\",\n        \"text-decoration\": \"textDecoration\",\n        \"text-anchor\": \"textAnchor\",\n        opacity: \"opacity\",\n        \"clip-path\": \"clipPath\",\n        \"clip-rule\": \"clipRule\",\n        \"vector-effect\": \"strokeUniform\",\n        \"image-rendering\": \"imageSmoothing\"\n    }, colorAttributes = {\n        stroke: \"strokeOpacity\",\n        fill: \"fillOpacity\"\n    }, fSize = \"font-size\", cPath = \"clip-path\";\n    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);\n    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);\n    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);\n    fabric.cssRules = {};\n    fabric.gradientDefs = {};\n    fabric.clipPaths = {};\n    function normalizeAttr(attr) {\n        // transform attribute names\n        if (attr in attributesMap) {\n            return attributesMap[attr];\n        }\n        return attr;\n    }\n    function normalizeValue(attr, value, parentAttributes, fontSize) {\n        var isArray = Array.isArray(value), parsed;\n        if ((attr === \"fill\" || attr === \"stroke\") && value === \"none\") {\n            value = \"\";\n        } else if (attr === \"strokeUniform\") {\n            return value === \"non-scaling-stroke\";\n        } else if (attr === \"strokeDashArray\") {\n            if (value === \"none\") {\n                value = null;\n            } else {\n                value = value.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n            }\n        } else if (attr === \"transformMatrix\") {\n            if (parentAttributes && parentAttributes.transformMatrix) {\n                value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\n            } else {\n                value = fabric.parseTransformAttribute(value);\n            }\n        } else if (attr === \"visible\") {\n            value = value !== \"none\" && value !== \"hidden\";\n            // display=none on parent element always takes precedence over child element\n            if (parentAttributes && parentAttributes.visible === false) {\n                value = false;\n            }\n        } else if (attr === \"opacity\") {\n            value = parseFloat(value);\n            if (parentAttributes && typeof parentAttributes.opacity !== \"undefined\") {\n                value *= parentAttributes.opacity;\n            }\n        } else if (attr === \"textAnchor\" /* text-anchor */ ) {\n            value = value === \"start\" ? \"left\" : value === \"end\" ? \"right\" : \"center\";\n        } else if (attr === \"charSpacing\") {\n            // parseUnit returns px and we convert it to em\n            parsed = parseUnit(value, fontSize) / fontSize * 1000;\n        } else if (attr === \"paintFirst\") {\n            var fillIndex = value.indexOf(\"fill\");\n            var strokeIndex = value.indexOf(\"stroke\");\n            var value = \"fill\";\n            if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {\n                value = \"stroke\";\n            } else if (fillIndex === -1 && strokeIndex > -1) {\n                value = \"stroke\";\n            }\n        } else if (attr === \"href\" || attr === \"xlink:href\" || attr === \"font\") {\n            return value;\n        } else if (attr === \"imageSmoothing\") {\n            return value === \"optimizeQuality\";\n        } else {\n            parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\n        }\n        return !isArray && isNaN(parsed) ? value : parsed;\n    }\n    /**\n    * @private\n    */ function getSvgRegex(arr) {\n        return new RegExp(\"^(\" + arr.join(\"|\") + \")\\\\b\", \"i\");\n    }\n    /**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */ function _setStrokeFillOpacity(attributes) {\n        for(var attr in colorAttributes){\n            if (typeof attributes[colorAttributes[attr]] === \"undefined\" || attributes[attr] === \"\") {\n                continue;\n            }\n            if (typeof attributes[attr] === \"undefined\") {\n                if (!fabric.Object.prototype[attr]) {\n                    continue;\n                }\n                attributes[attr] = fabric.Object.prototype[attr];\n            }\n            if (attributes[attr].indexOf(\"url(\") === 0) {\n                continue;\n            }\n            var color = new fabric.Color(attributes[attr]);\n            attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\n        }\n        return attributes;\n    }\n    /**\n   * @private\n   */ function _getMultipleNodes(doc, nodeNames) {\n        var nodeName, nodeArray = [], nodeList, i, len;\n        for(i = 0, len = nodeNames.length; i < len; i++){\n            nodeName = nodeNames[i];\n            nodeList = doc.getElementsByTagName(nodeName);\n            nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\n        }\n        return nodeArray;\n    }\n    /**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */ fabric.parseTransformAttribute = function() {\n        function rotateMatrix(matrix, args) {\n            var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]), x = 0, y = 0;\n            if (args.length === 3) {\n                x = args[1];\n                y = args[2];\n            }\n            matrix[0] = cos;\n            matrix[1] = sin;\n            matrix[2] = -sin;\n            matrix[3] = cos;\n            matrix[4] = x - (cos * x - sin * y);\n            matrix[5] = y - (sin * x + cos * y);\n        }\n        function scaleMatrix(matrix, args) {\n            var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];\n            matrix[0] = multiplierX;\n            matrix[3] = multiplierY;\n        }\n        function skewMatrix(matrix, args, pos) {\n            matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));\n        }\n        function translateMatrix(matrix, args) {\n            matrix[4] = args[0];\n            if (args.length === 2) {\n                matrix[5] = args[1];\n            }\n        }\n        // identity matrix\n        var iMatrix = fabric.iMatrix, // == begin transform regexp\n        number = fabric.reNum, commaWsp = fabric.commaWsp, skewX = \"(?:(skewX)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", skewY = \"(?:(skewY)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", rotate = \"(?:(rotate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", scale = \"(?:(scale)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", translate = \"(?:(translate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", matrix = \"(?:(matrix)\\\\s*\\\\(\\\\s*\" + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + \"\\\\s*\\\\))\", transform = \"(?:\" + matrix + \"|\" + translate + \"|\" + scale + \"|\" + rotate + \"|\" + skewX + \"|\" + skewY + \")\", transforms = \"(?:\" + transform + \"(?:\" + commaWsp + \"*\" + transform + \")*\" + \")\", transformList = \"^\\\\s*(?:\" + transforms + \"?)\\\\s*$\", // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n        reTransformList = new RegExp(transformList), // == end transform regexp\n        reTransform = new RegExp(transform, \"g\");\n        return function(attributeValue) {\n            // start with identity matrix\n            var matrix = iMatrix.concat(), matrices = [];\n            // return if no argument was given or\n            // an argument does not match transform attribute regexp\n            if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {\n                return matrix;\n            }\n            attributeValue.replace(reTransform, function(match) {\n                var m = new RegExp(transform).exec(match).filter(function(match) {\n                    // match !== '' && match != null\n                    return !!match;\n                }), operation = m[1], args = m.slice(2).map(parseFloat);\n                switch(operation){\n                    case \"translate\":\n                        translateMatrix(matrix, args);\n                        break;\n                    case \"rotate\":\n                        args[0] = fabric.util.degreesToRadians(args[0]);\n                        rotateMatrix(matrix, args);\n                        break;\n                    case \"scale\":\n                        scaleMatrix(matrix, args);\n                        break;\n                    case \"skewX\":\n                        skewMatrix(matrix, args, 2);\n                        break;\n                    case \"skewY\":\n                        skewMatrix(matrix, args, 1);\n                        break;\n                    case \"matrix\":\n                        matrix = args;\n                        break;\n                }\n                // snapshot current matrix into matrices array\n                matrices.push(matrix.concat());\n                // reset\n                matrix = iMatrix.concat();\n            });\n            var combinedMatrix = matrices[0];\n            while(matrices.length > 1){\n                matrices.shift();\n                combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\n            }\n            return combinedMatrix;\n        };\n    }();\n    /**\n   * @private\n   */ function parseStyleString(style, oStyle) {\n        var attr, value;\n        style.replace(/;\\s*$/, \"\").split(\";\").forEach(function(chunk) {\n            var pair = chunk.split(\":\");\n            attr = pair[0].trim().toLowerCase();\n            value = pair[1].trim();\n            oStyle[attr] = value;\n        });\n    }\n    /**\n   * @private\n   */ function parseStyleObject(style, oStyle) {\n        var attr, value;\n        for(var prop in style){\n            if (typeof style[prop] === \"undefined\") {\n                continue;\n            }\n            attr = prop.toLowerCase();\n            value = style[prop];\n            oStyle[attr] = value;\n        }\n    }\n    /**\n   * @private\n   */ function getGlobalStylesForElement(element, svgUid) {\n        var styles = {};\n        for(var rule in fabric.cssRules[svgUid]){\n            if (elementMatchesRule(element, rule.split(\" \"))) {\n                for(var property in fabric.cssRules[svgUid][rule]){\n                    styles[property] = fabric.cssRules[svgUid][rule][property];\n                }\n            }\n        }\n        return styles;\n    }\n    /**\n   * @private\n   */ function elementMatchesRule(element, selectors) {\n        var firstMatching, parentMatching = true;\n        //start from rightmost selector.\n        firstMatching = selectorMatches(element, selectors.pop());\n        if (firstMatching && selectors.length) {\n            parentMatching = doesSomeParentMatch(element, selectors);\n        }\n        return firstMatching && parentMatching && selectors.length === 0;\n    }\n    function doesSomeParentMatch(element, selectors) {\n        var selector, parentMatching = true;\n        while(element.parentNode && element.parentNode.nodeType === 1 && selectors.length){\n            if (parentMatching) {\n                selector = selectors.pop();\n            }\n            element = element.parentNode;\n            parentMatching = selectorMatches(element, selector);\n        }\n        return selectors.length === 0;\n    }\n    /**\n   * @private\n   */ function selectorMatches(element, selector) {\n        var nodeName = element.nodeName, classNames = element.getAttribute(\"class\"), id = element.getAttribute(\"id\"), matcher, i;\n        // i check if a selector matches slicing away part from it.\n        // if i get empty string i should match\n        matcher = new RegExp(\"^\" + nodeName, \"i\");\n        selector = selector.replace(matcher, \"\");\n        if (id && selector.length) {\n            matcher = new RegExp(\"#\" + id + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n            selector = selector.replace(matcher, \"\");\n        }\n        if (classNames && selector.length) {\n            classNames = classNames.split(\" \");\n            for(i = classNames.length; i--;){\n                matcher = new RegExp(\"\\\\.\" + classNames[i] + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n                selector = selector.replace(matcher, \"\");\n            }\n        }\n        return selector.length === 0;\n    }\n    /**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */ function elementById(doc, id) {\n        var el;\n        doc.getElementById && (el = doc.getElementById(id));\n        if (el) {\n            return el;\n        }\n        var node, i, len, nodelist = doc.getElementsByTagName(\"*\");\n        for(i = 0, len = nodelist.length; i < len; i++){\n            node = nodelist[i];\n            if (id === node.getAttribute(\"id\")) {\n                return node;\n            }\n        }\n    }\n    /**\n   * @private\n   */ function parseUseDirectives(doc) {\n        var nodelist = _getMultipleNodes(doc, [\n            \"use\",\n            \"svg:use\"\n        ]), i = 0;\n        while(nodelist.length && i < nodelist.length){\n            var el = nodelist[i], xlinkAttribute = el.getAttribute(\"xlink:href\") || el.getAttribute(\"href\");\n            if (xlinkAttribute === null) {\n                return;\n            }\n            var xlink = xlinkAttribute.slice(1), x = el.getAttribute(\"x\") || 0, y = el.getAttribute(\"y\") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute(\"transform\") || \"\") + \" translate(\" + x + \", \" + y + \")\", parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;\n            applyViewboxTransform(el2);\n            if (/^svg$/i.test(el2.nodeName)) {\n                var el3 = el2.ownerDocument.createElementNS(namespace, \"g\");\n                for(j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++){\n                    attr = attrs.item(j);\n                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);\n                }\n                // el2.firstChild != null\n                while(el2.firstChild){\n                    el3.appendChild(el2.firstChild);\n                }\n                el2 = el3;\n            }\n            for(j = 0, attrs = el.attributes, len = attrs.length; j < len; j++){\n                attr = attrs.item(j);\n                if (attr.nodeName === \"x\" || attr.nodeName === \"y\" || attr.nodeName === \"xlink:href\" || attr.nodeName === \"href\") {\n                    continue;\n                }\n                if (attr.nodeName === \"transform\") {\n                    currentTrans = attr.nodeValue + \" \" + currentTrans;\n                } else {\n                    el2.setAttribute(attr.nodeName, attr.nodeValue);\n                }\n            }\n            el2.setAttribute(\"transform\", currentTrans);\n            el2.setAttribute(\"instantiated_by_use\", \"1\");\n            el2.removeAttribute(\"id\");\n            parentNode = el.parentNode;\n            parentNode.replaceChild(el2, el);\n            // some browsers do not shorten nodelist after replaceChild (IE8)\n            if (nodelist.length === oldLength) {\n                i++;\n            }\n        }\n    }\n    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n    // matches, e.g.: +14.56e-12, etc.\n    var reViewBoxAttrValue = new RegExp(\"^\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*\" + \"$\");\n    /**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */ function applyViewboxTransform(element) {\n        if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {\n            return {};\n        }\n        var viewBoxAttr = element.getAttribute(\"viewBox\"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix, el, widthAttr = element.getAttribute(\"width\"), heightAttr = element.getAttribute(\"height\"), x = element.getAttribute(\"x\") || 0, y = element.getAttribute(\"y\") || 0, preserveAspectRatio = element.getAttribute(\"preserveAspectRatio\") || \"\", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === \"100%\" || heightAttr === \"100%\", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = \"\", widthDiff = 0, heightDiff = 0;\n        parsedDim.width = 0;\n        parsedDim.height = 0;\n        parsedDim.toBeParsed = toBeParsed;\n        if (missingViewBox) {\n            if ((x || y) && element.parentNode && element.parentNode.nodeName !== \"#document\") {\n                translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n                matrix = (element.getAttribute(\"transform\") || \"\") + translateMatrix;\n                element.setAttribute(\"transform\", matrix);\n                element.removeAttribute(\"x\");\n                element.removeAttribute(\"y\");\n            }\n        }\n        if (toBeParsed) {\n            return parsedDim;\n        }\n        if (missingViewBox) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            // set a transform for elements that have x y and are inner(only) SVGs\n            return parsedDim;\n        }\n        minX = -parseFloat(viewBoxAttr[1]);\n        minY = -parseFloat(viewBoxAttr[2]);\n        viewBoxWidth = parseFloat(viewBoxAttr[3]);\n        viewBoxHeight = parseFloat(viewBoxAttr[4]);\n        parsedDim.minX = minX;\n        parsedDim.minY = minY;\n        parsedDim.viewBoxWidth = viewBoxWidth;\n        parsedDim.viewBoxHeight = viewBoxHeight;\n        if (!missingDimAttr) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            scaleX = parsedDim.width / viewBoxWidth;\n            scaleY = parsedDim.height / viewBoxHeight;\n        } else {\n            parsedDim.width = viewBoxWidth;\n            parsedDim.height = viewBoxHeight;\n        }\n        // default is to preserve aspect ratio\n        preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\n        if (preserveAspectRatio.alignX !== \"none\") {\n            //translate all container for the effect of Mid, Min, Max\n            if (preserveAspectRatio.meetOrSlice === \"meet\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n            // calculate additional translation to move the viewbox\n            }\n            if (preserveAspectRatio.meetOrSlice === \"slice\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n            // calculate additional translation to move the viewbox\n            }\n            widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n            heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n            if (preserveAspectRatio.alignX === \"Mid\") {\n                widthDiff /= 2;\n            }\n            if (preserveAspectRatio.alignY === \"Mid\") {\n                heightDiff /= 2;\n            }\n            if (preserveAspectRatio.alignX === \"Min\") {\n                widthDiff = 0;\n            }\n            if (preserveAspectRatio.alignY === \"Min\") {\n                heightDiff = 0;\n            }\n        }\n        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\n            return parsedDim;\n        }\n        if ((x || y) && element.parentNode.nodeName !== \"#document\") {\n            translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n        }\n        matrix = translateMatrix + \" matrix(\" + scaleX + \" 0\" + \" 0 \" + scaleY + \" \" + (minX * scaleX + widthDiff) + \" \" + (minY * scaleY + heightDiff) + \") \";\n        // seems unused.\n        // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\n        if (element.nodeName === \"svg\") {\n            el = element.ownerDocument.createElementNS(fabric.svgNS, \"g\");\n            // element.firstChild != null\n            while(element.firstChild){\n                el.appendChild(element.firstChild);\n            }\n            element.appendChild(el);\n        } else {\n            el = element;\n            el.removeAttribute(\"x\");\n            el.removeAttribute(\"y\");\n            matrix = el.getAttribute(\"transform\") + matrix;\n        }\n        el.setAttribute(\"transform\", matrix);\n        return parsedDim;\n    }\n    function hasAncestorWithNodeName(element, nodeName) {\n        while(element && (element = element.parentNode)){\n            if (element.nodeName && nodeName.test(element.nodeName.replace(\"svg:\", \"\")) && !element.getAttribute(\"instantiated_by_use\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */ fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {\n        if (!doc) {\n            return;\n        }\n        parseUseDirectives(doc);\n        var svgUid = fabric.Object.__uid++, i, len, options = applyViewboxTransform(doc), descendants = fabric.util.toArray(doc.getElementsByTagName(\"*\"));\n        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;\n        options.svgUid = svgUid;\n        if (descendants.length === 0 && fabric.isLikelyNode) {\n            // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n            // https://github.com/ajaxorg/node-o3-xml/issues/21\n            descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\n            var arr = [];\n            for(i = 0, len = descendants.length; i < len; i++){\n                arr[i] = descendants[i];\n            }\n            descendants = arr;\n        }\n        var elements = descendants.filter(function(el) {\n            applyViewboxTransform(el);\n            return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\")) && !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n        });\n        if (!elements || elements && !elements.length) {\n            callback && callback([], {});\n            return;\n        }\n        var clipPaths = {};\n        descendants.filter(function(el) {\n            return el.nodeName.replace(\"svg:\", \"\") === \"clipPath\";\n        }).forEach(function(el) {\n            var id = el.getAttribute(\"id\");\n            clipPaths[id] = fabric.util.toArray(el.getElementsByTagName(\"*\")).filter(function(el) {\n                return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\"));\n            });\n        });\n        fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\n        fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\n        fabric.clipPaths[svgUid] = clipPaths;\n        // Precedence of rules:   style > class > attribute\n        fabric.parseElements(elements, function(instances, elements) {\n            if (callback) {\n                callback(instances, options, elements, descendants);\n                delete fabric.gradientDefs[svgUid];\n                delete fabric.cssRules[svgUid];\n                delete fabric.clipPaths[svgUid];\n            }\n        }, clone(options), reviver, parsingOptions);\n    };\n    function recursivelyParseGradientsXlink(doc, gradient) {\n        var gradientsAttrs = [\n            \"gradientTransform\",\n            \"x1\",\n            \"x2\",\n            \"y1\",\n            \"y2\",\n            \"gradientUnits\",\n            \"cx\",\n            \"cy\",\n            \"r\",\n            \"fx\",\n            \"fy\"\n        ], xlinkAttr = \"xlink:href\", xLink = gradient.getAttribute(xlinkAttr).slice(1), referencedGradient = elementById(doc, xLink);\n        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n            recursivelyParseGradientsXlink(doc, referencedGradient);\n        }\n        gradientsAttrs.forEach(function(attr) {\n            if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {\n                gradient.setAttribute(attr, referencedGradient.getAttribute(attr));\n            }\n        });\n        if (!gradient.children.length) {\n            var referenceClone = referencedGradient.cloneNode(true);\n            while(referenceClone.firstChild){\n                gradient.appendChild(referenceClone.firstChild);\n            }\n        }\n        gradient.removeAttribute(xlinkAttr);\n    }\n    var reFontDeclaration = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*\" + \"(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + fabric.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + fabric.reNum + \"))?\\\\s+(.*)\");\n    extend(fabric, {\n        /**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */ parseFontDeclaration: function(value, oStyle) {\n            var match = value.match(reFontDeclaration);\n            if (!match) {\n                return;\n            }\n            var fontStyle = match[1], // font variant is not used\n            // fontVariant = match[2],\n            fontWeight = match[3], fontSize = match[4], lineHeight = match[5], fontFamily = match[6];\n            if (fontStyle) {\n                oStyle.fontStyle = fontStyle;\n            }\n            if (fontWeight) {\n                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\n            }\n            if (fontSize) {\n                oStyle.fontSize = parseUnit(fontSize);\n            }\n            if (fontFamily) {\n                oStyle.fontFamily = fontFamily;\n            }\n            if (lineHeight) {\n                oStyle.lineHeight = lineHeight === \"normal\" ? 1 : lineHeight;\n            }\n        },\n        /**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */ getGradientDefs: function(doc) {\n            var tagArray = [\n                \"linearGradient\",\n                \"radialGradient\",\n                \"svg:linearGradient\",\n                \"svg:radialGradient\"\n            ], elList = _getMultipleNodes(doc, tagArray), el, j = 0, gradientDefs = {};\n            j = elList.length;\n            while(j--){\n                el = elList[j];\n                if (el.getAttribute(\"xlink:href\")) {\n                    recursivelyParseGradientsXlink(doc, el);\n                }\n                gradientDefs[el.getAttribute(\"id\")] = el;\n            }\n            return gradientDefs;\n        },\n        /**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */ parseAttributes: function(element, attributes, svgUid) {\n            if (!element) {\n                return;\n            }\n            var value, parentAttributes = {}, fontSize, parentFontSize;\n            if (typeof svgUid === \"undefined\") {\n                svgUid = element.getAttribute(\"svgUid\");\n            }\n            // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\n            if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {\n                parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\n            }\n            var ownAttributes = attributes.reduce(function(memo, attr) {\n                value = element.getAttribute(attr);\n                if (value) {\n                    memo[attr] = value;\n                }\n                return memo;\n            }, {});\n            // add values parsed from style, which take precedence over attributes\n            // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\n            var cssAttrs = extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element));\n            ownAttributes = extend(ownAttributes, cssAttrs);\n            if (cssAttrs[cPath]) {\n                element.setAttribute(cPath, cssAttrs[cPath]);\n            }\n            fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            if (ownAttributes[fSize]) {\n                // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\n                ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);\n            }\n            var normalizedAttr, normalizedValue, normalizedStyle = {};\n            for(var attr in ownAttributes){\n                normalizedAttr = normalizeAttr(attr);\n                normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);\n                normalizedStyle[normalizedAttr] = normalizedValue;\n            }\n            if (normalizedStyle && normalizedStyle.font) {\n                fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);\n            }\n            var mergedAttrs = extend(parentAttributes, normalizedStyle);\n            return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);\n        },\n        /**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */ parseElements: function(elements, callback, options, reviver, parsingOptions) {\n            new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();\n        },\n        /**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */ parseStyleAttribute: function(element) {\n            var oStyle = {}, style = element.getAttribute(\"style\");\n            if (!style) {\n                return oStyle;\n            }\n            if (typeof style === \"string\") {\n                parseStyleString(style, oStyle);\n            } else {\n                parseStyleObject(style, oStyle);\n            }\n            return oStyle;\n        },\n        /**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */ parsePointsAttribute: function(points) {\n            // points attribute is required and must not be empty\n            if (!points) {\n                return null;\n            }\n            // replace commas with whitespace and remove bookending whitespace\n            points = points.replace(/,/g, \" \").trim();\n            points = points.split(/\\s+/);\n            var parsedPoints = [], i, len;\n            for(i = 0, len = points.length; i < len; i += 2){\n                parsedPoints.push({\n                    x: parseFloat(points[i]),\n                    y: parseFloat(points[i + 1])\n                });\n            }\n            // odd number of points is an error\n            // if (parsedPoints.length % 2 !== 0) {\n            //   return null;\n            // }\n            return parsedPoints;\n        },\n        /**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */ getCSSRules: function(doc) {\n            var styles = doc.getElementsByTagName(\"style\"), i, len, allRules = {}, rules;\n            // very crude parsing of style contents\n            for(i = 0, len = styles.length; i < len; i++){\n                var styleContents = styles[i].textContent;\n                // remove comments\n                styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n                if (styleContents.trim() === \"\") {\n                    continue;\n                }\n                // recovers all the rule in this form `body { style code... }`\n                // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n                rules = styleContents.split(\"}\");\n                // remove empty rules.\n                rules = rules.filter(function(rule) {\n                    return rule.trim();\n                });\n                // at this point we have hopefully an array of rules `body { style code... `\n                // eslint-disable-next-line no-loop-func\n                rules.forEach(function(rule) {\n                    var match = rule.split(\"{\"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(\";\").filter(function(pair) {\n                        return pair.trim();\n                    });\n                    for(i = 0, len = propertyValuePairs.length; i < len; i++){\n                        var pair = propertyValuePairs[i].split(\":\"), property = pair[0].trim(), value = pair[1].trim();\n                        ruleObj[property] = value;\n                    }\n                    rule = match[0].trim();\n                    rule.split(\",\").forEach(function(_rule) {\n                        _rule = _rule.replace(/^svg/i, \"\").trim();\n                        if (_rule === \"\") {\n                            return;\n                        }\n                        if (allRules[_rule]) {\n                            fabric.util.object.extend(allRules[_rule], ruleObj);\n                        } else {\n                            allRules[_rule] = fabric.util.object.clone(ruleObj);\n                        }\n                    });\n                });\n            }\n            return allRules;\n        },\n        /**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromURL: function(url, callback, reviver, options) {\n            url = url.replace(/^\\n\\s*/, \"\").trim();\n            new fabric.util.request(url, {\n                method: \"get\",\n                onComplete: onComplete\n            });\n            function onComplete(r) {\n                var xml = r.responseXML;\n                if (!xml || !xml.documentElement) {\n                    callback && callback(null);\n                    return false;\n                }\n                fabric.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {\n                    callback && callback(results, _options, elements, allElements);\n                }, reviver, options);\n            }\n        },\n        /**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromString: function(string, callback, reviver, options) {\n            var parser = new fabric.window.DOMParser(), doc = parser.parseFromString(string.trim(), \"text/xml\");\n            fabric.parseSVGDocument(doc.documentElement, function(results, _options, elements, allElements) {\n                callback(results, _options, elements, allElements);\n            }, reviver, options);\n        }\n    });\n})( true ? exports : 0);\nfabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {\n    this.elements = elements;\n    this.callback = callback;\n    this.options = options;\n    this.reviver = reviver;\n    this.svgUid = options && options.svgUid || 0;\n    this.parsingOptions = parsingOptions;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n};\n(function(proto) {\n    proto.parse = function() {\n        this.instances = new Array(this.elements.length);\n        this.numElements = this.elements.length;\n        this.createObjects();\n    };\n    proto.createObjects = function() {\n        var _this = this;\n        this.elements.forEach(function(element, i) {\n            element.setAttribute(\"svgUid\", _this.svgUid);\n            _this.createObject(element, i);\n        });\n    };\n    proto.findTag = function(el) {\n        return fabric[fabric.util.string.capitalize(el.tagName.replace(\"svg:\", \"\"))];\n    };\n    proto.createObject = function(el, index) {\n        var klass = this.findTag(el);\n        if (klass && klass.fromElement) {\n            try {\n                klass.fromElement(el, this.createCallback(index, el), this.options);\n            } catch (err) {\n                fabric.log(err);\n            }\n        } else {\n            this.checkIfDone();\n        }\n    };\n    proto.createCallback = function(index, el) {\n        var _this = this;\n        return function(obj) {\n            var _options;\n            _this.resolveGradient(obj, el, \"fill\");\n            _this.resolveGradient(obj, el, \"stroke\");\n            if (obj instanceof fabric.Image && obj._originalElement) {\n                _options = obj.parsePreserveAspectRatioAttribute(el);\n            }\n            obj._removeTransformMatrix(_options);\n            _this.resolveClipPath(obj, el);\n            _this.reviver && _this.reviver(el, obj);\n            _this.instances[index] = obj;\n            _this.checkIfDone();\n        };\n    };\n    proto.extractPropertyDefinition = function(obj, property, storage) {\n        var value = obj[property], regex = this.regexUrl;\n        if (!regex.test(value)) {\n            return;\n        }\n        regex.lastIndex = 0;\n        var id = regex.exec(value)[1];\n        regex.lastIndex = 0;\n        return fabric[storage][this.svgUid][id];\n    };\n    proto.resolveGradient = function(obj, el, property) {\n        var gradientDef = this.extractPropertyDefinition(obj, property, \"gradientDefs\");\n        if (gradientDef) {\n            var opacityAttr = el.getAttribute(property + \"-opacity\");\n            var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);\n            obj.set(property, gradient);\n        }\n    };\n    proto.createClipPathCallback = function(obj, container) {\n        return function(_newObj) {\n            _newObj._removeTransformMatrix();\n            _newObj.fillRule = _newObj.clipRule;\n            container.push(_newObj);\n        };\n    };\n    proto.resolveClipPath = function(obj, usingElement) {\n        var clipPath = this.extractPropertyDefinition(obj, \"clipPath\", \"clipPaths\"), element, klass, objTransformInv, container, gTransform, options;\n        if (clipPath) {\n            container = [];\n            objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());\n            // move the clipPath tag as sibling to the real element that is using it\n            var clipPathTag = clipPath[0].parentNode;\n            var clipPathOwner = usingElement;\n            while(clipPathOwner.parentNode && clipPathOwner.getAttribute(\"clip-path\") !== obj.clipPath){\n                clipPathOwner = clipPathOwner.parentNode;\n            }\n            clipPathOwner.parentNode.appendChild(clipPathTag);\n            for(var i = 0; i < clipPath.length; i++){\n                element = clipPath[i];\n                klass = this.findTag(element);\n                klass.fromElement(element, this.createClipPathCallback(obj, container), this.options);\n            }\n            if (container.length === 1) {\n                clipPath = container[0];\n            } else {\n                clipPath = new fabric.Group(container);\n            }\n            gTransform = fabric.util.multiplyTransformMatrices(objTransformInv, clipPath.calcTransformMatrix());\n            if (clipPath.clipPath) {\n                this.resolveClipPath(clipPath, clipPathOwner);\n            }\n            var options = fabric.util.qrDecompose(gTransform);\n            clipPath.flipX = false;\n            clipPath.flipY = false;\n            clipPath.set(\"scaleX\", options.scaleX);\n            clipPath.set(\"scaleY\", options.scaleY);\n            clipPath.angle = options.angle;\n            clipPath.skewX = options.skewX;\n            clipPath.skewY = 0;\n            clipPath.setPositionByOrigin({\n                x: options.translateX,\n                y: options.translateY\n            }, \"center\", \"center\");\n            obj.clipPath = clipPath;\n        } else {\n            // if clip-path does not resolve to any element, delete the property.\n            delete obj.clipPath;\n        }\n    };\n    proto.checkIfDone = function() {\n        if (--this.numElements === 0) {\n            this.instances = this.instances.filter(function(el) {\n                // eslint-disable-next-line no-eq-null, eqeqeq\n                return el != null;\n            });\n            this.callback(this.instances, this.elements);\n        }\n    };\n})(fabric.ElementsParser.prototype);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Point) {\n        fabric.warn(\"fabric.Point is already defined\");\n        return;\n    }\n    fabric.Point = Point;\n    /**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */ function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype = /** @lends fabric.Point.prototype */ {\n        type: \"point\",\n        constructor: Point,\n        /**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */ add: function(that) {\n            return new Point(this.x + that.x, this.y + that.y);\n        },\n        /**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ addEquals: function(that) {\n            this.x += that.x;\n            this.y += that.y;\n            return this;\n        },\n        /**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */ scalarAdd: function(scalar) {\n            return new Point(this.x + scalar, this.y + scalar);\n        },\n        /**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarAddEquals: function(scalar) {\n            this.x += scalar;\n            this.y += scalar;\n            return this;\n        },\n        /**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */ subtract: function(that) {\n            return new Point(this.x - that.x, this.y - that.y);\n        },\n        /**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ subtractEquals: function(that) {\n            this.x -= that.x;\n            this.y -= that.y;\n            return this;\n        },\n        /**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ scalarSubtract: function(scalar) {\n            return new Point(this.x - scalar, this.y - scalar);\n        },\n        /**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarSubtractEquals: function(scalar) {\n            this.x -= scalar;\n            this.y -= scalar;\n            return this;\n        },\n        /**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ multiply: function(scalar) {\n            return new Point(this.x * scalar, this.y * scalar);\n        },\n        /**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ multiplyEquals: function(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            return this;\n        },\n        /**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ divide: function(scalar) {\n            return new Point(this.x / scalar, this.y / scalar);\n        },\n        /**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ divideEquals: function(scalar) {\n            this.x /= scalar;\n            this.y /= scalar;\n            return this;\n        },\n        /**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ eq: function(that) {\n            return this.x === that.x && this.y === that.y;\n        },\n        /**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lt: function(that) {\n            return this.x < that.x && this.y < that.y;\n        },\n        /**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lte: function(that) {\n            return this.x <= that.x && this.y <= that.y;\n        },\n        /**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gt: function(that) {\n            return this.x > that.x && this.y > that.y;\n        },\n        /**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gte: function(that) {\n            return this.x >= that.x && this.y >= that.y;\n        },\n        /**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */ lerp: function(that, t) {\n            if (typeof t === \"undefined\") {\n                t = 0.5;\n            }\n            t = Math.max(Math.min(1, t), 0);\n            return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\n        },\n        /**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */ distanceFrom: function(that) {\n            var dx = this.x - that.x, dy = this.y - that.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        /**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ midPointFrom: function(that) {\n            return this.lerp(that);\n        },\n        /**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ min: function(that) {\n            return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\n        },\n        /**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ max: function(that) {\n            return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\n        },\n        /**\n     * Returns string representation of this point\n     * @return {String}\n     */ toString: function() {\n            return this.x + \",\" + this.y;\n        },\n        /**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */ setXY: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */ setX: function(x) {\n            this.x = x;\n            return this;\n        },\n        /**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */ setY: function(y) {\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */ setFromPoint: function(that) {\n            this.x = that.x;\n            this.y = that.y;\n            return this;\n        },\n        /**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */ swap: function(that) {\n            var x = this.x, y = this.y;\n            this.x = that.x;\n            this.y = that.y;\n            that.x = x;\n            that.y = y;\n        },\n        /**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */ clone: function() {\n            return new Point(this.x, this.y);\n        }\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Intersection) {\n        fabric.warn(\"fabric.Intersection is already defined\");\n        return;\n    }\n    /**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */ function Intersection(status) {\n        this.status = status;\n        this.points = [];\n    }\n    fabric.Intersection = Intersection;\n    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\n        constructor: Intersection,\n        /**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoint: function(point) {\n            this.points.push(point);\n            return this;\n        },\n        /**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoints: function(points) {\n            this.points = this.points.concat(points);\n            return this;\n        }\n    };\n    /**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {\n        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (uB !== 0) {\n            var ua = uaT / uB, ub = ubT / uB;\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\n            } else {\n                result = new Intersection();\n            }\n        } else {\n            if (uaT === 0 || ubT === 0) {\n                result = new Intersection(\"Coincident\");\n            } else {\n                result = new Intersection(\"Parallel\");\n            }\n        }\n        return result;\n    };\n    /**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\n        var result = new Intersection(), length = points.length, b1, b2, inter, i;\n        for(i = 0; i < length; i++){\n            b1 = points[i];\n            b2 = points[(i + 1) % length];\n            inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {\n        var result = new Intersection(), length = points1.length, i;\n        for(i = 0; i < length; i++){\n            var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {\n        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric.Point(max.x, min.y), bottomLeft = new fabric.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Color) {\n        fabric.warn(\"fabric.Color is already defined.\");\n        return;\n    }\n    /**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */ function Color(color) {\n        if (!color) {\n            this.setSource([\n                0,\n                0,\n                0,\n                1\n            ]);\n        } else {\n            this._tryParsingColor(color);\n        }\n    }\n    fabric.Color = Color;\n    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\n        /**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */ _tryParsingColor: function(color) {\n            var source;\n            if (color in Color.colorNameMap) {\n                color = Color.colorNameMap[color];\n            }\n            if (color === \"transparent\") {\n                source = [\n                    255,\n                    255,\n                    255,\n                    0\n                ];\n            }\n            if (!source) {\n                source = Color.sourceFromHex(color);\n            }\n            if (!source) {\n                source = Color.sourceFromRgb(color);\n            }\n            if (!source) {\n                source = Color.sourceFromHsl(color);\n            }\n            if (!source) {\n                //if color is not recognize let's make black as canvas does\n                source = [\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n            }\n            if (source) {\n                this.setSource(source);\n            }\n        },\n        /**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */ _rgbToHsl: function(r, g, b) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            var h, s, l, max = fabric.util.array.max([\n                r,\n                g,\n                b\n            ]), min = fabric.util.array.min([\n                r,\n                g,\n                b\n            ]);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                Math.round(h * 360),\n                Math.round(s * 100),\n                Math.round(l * 100)\n            ];\n        },\n        /**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */ getSource: function() {\n            return this._source;\n        },\n        /**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */ setSource: function(source) {\n            this._source = source;\n        },\n        /**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */ toRgb: function() {\n            var source = this.getSource();\n            return \"rgb(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \")\";\n        },\n        /**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */ toRgba: function() {\n            var source = this.getSource();\n            return \"rgba(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \",\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */ toHsl: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsl(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%)\";\n        },\n        /**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */ toHsla: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsla(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%,\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */ toHex: function() {\n            var source = this.getSource(), r, g, b;\n            r = source[0].toString(16);\n            r = r.length === 1 ? \"0\" + r : r;\n            g = source[1].toString(16);\n            g = g.length === 1 ? \"0\" + g : g;\n            b = source[2].toString(16);\n            b = b.length === 1 ? \"0\" + b : b;\n            return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\n        },\n        /**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */ toHexa: function() {\n            var source = this.getSource(), a;\n            a = Math.round(source[3] * 255);\n            a = a.toString(16);\n            a = a.length === 1 ? \"0\" + a : a;\n            return this.toHex() + a.toUpperCase();\n        },\n        /**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */ getAlpha: function() {\n            return this.getSource()[3];\n        },\n        /**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */ setAlpha: function(alpha) {\n            var source = this.getSource();\n            source[3] = alpha;\n            this.setSource(source);\n            return this;\n        },\n        /**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */ toGrayscale: function() {\n            var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */ toBlackWhite: function(threshold) {\n            var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];\n            threshold = threshold || 127;\n            average = Number(average) < Number(threshold) ? 0 : 255;\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */ overlayWith: function(otherColor) {\n            if (!(otherColor instanceof Color)) {\n                otherColor = new Color(otherColor);\n            }\n            var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i;\n            for(i = 0; i < 3; i++){\n                result.push(Math.round(source[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));\n            }\n            result[3] = alpha;\n            this.setSource(result);\n            return this;\n        }\n    };\n    /**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\n    fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\n    /**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */ fabric.Color.colorNameMap = {\n        aliceblue: \"#F0F8FF\",\n        antiquewhite: \"#FAEBD7\",\n        aqua: \"#00FFFF\",\n        aquamarine: \"#7FFFD4\",\n        azure: \"#F0FFFF\",\n        beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\",\n        black: \"#000000\",\n        blanchedalmond: \"#FFEBCD\",\n        blue: \"#0000FF\",\n        blueviolet: \"#8A2BE2\",\n        brown: \"#A52A2A\",\n        burlywood: \"#DEB887\",\n        cadetblue: \"#5F9EA0\",\n        chartreuse: \"#7FFF00\",\n        chocolate: \"#D2691E\",\n        coral: \"#FF7F50\",\n        cornflowerblue: \"#6495ED\",\n        cornsilk: \"#FFF8DC\",\n        crimson: \"#DC143C\",\n        cyan: \"#00FFFF\",\n        darkblue: \"#00008B\",\n        darkcyan: \"#008B8B\",\n        darkgoldenrod: \"#B8860B\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        darkgreen: \"#006400\",\n        darkkhaki: \"#BDB76B\",\n        darkmagenta: \"#8B008B\",\n        darkolivegreen: \"#556B2F\",\n        darkorange: \"#FF8C00\",\n        darkorchid: \"#9932CC\",\n        darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\",\n        darkseagreen: \"#8FBC8F\",\n        darkslateblue: \"#483D8B\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        darkturquoise: \"#00CED1\",\n        darkviolet: \"#9400D3\",\n        deeppink: \"#FF1493\",\n        deepskyblue: \"#00BFFF\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        dodgerblue: \"#1E90FF\",\n        firebrick: \"#B22222\",\n        floralwhite: \"#FFFAF0\",\n        forestgreen: \"#228B22\",\n        fuchsia: \"#FF00FF\",\n        gainsboro: \"#DCDCDC\",\n        ghostwhite: \"#F8F8FF\",\n        gold: \"#FFD700\",\n        goldenrod: \"#DAA520\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        green: \"#008000\",\n        greenyellow: \"#ADFF2F\",\n        honeydew: \"#F0FFF0\",\n        hotpink: \"#FF69B4\",\n        indianred: \"#CD5C5C\",\n        indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\",\n        khaki: \"#F0E68C\",\n        lavender: \"#E6E6FA\",\n        lavenderblush: \"#FFF0F5\",\n        lawngreen: \"#7CFC00\",\n        lemonchiffon: \"#FFFACD\",\n        lightblue: \"#ADD8E6\",\n        lightcoral: \"#F08080\",\n        lightcyan: \"#E0FFFF\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        lightgreen: \"#90EE90\",\n        lightpink: \"#FFB6C1\",\n        lightsalmon: \"#FFA07A\",\n        lightseagreen: \"#20B2AA\",\n        lightskyblue: \"#87CEFA\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        lightsteelblue: \"#B0C4DE\",\n        lightyellow: \"#FFFFE0\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        linen: \"#FAF0E6\",\n        magenta: \"#FF00FF\",\n        maroon: \"#800000\",\n        mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        mediumseagreen: \"#3CB371\",\n        mediumslateblue: \"#7B68EE\",\n        mediumspringgreen: \"#00FA9A\",\n        mediumturquoise: \"#48D1CC\",\n        mediumvioletred: \"#C71585\",\n        midnightblue: \"#191970\",\n        mintcream: \"#F5FFFA\",\n        mistyrose: \"#FFE4E1\",\n        moccasin: \"#FFE4B5\",\n        navajowhite: \"#FFDEAD\",\n        navy: \"#000080\",\n        oldlace: \"#FDF5E6\",\n        olive: \"#808000\",\n        olivedrab: \"#6B8E23\",\n        orange: \"#FFA500\",\n        orangered: \"#FF4500\",\n        orchid: \"#DA70D6\",\n        palegoldenrod: \"#EEE8AA\",\n        palegreen: \"#98FB98\",\n        paleturquoise: \"#AFEEEE\",\n        palevioletred: \"#DB7093\",\n        papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\",\n        peru: \"#CD853F\",\n        pink: \"#FFC0CB\",\n        plum: \"#DDA0DD\",\n        powderblue: \"#B0E0E6\",\n        purple: \"#800080\",\n        rebeccapurple: \"#663399\",\n        red: \"#FF0000\",\n        rosybrown: \"#BC8F8F\",\n        royalblue: \"#4169E1\",\n        saddlebrown: \"#8B4513\",\n        salmon: \"#FA8072\",\n        sandybrown: \"#F4A460\",\n        seagreen: \"#2E8B57\",\n        seashell: \"#FFF5EE\",\n        sienna: \"#A0522D\",\n        silver: \"#C0C0C0\",\n        skyblue: \"#87CEEB\",\n        slateblue: \"#6A5ACD\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        snow: \"#FFFAFA\",\n        springgreen: \"#00FF7F\",\n        steelblue: \"#4682B4\",\n        tan: \"#D2B48C\",\n        teal: \"#008080\",\n        thistle: \"#D8BFD8\",\n        tomato: \"#FF6347\",\n        turquoise: \"#40E0D0\",\n        violet: \"#EE82EE\",\n        wheat: \"#F5DEB3\",\n        white: \"#FFFFFF\",\n        whitesmoke: \"#F5F5F5\",\n        yellow: \"#FFFF00\",\n        yellowgreen: \"#9ACD32\"\n    };\n    /**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */ function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgb = function(color) {\n        return Color.fromSource(Color.sourceFromRgb(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */ fabric.Color.sourceFromRgb = function(color) {\n        var match = color.match(Color.reRGBa);\n        if (match) {\n            var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\n            return [\n                parseInt(r, 10),\n                parseInt(g, 10),\n                parseInt(b, 10),\n                match[4] ? parseFloat(match[4]) : 1\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgba = Color.fromRgb;\n    /**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsl = function(color) {\n        return Color.fromSource(Color.sourceFromHsl(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */ fabric.Color.sourceFromHsl = function(color) {\n        var match = color.match(Color.reHSLa);\n        if (!match) {\n            return;\n        }\n        var h = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            var q = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n    };\n    /**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsla = Color.fromHsl;\n    /**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */ fabric.Color.fromHex = function(color) {\n        return Color.fromSource(Color.sourceFromHex(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */ fabric.Color.sourceFromHex = function(color) {\n        if (color.match(Color.reHex)) {\n            var value = color.slice(color.indexOf(\"#\") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : \"FF\";\n            return [\n                parseInt(r, 16),\n                parseInt(g, 16),\n                parseInt(b, 16),\n                parseFloat((parseInt(a, 16) / 255).toFixed(2))\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */ fabric.Color.fromSource = function(source) {\n        var oColor = new Color();\n        oColor.setSource(source);\n        return oColor;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), scaleMap = [\n        \"e\",\n        \"se\",\n        \"s\",\n        \"sw\",\n        \"w\",\n        \"nw\",\n        \"n\",\n        \"ne\",\n        \"e\"\n    ], skewMap = [\n        \"ns\",\n        \"nesw\",\n        \"ew\",\n        \"nwse\"\n    ], controls = {}, LEFT = \"left\", TOP = \"top\", RIGHT = \"right\", BOTTOM = \"bottom\", CENTER = \"center\", opposite = {\n        top: BOTTOM,\n        bottom: TOP,\n        left: RIGHT,\n        right: LEFT,\n        center: CENTER\n    }, radiansToDegrees = fabric.util.radiansToDegrees, sign = Math.sign || function(x) {\n        return (x > 0) - (x < 0) || +x;\n    };\n    /**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */ function findCornerQuadrant(fabricObject, control) {\n        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n        return Math.round(cornerAngle % 360 / 45);\n    }\n    function fireEvent(eventName, options) {\n        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric.util.object.clone(options);\n        canvasOptions.target = target;\n        canvas && canvas.fire(\"object:\" + eventName, canvasOptions);\n        target.fire(eventName, options);\n    }\n    /**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */ function scaleIsProportional(eventData, fabricObject) {\n        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];\n        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;\n    }\n    /**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */ function isTransformCentered(transform) {\n        return transform.originX === CENTER && transform.originY === CENTER;\n    }\n    /**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */ function scalingIsForbidden(fabricObject, by, scaleProportionally) {\n        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;\n        if (lockX && lockY) {\n            return true;\n        }\n        if (!by && (lockX || lockY) && scaleProportionally) {\n            return true;\n        }\n        if (lockX && by === \"x\") {\n            return true;\n        }\n        if (lockY && by === \"y\") {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = \"\";\n        if (control.x !== 0 && control.y === 0) {\n            by = \"x\";\n        } else if (control.x === 0 && control.y !== 0) {\n            by = \"y\";\n        }\n        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control);\n        return scaleMap[n] + \"-resize\";\n    }\n    /**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function skewCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\";\n        if (control.x !== 0 && fabricObject.lockSkewingY) {\n            return notAllowed;\n        }\n        if (control.y !== 0 && fabricObject.lockSkewingX) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control) % 4;\n        return skewMap[n] + \"-resize\";\n    }\n    /**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {\n        if (eventData[fabricObject.canvas.altActionKey]) {\n            return controls.skewCursorStyleHandler(eventData, control, fabricObject);\n        }\n        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);\n    }\n    /**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */ function scaleOrSkewActionName(eventData, control, fabricObject) {\n        var isAlternative = eventData[fabricObject.canvas.altActionKey];\n        if (control.x === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewX\" : \"scaleY\";\n        }\n        if (control.y === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewY\" : \"scaleX\";\n        }\n    }\n    /**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function rotationStyleHandler(eventData, control, fabricObject) {\n        if (fabricObject.lockRotation) {\n            return \"not-allowed\";\n        }\n        return control.cursorStyle;\n    }\n    function commonEventInfo(eventData, transform, x, y) {\n        return {\n            e: eventData,\n            transform: transform,\n            pointer: {\n                x: x,\n                y: y\n            }\n        };\n    }\n    /**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFixedAnchor(actionHandler) {\n        return function(eventData, transform, x, y) {\n            var target = transform.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY), actionPerformed = actionHandler(eventData, transform, x, y);\n            target.setPositionByOrigin(constraint, transform.originX, transform.originY);\n            return actionPerformed;\n        };\n    }\n    /**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFireEvent(eventName, actionHandler) {\n        return function(eventData, transform, x, y) {\n            var actionPerformed = actionHandler(eventData, transform, x, y);\n            if (actionPerformed) {\n                fireEvent(eventName, commonEventInfo(eventData, transform, x, y));\n            }\n            return actionPerformed;\n        };\n    }\n    /**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */ function getLocalPoint(transform, originX, originY, x, y) {\n        var target = transform.target, control = target.controls[transform.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);\n        if (localPoint.x >= padding) {\n            localPoint.x -= padding;\n        }\n        if (localPoint.x <= -padding) {\n            localPoint.x += padding;\n        }\n        if (localPoint.y >= padding) {\n            localPoint.y -= padding;\n        }\n        if (localPoint.y <= padding) {\n            localPoint.y += padding;\n        }\n        localPoint.x -= control.offsetX;\n        localPoint.y -= control.offsetY;\n        return localPoint;\n    }\n    /**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */ function targetHasOneFlip(target) {\n        return target.flipX !== target.flipY;\n    }\n    /**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */ function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {\n        if (target[oppositeSkew] !== 0) {\n            var newDim = target._getTransformedDimensions()[axis];\n            var newValue = reference / newDim * target[scaleToCompensate];\n            target.set(scaleToCompensate, newValue);\n        }\n    }\n    /**\n   * Action handler for skewing on the X axis\n   * @private\n   */ function skewObjectX(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().y;\n            target.set(\"skewX\", newSkew);\n            compensateScaleForSkew(target, \"skewY\", \"scaleY\", \"y\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Action handler for skewing on the Y axis\n   * @private\n   */ function skewObjectY(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().x;\n            target.set(\"skewY\", newSkew);\n            compensateScaleForSkew(target, \"skewX\", \"scaleX\", \"x\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerX(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewX > 0 and originY bottom we anchor on right\n        // if skewX > 0 and originY top we anchor on left\n        // if skewX < 0 and originY bottom we anchor on left\n        // if skewX < 0 and originY top we anchor on right\n        // if skewX is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;\n        if (target.lockSkewingX) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.x > 0) {\n                // we are pulling right, anchor left;\n                originX = LEFT;\n            } else {\n                // we are pulling right, anchor right\n                originX = RIGHT;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originX = originY === TOP ? LEFT : RIGHT;\n            }\n            if (currentSkew < 0) {\n                originX = originY === TOP ? RIGHT : LEFT;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originX = originX === LEFT ? RIGHT : LEFT;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originX = originX;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectX));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerY(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewY > 0 and originX left we anchor on top\n        // if skewY > 0 and originX right we anchor on bottom\n        // if skewY < 0 and originX left we anchor on bottom\n        // if skewY < 0 and originX right we anchor on top\n        // if skewY is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;\n        if (target.lockSkewingY) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.y > 0) {\n                // we are pulling down, anchor up;\n                originY = TOP;\n            } else {\n                // we are pulling up, anchor down\n                originY = BOTTOM;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originY = originX === LEFT ? TOP : BOTTOM;\n            }\n            if (currentSkew < 0) {\n                originY = originX === LEFT ? BOTTOM : TOP;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originY = originY === TOP ? BOTTOM : TOP;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originY = originY;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectY));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function rotationWithSnapping(eventData, transform, x, y) {\n        var t = transform, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);\n        if (target.lockRotation) {\n            return false;\n        }\n        var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;\n        if (target.snapAngle > 0) {\n            var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\n            if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\n                angle = leftAngleLocked;\n            } else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\n                angle = rightAngleLocked;\n            }\n        }\n        // normalize angle to positive value\n        if (angle < 0) {\n            angle = 360 + angle;\n        }\n        angle %= 360;\n        hasRotated = target.angle !== angle;\n        target.angle = angle;\n        return hasRotated;\n    }\n    /**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function scaleObject(eventData, transform, x, y, options) {\n        options = options || {};\n        var target = transform.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform.gestureScale;\n        if (forbidScaling) {\n            return false;\n        }\n        if (gestureScale) {\n            scaleX = transform.scaleX * gestureScale;\n            scaleY = transform.scaleY * gestureScale;\n        } else {\n            newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);\n            // use of sign: We use sign to detect change of direction of an action. sign usually change when\n            // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n            // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n            // cross many time the origin point and flip the object. so we need a way to filter out the noise.\n            // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\n            signX = by !== \"y\" ? sign(newPoint.x) : 1;\n            signY = by !== \"x\" ? sign(newPoint.y) : 1;\n            if (!transform.signX) {\n                transform.signX = signX;\n            }\n            if (!transform.signY) {\n                transform.signY = signY;\n            }\n            if (target.lockScalingFlip && (transform.signX !== signX || transform.signY !== signY)) {\n                return false;\n            }\n            dim = target._getTransformedDimensions();\n            // missing detection of flip and logic to switch the origin\n            if (scaleProportionally && !by) {\n                // uniform scaling\n                var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance / originalDistance;\n                scaleX = original.scaleX * scale;\n                scaleY = original.scaleY * scale;\n            } else {\n                scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);\n                scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);\n            }\n            // if we are scaling by center, we need to double the scale\n            if (isTransformCentered(transform)) {\n                scaleX *= 2;\n                scaleY *= 2;\n            }\n            if (transform.signX !== signX && by !== \"y\") {\n                transform.originX = opposite[transform.originX];\n                scaleX *= -1;\n                transform.signX = signX;\n            }\n            if (transform.signY !== signY && by !== \"x\") {\n                transform.originY = opposite[transform.originY];\n                scaleY *= -1;\n                transform.signY = signY;\n            }\n        }\n        // minScale is taken are in the setter.\n        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;\n        if (!by) {\n            !lockScalingX && target.set(\"scaleX\", scaleX);\n            !lockScalingY && target.set(\"scaleY\", scaleY);\n        } else {\n            // forbidden cases already handled on top here.\n            by === \"x\" && target.set(\"scaleX\", scaleX);\n            by === \"y\" && target.set(\"scaleY\", scaleY);\n        }\n        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;\n    }\n    /**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectFromCorner(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y);\n    }\n    /**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectX(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"x\"\n        });\n    }\n    /**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectY(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"y\"\n        });\n    }\n    /**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingYOrSkewingX(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerX(eventData, transform, x, y);\n        }\n        return controls.scalingY(eventData, transform, x, y);\n    }\n    /**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingXOrSkewingY(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerY(eventData, transform, x, y);\n        }\n        return controls.scalingX(eventData, transform, x, y);\n    }\n    /**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function changeWidth(eventData, transform, x, y) {\n        var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;\n        target.set(\"width\", Math.max(newWidth, 0));\n        return oldWidth !== newWidth;\n    }\n    /**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */ function dragHandler(eventData, transform, x, y) {\n        var target = transform.target, newLeft = x - transform.offsetX, newTop = y - transform.offsetY, moveX = !target.get(\"lockMovementX\") && target.left !== newLeft, moveY = !target.get(\"lockMovementY\") && target.top !== newTop;\n        moveX && target.set(\"left\", newLeft);\n        moveY && target.set(\"top\", newTop);\n        if (moveX || moveY) {\n            fireEvent(\"moving\", commonEventInfo(eventData, transform, x, y));\n        }\n        return moveX || moveY;\n    }\n    controls.scaleCursorStyleHandler = scaleCursorStyleHandler;\n    controls.skewCursorStyleHandler = skewCursorStyleHandler;\n    controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;\n    controls.rotationWithSnapping = wrapWithFireEvent(\"rotating\", wrapWithFixedAnchor(rotationWithSnapping));\n    controls.scalingEqually = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectFromCorner));\n    controls.scalingX = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectX));\n    controls.scalingY = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectY));\n    controls.scalingYOrSkewingX = scalingYOrSkewingX;\n    controls.scalingXOrSkewingY = scalingXOrSkewingY;\n    controls.changeWidth = wrapWithFireEvent(\"resizing\", wrapWithFixedAnchor(changeWidth));\n    controls.skewHandlerX = skewHandlerX;\n    controls.skewHandlerY = skewHandlerY;\n    controls.dragHandler = dragHandler;\n    controls.scaleOrSkewActionName = scaleOrSkewActionName;\n    controls.rotationStyleHandler = rotationStyleHandler;\n    controls.fireEvent = fireEvent;\n    controls.wrapWithFixedAnchor = wrapWithFixedAnchor;\n    controls.wrapWithFireEvent = wrapWithFireEvent;\n    controls.getLocalPoint = getLocalPoint;\n    fabric.controlsUtils = controls;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians, controls = fabric.controlsUtils;\n    /**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // as soon as fabric react v5, remove ie11, use proper ellipse code.\n        if (xSize > ySize) {\n            size = xSize;\n            ctx.scale(1.0, ySize / xSize);\n            myTop = top * xSize / ySize;\n        } else if (ySize > xSize) {\n            size = ySize;\n            ctx.scale(xSize / ySize, 1.0);\n            myLeft = left * ySize / xSize;\n        } else {\n            size = xSize;\n        }\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);\n        ctx[methodName]();\n        if (stroke) {\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    /**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.translate(left, top);\n        ctx.rotate(degreesToRadians(fabricObject.angle));\n        // this does not work, and fixed with ( && ) does not make sense.\n        // to have real transparent corners we need the controls on upperCanvas\n        // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        ctx[methodName + \"Rect\"](-xSizeBy2, -ySizeBy2, xSize, ySize);\n        if (stroke) {\n            ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        }\n        ctx.restore();\n    }\n    controls.renderCircleControl = renderCircleControl;\n    controls.renderSquareControl = renderSquareControl;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    function Control(options) {\n        for(var i in options){\n            this[i] = options[i];\n        }\n    }\n    fabric.Control = Control;\n    fabric.Control.prototype = /** @lends fabric.Control.prototype */ {\n        /**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */ visible: true,\n        /**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */ actionName: \"scale\",\n        /**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */ angle: 0,\n        /**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ x: 0,\n        /**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ y: 0,\n        /**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeX: null,\n        /**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeY: null,\n        /**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeX: null,\n        /**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeY: null,\n        /**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */ cursorStyle: \"crosshair\",\n        /**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */ withConnection: false,\n        /**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ actionHandler: function() {},\n        /**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseDownHandler: function() {},\n        /**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseUpHandler: function() {},\n        /**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getActionHandler: function() {\n            return this.actionHandler;\n        },\n        /**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseDownHandler: function() {\n            return this.mouseDownHandler;\n        },\n        /**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseUpHandler: function() {\n            return this.mouseUpHandler;\n        },\n        /**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ cursorStyleHandler: function(eventData, control /* fabricObject */ ) {\n            return control.cursorStyle;\n        },\n        /**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ getActionName: function(eventData, control /* fabricObject */ ) {\n            return control.actionName;\n        },\n        /**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */ getVisibility: function(fabricObject, controlKey) {\n            var objectVisibility = fabricObject._controlsVisibility;\n            if (objectVisibility && typeof objectVisibility[controlKey] !== \"undefined\") {\n                return objectVisibility[controlKey];\n            }\n            return this.visible;\n        },\n        /**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */ setVisibility: function(visibility /* name, fabricObject */ ) {\n            this.visible = visibility;\n        },\n        positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */ ) {\n            var point = fabric.util.transformPoint({\n                x: this.x * dim.x + this.offsetX,\n                y: this.y * dim.y + this.offsetY\n            }, finalMatrix);\n            return point;\n        },\n        /**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */ calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {\n            var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;\n            if (xSize && ySize && xSize !== ySize) {\n                // handle rectangular corners\n                var controlTriangleAngle = Math.atan2(ySize, xSize);\n                var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;\n                var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);\n                // use complementary angle for two corners\n                cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);\n                sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);\n            } else {\n                // handle square corners\n                // use default object corner size unless size is defined\n                var cornerSize = xSize && ySize ? xSize : objectCornerSize;\n                /* 0.7071067812 stands for sqrt(2)/2 */ cornerHypotenuse = cornerSize * 0.7071067812;\n                // complementary angles are equal since they're both 45 degrees\n                var newTheta = fabric.util.degreesToRadians(45 - objectAngle);\n                cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);\n            }\n            return {\n                tl: {\n                    x: centerX - sinHalfOffsetComp,\n                    y: centerY - cosHalfOffsetComp\n                },\n                tr: {\n                    x: centerX + cosHalfOffset,\n                    y: centerY - sinHalfOffset\n                },\n                bl: {\n                    x: centerX - cosHalfOffset,\n                    y: centerY + sinHalfOffset\n                },\n                br: {\n                    x: centerX + sinHalfOffsetComp,\n                    y: centerY + cosHalfOffsetComp\n                }\n            };\n        },\n        /**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */ render: function(ctx, left, top, styleOverride, fabricObject) {\n            styleOverride = styleOverride || {};\n            switch(styleOverride.cornerStyle || fabricObject.cornerStyle){\n                case \"circle\":\n                    fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);\n                    break;\n                default:\n                    fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);\n            }\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    /* _FROM_SVG_START_ */ function getColorStop(el, multiplier) {\n        var style = el.getAttribute(\"style\"), offset = el.getAttribute(\"offset\") || 0, color, colorAlpha, opacity, i;\n        // convert percents to absolute values\n        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\n        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\n        if (style) {\n            var keyValuePairs = style.split(/\\s*;\\s*/);\n            if (keyValuePairs[keyValuePairs.length - 1] === \"\") {\n                keyValuePairs.pop();\n            }\n            for(i = keyValuePairs.length; i--;){\n                var split = keyValuePairs[i].split(/\\s*:\\s*/), key = split[0].trim(), value = split[1].trim();\n                if (key === \"stop-color\") {\n                    color = value;\n                } else if (key === \"stop-opacity\") {\n                    opacity = value;\n                }\n            }\n        }\n        if (!color) {\n            color = el.getAttribute(\"stop-color\") || \"rgb(0,0,0)\";\n        }\n        if (!opacity) {\n            opacity = el.getAttribute(\"stop-opacity\");\n        }\n        color = new fabric.Color(color);\n        colorAlpha = color.getAlpha();\n        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\n        opacity *= colorAlpha * multiplier;\n        return {\n            offset: offset,\n            color: color.toRgb(),\n            opacity: opacity\n        };\n    }\n    function getLinearCoords(el) {\n        return {\n            x1: el.getAttribute(\"x1\") || 0,\n            y1: el.getAttribute(\"y1\") || 0,\n            x2: el.getAttribute(\"x2\") || \"100%\",\n            y2: el.getAttribute(\"y2\") || 0\n        };\n    }\n    function getRadialCoords(el) {\n        return {\n            x1: el.getAttribute(\"fx\") || el.getAttribute(\"cx\") || \"50%\",\n            y1: el.getAttribute(\"fy\") || el.getAttribute(\"cy\") || \"50%\",\n            r1: 0,\n            x2: el.getAttribute(\"cx\") || \"50%\",\n            y2: el.getAttribute(\"cy\") || \"50%\",\n            r2: el.getAttribute(\"r\") || \"50%\"\n        };\n    }\n    /* _FROM_SVG_END_ */ var clone = fabric.util.object.clone;\n    /**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */ fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\n        /**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */ gradientTransform: null,\n        /**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */ gradientUnits: \"pixels\",\n        /**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */ type: \"linear\",\n        /**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */ initialize: function(options) {\n            options || (options = {});\n            options.coords || (options.coords = {});\n            var coords, _this = this;\n            // sets everything, then coords and colorstops get sets again\n            Object.keys(options).forEach(function(option) {\n                _this[option] = options[option];\n            });\n            if (this.id) {\n                this.id += \"_\" + fabric.Object.__uid++;\n            } else {\n                this.id = fabric.Object.__uid++;\n            }\n            coords = {\n                x1: options.coords.x1 || 0,\n                y1: options.coords.y1 || 0,\n                x2: options.coords.x2 || 0,\n                y2: options.coords.y2 || 0\n            };\n            if (this.type === \"radial\") {\n                coords.r1 = options.coords.r1 || 0;\n                coords.r2 = options.coords.r2 || 0;\n            }\n            this.coords = coords;\n            this.colorStops = options.colorStops.slice();\n        },\n        /**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */ addColorStop: function(colorStops) {\n            for(var position in colorStops){\n                var color = new fabric.Color(colorStops[position]);\n                this.colorStops.push({\n                    offset: parseFloat(position),\n                    color: color.toRgb(),\n                    opacity: color.getAlpha()\n                });\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */ toObject: function(propertiesToInclude) {\n            var object = {\n                type: this.type,\n                coords: this.coords,\n                colorStops: this.colorStops,\n                offsetX: this.offsetX,\n                offsetY: this.offsetY,\n                gradientUnits: this.gradientUnits,\n                gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */ toSVG: function(object, options) {\n            var coords = clone(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\";\n            // colorStops must be sorted ascending\n            colorStops.sort(function(a, b) {\n                return a.offset - b.offset;\n            });\n            if (gradientUnits === \"objectBoundingBox\") {\n                offsetX /= object.width;\n                offsetY /= object.height;\n            } else {\n                offsetX += object.width / 2;\n                offsetY += object.height / 2;\n            }\n            if (object.type === \"path\" && this.gradientUnits !== \"percentage\") {\n                offsetX -= object.pathOffset.x;\n                offsetY -= object.pathOffset.y;\n            }\n            transform[4] -= offsetX;\n            transform[5] -= offsetY;\n            commonAttributes = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"' + gradientUnits + '\"';\n            commonAttributes += ' gradientTransform=\"' + (withViewport ? options.additionalTransform + \" \" : \"\") + fabric.util.matrixToSVG(transform) + '\" ';\n            if (this.type === \"linear\") {\n                markup = [\n                    \"<linearGradient \",\n                    commonAttributes,\n                    ' x1=\"',\n                    coords.x1,\n                    '\" y1=\"',\n                    coords.y1,\n                    '\" x2=\"',\n                    coords.x2,\n                    '\" y2=\"',\n                    coords.y2,\n                    '\">\\n'\n                ];\n            } else if (this.type === \"radial\") {\n                // svg radial gradient has just 1 radius. the biggest.\n                markup = [\n                    \"<radialGradient \",\n                    commonAttributes,\n                    ' cx=\"',\n                    needsSwap ? coords.x1 : coords.x2,\n                    '\" cy=\"',\n                    needsSwap ? coords.y1 : coords.y2,\n                    '\" r=\"',\n                    needsSwap ? coords.r1 : coords.r2,\n                    '\" fx=\"',\n                    needsSwap ? coords.x2 : coords.x1,\n                    '\" fy=\"',\n                    needsSwap ? coords.y2 : coords.y1,\n                    '\">\\n'\n                ];\n            }\n            if (this.type === \"radial\") {\n                if (needsSwap) {\n                    // svg goes from internal to external radius. if radius are inverted, swap color stops.\n                    colorStops = colorStops.concat();\n                    colorStops.reverse();\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset = 1 - colorStops[i].offset;\n                    }\n                }\n                var minRadius = Math.min(coords.r1, coords.r2);\n                if (minRadius > 0) {\n                    // i have to shift all colorStops and add new one in 0.\n                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);\n                    }\n                }\n            }\n            for(i = 0, len = colorStops.length; i < len; i++){\n                var colorStop = colorStops[i];\n                markup.push(\"<stop \", 'offset=\"', colorStop.offset * 100 + \"%\", '\" style=\"stop-color:', colorStop.color, typeof colorStop.opacity !== \"undefined\" ? \";stop-opacity: \" + colorStop.opacity : \";\", '\"/>\\n');\n            }\n            markup.push(this.type === \"linear\" ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\");\n            return markup.join(\"\");\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */ toLive: function(ctx) {\n            var gradient, coords = fabric.util.object.clone(this.coords), i, len;\n            if (!this.type) {\n                return;\n            }\n            if (this.type === \"linear\") {\n                gradient = ctx.createLinearGradient(coords.x1, coords.y1, coords.x2, coords.y2);\n            } else if (this.type === \"radial\") {\n                gradient = ctx.createRadialGradient(coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\n            }\n            for(i = 0, len = this.colorStops.length; i < len; i++){\n                var color = this.colorStops[i].color, opacity = this.colorStops[i].opacity, offset = this.colorStops[i].offset;\n                if (typeof opacity !== \"undefined\") {\n                    color = new fabric.Color(color).setAlpha(opacity).toRgba();\n                }\n                gradient.addColorStop(offset, color);\n            }\n            return gradient;\n        }\n    });\n    fabric.util.object.extend(fabric.Gradient, {\n        /* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */ fromElement: function(el, instance, opacityAttr, svgOptions) {\n            /**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */ var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);\n            multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;\n            if (isNaN(multiplier)) {\n                multiplier = 1;\n            }\n            var colorStopEls = el.getElementsByTagName(\"stop\"), type, gradientUnits = el.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\", gradientTransform = el.getAttribute(\"gradientTransform\") || \"\", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;\n            if (el.nodeName === \"linearGradient\" || el.nodeName === \"LINEARGRADIENT\") {\n                type = \"linear\";\n                coords = getLinearCoords(el);\n            } else {\n                type = \"radial\";\n                coords = getRadialCoords(el);\n            }\n            for(i = colorStopEls.length; i--;){\n                colorStops.push(getColorStop(colorStopEls[i], multiplier));\n            }\n            transformMatrix = fabric.parseTransformAttribute(gradientTransform);\n            __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);\n            if (gradientUnits === \"pixels\") {\n                offsetX = -instance.left;\n                offsetY = -instance.top;\n            }\n            var gradient = new fabric.Gradient({\n                id: el.getAttribute(\"id\"),\n                type: type,\n                coords: coords,\n                colorStops: colorStops,\n                gradientUnits: gradientUnits,\n                gradientTransform: transformMatrix,\n                offsetX: offsetX,\n                offsetY: offsetY\n            });\n            return gradient;\n        }\n    });\n    /**\n   * @private\n   */ function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {\n        var propValue, finalValue;\n        Object.keys(options).forEach(function(prop) {\n            propValue = options[prop];\n            if (propValue === \"Infinity\") {\n                finalValue = 1;\n            } else if (propValue === \"-Infinity\") {\n                finalValue = 0;\n            } else {\n                finalValue = parseFloat(options[prop], 10);\n                if (typeof propValue === \"string\" && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)) {\n                    finalValue *= 0.01;\n                    if (gradientUnits === \"pixels\") {\n                        // then we need to fix those percentages here in svg parsing\n                        if (prop === \"x1\" || prop === \"x2\" || prop === \"r2\") {\n                            finalValue *= svgOptions.viewBoxWidth || svgOptions.width;\n                        }\n                        if (prop === \"y1\" || prop === \"y2\") {\n                            finalValue *= svgOptions.viewBoxHeight || svgOptions.height;\n                        }\n                    }\n                }\n            }\n            options[prop] = finalValue;\n        });\n    }\n})();\n(function() {\n    \"use strict\";\n    var toFixed = fabric.util.toFixed;\n    /**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */ fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\n        /**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */ repeat: \"repeat\",\n        /**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */ crossOrigin: \"\",\n        /**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */ patternTransform: null,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */ initialize: function(options, callback) {\n            options || (options = {});\n            this.id = fabric.Object.__uid++;\n            this.setOptions(options);\n            if (!options.source || options.source && typeof options.source !== \"string\") {\n                callback && callback(this);\n                return;\n            } else {\n                // img src string\n                var _this = this;\n                this.source = fabric.util.createImage();\n                fabric.util.loadImage(options.source, function(img, isError) {\n                    _this.source = img;\n                    callback && callback(_this, isError);\n                }, null, this.crossOrigin);\n            }\n        },\n        /**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source, object;\n            // <img> element\n            if (typeof this.source.src === \"string\") {\n                source = this.source.src;\n            } else if (typeof this.source === \"object\" && this.source.toDataURL) {\n                source = this.source.toDataURL();\n            }\n            object = {\n                type: \"pattern\",\n                source: source,\n                repeat: this.repeat,\n                crossOrigin: this.crossOrigin,\n                offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),\n                offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),\n                patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */ toSVG: function(object) {\n            var patternSource = typeof this.source === \"function\" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = \"\";\n            if (this.repeat === \"repeat-x\" || this.repeat === \"no-repeat\") {\n                patternHeight = 1;\n                if (patternOffsetY) {\n                    patternHeight += Math.abs(patternOffsetY);\n                }\n            }\n            if (this.repeat === \"repeat-y\" || this.repeat === \"no-repeat\") {\n                patternWidth = 1;\n                if (patternOffsetX) {\n                    patternWidth += Math.abs(patternOffsetX);\n                }\n            }\n            if (patternSource.src) {\n                patternImgSrc = patternSource.src;\n            } else if (patternSource.toDataURL) {\n                patternImgSrc = patternSource.toDataURL();\n            }\n            return '<pattern id=\"SVGID_' + this.id + '\" x=\"' + patternOffsetX + '\" y=\"' + patternOffsetY + '\" width=\"' + patternWidth + '\" height=\"' + patternHeight + '\">\\n' + '<image x=\"0\" y=\"0\"' + ' width=\"' + patternSource.width + '\" height=\"' + patternSource.height + '\" xlink:href=\"' + patternImgSrc + '\"></image>\\n' + \"</pattern>\\n\";\n        },\n        /* _TO_SVG_END_ */ setOptions: function(options) {\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n        },\n        /**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */ toLive: function(ctx) {\n            var source = this.source;\n            // if the image failed to load, return, and allow rest to continue loading\n            if (!source) {\n                return \"\";\n            }\n            // if an image\n            if (typeof source.src !== \"undefined\") {\n                if (!source.complete) {\n                    return \"\";\n                }\n                if (source.naturalWidth === 0 || source.naturalHeight === 0) {\n                    return \"\";\n                }\n            }\n            return ctx.createPattern(source, this.repeat);\n        }\n    });\n})();\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), toFixed = fabric.util.toFixed;\n    if (fabric.Shadow) {\n        fabric.warn(\"fabric.Shadow is already defined.\");\n        return;\n    }\n    /**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */ fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\n        /**\n     * Shadow color\n     * @type String\n     * @default\n     */ color: \"rgb(0,0,0)\",\n        /**\n     * Shadow blur\n     * @type Number\n     */ blur: 0,\n        /**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */ affectStroke: false,\n        /**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */ nonScaling: false,\n        /**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */ initialize: function(options) {\n            if (typeof options === \"string\") {\n                options = this._parseShadow(options);\n            }\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n            this.id = fabric.Object.__uid++;\n        },\n        /**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */ _parseShadow: function(shadow) {\n            var shadowStr = shadow.trim(), offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\";\n            return {\n                color: color.trim(),\n                offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,\n                offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,\n                blur: parseFloat(offsetsAndBlur[3], 10) || 0\n            };\n        },\n        /**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */ toString: function() {\n            return [\n                this.offsetX,\n                this.offsetY,\n                this.blur,\n                this.color\n            ].join(\"px \");\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */ toSVG: function(object) {\n            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, offset = fabric.util.rotateVector({\n                x: this.offsetX,\n                y: this.offsetY\n            }, fabric.util.degreesToRadians(-object.angle)), BLUR_BOX = 20, color = new fabric.Color(this.color);\n            if (object.width && object.height) {\n                //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n                // we add some extra space to filter box to contain the blur ( 20 )\n                fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n                fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n            }\n            if (object.flipX) {\n                offset.x *= -1;\n            }\n            if (object.flipY) {\n                offset.y *= -1;\n            }\n            return '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' + 'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + \">\\n\" + '\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\"></feGaussianBlur>\\n' + '\t<feOffset dx=\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '\" dy=\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\" result=\"oBlur\" ></feOffset>\\n' + '\t<feFlood flood-color=\"' + color.toRgb() + '\" flood-opacity=\"' + color.getAlpha() + '\"/>\\n' + '\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' + \"\t<feMerge>\\n\" + \"\t\t<feMergeNode></feMergeNode>\\n\" + '\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' + \"\t</feMerge>\\n\" + \"</filter>\\n\";\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */ toObject: function() {\n            if (this.includeDefaultValues) {\n                return {\n                    color: this.color,\n                    blur: this.blur,\n                    offsetX: this.offsetX,\n                    offsetY: this.offsetY,\n                    affectStroke: this.affectStroke,\n                    nonScaling: this.nonScaling\n                };\n            }\n            var obj = {}, proto = fabric.Shadow.prototype;\n            [\n                \"color\",\n                \"blur\",\n                \"offsetX\",\n                \"offsetY\",\n                \"affectStroke\",\n                \"nonScaling\"\n            ].forEach(function(prop) {\n                if (this[prop] !== proto[prop]) {\n                    obj[prop] = this[prop];\n                }\n            }, this);\n            return obj;\n        }\n    });\n    /**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\n    fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\n})( true ? exports : 0);\n(function() {\n    \"use strict\";\n    if (fabric.StaticCanvas) {\n        fabric.warn(\"fabric.StaticCanvas is already defined.\");\n        return;\n    }\n    // aliases for faster resolution\n    var extend = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error(\"Could not initialize `canvas` element\");\n    /**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */ fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n        },\n        /**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ backgroundImage: null,\n        /**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ overlayColor: \"\",\n        /**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ overlayImage: null,\n        /**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */ stateful: false,\n        /**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */ renderOnAddRemove: true,\n        /**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */ controlsAboveOverlay: false,\n        /**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */ allowTouchScrolling: false,\n        /**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */ imageSmoothingEnabled: true,\n        /**\n     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport\n     * @type Array\n     * @example <caption>Default transform</caption>\n     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];\n     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>\n     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];\n     * @default\n     */ viewportTransform: fabric.iMatrix.concat(),\n        /**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ backgroundVpt: true,\n        /**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ overlayVpt: true,\n        /**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */ enableRetinaScaling: true,\n        /**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */ vptCoords: {},\n        /**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */ skipOffscreen: true,\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */ _initStatic: function(el, options) {\n            var cb = this.requestRenderAllBound;\n            this._objects = [];\n            this._createLowerCanvas(el);\n            this._initOptions(options);\n            // only initialize retina scaling once\n            if (!this.interactive) {\n                this._initRetinaScaling();\n            }\n            if (options.overlayImage) {\n                this.setOverlayImage(options.overlayImage, cb);\n            }\n            if (options.backgroundImage) {\n                this.setBackgroundImage(options.backgroundImage, cb);\n            }\n            if (options.backgroundColor) {\n                this.setBackgroundColor(options.backgroundColor, cb);\n            }\n            if (options.overlayColor) {\n                this.setOverlayColor(options.overlayColor, cb);\n            }\n            this.calcOffset();\n        },\n        /**\n     * @private\n     */ _isRetinaScaling: function() {\n            return fabric.devicePixelRatio > 1 && this.enableRetinaScaling;\n        },\n        /**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */ getRetinaScaling: function() {\n            return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;\n        },\n        /**\n     * @private\n     */ _initRetinaScaling: function() {\n            if (!this._isRetinaScaling()) {\n                return;\n            }\n            var scaleRatio = fabric.devicePixelRatio;\n            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);\n            if (this.upperCanvasEl) {\n                this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);\n            }\n        },\n        __initRetinaScaling: function(scaleRatio, canvas, context) {\n            canvas.setAttribute(\"width\", this.width * scaleRatio);\n            canvas.setAttribute(\"height\", this.height * scaleRatio);\n            context.scale(scaleRatio, scaleRatio);\n        },\n        /**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ calcOffset: function() {\n            this._offset = getElementOffset(this.lowerCanvasEl);\n            return this;\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ setOverlayImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"overlayImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\n        setBackgroundImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"backgroundImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setOverlayColor: function(overlayColor, callback) {\n            return this.__setBgOverlayColor(\"overlayColor\", overlayColor, callback);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setBackgroundColor: function(backgroundColor, callback) {\n            return this.__setBgOverlayColor(\"backgroundColor\", backgroundColor, callback);\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */ __setBgOverlayImage: function(property, image, callback, options) {\n            if (typeof image === \"string\") {\n                fabric.util.loadImage(image, function(img, isError) {\n                    if (img) {\n                        var instance = new fabric.Image(img, options);\n                        this[property] = instance;\n                        instance.canvas = this;\n                    }\n                    callback && callback(img, isError);\n                }, this, options && options.crossOrigin);\n            } else {\n                options && image.setOptions(options);\n                this[property] = image;\n                image && (image.canvas = this);\n                callback && callback(image, false);\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */ __setBgOverlayColor: function(property, color, callback) {\n            this[property] = color;\n            this._initGradient(color, property);\n            this._initPattern(color, property, callback);\n            return this;\n        },\n        /**\n     * @private\n     */ _createCanvasElement: function() {\n            var element = createCanvasElement();\n            if (!element) {\n                throw CANVAS_INIT_ERROR;\n            }\n            if (!element.style) {\n                element.style = {};\n            }\n            if (typeof element.getContext === \"undefined\") {\n                throw CANVAS_INIT_ERROR;\n            }\n            return element;\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initOptions: function(options) {\n            var lowerCanvasEl = this.lowerCanvasEl;\n            this._setOptions(options);\n            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;\n            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;\n            if (!this.lowerCanvasEl.style) {\n                return;\n            }\n            lowerCanvasEl.width = this.width;\n            lowerCanvasEl.height = this.height;\n            lowerCanvasEl.style.width = this.width + \"px\";\n            lowerCanvasEl.style.height = this.height + \"px\";\n            this.viewportTransform = this.viewportTransform.slice();\n        },\n        /**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */ _createLowerCanvas: function(canvasEl) {\n            // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\n            if (canvasEl && canvasEl.getContext) {\n                this.lowerCanvasEl = canvasEl;\n            } else {\n                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\n            }\n            fabric.util.addClass(this.lowerCanvasEl, \"lower-canvas\");\n            this._originalCanvasStyle = this.lowerCanvasEl.style;\n            if (this.interactive) {\n                this._applyCanvasStyle(this.lowerCanvasEl);\n            }\n            this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */ getWidth: function() {\n            return this.width;\n        },\n        /**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */ getHeight: function() {\n            return this.height;\n        },\n        /**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setWidth: function(value, options) {\n            return this.setDimensions({\n                width: value\n            }, options);\n        },\n        /**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setHeight: function(value, options) {\n            return this.setDimensions({\n                height: value\n            }, options);\n        },\n        /**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setDimensions: function(dimensions, options) {\n            var cssValue;\n            options = options || {};\n            for(var prop in dimensions){\n                cssValue = dimensions[prop];\n                if (!options.cssOnly) {\n                    this._setBackstoreDimension(prop, dimensions[prop]);\n                    cssValue += \"px\";\n                    this.hasLostContext = true;\n                }\n                if (!options.backstoreOnly) {\n                    this._setCssDimension(prop, cssValue);\n                }\n            }\n            if (this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n            }\n            this._initRetinaScaling();\n            this.calcOffset();\n            if (!options.cssOnly) {\n                this.requestRenderAll();\n            }\n            return this;\n        },\n        /**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setBackstoreDimension: function(prop, value) {\n            this.lowerCanvasEl[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl[prop] = value;\n            }\n            if (this.cacheCanvasEl) {\n                this.cacheCanvasEl[prop] = value;\n            }\n            this[prop] = value;\n            return this;\n        },\n        /**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setCssDimension: function(prop, value) {\n            this.lowerCanvasEl.style[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl.style[prop] = value;\n            }\n            if (this.wrapperEl) {\n                this.wrapperEl.style[prop] = value;\n            }\n            return this;\n        },\n        /**\n     * Returns canvas zoom level\n     * @return {Number}\n     */ getZoom: function() {\n            return this.viewportTransform[0];\n        },\n        /**\n     * Sets viewport transformation of this canvas instance\n     * @param {Array} vpt a Canvas 2D API transform matrix\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setViewportTransform: function(vpt) {\n            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;\n            this.viewportTransform = vpt;\n            for(i = 0, len = this._objects.length; i < len; i++){\n                object = this._objects[i];\n                object.group || object.setCoords(true);\n            }\n            if (activeObject) {\n                activeObject.setCoords();\n            }\n            if (backgroundObject) {\n                backgroundObject.setCoords(true);\n            }\n            if (overlayObject) {\n                overlayObject.setCoords(true);\n            }\n            this.calcViewportBoundaries();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ zoomToPoint: function(point, value) {\n            // TODO: just change the scale, preserve other transformations\n            var before = point, vpt = this.viewportTransform.slice(0);\n            point = transformPoint(point, invertTransform(this.viewportTransform));\n            vpt[0] = value;\n            vpt[3] = value;\n            var after = transformPoint(point, vpt);\n            vpt[4] += before.x - after.x;\n            vpt[5] += before.y - after.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setZoom: function(value) {\n            this.zoomToPoint(new fabric.Point(0, 0), value);\n            return this;\n        },\n        /**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ absolutePan: function(point) {\n            var vpt = this.viewportTransform.slice(0);\n            vpt[4] = -point.x;\n            vpt[5] = -point.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ relativePan: function(point) {\n            return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));\n        },\n        /**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */ getElement: function() {\n            return this.lowerCanvasEl;\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */ _onObjectAdded: function(obj) {\n            this.stateful && obj.setupState();\n            obj._set(\"canvas\", this);\n            obj.setCoords();\n            this.fire(\"object:added\", {\n                target: obj\n            });\n            obj.fire(\"added\");\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            this.fire(\"object:removed\", {\n                target: obj\n            });\n            obj.fire(\"removed\");\n            delete obj.canvas;\n        },\n        /**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clearContext: function(ctx) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            return this;\n        },\n        /**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */ getContext: function() {\n            return this.contextContainer;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            this.remove.apply(this, this.getObjects());\n            this.backgroundImage = null;\n            this.overlayImage = null;\n            this.backgroundColor = \"\";\n            this.overlayColor = \"\";\n            if (this._hasITextHandlers) {\n                this.off(\"mouse:up\", this._mouseUpITextHandler);\n                this._iTextInstances = null;\n                this._hasITextHandlers = false;\n            }\n            this.clearContext(this.contextContainer);\n            this.fire(\"canvas:cleared\");\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._objects);\n            return this;\n        },\n        /**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAndReset: function() {\n            this.isRendering = 0;\n            this.renderAll();\n        },\n        /**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ requestRenderAll: function() {\n            if (!this.isRendering) {\n                this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);\n            }\n            return this;\n        },\n        /**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */ calcViewportBoundaries: function() {\n            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);\n            points.tl = transformPoint({\n                x: 0,\n                y: 0\n            }, iVpt);\n            points.br = transformPoint({\n                x: width,\n                y: height\n            }, iVpt);\n            points.tr = new fabric.Point(points.br.x, points.tl.y);\n            points.bl = new fabric.Point(points.tl.x, points.br.y);\n            this.vptCoords = points;\n            return points;\n        },\n        cancelRequestedRender: function() {\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n        },\n        /**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderCanvas: function(ctx, objects) {\n            var v = this.viewportTransform, path = this.clipPath;\n            this.cancelRequestedRender();\n            this.calcViewportBoundaries();\n            this.clearContext(ctx);\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);\n            this.fire(\"before:render\", {\n                ctx: ctx\n            });\n            this._renderBackground(ctx);\n            ctx.save();\n            //apply viewport transform once for all rendering process\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this._renderObjects(ctx, objects);\n            ctx.restore();\n            if (!this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            if (path) {\n                path.canvas = this;\n                // needed to setup a couple of variables\n                path.shouldCache();\n                path._transformDone = true;\n                path.renderCache({\n                    forClipping: true\n                });\n                this.drawClipPathOnCanvas(ctx);\n            }\n            this._renderOverlay(ctx);\n            if (this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            this.fire(\"after:render\", {\n                ctx: ctx\n            });\n        },\n        /**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawClipPathOnCanvas: function(ctx) {\n            var v = this.viewportTransform, path = this.clipPath;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4;\n            ctx.globalCompositeOperation = \"destination-in\";\n            path.transform(ctx);\n            ctx.scale(1 / path.zoomX, 1 / path.zoomY);\n            ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */ _renderObjects: function(ctx, objects) {\n            var i, len;\n            for(i = 0, len = objects.length; i < len; ++i){\n                objects[i] && objects[i].render(ctx);\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */ _renderBackgroundOrOverlay: function(ctx, property) {\n            var fill = this[property + \"Color\"], object = this[property + \"Image\"], v = this.viewportTransform, needsVpt = this[property + \"Vpt\"];\n            if (!fill && !object) {\n                return;\n            }\n            if (fill) {\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(this.width, 0);\n                ctx.lineTo(this.width, this.height);\n                ctx.lineTo(0, this.height);\n                ctx.closePath();\n                ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);\n                var m = fill.gradientTransform || fill.patternTransform;\n                m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n                ctx.fill();\n                ctx.restore();\n            }\n            if (object) {\n                ctx.save();\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                object.render(ctx);\n                ctx.restore();\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"background\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderOverlay: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"overlay\");\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     * @deprecated migrate to `getCenterPoint`\n     */ getCenter: function() {\n            return {\n                top: this.height / 2,\n                left: this.width / 2\n            };\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * @return {fabric.Point} \n     */ getCenterPoint: function() {\n            return new fabric.Point(this.width / 2, this.height / 2);\n        },\n        /**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */ centerObjectH: function(object) {\n            return this._centerObject(object, new fabric.Point(this.getCenterPoint().x, object.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObjectV: function(object) {\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObject: function(object) {\n            var center = this.getCenterPoint();\n            return this._centerObject(object, center);\n        },\n        /**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObject: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, vpCenter);\n        },\n        /**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectH: function(object) {\n            var vpCenter = this.getVpCenter();\n            this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\n            return this;\n        },\n        /**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectV: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\n        },\n        /**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */ getVpCenter: function() {\n            var center = this.getCenterPoint(), iVpt = invertTransform(this.viewportTransform);\n            return transformPoint(center, iVpt);\n        },\n        /**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ _centerObject: function(object, center) {\n            object.setPositionByOrigin(center, \"center\", \"center\");\n            object.setCoords();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */ toDatalessJSON: function(propertiesToInclude) {\n            return this.toDatalessObject(propertiesToInclude);\n        },\n        /**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toObject\", propertiesToInclude);\n        },\n        /**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toDatalessObject\", propertiesToInclude);\n        },\n        /**\n     * @private\n     */ _toObjectMethod: function(methodName, propertiesToInclude) {\n            var clipPath = this.clipPath, data = {\n                version: fabric.version,\n                objects: this._toObjects(methodName, propertiesToInclude)\n            };\n            if (clipPath && !clipPath.excludeFromExport) {\n                data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);\n            }\n            extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\n            fabric.util.populateWithProperties(this, data, propertiesToInclude);\n            return data;\n        },\n        /**\n     * @private\n     */ _toObjects: function(methodName, propertiesToInclude) {\n            return this._objects.filter(function(object) {\n                return !object.excludeFromExport;\n            }).map(function(instance) {\n                return this._toObject(instance, methodName, propertiesToInclude);\n            }, this);\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            var originalValue;\n            if (!this.includeDefaultValues) {\n                originalValue = instance.includeDefaultValues;\n                instance.includeDefaultValues = false;\n            }\n            var object = instance[methodName](propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                instance.includeDefaultValues = originalValue;\n            }\n            return object;\n        },\n        /**\n     * @private\n     */ __serializeBgOverlay: function(methodName, propertiesToInclude) {\n            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;\n            if (bgColor && bgColor.toObject) {\n                if (!bgColor.excludeFromExport) {\n                    data.background = bgColor.toObject(propertiesToInclude);\n                }\n            } else if (bgColor) {\n                data.background = bgColor;\n            }\n            if (overlayColor && overlayColor.toObject) {\n                if (!overlayColor.excludeFromExport) {\n                    data.overlay = overlayColor.toObject(propertiesToInclude);\n                }\n            } else if (overlayColor) {\n                data.overlay = overlayColor;\n            }\n            if (bgImage && !bgImage.excludeFromExport) {\n                data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);\n            }\n            if (overlayImage && !overlayImage.excludeFromExport) {\n                data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);\n            }\n            return data;\n        },\n        /* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */ svgViewportTransformation: true,\n        /**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */ toSVG: function(options, reviver) {\n            options || (options = {});\n            options.reviver = reviver;\n            var markup = [];\n            this._setSVGPreamble(markup, options);\n            this._setSVGHeader(markup, options);\n            if (this.clipPath) {\n                markup.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n');\n            }\n            this._setSVGBgOverlayColor(markup, \"background\");\n            this._setSVGBgOverlayImage(markup, \"backgroundImage\", reviver);\n            this._setSVGObjects(markup, reviver);\n            if (this.clipPath) {\n                markup.push(\"</g>\\n\");\n            }\n            this._setSVGBgOverlayColor(markup, \"overlay\");\n            this._setSVGBgOverlayImage(markup, \"overlayImage\", reviver);\n            markup.push(\"</svg>\");\n            return markup.join(\"\");\n        },\n        /**\n     * @private\n     */ _setSVGPreamble: function(markup, options) {\n            if (options.suppressPreamble) {\n                return;\n            }\n            markup.push('<?xml version=\"1.0\" encoding=\"', options.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n        },\n        /**\n     * @private\n     */ _setSVGHeader: function(markup, options) {\n            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (options.viewBox) {\n                viewBox = 'viewBox=\"' + options.viewBox.x + \" \" + options.viewBox.y + \" \" + options.viewBox.width + \" \" + options.viewBox.height + '\" ';\n            } else {\n                if (this.svgViewportTransformation) {\n                    vpt = this.viewportTransform;\n                    viewBox = 'viewBox=\"' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\" ';\n                }\n            }\n            markup.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', width, '\" ', 'height=\"', height, '\" ', viewBox, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", fabric.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(options), \"</defs>\\n\");\n        },\n        createSVGClipPathMarkup: function(options) {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                return '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(options.reviver) + \"</clipPath>\\n\";\n            }\n            return \"\";\n        },\n        /**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */ createSVGRefElementsMarkup: function() {\n            var _this = this, markup = [\n                \"background\",\n                \"overlay\"\n            ].map(function(prop) {\n                var fill = _this[prop + \"Color\"];\n                if (fill && fill.toLive) {\n                    var shouldTransform = _this[prop + \"Vpt\"], vpt = _this.viewportTransform, object = {\n                        width: _this.width / (shouldTransform ? vpt[0] : 1),\n                        height: _this.height / (shouldTransform ? vpt[3] : 1)\n                    };\n                    return fill.toSVG(object, {\n                        additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : \"\"\n                    });\n                }\n            });\n            return markup.join(\"\");\n        },\n        /**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */ createSVGFontFacesMarkup: function() {\n            var markup = \"\", fontList = {}, obj, fontFamily, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];\n            this._objects.forEach(function add(object) {\n                objects.push(object);\n                if (object._objects) {\n                    object._objects.forEach(add);\n                }\n            });\n            for(i = 0, len = objects.length; i < len; i++){\n                obj = objects[i];\n                fontFamily = obj.fontFamily;\n                if (obj.type.indexOf(\"text\") === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\n                    continue;\n                }\n                fontList[fontFamily] = true;\n                if (!obj.styles) {\n                    continue;\n                }\n                style = obj.styles;\n                for(rowIndex in style){\n                    row = style[rowIndex];\n                    for(charIndex in row){\n                        _char = row[charIndex];\n                        fontFamily = _char.fontFamily;\n                        if (!fontList[fontFamily] && fontPaths[fontFamily]) {\n                            fontList[fontFamily] = true;\n                        }\n                    }\n                }\n            }\n            for(var j in fontList){\n                markup += [\n                    \"\t\t@font-face {\\n\",\n                    \"\t\t\tfont-family: '\",\n                    j,\n                    \"';\\n\",\n                    \"\t\t\tsrc: url('\",\n                    fontPaths[j],\n                    \"');\\n\",\n                    \"\t\t}\\n\"\n                ].join(\"\");\n            }\n            if (markup) {\n                markup = [\n                    '\t<style type=\"text/css\">',\n                    \"<![CDATA[\\n\",\n                    markup,\n                    \"]]>\",\n                    \"</style>\\n\"\n                ].join(\"\");\n            }\n            return markup;\n        },\n        /**\n     * @private\n     */ _setSVGObjects: function(markup, reviver) {\n            var instance, i, len, objects = this._objects;\n            for(i = 0, len = objects.length; i < len; i++){\n                instance = objects[i];\n                if (instance.excludeFromExport) {\n                    continue;\n                }\n                this._setSVGObject(markup, instance, reviver);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            markup.push(instance.toSVG(reviver));\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayImage: function(markup, property, reviver) {\n            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {\n                markup.push(this[property].toSVG(reviver));\n            }\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayColor: function(markup, property) {\n            var filler = this[property + \"Color\"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;\n            if (!filler) {\n                return;\n            }\n            if (filler.toLive) {\n                var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + \"Vpt\"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : \"\";\n                markup.push('<rect transform=\"' + additionalTransform + \" translate(\", finalWidth / 2, \",\", finalHeight / 2, ')\"', ' x=\"', filler.offsetX - finalWidth / 2, '\" y=\"', filler.offsetY - finalHeight / 2, '\" ', 'width=\"', repeat === \"repeat-y\" || repeat === \"no-repeat\" ? filler.source.width : finalWidth, '\" height=\"', repeat === \"repeat-x\" || repeat === \"no-repeat\" ? filler.source.height : finalHeight, '\" fill=\"url(#SVGID_' + filler.id + ')\"', \"></rect>\\n\");\n            } else {\n                markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', filler, '\"', \"></rect>\\n\");\n            }\n        },\n        /* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendToBack: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.unshift(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.unshift(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringToFront: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.push(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.push(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendBackwards: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx > 0 + objsMoved) {\n                        newIdx = idx - 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== 0) {\n                    // if object is not on the bottom of stack\n                    newIdx = this._findNewLowerIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewLowerIndex: function(object, idx, intersecting) {\n            var newIdx, i;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse down the stack looking for the nearest intersecting object\n                for(i = idx - 1; i >= 0; --i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx - 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringForward: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx < this._objects.length - 1 - objsMoved) {\n                        newIdx = idx + 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== this._objects.length - 1) {\n                    // if object is not on top of stack (last item in an array)\n                    newIdx = this._findNewUpperIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewUpperIndex: function(object, idx, intersecting) {\n            var newIdx, i, len;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse up the stack looking for the nearest intersecting object\n                for(i = idx + 1, len = this._objects.length; i < len; ++i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx + 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ moveTo: function(object, index) {\n            removeFromArray(this._objects, object);\n            this._objects.splice(index, 0, object);\n            return this.renderOnAddRemove && this.requestRenderAll();\n        },\n        /**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            // cancel eventually ongoing renders\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n            if (this.backgroundImage && this.backgroundImage.dispose) {\n                this.backgroundImage.dispose();\n            }\n            this.backgroundImage = null;\n            if (this.overlayImage && this.overlayImage.dispose) {\n                this.overlayImage.dispose();\n            }\n            this.overlayImage = null;\n            this._iTextInstances = null;\n            this.contextContainer = null;\n            // restore canvas style\n            this.lowerCanvasEl.classList.remove(\"lower-canvas\");\n            fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);\n            delete this._originalCanvasStyle;\n            // restore canvas size to original size in case retina scaling was applied\n            this.lowerCanvasEl.setAttribute(\"width\", this.width);\n            this.lowerCanvasEl.setAttribute(\"height\", this.height);\n            fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);\n            this.lowerCanvasEl = undefined;\n            return this;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Canvas (\" + this.complexity() + \"): \" + \"{ objects: \" + this._objects.length + \" }>\";\n        }\n    });\n    extend(fabric.StaticCanvas.prototype, fabric.Observable);\n    extend(fabric.StaticCanvas.prototype, fabric.Collection);\n    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\n    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\n        /**\n     * @static\n     * @type String\n     * @default\n     */ EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n        /**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */ supports: function(methodName) {\n            var el = createCanvasElement();\n            if (!el || !el.getContext) {\n                return null;\n            }\n            var ctx = el.getContext(\"2d\");\n            if (!ctx) {\n                return null;\n            }\n            switch(methodName){\n                case \"setLineDash\":\n                    return typeof ctx.setLineDash !== \"undefined\";\n                default:\n                    return null;\n            }\n        }\n    });\n    /**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */ fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\n    if (fabric.isLikelyNode) {\n        fabric.StaticCanvas.prototype.createPNGStream = function() {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createPNGStream();\n        };\n        fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createJPEGStream(opts);\n        };\n    }\n})();\n/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\n    /**\n   * Color of a brush\n   * @type String\n   * @default\n   */ color: \"rgb(0, 0, 0)\",\n    /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */ width: 1,\n    /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */ shadow: null,\n    /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */ strokeLineCap: \"round\",\n    /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */ strokeLineJoin: \"round\",\n    /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */ strokeMiterLimit: 10,\n    /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */ strokeDashArray: null,\n    /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */ limitedToCanvasSize: false,\n    /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.lineCap = this.strokeLineCap;\n        ctx.miterLimit = this.strokeMiterLimit;\n        ctx.lineJoin = this.strokeLineJoin;\n        ctx.setLineDash(this.strokeDashArray || []);\n    },\n    /**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */ _saveAndTransform: function(ctx) {\n        var v = this.canvas.viewportTransform;\n        ctx.save();\n        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n    },\n    /**\n   * Sets brush shadow styles\n   * @private\n   */ _setShadow: function() {\n        if (!this.shadow) {\n            return;\n        }\n        var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();\n        if (canvas && canvas._isRetinaScaling()) {\n            zoom *= fabric.devicePixelRatio;\n        }\n        ctx.shadowColor = shadow.color;\n        ctx.shadowBlur = shadow.blur * zoom;\n        ctx.shadowOffsetX = shadow.offsetX * zoom;\n        ctx.shadowOffsetY = shadow.offsetY * zoom;\n    },\n    needsFullRender: function() {\n        var color = new fabric.Color(this.color);\n        return color.getAlpha() < 1 || !!this.shadow;\n    },\n    /**\n   * Removes brush shadow styles\n   * @private\n   */ _resetShadow: function() {\n        var ctx = this.canvas.contextTop;\n        ctx.shadowColor = \"\";\n        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n    },\n    /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */ _isOutSideCanvas: function(pointer) {\n        return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();\n    }\n});\n(function() {\n    /**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */ fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\n        /**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */ decimate: 0.4,\n        /**\n     * Draws a straight line between last recorded point to current pointer\n     * Used for `shift` functionality\n     *\n     * @type boolean\n     * @default false\n     */ drawStraightLine: false,\n        /**\n     * The event modifier key that makes the brush draw a straight line.\n     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.\n     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}\n     */ straightLineKey: \"shiftKey\",\n        /**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */ initialize: function(canvas) {\n            this.canvas = canvas;\n            this._points = [];\n        },\n        needsFullRender: function() {\n            return this.callSuper(\"needsFullRender\") || this._hasStraightLine;\n        },\n        /**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */ _drawSegment: function(ctx, p1, p2) {\n            var midPoint = p1.midPointFrom(p2);\n            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n            return midPoint;\n        },\n        /**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */ onMouseDown: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            this._prepareForDrawing(pointer);\n            // capture coordinates immediately\n            // this allows to draw dots (when movement never occurs)\n            this._captureDrawingPath(pointer);\n            this._render();\n        },\n        /**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */ onMouseMove: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n                return;\n            }\n            if (this._captureDrawingPath(pointer) && this._points.length > 1) {\n                if (this.needsFullRender()) {\n                    // redraw curve\n                    // clear top canvas\n                    this.canvas.clearContext(this.canvas.contextTop);\n                    this._render();\n                } else {\n                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;\n                    // draw the curve update\n                    this._saveAndTransform(ctx);\n                    if (this.oldEnd) {\n                        ctx.beginPath();\n                        ctx.moveTo(this.oldEnd.x, this.oldEnd.y);\n                    }\n                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        },\n        /**\n     * Invoked on mouse up\n     */ onMouseUp: function(options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return true;\n            }\n            this.drawStraightLine = false;\n            this.oldEnd = undefined;\n            this._finalizeAndAddPath();\n            return false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _prepareForDrawing: function(pointer) {\n            var p = new fabric.Point(pointer.x, pointer.y);\n            this._reset();\n            this._addPoint(p);\n            this.canvas.contextTop.moveTo(p.x, p.y);\n        },\n        /**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */ _addPoint: function(point) {\n            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {\n                return false;\n            }\n            if (this.drawStraightLine && this._points.length > 1) {\n                this._hasStraightLine = true;\n                this._points.pop();\n            }\n            this._points.push(point);\n            return true;\n        },\n        /**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */ _reset: function() {\n            this._points = [];\n            this._setBrushStyles(this.canvas.contextTop);\n            this._setShadow();\n            this._hasStraightLine = false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _captureDrawingPath: function(pointer) {\n            var pointerPoint = new fabric.Point(pointer.x, pointer.y);\n            return this._addPoint(pointerPoint);\n        },\n        /**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     * @param {CanvasRenderingContext2D} [ctx]\n     */ _render: function(ctx) {\n            var i, len, p1 = this._points[0], p2 = this._points[1];\n            ctx = ctx || this.canvas.contextTop;\n            this._saveAndTransform(ctx);\n            ctx.beginPath();\n            //if we only have 2 points in the path and they are the same\n            //it means that the user only clicked the canvas without moving the mouse\n            //then we should be drawing a dot. A path isn't drawn between two identical dots\n            //that's why we set them apart a bit\n            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\n                var width = this.width / 1000;\n                p1 = new fabric.Point(p1.x, p1.y);\n                p2 = new fabric.Point(p2.x, p2.y);\n                p1.x -= width;\n                p2.x += width;\n            }\n            ctx.moveTo(p1.x, p1.y);\n            for(i = 1, len = this._points.length; i < len; i++){\n                // we pick the point between pi + 1 & pi + 2 as the\n                // end point and p1 as our control point.\n                this._drawSegment(ctx, p1, p2);\n                p1 = this._points[i];\n                p2 = this._points[i + 1];\n            }\n            // Draw last line as a straight line while\n            // we wait for the next point to be able to calculate\n            // the bezier control point\n            ctx.lineTo(p1.x, p1.y);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */ convertPointsToSVGPath: function(points) {\n            var correction = this.width / 1000;\n            return fabric.util.getSmoothPathFromPoints(points, correction);\n        },\n        /**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */ _isEmptySVGPath: function(pathData) {\n            var pathString = fabric.util.joinPath(pathData);\n            return pathString === \"M 0 0 Q 0 0 0 0 L 0 0\";\n        },\n        /**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */ createPath: function(pathData) {\n            var path = new fabric.Path(pathData, {\n                fill: null,\n                stroke: this.color,\n                strokeWidth: this.width,\n                strokeLineCap: this.strokeLineCap,\n                strokeMiterLimit: this.strokeMiterLimit,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeDashArray: this.strokeDashArray\n            });\n            if (this.shadow) {\n                this.shadow.affectStroke = true;\n                path.shadow = new fabric.Shadow(this.shadow);\n            }\n            return path;\n        },\n        /**\n     * Decimate points array with the decimate value\n     */ decimatePoints: function(points, distance) {\n            if (points.length <= 2) {\n                return points;\n            }\n            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [\n                lastPoint\n            ], cDistance;\n            for(i = 1; i < l - 1; i++){\n                cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);\n                if (cDistance >= adjustedDistance) {\n                    lastPoint = points[i];\n                    newPoints.push(lastPoint);\n                }\n            }\n            /**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */ newPoints.push(points[l]);\n            return newPoints;\n        },\n        /**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */ _finalizeAndAddPath: function() {\n            var ctx = this.canvas.contextTop;\n            ctx.closePath();\n            if (this.decimate) {\n                this._points = this.decimatePoints(this._points, this.decimate);\n            }\n            var pathData = this.convertPointsToSVGPath(this._points);\n            if (this._isEmptySVGPath(pathData)) {\n                // do not create 0 width/height paths, as they are\n                // rendered inconsistently across browsers\n                // Firefox 4, for example, renders a dot,\n                // whereas Chrome 10 renders nothing\n                this.canvas.requestRenderAll();\n                return;\n            }\n            var path = this.createPath(pathData);\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.canvas.fire(\"before:path:created\", {\n                path: path\n            });\n            this.canvas.add(path);\n            this.canvas.requestRenderAll();\n            path.setCoords();\n            this._resetShadow();\n            // fire event 'path' created\n            this.canvas.fire(\"path:created\", {\n                path: path\n            });\n        }\n    });\n})();\n/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */ fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\n    /**\n   * Width of a brush\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.points = [];\n    },\n    /**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */ drawDot: function(pointer) {\n        var point = this.addPoint(pointer), ctx = this.canvas.contextTop;\n        this._saveAndTransform(ctx);\n        this.dot(ctx, point);\n        ctx.restore();\n    },\n    dot: function(ctx, point) {\n        ctx.fillStyle = point.fill;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    },\n    /**\n   * Invoked on mouse down\n   */ onMouseDown: function(pointer) {\n        this.points.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.drawDot(pointer);\n    },\n    /**\n   * Render the full state of the brush\n   * @private\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, len, points = this.points;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = points.length; i < len; i++){\n            this.dot(ctx, points[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        if (this.needsFullRender()) {\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.addPoint(pointer);\n            this._render();\n        } else {\n            this.drawDot(pointer);\n        }\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;\n        this.canvas.renderOnAddRemove = false;\n        var circles = [];\n        for(i = 0, len = this.points.length; i < len; i++){\n            var point = this.points[i], circle = new fabric.Circle({\n                radius: point.radius,\n                left: point.x,\n                top: point.y,\n                originX: \"center\",\n                originY: \"center\",\n                fill: point.fill\n            });\n            this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));\n            circles.push(circle);\n        }\n        var group = new fabric.Group(circles);\n        group.canvas = this.canvas;\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */ addPoint: function(pointer) {\n        var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();\n        pointerPoint.radius = circleRadius;\n        pointerPoint.fill = circleColor;\n        this.points.push(pointerPoint);\n        return pointerPoint;\n    }\n});\n/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */ fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\n    /**\n   * Width of a spray\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */ density: 20,\n    /**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */ dotWidth: 1,\n    /**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */ dotWidthVariance: 1,\n    /**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */ randomOpacity: false,\n    /**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */ optimizeOverlapping: true,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.sprayChunks = [];\n    },\n    /**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */ onMouseDown: function(pointer) {\n        this.sprayChunks.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\n        this.canvas.renderOnAddRemove = false;\n        var rects = [];\n        for(var i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            var sprayChunk = this.sprayChunks[i];\n            for(var j = 0, jlen = sprayChunk.length; j < jlen; j++){\n                var rect = new fabric.Rect({\n                    width: sprayChunk[j].width,\n                    height: sprayChunk[j].width,\n                    left: sprayChunk[j].x + 1,\n                    top: sprayChunk[j].y + 1,\n                    originX: \"center\",\n                    originY: \"center\",\n                    fill: this.color\n                });\n                rects.push(rect);\n            }\n        }\n        if (this.optimizeOverlapping) {\n            rects = this._getOptimizedRects(rects);\n        }\n        var group = new fabric.Group(rects);\n        this.shadow && group.set(\"shadow\", new fabric.Shadow(this.shadow));\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @private\n   * @param {Array} rects\n   */ _getOptimizedRects: function(rects) {\n        // avoid creating duplicate rects at the same coordinates\n        var uniqueRects = {}, key, i, len;\n        for(i = 0, len = rects.length; i < len; i++){\n            key = rects[i].left + \"\" + rects[i].top;\n            if (!uniqueRects[key]) {\n                uniqueRects[key] = rects[i];\n            }\n        }\n        var uniqueRectsArray = [];\n        for(key in uniqueRects){\n            uniqueRectsArray.push(uniqueRects[key]);\n        }\n        return uniqueRectsArray;\n    },\n    /**\n   * Render new chunk of spray brush\n   */ render: function(sprayChunk) {\n        var ctx = this.canvas.contextTop, i, len;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = sprayChunk.length; i < len; i++){\n            var point = sprayChunk[i];\n            if (typeof point.opacity !== \"undefined\") {\n                ctx.globalAlpha = point.opacity;\n            }\n            ctx.fillRect(point.x, point.y, point.width, point.width);\n        }\n        ctx.restore();\n    },\n    /**\n   * Render all spray chunks\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, ilen;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            this.render(this.sprayChunks[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * @param {Object} pointer\n   */ addSprayChunk: function(pointer) {\n        this.sprayChunkPoints = [];\n        var x, y, width, radius = this.width / 2, i;\n        for(i = 0; i < this.density; i++){\n            x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\n            y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\n            if (this.dotWidthVariance) {\n                width = fabric.util.getRandomInt(// bottom clamp width to 1\n                Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);\n            } else {\n                width = this.dotWidth;\n            }\n            var point = new fabric.Point(x, y);\n            point.width = width;\n            if (this.randomOpacity) {\n                point.opacity = fabric.util.getRandomInt(0, 100) / 100;\n            }\n            this.sprayChunkPoints.push(point);\n        }\n        this.sprayChunks.push(this.sprayChunkPoints);\n    }\n});\n/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\n    getPatternSrc: function() {\n        var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext(\"2d\");\n        patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n        patternCtx.fillStyle = this.color;\n        patternCtx.beginPath();\n        patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\n        patternCtx.closePath();\n        patternCtx.fill();\n        return patternCanvas;\n    },\n    getPatternSrcFunction: function() {\n        return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n    },\n    /**\n   * Creates \"pattern\" instance property\n   * @param {CanvasRenderingContext2D} ctx\n   */ getPattern: function(ctx) {\n        return ctx.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n    },\n    /**\n   * Sets brush styles\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        this.callSuper(\"_setBrushStyles\", ctx);\n        ctx.strokeStyle = this.getPattern(ctx);\n    },\n    /**\n   * Creates path\n   */ createPath: function(pathData) {\n        var path = this.callSuper(\"createPath\", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\n        path.stroke = new fabric.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -topLeft.x,\n            offsetY: -topLeft.y\n        });\n        return path;\n    }\n});\n(function() {\n    var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;\n    /**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop:before before drop event. same native event. This is added to handle edge cases\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   */ fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n            this._initInteractive();\n            this._createCacheCanvas();\n        },\n        /**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */ uniformScaling: true,\n        /**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ uniScaleKey: \"shiftKey\",\n        /**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: false,\n        /**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ centeredKey: \"altKey\",\n        /**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ altActionKey: \"shiftKey\",\n        /**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */ interactive: true,\n        /**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */ selection: true,\n        /**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */ selectionKey: \"shiftKey\",\n        /**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */ altSelectionKey: null,\n        /**\n     * Color of selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(100, 100, 255, 0.3)\",\n        /**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */ selectionDashArray: [],\n        /**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */ selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n        /**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */ selectionLineWidth: 1,\n        /**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */ selectionFullyContained: false,\n        /**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: \"move\",\n        /**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */ moveCursor: \"move\",\n        /**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */ defaultCursor: \"default\",\n        /**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */ freeDrawingCursor: \"crosshair\",\n        /**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */ notAllowedCursor: \"not-allowed\",\n        /**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */ containerClass: \"canvas-container\",\n        /**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */ targetFindTolerance: 0,\n        /**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */ skipTargetFind: false,\n        /**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */ isDrawingMode: false,\n        /**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */ preserveObjectStacking: false,\n        /**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */ snapAngle: 0,\n        /**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */ snapThreshold: null,\n        /**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ stopContextMenu: false,\n        /**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ fireRightClick: false,\n        /**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */ fireMiddleClick: false,\n        /**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */ targets: [],\n        /**\n     * When the option is enabled, PointerEvent is used instead of MouseEvent.\n     * @type Boolean\n     * @default\n     */ enablePointerEvents: false,\n        /**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */ _hoveredTarget: null,\n        /**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */ _hoveredTargets: [],\n        /**\n     * @private\n     */ _initInteractive: function() {\n            this._currentTransform = null;\n            this._groupSelector = null;\n            this._initWrapperElement();\n            this._createUpperCanvas();\n            this._initEventListeners();\n            this._initRetinaScaling();\n            this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\n            this.calcOffset();\n        },\n        /**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */ _chooseObjectsToRender: function() {\n            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;\n            if (activeObjects.length > 0 && !this.preserveObjectStacking) {\n                objsToRender = [];\n                activeGroupObjects = [];\n                for(var i = 0, length = this._objects.length; i < length; i++){\n                    object = this._objects[i];\n                    if (activeObjects.indexOf(object) === -1) {\n                        objsToRender.push(object);\n                    } else {\n                        activeGroupObjects.push(object);\n                    }\n                }\n                if (activeObjects.length > 1) {\n                    this._activeObject._objects = activeGroupObjects;\n                }\n                objsToRender.push.apply(objsToRender, activeGroupObjects);\n            } else {\n                objsToRender = this._objects;\n            }\n            return objsToRender;\n        },\n        /**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\n                this.clearContext(this.contextTop);\n                this.contextTopDirty = false;\n            }\n            if (this.hasLostContext) {\n                this.renderTopLayer(this.contextTop);\n                this.hasLostContext = false;\n            }\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\n            return this;\n        },\n        renderTopLayer: function(ctx) {\n            ctx.save();\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._render();\n                this.contextTopDirty = true;\n            }\n            // we render the top context - last object\n            if (this.selection && this._groupSelector) {\n                this._drawSelection(ctx);\n                this.contextTopDirty = true;\n            }\n            ctx.restore();\n        },\n        /**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ renderTop: function() {\n            var ctx = this.contextTop;\n            this.clearContext(ctx);\n            this.renderTopLayer(ctx);\n            this.fire(\"after:render\");\n            return this;\n        },\n        /**\n     * @private\n     */ _normalizePointer: function(object, pointer) {\n            var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);\n            return fabric.util.transformPoint(vptPointer, invertedM);\n        },\n        /**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */ isTargetTransparent: function(target, x, y) {\n            // in case the target is the activeObject, we cannot execute this optimization\n            // because we need to draw controls too.\n            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {\n                var normalizedPointer = this._normalizePointer(target, {\n                    x: x,\n                    y: y\n                }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);\n                var isTransparent = fabric.util.isTransparent(target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);\n                return isTransparent;\n            }\n            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;\n            target.selectionBackgroundColor = \"\";\n            this.clearContext(ctx);\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            target.render(ctx);\n            ctx.restore();\n            target.selectionBackgroundColor = originalColor;\n            var isTransparent = fabric.util.isTransparent(ctx, x, y, this.targetFindTolerance);\n            return isTransparent;\n        },\n        /**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */ _isSelectionKeyPressed: function(e) {\n            var selectionKeyPressed = false;\n            if (Array.isArray(this.selectionKey)) {\n                selectionKeyPressed = !!this.selectionKey.find(function(key) {\n                    return e[key] === true;\n                });\n            } else {\n                selectionKeyPressed = e[this.selectionKey];\n            }\n            return selectionKeyPressed;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _shouldClearSelection: function(e, target) {\n            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;\n            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;\n        },\n        /**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */ _shouldCenterTransform: function(target, action, altKey) {\n            if (!target) {\n                return;\n            }\n            var centerTransform;\n            if (action === \"scale\" || action === \"scaleX\" || action === \"scaleY\" || action === \"resizing\") {\n                centerTransform = this.centeredScaling || target.centeredScaling;\n            } else if (action === \"rotate\") {\n                centerTransform = this.centeredRotation || target.centeredRotation;\n            }\n            return centerTransform ? !altKey : altKey;\n        },\n        /**\n     * should disappear before release 4.0\n     * @private\n     */ _getOriginFromCorner: function(target, corner) {\n            var origin = {\n                x: target.originX,\n                y: target.originY\n            };\n            if (corner === \"ml\" || corner === \"tl\" || corner === \"bl\") {\n                origin.x = \"right\";\n            } else if (corner === \"mr\" || corner === \"tr\" || corner === \"br\") {\n                origin.x = \"left\";\n            }\n            if (corner === \"tl\" || corner === \"mt\" || corner === \"tr\") {\n                origin.y = \"bottom\";\n            } else if (corner === \"bl\" || corner === \"mb\" || corner === \"br\") {\n                origin.y = \"top\";\n            }\n            return origin;\n        },\n        /**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */ _getActionFromCorner: function(alreadySelected, corner, e, target) {\n            if (!corner || !alreadySelected) {\n                return \"drag\";\n            }\n            var control = target.controls[corner];\n            return control.getActionName(e, control, target);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _setupCurrentTransform: function(e, target, alreadySelected) {\n            if (!target) {\n                return;\n            }\n            var pointer = this.getPointer(e), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e, target), origin = this._getOriginFromCorner(target, corner), altKey = e[this.centeredKey], transform = {\n                target: target,\n                action: action,\n                actionHandler: actionHandler,\n                corner: corner,\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                // used by transation\n                offsetX: pointer.x - target.left,\n                offsetY: pointer.y - target.top,\n                originX: origin.x,\n                originY: origin.y,\n                ex: pointer.x,\n                ey: pointer.y,\n                lastX: pointer.x,\n                lastY: pointer.y,\n                // unsure they are useful anymore.\n                // left: target.left,\n                // top: target.top,\n                theta: degreesToRadians(target.angle),\n                // end of unsure\n                width: target.width * target.scaleX,\n                shiftKey: e.shiftKey,\n                altKey: altKey,\n                original: fabric.util.saveObjectTransform(target)\n            };\n            if (this._shouldCenterTransform(target, action, altKey)) {\n                transform.originX = \"center\";\n                transform.originY = \"center\";\n            }\n            transform.original.originX = origin.x;\n            transform.original.originY = origin.y;\n            this._currentTransform = transform;\n            this._beforeTransform(e);\n        },\n        /**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */ setCursor: function(value) {\n            this.upperCanvasEl.style.cursor = value;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */ _drawSelection: function(ctx) {\n            var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;\n            if (this.selectionColor) {\n                ctx.fillStyle = this.selectionColor;\n                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);\n            }\n            if (!this.selectionLineWidth || !this.selectionBorderColor) {\n                return;\n            }\n            ctx.lineWidth = this.selectionLineWidth;\n            ctx.strokeStyle = this.selectionBorderColor;\n            minX += strokeOffset;\n            minY += strokeOffset;\n            maxX -= strokeOffset;\n            maxY -= strokeOffset;\n            // selection border\n            fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\n            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);\n        },\n        /**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */ findTarget: function(e, skipGroup) {\n            if (this.skipTargetFind) {\n                return;\n            }\n            var ignoreZoom = true, pointer = this.getPointer(e, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;\n            // first check current group (if one exists)\n            // active group does not check sub targets like normal groups.\n            // if active group just exits.\n            this.targets = [];\n            // if we hit the corner of an activeObject, let's return that.\n            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {\n                return activeObject;\n            }\n            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                return activeObject;\n            }\n            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                if (!this.preserveObjectStacking) {\n                    return activeObject;\n                } else {\n                    activeTarget = activeObject;\n                    activeTargetSubs = this.targets;\n                    this.targets = [];\n                }\n            }\n            var target = this._searchPossibleTargets(this._objects, pointer);\n            if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\n                target = activeTarget;\n                this.targets = activeTargetSubs;\n            }\n            return target;\n        },\n        /**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */ _checkTarget: function(pointer, obj, globalPointer) {\n            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\n            obj.containsPoint(pointer)) {\n                if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\n                    var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);\n                    if (!isTransparent) {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n        },\n        /**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */ _searchPossibleTargets: function(objects, pointer) {\n            // Cache all targets where their bounding box contains point.\n            var target, i = objects.length, subTarget;\n            // Do not check for currently grouped objects, since we check the parent group itself.\n            // until we call this function specifically to search inside the activeGroup\n            while(i--){\n                var objToCheck = objects[i];\n                var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;\n                if (this._checkTarget(pointerToUse, objToCheck, pointer)) {\n                    target = objects[i];\n                    if (target.subTargetCheck && target instanceof fabric.Group) {\n                        subTarget = this._searchPossibleTargets(target._objects, pointer);\n                        subTarget && this.targets.push(subTarget);\n                    }\n                    break;\n                }\n            }\n            return target;\n        },\n        /**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ restorePointerVpt: function(pointer) {\n            return fabric.util.transformPoint(pointer, fabric.util.invertTransform(this.viewportTransform));\n        },\n        /**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ getPointer: function(e, ignoreZoom) {\n            // return cached values if we are in the event processing chain\n            if (this._absolutePointer && !ignoreZoom) {\n                return this._absolutePointer;\n            }\n            if (this._pointer && ignoreZoom) {\n                return this._pointer;\n            }\n            var pointer = getPointer(e), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;\n            if (!boundsWidth || !boundsHeight) {\n                if (\"top\" in bounds && \"bottom\" in bounds) {\n                    boundsHeight = Math.abs(bounds.top - bounds.bottom);\n                }\n                if (\"right\" in bounds && \"left\" in bounds) {\n                    boundsWidth = Math.abs(bounds.right - bounds.left);\n                }\n            }\n            this.calcOffset();\n            pointer.x = pointer.x - this._offset.left;\n            pointer.y = pointer.y - this._offset.top;\n            if (!ignoreZoom) {\n                pointer = this.restorePointerVpt(pointer);\n            }\n            var retinaScaling = this.getRetinaScaling();\n            if (retinaScaling !== 1) {\n                pointer.x /= retinaScaling;\n                pointer.y /= retinaScaling;\n            }\n            if (boundsWidth === 0 || boundsHeight === 0) {\n                // If bounds are not available (i.e. not visible), do not apply scale.\n                cssScale = {\n                    width: 1,\n                    height: 1\n                };\n            } else {\n                cssScale = {\n                    width: upperCanvasEl.width / boundsWidth,\n                    height: upperCanvasEl.height / boundsHeight\n                };\n            }\n            return {\n                x: pointer.x * cssScale.width,\n                y: pointer.y * cssScale.height\n            };\n        },\n        /**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */ _createUpperCanvas: function() {\n            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\"), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;\n            // there is no need to create a new upperCanvas element if we have already one.\n            if (upperCanvasEl) {\n                upperCanvasEl.className = \"\";\n            } else {\n                upperCanvasEl = this._createCanvasElement();\n                this.upperCanvasEl = upperCanvasEl;\n            }\n            fabric.util.addClass(upperCanvasEl, \"upper-canvas \" + lowerCanvasClass);\n            this.wrapperEl.appendChild(upperCanvasEl);\n            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);\n            this._applyCanvasStyle(upperCanvasEl);\n            this.contextTop = upperCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns context of top canvas where interactions are drawn\n     * @returns {CanvasRenderingContext2D}\n     */ getTopContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * @private\n     */ _createCacheCanvas: function() {\n            this.cacheCanvasEl = this._createCanvasElement();\n            this.cacheCanvasEl.setAttribute(\"width\", this.width);\n            this.cacheCanvasEl.setAttribute(\"height\", this.height);\n            this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _initWrapperElement: function() {\n            this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, \"div\", {\n                \"class\": this.containerClass\n            });\n            fabric.util.setStyle(this.wrapperEl, {\n                width: this.width + \"px\",\n                height: this.height + \"px\",\n                position: \"relative\"\n            });\n            fabric.util.makeElementUnselectable(this.wrapperEl);\n        },\n        /**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */ _applyCanvasStyle: function(element) {\n            var width = this.width || element.width, height = this.height || element.height;\n            fabric.util.setStyle(element, {\n                position: \"absolute\",\n                width: width + \"px\",\n                height: height + \"px\",\n                left: 0,\n                top: 0,\n                \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\",\n                \"-ms-touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            });\n            element.width = width;\n            element.height = height;\n            fabric.util.makeElementUnselectable(element);\n        },\n        /**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */ _copyCanvasStyle: function(fromEl, toEl) {\n            toEl.style.cssText = fromEl.style.cssText;\n        },\n        /**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */ getSelectionContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */ getSelectionElement: function() {\n            return this.upperCanvasEl;\n        },\n        /**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */ getActiveObject: function() {\n            return this._activeObject;\n        },\n        /**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */ getActiveObjects: function() {\n            var active = this._activeObject;\n            if (active) {\n                if (active.type === \"activeSelection\" && active._objects) {\n                    return active._objects.slice(0);\n                } else {\n                    return [\n                        active\n                    ];\n                }\n            }\n            return [];\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            // removing active object should fire \"selection:cleared\" events\n            if (obj === this._activeObject) {\n                this.fire(\"before:selection:cleared\", {\n                    target: obj\n                });\n                this._discardActiveObject();\n                this.fire(\"selection:cleared\", {\n                    target: obj\n                });\n                obj.fire(\"deselected\");\n            }\n            if (obj === this._hoveredTarget) {\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n            this.callSuper(\"_onObjectRemoved\", obj);\n        },\n        /**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */ _fireSelectionEvents: function(oldObjects, e) {\n            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];\n            oldObjects.forEach(function(oldObject) {\n                if (objects.indexOf(oldObject) === -1) {\n                    somethingChanged = true;\n                    oldObject.fire(\"deselected\", {\n                        e: e,\n                        target: oldObject\n                    });\n                    removed.push(oldObject);\n                }\n            });\n            objects.forEach(function(object) {\n                if (oldObjects.indexOf(object) === -1) {\n                    somethingChanged = true;\n                    object.fire(\"selected\", {\n                        e: e,\n                        target: object\n                    });\n                    added.push(object);\n                }\n            });\n            if (oldObjects.length > 0 && objects.length > 0) {\n                somethingChanged && this.fire(\"selection:updated\", {\n                    e: e,\n                    selected: added,\n                    deselected: removed\n                });\n            } else if (objects.length > 0) {\n                this.fire(\"selection:created\", {\n                    e: e,\n                    selected: added\n                });\n            } else if (oldObjects.length > 0) {\n                this.fire(\"selection:cleared\", {\n                    e: e,\n                    deselected: removed\n                });\n            }\n        },\n        /**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setActiveObject: function(object, e) {\n            var currentActives = this.getActiveObjects();\n            this._setActiveObject(object, e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */ _setActiveObject: function(object, e) {\n            if (this._activeObject === object) {\n                return false;\n            }\n            if (!this._discardActiveObject(e, object)) {\n                return false;\n            }\n            if (object.onSelect({\n                e: e\n            })) {\n                return false;\n            }\n            this._activeObject = object;\n            return true;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */ _discardActiveObject: function(e, object) {\n            var obj = this._activeObject;\n            if (obj) {\n                // onDeselect return TRUE to cancel selection;\n                if (obj.onDeselect({\n                    e: e,\n                    object: object\n                })) {\n                    return false;\n                }\n                this._activeObject = null;\n            }\n            return true;\n        },\n        /**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ discardActiveObject: function(e) {\n            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();\n            if (currentActives.length) {\n                this.fire(\"before:selection:cleared\", {\n                    target: activeObject,\n                    e: e\n                });\n            }\n            this._discardActiveObject(e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            var wrapper = this.wrapperEl;\n            this.removeListeners();\n            wrapper.removeChild(this.upperCanvasEl);\n            wrapper.removeChild(this.lowerCanvasEl);\n            this.contextCache = null;\n            this.contextTop = null;\n            [\n                \"upperCanvasEl\",\n                \"cacheCanvasEl\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n            if (wrapper.parentNode) {\n                wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\n            }\n            delete this.wrapperEl;\n            fabric.StaticCanvas.prototype.dispose.call(this);\n            return this;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            // this.discardActiveGroup();\n            this.discardActiveObject();\n            this.clearContext(this.contextTop);\n            return this.callSuper(\"clear\");\n        },\n        /**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */ drawControls: function(ctx) {\n            var activeObject = this._activeObject;\n            if (activeObject) {\n                activeObject._renderControls(ctx);\n            }\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            //If the object is part of the current selection group, it should\n            //be transformed appropriately\n            //i.e. it should be serialised as it would appear if the selection group\n            //were to be destroyed.\n            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper(\"_toObject\", instance, methodName, propertiesToInclude);\n            //Undo the damage we did by changing all of its properties\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n            return object;\n        },\n        /**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */ _realizeGroupTransformOnObject: function(instance) {\n            if (instance.group && instance.group.type === \"activeSelection\" && this._activeObject === instance.group) {\n                var layoutProps = [\n                    \"angle\",\n                    \"flipX\",\n                    \"flipY\",\n                    \"left\",\n                    \"scaleX\",\n                    \"scaleY\",\n                    \"skewX\",\n                    \"skewY\",\n                    \"top\"\n                ];\n                //Copy all the positionally relevant properties across now\n                var originalValues = {};\n                layoutProps.forEach(function(prop) {\n                    originalValues[prop] = instance[prop];\n                });\n                fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());\n                return originalValues;\n            } else {\n                return null;\n            }\n        },\n        /**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */ _unwindGroupTransformOnObject: function(instance, originalValues) {\n            if (originalValues) {\n                instance.set(originalValues);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            //If the object is in a selection group, simulate what would happen to that\n            //object when the group is deselected\n            var originalProperties = this._realizeGroupTransformOnObject(instance);\n            this.callSuper(\"_setSVGObject\", markup, instance, reviver);\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n        },\n        setViewportTransform: function(vpt) {\n            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {\n                this._activeObject.clearContextTop();\n            }\n            fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);\n        }\n    });\n    // copying static properties manually to work around Opera's bug,\n    // where \"prototype\" property is enumerable and overrides existing prototype\n    for(var prop in fabric.StaticCanvas){\n        if (prop !== \"prototype\") {\n            fabric.Canvas[prop] = fabric.StaticCanvas[prop];\n        }\n    }\n})();\n(function() {\n    var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = {\n        passive: false\n    };\n    function checkClick(e, value) {\n        return e.button && e.button === value - 1;\n    }\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */ mainTouchId: null,\n        /**\n     * Adds mouse listeners to canvas\n     * @private\n     */ _initEventListeners: function() {\n            // in case we initialized the class twice. This should not happen normally\n            // but in some kind of applications where the canvas element may be changed\n            // this is a workaround to having double listeners.\n            this.removeListeners();\n            this._bindEvents();\n            this.addOrRemove(addListener, \"add\");\n        },\n        /**\n     * return an event prefix pointer or mouse.\n     * @private\n     */ _getEventPrefix: function() {\n            return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n        },\n        addOrRemove: function(functor, eventjsFunctor) {\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            functor(fabric.window, \"resize\", this._onResize);\n            functor(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n            functor(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            functor(canvasElement, eventTypePrefix + \"out\", this._onMouseOut);\n            functor(canvasElement, eventTypePrefix + \"enter\", this._onMouseEnter);\n            functor(canvasElement, \"wheel\", this._onMouseWheel);\n            functor(canvasElement, \"contextmenu\", this._onContextMenu);\n            functor(canvasElement, \"dblclick\", this._onDoubleClick);\n            functor(canvasElement, \"dragover\", this._onDragOver);\n            functor(canvasElement, \"dragenter\", this._onDragEnter);\n            functor(canvasElement, \"dragleave\", this._onDragLeave);\n            functor(canvasElement, \"drop\", this._onDrop);\n            if (!this.enablePointerEvents) {\n                functor(canvasElement, \"touchstart\", this._onTouchStart, addEventOptions);\n            }\n            if (typeof eventjs !== \"undefined\" && eventjsFunctor in eventjs) {\n                eventjs[eventjsFunctor](canvasElement, \"gesture\", this._onGesture);\n                eventjs[eventjsFunctor](canvasElement, \"drag\", this._onDrag);\n                eventjs[eventjsFunctor](canvasElement, \"orientation\", this._onOrientationChange);\n                eventjs[eventjsFunctor](canvasElement, \"shake\", this._onShake);\n                eventjs[eventjsFunctor](canvasElement, \"longpress\", this._onLongPress);\n            }\n        },\n        /**\n     * Removes all event listeners\n     */ removeListeners: function() {\n            this.addOrRemove(removeListener, \"remove\");\n            // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     */ _bindEvents: function() {\n            if (this.eventsBound) {\n                // for any reason we pass here twice we do not want to bind events twice.\n                return;\n            }\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onTouchStart = this._onTouchStart.bind(this);\n            this._onMouseMove = this._onMouseMove.bind(this);\n            this._onMouseUp = this._onMouseUp.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onResize = this._onResize.bind(this);\n            this._onGesture = this._onGesture.bind(this);\n            this._onDrag = this._onDrag.bind(this);\n            this._onShake = this._onShake.bind(this);\n            this._onLongPress = this._onLongPress.bind(this);\n            this._onOrientationChange = this._onOrientationChange.bind(this);\n            this._onMouseWheel = this._onMouseWheel.bind(this);\n            this._onMouseOut = this._onMouseOut.bind(this);\n            this._onMouseEnter = this._onMouseEnter.bind(this);\n            this._onContextMenu = this._onContextMenu.bind(this);\n            this._onDoubleClick = this._onDoubleClick.bind(this);\n            this._onDragOver = this._onDragOver.bind(this);\n            this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\");\n            this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\");\n            this._onDrop = this._onDrop.bind(this);\n            this.eventsBound = true;\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */ _onGesture: function(e, self) {\n            this.__onTransformGesture && this.__onTransformGesture(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */ _onDrag: function(e, self) {\n            this.__onDrag && this.__onDrag(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */ _onMouseWheel: function(e) {\n            this.__onMouseWheel(e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseOut: function(e) {\n            var target = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n                target: target,\n                e: e\n            });\n            this._hoveredTarget = null;\n            target && target.fire(\"mouseout\", {\n                e: e\n            });\n            var _this = this;\n            this._hoveredTargets.forEach(function(_target) {\n                _this.fire(\"mouse:out\", {\n                    target: target,\n                    e: e\n                });\n                _target && target.fire(\"mouseout\", {\n                    e: e\n                });\n            });\n            this._hoveredTargets = [];\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */ _onMouseEnter: function(e) {\n            // This find target and consequent 'mouse:over' is used to\n            // clear old instances on hovered target.\n            // calling findTarget has the side effect of killing target.__corner.\n            // as a short term fix we are not firing this if we are currently transforming.\n            // as a long term fix we need to separate the action of finding a target with the\n            // side effects we added to it.\n            if (!this._currentTransform && !this.findTarget(e)) {\n                this.fire(\"mouse:over\", {\n                    target: null,\n                    e: e\n                });\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */ _onOrientationChange: function(e, self) {\n            this.__onOrientationChange && this.__onOrientationChange(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onShake: function(e, self) {\n            this.__onShake && this.__onShake(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onLongPress: function(e, self) {\n            this.__onLongPress && this.__onLongPress(e, self);\n        },\n        /**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */ _onDragOver: function(e) {\n            e.preventDefault();\n            var target = this._simpleEventHandler(\"dragover\", e);\n            this._fireEnterLeaveEvents(target, e);\n        },\n        /**\n     * `drop:before` is a an event that allow you to schedule logic\n     * before the `drop` event. Prefer `drop` event always, but if you need\n     * to run some drop-disabling logic on an event, since there is no way\n     * to handle event handlers ordering, use `drop:before`\n     * @param {Event} e\n     */ _onDrop: function(e) {\n            this._simpleEventHandler(\"drop:before\", e);\n            return this._simpleEventHandler(\"drop\", e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onContextMenu: function(e) {\n            if (this.stopContextMenu) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            return false;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onDoubleClick: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"dblclick\");\n            this._resetTransformEventData(e);\n        },\n        /**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */ getPointerId: function(evt) {\n            var changedTouches = evt.changedTouches;\n            if (changedTouches) {\n                return changedTouches[0] && changedTouches[0].identifier;\n            }\n            if (this.enablePointerEvents) {\n                return evt.pointerId;\n            }\n            return -1;\n        },\n        /**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */ _isMainEvent: function(evt) {\n            if (evt.isPrimary === true) {\n                return true;\n            }\n            if (evt.isPrimary === false) {\n                return false;\n            }\n            if (evt.type === \"touchend\" && evt.touches.length === 0) {\n                return true;\n            }\n            if (evt.changedTouches) {\n                return evt.changedTouches[0].identifier === this.mainTouchId;\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchStart: function(e) {\n            e.preventDefault();\n            if (this.mainTouchId === null) {\n                this.mainTouchId = this.getPointerId(e);\n            }\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            addListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            addListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            // Unbind mousedown to prevent double triggers from touch devices\n            removeListener(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDown: function(e) {\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            removeListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            addListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            addListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchEnd: function(e) {\n            if (e.touches.length > 0) {\n                // if there are still touches stop here\n                return;\n            }\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            this.mainTouchId = null;\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            var _this = this;\n            if (this._willAddMouseDown) {\n                clearTimeout(this._willAddMouseDown);\n            }\n            this._willAddMouseDown = setTimeout(function() {\n                // Wait 400ms before rebinding mousedown to prevent double triggers\n                // from touch devices\n                addListener(_this.upperCanvasEl, eventTypePrefix + \"down\", _this._onMouseDown);\n                _this._willAddMouseDown = 0;\n            }, 400);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUp: function(e) {\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            if (this._isMainEvent(e)) {\n                removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n                removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n                addListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMove: function(e) {\n            !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\n            this.__onMouseMove(e);\n        },\n        /**\n     * @private\n     */ _onResize: function() {\n            this.calcOffset();\n        },\n        /**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */ _shouldRender: function(target) {\n            var activeObject = this._activeObject;\n            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {\n                // this covers: switch of target, from target to no target, selection of target\n                // multiSelection with key and mouse\n                return true;\n            } else if (activeObject && activeObject.isEditing) {\n                // if we mouse up/down over a editing textbox a cursor change,\n                // there is no need to re render\n                return false;\n            }\n            return false;\n        },\n        /**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseUp: function(e) {\n            var target, transform = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;\n            this._cacheTransformEventData(e);\n            target = this._target;\n            this._handleEvent(e, \"up:before\");\n            // if right/middle click just fire events and return\n            // target undefined will make the _handleEvent search the target\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"up\", RIGHT_CLICK, isClick);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"up\", MIDDLE_CLICK, isClick);\n                }\n                this._resetTransformEventData();\n                return;\n            }\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this._onMouseUpInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            if (transform) {\n                this._finalizeCurrentTransform(e);\n                shouldRender = transform.actionPerformed;\n            }\n            if (!isClick) {\n                var targetWasActive = target === this._activeObject;\n                this._maybeGroupObjects(e);\n                if (!shouldRender) {\n                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;\n                }\n            }\n            var corner, pointer;\n            if (target) {\n                corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                if (target.selectable && target !== this._activeObject && target.activeOn === \"up\") {\n                    this.setActiveObject(target, e);\n                    shouldRender = true;\n                } else {\n                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e, target, control);\n                    if (mouseUpHandler) {\n                        pointer = this.getPointer(e);\n                        mouseUpHandler(e, transform, pointer.x, pointer.y);\n                    }\n                }\n                target.isMoving = false;\n            }\n            // if we are ending up a transform on a different control or a new object\n            // fire the original mouse up from the corner that started the transform\n            if (transform && (transform.target !== target || transform.corner !== corner)) {\n                var originalControl = transform.target && transform.target.controls[transform.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);\n                pointer = pointer || this.getPointer(e);\n                originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);\n            }\n            this._setCursorFromEvent(e, target);\n            this._handleEvent(e, \"up\", LEFT_CLICK, isClick);\n            this._groupSelector = null;\n            this._currentTransform = null;\n            // reset the target information about which corner is selected\n            target && (target.__corner = 0);\n            if (shouldRender) {\n                this.requestRenderAll();\n            } else if (!isClick) {\n                this.renderTop();\n            }\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */ _simpleEventHandler: function(eventType, e) {\n            var target = this.findTarget(e), targets = this.targets, options = {\n                e: e,\n                target: target,\n                subTargets: targets\n            };\n            this.fire(eventType, options);\n            target && target.fire(eventType, options);\n            if (!targets) {\n                return target;\n            }\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(eventType, options);\n            }\n            return target;\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */ _handleEvent: function(e, eventType, button, isClick) {\n            var target = this._target, targets = this.targets || [], options = {\n                e: e,\n                target: target,\n                subTargets: targets,\n                button: button || LEFT_CLICK,\n                isClick: isClick || false,\n                pointer: this._pointer,\n                absolutePointer: this._absolutePointer,\n                transform: this._currentTransform\n            };\n            if (eventType === \"up\") {\n                options.currentTarget = this.findTarget(e);\n                options.currentSubTargets = this.targets;\n            }\n            this.fire(\"mouse:\" + eventType, options);\n            target && target.fire(\"mouse\" + eventType, options);\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(\"mouse\" + eventType, options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */ _finalizeCurrentTransform: function(e) {\n            var transform = this._currentTransform, target = transform.target, options = {\n                e: e,\n                target: target,\n                transform: transform,\n                action: transform.action\n            };\n            if (target._scaling) {\n                target._scaling = false;\n            }\n            target.setCoords();\n            if (transform.actionPerformed || this.stateful && target.hasStateChanged()) {\n                this._fire(\"modified\", options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDownInDrawingMode: function(e) {\n            this._isCurrentlyDrawing = true;\n            if (this.getActiveObject()) {\n                this.discardActiveObject(e).requestRenderAll();\n            }\n            var pointer = this.getPointer(e);\n            this.freeDrawingBrush.onMouseDown(pointer, {\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"down\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMoveInDrawingMode: function(e) {\n            if (this._isCurrentlyDrawing) {\n                var pointer = this.getPointer(e);\n                this.freeDrawingBrush.onMouseMove(pointer, {\n                    e: e,\n                    pointer: pointer\n                });\n            }\n            this.setCursor(this.freeDrawingCursor);\n            this._handleEvent(e, \"move\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUpInDrawingMode: function(e) {\n            var pointer = this.getPointer(e);\n            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"up\");\n        },\n        /**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ __onMouseDown: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"down:before\");\n            var target = this._target;\n            // if right click just fire events\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"down\", RIGHT_CLICK);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"down\", MIDDLE_CLICK);\n                }\n                return;\n            }\n            if (this.isDrawingMode) {\n                this._onMouseDownInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            // ignore if some object is being transformed at this moment\n            if (this._currentTransform) {\n                return;\n            }\n            var pointer = this._pointer;\n            // save pointer for check in __onMouseUp event\n            this._previousPointer = pointer;\n            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e, target);\n            if (this._shouldClearSelection(e, target)) {\n                this.discardActiveObject(e);\n            } else if (shouldGroup) {\n                this._handleGrouping(e, target);\n                target = this._activeObject;\n            }\n            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {\n                this._groupSelector = {\n                    ex: this._absolutePointer.x,\n                    ey: this._absolutePointer.y,\n                    top: 0,\n                    left: 0\n                };\n            }\n            if (target) {\n                var alreadySelected = target === this._activeObject;\n                if (target.selectable && target.activeOn === \"down\") {\n                    this.setActiveObject(target, e);\n                }\n                var corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                target.__corner = corner;\n                if (target === this._activeObject && (corner || !shouldGroup)) {\n                    this._setupCurrentTransform(e, target, alreadySelected);\n                    var control = target.controls[corner], pointer = this.getPointer(e), mouseDownHandler = control && control.getMouseDownHandler(e, target, control);\n                    if (mouseDownHandler) {\n                        mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);\n                    }\n                }\n            }\n            this._handleEvent(e, \"down\");\n            // we must renderAll so that we update the visuals\n            (shouldRender || shouldGroup) && this.requestRenderAll();\n        },\n        /**\n     * reset cache form common information needed during event processing\n     * @private\n     */ _resetTransformEventData: function() {\n            this._target = null;\n            this._pointer = null;\n            this._absolutePointer = null;\n        },\n        /**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */ _cacheTransformEventData: function(e) {\n            // reset in order to avoid stale caching\n            this._resetTransformEventData();\n            this._pointer = this.getPointer(e, true);\n            this._absolutePointer = this.restorePointerVpt(this._pointer);\n            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;\n        },\n        /**\n     * @private\n     */ _beforeTransform: function(e) {\n            var t = this._currentTransform;\n            this.stateful && t.target.saveState();\n            this.fire(\"before:transform\", {\n                e: e,\n                transform: t\n            });\n        },\n        /**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ __onMouseMove: function(e) {\n            this._handleEvent(e, \"move:before\");\n            this._cacheTransformEventData(e);\n            var target, pointer;\n            if (this.isDrawingMode) {\n                this._onMouseMoveInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            var groupSelector = this._groupSelector;\n            // We initially clicked in an empty area, so we draw a box for multiple selection\n            if (groupSelector) {\n                pointer = this._absolutePointer;\n                groupSelector.left = pointer.x - groupSelector.ex;\n                groupSelector.top = pointer.y - groupSelector.ey;\n                this.renderTop();\n            } else if (!this._currentTransform) {\n                target = this.findTarget(e) || null;\n                this._setCursorFromEvent(e, target);\n                this._fireOverOutEvents(target, e);\n            } else {\n                this._transformObject(e);\n            }\n            this._handleEvent(e, \"move\");\n            this._resetTransformEventData();\n        },\n        /**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */ _fireOverOutEvents: function(target, e) {\n            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _hoveredTarget,\n                evtOut: \"mouseout\",\n                canvasEvtOut: \"mouse:out\",\n                evtIn: \"mouseover\",\n                canvasEvtIn: \"mouse:over\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"mouseout\",\n                    evtIn: \"mouseover\"\n                });\n            }\n            this._hoveredTarget = target;\n            this._hoveredTargets = this.targets.concat();\n        },\n        /**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */ _fireEnterLeaveEvents: function(target, e) {\n            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _draggedoverTarget,\n                evtOut: \"dragleave\",\n                evtIn: \"dragenter\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"dragleave\",\n                    evtIn: \"dragenter\"\n                });\n            }\n            this._draggedoverTarget = target;\n        },\n        /**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */ fireSyntheticInOutEvents: function(target, e, config) {\n            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;\n            if (targetChanged) {\n                inOpt = {\n                    e: e,\n                    target: target,\n                    previousTarget: oldTarget\n                };\n                outOpt = {\n                    e: e,\n                    target: oldTarget,\n                    nextTarget: target\n                };\n            }\n            inFires = target && targetChanged;\n            outFires = oldTarget && targetChanged;\n            if (outFires) {\n                canvasEvtOut && this.fire(canvasEvtOut, outOpt);\n                oldTarget.fire(config.evtOut, outOpt);\n            }\n            if (inFires) {\n                canvasEvtIn && this.fire(canvasEvtIn, inOpt);\n                target.fire(config.evtIn, inOpt);\n            }\n        },\n        /**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseWheel: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"wheel\");\n            this._resetTransformEventData();\n        },\n        /**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */ _transformObject: function(e) {\n            var pointer = this.getPointer(e), transform = this._currentTransform;\n            transform.reset = false;\n            transform.shiftKey = e.shiftKey;\n            transform.altKey = e[this.centeredKey];\n            this._performTransformAction(e, transform, pointer);\n            transform.actionPerformed && this.requestRenderAll();\n        },\n        /**\n     * @private\n     */ _performTransformAction: function(e, transform, pointer) {\n            var x = pointer.x, y = pointer.y, action = transform.action, actionPerformed = false, actionHandler = transform.actionHandler;\n            // this object could be created from the function in the control handlers\n            if (actionHandler) {\n                actionPerformed = actionHandler(e, transform, x, y);\n            }\n            if (action === \"drag\" && actionPerformed) {\n                transform.target.isMoving = true;\n                this.setCursor(transform.target.moveCursor || this.moveCursor);\n            }\n            transform.actionPerformed = transform.actionPerformed || actionPerformed;\n        },\n        /**\n     * @private\n     */ _fire: fabric.controlsUtils.fireEvent,\n        /**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */ _setCursorFromEvent: function(e, target) {\n            if (!target) {\n                this.setCursor(this.defaultCursor);\n                return false;\n            }\n            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === \"activeSelection\" ? this._activeObject : null, // only show proper corner when group selection is not active\n            corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e, true));\n            if (!corner) {\n                if (target.subTargetCheck) {\n                    // hoverCursor should come from top-most subTarget,\n                    // so we walk the array backwards\n                    this.targets.concat().reverse().map(function(_target) {\n                        hoverCursor = _target.hoverCursor || hoverCursor;\n                    });\n                }\n                this.setCursor(hoverCursor);\n            } else {\n                this.setCursor(this.getCornerCursor(corner, target, e));\n            }\n        },\n        /**\n     * @private\n     */ getCornerCursor: function(corner, target, e) {\n            var control = target.controls[corner];\n            return control.cursorStyleHandler(e, control, target);\n        }\n    });\n})();\n(function() {\n    var min = Math.min, max = Math.max;\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */ _shouldGroup: function(e, target) {\n            var activeObject = this._activeObject;\n            return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === \"activeSelection\") && !target.onSelect({\n                e: e\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _handleGrouping: function(e, target) {\n            var activeObject = this._activeObject;\n            // avoid multi select when shift click on a corner\n            if (activeObject.__corner) {\n                return;\n            }\n            if (target === activeObject) {\n                // if it's a group, find target again, using activeGroup objects\n                target = this.findTarget(e, true);\n                // if even object is not found or we are on activeObjectCorner, bail out\n                if (!target || !target.selectable) {\n                    return;\n                }\n            }\n            if (activeObject && activeObject.type === \"activeSelection\") {\n                this._updateActiveSelection(target, e);\n            } else {\n                this._createActiveSelection(target, e);\n            }\n        },\n        /**\n     * @private\n     */ _updateActiveSelection: function(target, e) {\n            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);\n            if (activeSelection.contains(target)) {\n                activeSelection.removeWithUpdate(target);\n                this._hoveredTarget = target;\n                this._hoveredTargets = this.targets.concat();\n                if (activeSelection.size() === 1) {\n                    // activate last remaining object\n                    this._setActiveObject(activeSelection.item(0), e);\n                }\n            } else {\n                activeSelection.addWithUpdate(target);\n                this._hoveredTarget = activeSelection;\n                this._hoveredTargets = this.targets.concat();\n            }\n            this._fireSelectionEvents(currentActiveObjects, e);\n        },\n        /**\n     * @private\n     */ _createActiveSelection: function(target, e) {\n            var currentActives = this.getActiveObjects(), group = this._createGroup(target);\n            this._hoveredTarget = group;\n            // ISSUE 4115: should we consider subTargets here?\n            // this._hoveredTargets = [];\n            // this._hoveredTargets = this.targets.concat();\n            this._setActiveObject(group, e);\n            this._fireSelectionEvents(currentActives, e);\n        },\n        /**\n     * @private\n     * @param {Object} target\n     */ _createGroup: function(target) {\n            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [\n                this._activeObject,\n                target\n            ] : [\n                target,\n                this._activeObject\n            ];\n            this._activeObject.isEditing && this._activeObject.exitEditing();\n            return new fabric.ActiveSelection(groupObjects, {\n                canvas: this\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e mouse event\n     */ _groupSelectedObjects: function(e) {\n            var group = this._collectObjects(e), aGroup;\n            // do not create group for 1 element only\n            if (group.length === 1) {\n                this.setActiveObject(group[0], e);\n            } else if (group.length > 1) {\n                aGroup = new fabric.ActiveSelection(group.reverse(), {\n                    canvas: this\n                });\n                this.setActiveObject(aGroup, e);\n            }\n        },\n        /**\n     * @private\n     */ _collectObjects: function(e) {\n            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;\n            // we iterate reverse order to collect top first in case of click.\n            for(var i = this._objects.length; i--;){\n                currentObject = this._objects[i];\n                if (!currentObject || !currentObject.selectable || !currentObject.visible) {\n                    continue;\n                }\n                if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {\n                    group.push(currentObject);\n                    // only add one object if it's a click\n                    if (isClick) {\n                        break;\n                    }\n                }\n            }\n            if (group.length > 1) {\n                group = group.filter(function(object) {\n                    return !object.onSelect({\n                        e: e\n                    });\n                });\n            }\n            return group;\n        },\n        /**\n     * @private\n     */ _maybeGroupObjects: function(e) {\n            if (this.selection && this._groupSelector) {\n                this._groupSelectedObjects(e);\n            }\n            this.setCursor(this.defaultCursor);\n            // clear selection and current transformation\n            this._groupSelector = null;\n        }\n    });\n})();\n(function() {\n    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */ toDataURL: function(options) {\n            options || (options = {});\n            var format = options.format || \"png\", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);\n            return fabric.util.toDataURL(canvasEl, format, quality);\n        },\n        /**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */ toCanvasElement: function(multiplier, cropping) {\n            multiplier = multiplier || 1;\n            cropping = cropping || {};\n            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [\n                newZoom,\n                0,\n                0,\n                newZoom,\n                translateX,\n                translateY\n            ], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;\n            canvasEl.width = scaledWidth;\n            canvasEl.height = scaledHeight;\n            this.contextTop = null;\n            this.enableRetinaScaling = false;\n            this.interactive = false;\n            this.viewportTransform = newVp;\n            this.width = scaledWidth;\n            this.height = scaledHeight;\n            this.calcViewportBoundaries();\n            this.renderCanvas(canvasEl.getContext(\"2d\"), this._objects);\n            this.viewportTransform = vp;\n            this.width = originalWidth;\n            this.height = originalHeight;\n            this.calcViewportBoundaries();\n            this.interactive = originalInteractive;\n            this.enableRetinaScaling = originalRetina;\n            this.contextTop = originalContextTop;\n            return canvasEl;\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */ loadFromJSON: function(json, callback, reviver) {\n        if (!json) {\n            return;\n        }\n        // serialize if it wasn't already\n        var serialized = typeof json === \"string\" ? JSON.parse(json) : fabric.util.object.clone(json);\n        var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;\n        this.renderOnAddRemove = false;\n        delete serialized.clipPath;\n        this._enlivenObjects(serialized.objects, function(enlivenedObjects) {\n            _this.clear();\n            _this._setBgOverlay(serialized, function() {\n                if (clipPath) {\n                    _this._enlivenObjects([\n                        clipPath\n                    ], function(enlivenedCanvasClip) {\n                        _this.clipPath = enlivenedCanvasClip[0];\n                        _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                    });\n                } else {\n                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                }\n            });\n        }, reviver);\n        return this;\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {\n        var _this = this;\n        enlivenedObjects.forEach(function(obj, index) {\n            // we splice the array just in case some custom classes restored from JSON\n            // will add more object to canvas at canvas init.\n            _this.insertAt(obj, index);\n        });\n        this.renderOnAddRemove = renderOnAddRemove;\n        // remove parts i cannot set as options\n        delete serialized.objects;\n        delete serialized.backgroundImage;\n        delete serialized.overlayImage;\n        delete serialized.background;\n        delete serialized.overlay;\n        // this._initOptions does too many things to just\n        // call it. Normally loading an Object from JSON\n        // create the Object instance. Here the Canvas is\n        // already an instance and we are just loading things over it\n        this._setOptions(serialized);\n        this.renderAll();\n        callback && callback();\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ _setBgOverlay: function(serialized, callback) {\n        var loaded = {\n            backgroundColor: false,\n            overlayColor: false,\n            backgroundImage: false,\n            overlayImage: false\n        };\n        if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\n            callback && callback();\n            return;\n        }\n        var cbIfLoaded = function() {\n            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\n                callback && callback();\n            }\n        };\n        this.__setBgOverlay(\"backgroundImage\", serialized.backgroundImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayImage\", serialized.overlayImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"backgroundColor\", serialized.background, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayColor\", serialized.overlay, loaded, cbIfLoaded);\n    },\n    /**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */ __setBgOverlay: function(property, value, loaded, callback) {\n        var _this = this;\n        if (!value) {\n            loaded[property] = true;\n            callback && callback();\n            return;\n        }\n        if (property === \"backgroundImage\" || property === \"overlayImage\") {\n            fabric.util.enlivenObjects([\n                value\n            ], function(enlivedObject) {\n                _this[property] = enlivedObject[0];\n                loaded[property] = true;\n                callback && callback();\n            });\n        } else {\n            this[\"set\" + fabric.util.string.capitalize(property, true)](value, function() {\n                loaded[property] = true;\n                callback && callback();\n            });\n        }\n    },\n    /**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */ _enlivenObjects: function(objects, callback, reviver) {\n        if (!objects || objects.length === 0) {\n            callback && callback([]);\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            callback && callback(enlivenedObjects);\n        }, null, reviver);\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */ _toDataURL: function(format, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURL(format));\n        });\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */ _toDataURLWithMultiplier: function(format, multiplier, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURLWithMultiplier(format, multiplier));\n        });\n    },\n    /**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */ clone: function(callback, properties) {\n        var data = JSON.stringify(this.toJSON(properties));\n        this.cloneWithoutData(function(clone) {\n            clone.loadFromJSON(data, function() {\n                callback && callback(clone);\n            });\n        });\n    },\n    /**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */ cloneWithoutData: function(callback) {\n        var el = fabric.util.createCanvasElement();\n        el.width = this.width;\n        el.height = this.height;\n        var clone = new fabric.Canvas(el);\n        if (this.backgroundImage) {\n            clone.setBackgroundImage(this.backgroundImage.src, function() {\n                clone.renderAll();\n                callback && callback(clone);\n            });\n            clone.backgroundImageOpacity = this.backgroundImageOpacity;\n            clone.backgroundImageStretch = this.backgroundImageStretch;\n        } else {\n            callback && callback(clone);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, capitalize = fabric.util.string.capitalize, degreesToRadians = fabric.util.degreesToRadians, objectCaching = !fabric.isLikelyNode, ALIASING_LIMIT = 2;\n    if (fabric.Object) {\n        return;\n    }\n    /**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */ fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {\n        /**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */ type: \"object\",\n        /**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originX: \"left\",\n        /**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originY: \"top\",\n        /**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */ top: 0,\n        /**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */ left: 0,\n        /**\n     * Object width\n     * @type Number\n     * @default\n     */ width: 0,\n        /**\n     * Object height\n     * @type Number\n     * @default\n     */ height: 0,\n        /**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */ scaleX: 1,\n        /**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */ scaleY: 1,\n        /**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */ flipX: false,\n        /**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */ flipY: false,\n        /**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */ opacity: 1,\n        /**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */ angle: 0,\n        /**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewX: 0,\n        /**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewY: 0,\n        /**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */ cornerSize: 13,\n        /**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */ touchCornerSize: 24,\n        /**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */ transparentCorners: true,\n        /**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: null,\n        /**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */ moveCursor: null,\n        /**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */ padding: 0,\n        /**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */ borderColor: \"rgb(178,204,255)\",\n        /**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ borderDashArray: null,\n        /**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */ cornerColor: \"rgb(178,204,255)\",\n        /**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ cornerStrokeColor: null,\n        /**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */ cornerStyle: \"rect\",\n        /**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ cornerDashArray: null,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: true,\n        /**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ fill: \"rgb(0,0,0)\",\n        /**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */ fillRule: \"nonzero\",\n        /**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */ globalCompositeOperation: \"source-over\",\n        /**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */ selectionBackgroundColor: \"\",\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */ strokeWidth: 1,\n        /**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */ strokeDashArray: null,\n        /**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */ strokeDashOffset: 0,\n        /**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */ strokeLineCap: \"butt\",\n        /**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */ strokeLineJoin: \"miter\",\n        /**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */ strokeMiterLimit: 4,\n        /**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */ borderOpacityWhenMoving: 0.4,\n        /**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */ borderScaleFactor: 1,\n        /**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */ minScaleLimit: 0,\n        /**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */ selectable: true,\n        /**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */ evented: true,\n        /**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */ visible: true,\n        /**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */ hasControls: true,\n        /**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */ hasBorders: true,\n        /**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementX: false,\n        /**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementY: false,\n        /**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */ lockRotation: false,\n        /**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingX: false,\n        /**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingY: false,\n        /**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingX: false,\n        /**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingY: false,\n        /**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */ lockScalingFlip: false,\n        /**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ excludeFromExport: false,\n        /**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */ objectCaching: objectCaching,\n        /**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */ statefullCache: false,\n        /**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ noScaleCache: true,\n        /**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */ strokeUniform: false,\n        /**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ dirty: true,\n        /**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */ __corner: 0,\n        /**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */ paintFirst: \"fill\",\n        /**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */ activeOn: \"down\",\n        /**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: (\"top left width height scaleX scaleY flipX flipY originX originY transformMatrix \" + \"stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit \" + \"angle opacity fill globalCompositeOperation shadow visible backgroundColor \" + \"skewX skewY fillRule paintFirst clipPath strokeUniform\").split(\" \"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: (\"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform\" + \" strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath\").split(\" \"),\n        /**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */ colorProperties: \"fill stroke backgroundColor\".split(\" \"),\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ inverted: false,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ absolutePositioned: false,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            if (options) {\n                this.setOptions(options);\n            }\n        },\n        /**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */ _createCacheCanvas: function() {\n            this._cacheProperties = {};\n            this._cacheCanvas = fabric.util.createCanvasElement();\n            this._cacheContext = this._cacheCanvas.getContext(\"2d\");\n            this._updateCacheCanvas();\n            // if canvas gets created, is empty, so dirty.\n            this.dirty = true;\n        },\n        /**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _limitCacheSize: function(dims) {\n            var perfLimitSizeTotal = fabric.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;\n            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {\n                if (width < min) {\n                    dims.width = min;\n                }\n                if (height < min) {\n                    dims.height = min;\n                }\n                return dims;\n            }\n            var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric.util.capValue, x = capValue(min, limitedDims.x, max), y = capValue(min, limitedDims.y, max);\n            if (width > x) {\n                dims.zoomX /= width / x;\n                dims.width = x;\n                dims.capped = true;\n            }\n            if (height > y) {\n                dims.zoomY /= height / y;\n                dims.height = y;\n                dims.capped = true;\n            }\n            return dims;\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var objectScale = this.getTotalObjectScaling(), // caculate dimensions without skewing\n            dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;\n            return {\n                // for sure this ALIASING_LIMIT is slightly creating problem\n                // in situation in which the cache canvas gets an upper limit\n                // also objectScale contains already scaleX and scaleY\n                width: neededX + ALIASING_LIMIT,\n                height: neededY + ALIASING_LIMIT,\n                zoomX: objectScale.scaleX,\n                zoomY: objectScale.scaleY,\n                x: neededX,\n                y: neededY\n            };\n        },\n        /**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */ _updateCacheCanvas: function() {\n            var targetCanvas = this.canvas;\n            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {\n                var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;\n                if (this === target && action.slice && action.slice(0, 5) === \"scale\") {\n                    return false;\n                }\n            }\n            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;\n            if (dimensionsChanged) {\n                var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;\n                shouldResizeCanvas = sizeGrowing || sizeShrinking;\n                if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {\n                    additionalWidth = width * 0.1;\n                    additionalHeight = height * 0.1;\n                }\n            }\n            if (this instanceof fabric.Text && this.path) {\n                shouldRedraw = true;\n                shouldResizeCanvas = true;\n                additionalWidth += this.getHeightOfLine(0) * this.zoomX;\n                additionalHeight += this.getHeightOfLine(0) * this.zoomY;\n            }\n            if (shouldRedraw) {\n                if (shouldResizeCanvas) {\n                    canvas.width = Math.ceil(width + additionalWidth);\n                    canvas.height = Math.ceil(height + additionalHeight);\n                } else {\n                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);\n                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);\n                }\n                drawingWidth = dims.x / 2;\n                drawingHeight = dims.y / 2;\n                this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;\n                this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;\n                this.cacheWidth = width;\n                this.cacheHeight = height;\n                this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);\n                this._cacheContext.scale(zoomX, zoomY);\n                this.zoomX = zoomX;\n                this.zoomY = zoomY;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */ setOptions: function(options) {\n            this._setOptions(options);\n            this._initGradient(options.fill, \"fill\");\n            this._initGradient(options.stroke, \"stroke\");\n            this._initPattern(options.fill, \"fill\");\n            this._initPattern(options.stroke, \"stroke\");\n        },\n        /**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */ transform: function(ctx) {\n            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;\n            var m = this.calcTransformMatrix(!needFullTransform);\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        },\n        /**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, object = {\n                type: this.type,\n                version: fabric.version,\n                originX: this.originX,\n                originY: this.originY,\n                left: toFixed(this.left, NUM_FRACTION_DIGITS),\n                top: toFixed(this.top, NUM_FRACTION_DIGITS),\n                width: toFixed(this.width, NUM_FRACTION_DIGITS),\n                height: toFixed(this.height, NUM_FRACTION_DIGITS),\n                fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n                stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n                strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\n                strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n                strokeLineCap: this.strokeLineCap,\n                strokeDashOffset: this.strokeDashOffset,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeUniform: this.strokeUniform,\n                strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\n                scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),\n                scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),\n                angle: toFixed(this.angle, NUM_FRACTION_DIGITS),\n                flipX: this.flipX,\n                flipY: this.flipY,\n                opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),\n                shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n                visible: this.visible,\n                backgroundColor: this.backgroundColor,\n                fillRule: this.fillRule,\n                paintFirst: this.paintFirst,\n                globalCompositeOperation: this.globalCompositeOperation,\n                skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),\n                skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)\n            };\n            if (this.clipPath && !this.clipPath.excludeFromExport) {\n                object.clipPath = this.clipPath.toObject(propertiesToInclude);\n                object.clipPath.inverted = this.clipPath.inverted;\n                object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;\n            }\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                object = this._removeDefaultValues(object);\n            }\n            return object;\n        },\n        /**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            // will be overwritten by subclasses\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * @private\n     * @param {Object} object\n     */ _removeDefaultValues: function(object) {\n            var prototype = fabric.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;\n            stateProperties.forEach(function(prop) {\n                if (prop === \"left\" || prop === \"top\") {\n                    return;\n                }\n                if (object[prop] === prototype[prop]) {\n                    delete object[prop];\n                }\n                // basically a check for [] === []\n                if (Array.isArray(object[prop]) && Array.isArray(prototype[prop]) && object[prop].length === 0 && prototype[prop].length === 0) {\n                    delete object[prop];\n                }\n            });\n            return object;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.\" + capitalize(this.type) + \">\";\n        },\n        /**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */ getObjectScaling: function() {\n            // if the object is a top level one, on the canvas, we go for simple aritmetic\n            // otherwise the complex method with angles will return approximations and decimals\n            // and will likely kill the cache when not needed\n            // https://github.com/fabricjs/fabric.js/issues/7157\n            if (!this.group) {\n                return {\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY\n                };\n            }\n            // if we are inside a group total zoom calculation is complex, we defer to generic matrices\n            var options = fabric.util.qrDecompose(this.calcTransformMatrix());\n            return {\n                scaleX: Math.abs(options.scaleX),\n                scaleY: Math.abs(options.scaleY)\n            };\n        },\n        /**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */ getTotalObjectScaling: function() {\n            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;\n            if (this.canvas) {\n                var zoom = this.canvas.getZoom();\n                var retina = this.canvas.getRetinaScaling();\n                scaleX *= zoom * retina;\n                scaleY *= zoom * retina;\n            }\n            return {\n                scaleX: scaleX,\n                scaleY: scaleY\n            };\n        },\n        /**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */ getObjectOpacity: function() {\n            var opacity = this.opacity;\n            if (this.group) {\n                opacity *= this.group.getObjectOpacity();\n            }\n            return opacity;\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */ _set: function(key, value) {\n            var shouldConstrainValue = key === \"scaleX\" || key === \"scaleY\", isChanged = this[key] !== value, groupNeedsUpdate = false;\n            if (shouldConstrainValue) {\n                value = this._constrainScale(value);\n            }\n            if (key === \"scaleX\" && value < 0) {\n                this.flipX = !this.flipX;\n                value *= -1;\n            } else if (key === \"scaleY\" && value < 0) {\n                this.flipY = !this.flipY;\n                value *= -1;\n            } else if (key === \"shadow\" && value && !(value instanceof fabric.Shadow)) {\n                value = new fabric.Shadow(value);\n            } else if (key === \"dirty\" && this.group) {\n                this.group.set(\"dirty\", value);\n            }\n            this[key] = value;\n            if (isChanged) {\n                groupNeedsUpdate = this.group && this.group.isOnACache();\n                if (this.cacheProperties.indexOf(key) > -1) {\n                    this.dirty = true;\n                    groupNeedsUpdate && this.group.set(\"dirty\", true);\n                } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {\n                    this.group.set(\"dirty\", true);\n                }\n            }\n            return this;\n        },\n        /**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */ setOnGroup: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */ getViewportTransform: function() {\n            if (this.canvas && this.canvas.viewportTransform) {\n                return this.canvas.viewportTransform;\n            }\n            return fabric.iMatrix.concat();\n        },\n        /*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */ isNotVisible: function() {\n            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n        },\n        /**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if width/height are zeros or object is not visible\n            if (this.isNotVisible()) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            ctx.save();\n            this._setupCompositeOperation(ctx);\n            this.drawSelectionBackground(ctx);\n            this.transform(ctx);\n            this._setOpacity(ctx);\n            this._setShadow(ctx, this);\n            if (this.shouldCache()) {\n                this.renderCache();\n                this.drawCacheOnCanvas(ctx);\n            } else {\n                this._removeCacheCanvas();\n                this.dirty = false;\n                this.drawObject(ctx);\n                if (this.objectCaching && this.statefullCache) {\n                    this.saveState({\n                        propertySet: \"cacheProperties\"\n                    });\n                }\n            }\n            ctx.restore();\n        },\n        renderCache: function(options) {\n            options = options || {};\n            if (!this._cacheCanvas || !this._cacheContext) {\n                this._createCacheCanvas();\n            }\n            if (this.isCacheDirty()) {\n                this.statefullCache && this.saveState({\n                    propertySet: \"cacheProperties\"\n                });\n                this.drawObject(this._cacheContext, options.forClipping);\n                this.dirty = false;\n            }\n        },\n        /**\n     * Remove cacheCanvas and its dimensions from the objects\n     */ _removeCacheCanvas: function() {\n            this._cacheCanvas = null;\n            this._cacheContext = null;\n            this.cacheWidth = 0;\n            this.cacheHeight = 0;\n        },\n        /**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasStroke: function() {\n            return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n        },\n        /**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasFill: function() {\n            return this.fill && this.fill !== \"transparent\";\n        },\n        /**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */ needsItsOwnCache: function() {\n            if (this.paintFirst === \"stroke\" && this.hasFill() && this.hasStroke() && typeof this.shadow === \"object\") {\n                return true;\n            }\n            if (this.clipPath) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());\n            return this.ownCaching;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n        },\n        /**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Object} clipPath\n     */ drawClipPathOnCache: function(ctx, clipPath) {\n            ctx.save();\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4\n            if (clipPath.inverted) {\n                ctx.globalCompositeOperation = \"destination-out\";\n            } else {\n                ctx.globalCompositeOperation = \"destination-in\";\n            }\n            //ctx.scale(1 / 2, 1 / 2);\n            if (clipPath.absolutePositioned) {\n                var m = fabric.util.invertTransform(this.calcTransformMatrix());\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            }\n            clipPath.transform(ctx);\n            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);\n            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx, forClipping) {\n            var originalFill = this.fill, originalStroke = this.stroke;\n            if (forClipping) {\n                this.fill = \"black\";\n                this.stroke = \"\";\n                this._setClippingProperties(ctx);\n            } else {\n                this._renderBackground(ctx);\n            }\n            this._render(ctx);\n            this._drawClipPath(ctx, this.clipPath);\n            this.fill = originalFill;\n            this.stroke = originalStroke;\n        },\n        /**\n     * Prepare clipPath state and cache and draw it on instance's cache\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {fabric.Object} clipPath\n     */ _drawClipPath: function(ctx, clipPath) {\n            if (!clipPath) {\n                return;\n            }\n            // needed to setup a couple of variables\n            // path canvas gets overridden with this one.\n            // TODO find a better solution?\n            clipPath.canvas = this.canvas;\n            clipPath.shouldCache();\n            clipPath._transformDone = true;\n            clipPath.renderCache({\n                forClipping: true\n            });\n            this.drawClipPathOnCache(ctx, clipPath);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            ctx.scale(1 / this.zoomX, 1 / this.zoomY);\n            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n        },\n        /**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.isNotVisible()) {\n                return false;\n            }\n            if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {\n                // in this case the context is already cleared.\n                return true;\n            } else {\n                if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n                    if (this._cacheCanvas && this._cacheContext && !skipCanvas) {\n                        var width = this.cacheWidth / this.zoomX;\n                        var height = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-width / 2, -height / 2, width, height);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            if (!this.backgroundColor) {\n                return;\n            }\n            var dim = this._getNonTransformedDimensions();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\n            // if there is background color no other shadows\n            // should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setOpacity: function(ctx) {\n            if (this.group && !this.group._transformDone) {\n                ctx.globalAlpha = this.getObjectOpacity();\n            } else {\n                ctx.globalAlpha *= this.opacity;\n            }\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            var stroke = decl.stroke;\n            if (stroke) {\n                ctx.lineWidth = decl.strokeWidth;\n                ctx.lineCap = decl.strokeLineCap;\n                ctx.lineDashOffset = decl.strokeDashOffset;\n                ctx.lineJoin = decl.strokeLineJoin;\n                ctx.miterLimit = decl.strokeMiterLimit;\n                if (stroke.toLive) {\n                    if (stroke.gradientUnits === \"percentage\" || stroke.gradientTransform || stroke.patternTransform) {\n                        // need to transform gradient in a pattern.\n                        // this is a slow process. If you are hitting this codepath, and the object\n                        // is not using caching, you should consider switching it on.\n                        // we need a canvas as big as the current object caching canvas.\n                        this._applyPatternForTransformedGradient(ctx, stroke);\n                    } else {\n                        // is a simple gradient or pattern\n                        ctx.strokeStyle = stroke.toLive(ctx, this);\n                        this._applyPatternGradientTransform(ctx, stroke);\n                    }\n                } else {\n                    // is a color\n                    ctx.strokeStyle = decl.stroke;\n                }\n            }\n        },\n        _setFillStyles: function(ctx, decl) {\n            var fill = decl.fill;\n            if (fill) {\n                if (fill.toLive) {\n                    ctx.fillStyle = fill.toLive(ctx, this);\n                    this._applyPatternGradientTransform(ctx, decl.fill);\n                } else {\n                    ctx.fillStyle = fill;\n                }\n            }\n        },\n        _setClippingProperties: function(ctx) {\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = \"transparent\";\n            ctx.fillStyle = \"#000000\";\n        },\n        /**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */ _setLineDash: function(ctx, dashArray) {\n            if (!dashArray || dashArray.length === 0) {\n                return;\n            }\n            // Spec requires the concatenation of two copies the dash list when the number of elements is odd\n            if (1 & dashArray.length) {\n                dashArray.push.apply(dashArray, dashArray);\n            }\n            ctx.setLineDash(dashArray);\n        },\n        /**\n     * Renders controls and borders for the object\n     * the context here is not transformed\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */ _renderControls: function(ctx, styleOverride) {\n            var vpt = this.getViewportTransform(), matrix = this.calcTransformMatrix(), options, drawBorders, drawControls;\n            styleOverride = styleOverride || {};\n            drawBorders = typeof styleOverride.hasBorders !== \"undefined\" ? styleOverride.hasBorders : this.hasBorders;\n            drawControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls;\n            matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\n            options = fabric.util.qrDecompose(matrix);\n            ctx.save();\n            ctx.translate(options.translateX, options.translateY);\n            ctx.lineWidth = 1 * this.borderScaleFactor;\n            if (!this.group) {\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            }\n            if (this.flipX) {\n                options.angle -= 180;\n            }\n            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));\n            if (styleOverride.forActiveSelection || this.group) {\n                drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);\n            } else {\n                drawBorders && this.drawBorders(ctx, styleOverride);\n            }\n            drawControls && this.drawControls(ctx, styleOverride);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;\n            if (shadow.nonScaling) {\n                scaling = {\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            } else {\n                scaling = this.getObjectScaling();\n            }\n            if (canvas && canvas._isRetinaScaling()) {\n                multX *= fabric.devicePixelRatio;\n                multY *= fabric.devicePixelRatio;\n            }\n            ctx.shadowColor = shadow.color;\n            ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\n            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;\n            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _removeShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            ctx.shadowColor = \"\";\n            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */ _applyPatternGradientTransform: function(ctx, filler) {\n            if (!filler || !filler.toLive) {\n                return {\n                    offsetX: 0,\n                    offsetY: 0\n                };\n            }\n            var t = filler.gradientTransform || filler.patternTransform;\n            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;\n            if (filler.gradientUnits === \"percentage\") {\n                ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);\n            } else {\n                ctx.transform(1, 0, 0, 1, offsetX, offsetY);\n            }\n            if (t) {\n                ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n            }\n            return {\n                offsetX: offsetX,\n                offsetY: offsetY\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderPaintInOrder: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderStroke(ctx);\n                this._renderFill(ctx);\n            } else {\n                this._renderFill(ctx);\n                this._renderStroke(ctx);\n            }\n        },\n        /**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function() {},\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderFill: function(ctx) {\n            if (!this.fill) {\n                return;\n            }\n            ctx.save();\n            this._setFillStyles(ctx, this);\n            if (this.fillRule === \"evenodd\") {\n                ctx.fill(\"evenodd\");\n            } else {\n                ctx.fill();\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderStroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            if (this.strokeUniform && this.group) {\n                var scaling = this.getObjectScaling();\n                ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);\n            } else if (this.strokeUniform) {\n                ctx.scale(1 / this.scaleX, 1 / this.scaleY);\n            }\n            this._setLineDash(ctx, this.strokeDashArray);\n            this._setStrokeStyles(ctx, this);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */ _applyPatternForTransformedGradient: function(ctx, filler) {\n            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.scale(dims.zoomX / this.scaleX / retinaScaling, dims.zoomY / this.scaleY / retinaScaling);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fillStyle = filler.toLive(ctx);\n            pCtx.fill();\n            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);\n            ctx.scale(retinaScaling * this.scaleX / dims.zoomX, retinaScaling * this.scaleY / dims.zoomY);\n            ctx.strokeStyle = pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: this.left + this.width / 2,\n                y: this.top + this.height / 2\n            };\n        },\n        /**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */ _assignTransformMatrixProps: function() {\n            if (this.transformMatrix) {\n                var options = fabric.util.qrDecompose(this.transformMatrix);\n                this.flipX = false;\n                this.flipY = false;\n                this.set(\"scaleX\", options.scaleX);\n                this.set(\"scaleY\", options.scaleY);\n                this.angle = options.angle;\n                this.skewX = options.skewX;\n                this.skewY = 0;\n            }\n        },\n        /**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */ _removeTransformMatrix: function(preserveAspectRatioOptions) {\n            var center = this._findCenterFromElement();\n            if (this.transformMatrix) {\n                this._assignTransformMatrixProps();\n                center = fabric.util.transformPoint(center, this.transformMatrix);\n            }\n            this.transformMatrix = null;\n            if (preserveAspectRatioOptions) {\n                this.scaleX *= preserveAspectRatioOptions.scaleX;\n                this.scaleY *= preserveAspectRatioOptions.scaleY;\n                this.cropX = preserveAspectRatioOptions.cropX;\n                this.cropY = preserveAspectRatioOptions.cropY;\n                center.x += preserveAspectRatioOptions.offsetLeft;\n                center.y += preserveAspectRatioOptions.offsetTop;\n                this.width = preserveAspectRatioOptions.width;\n                this.height = preserveAspectRatioOptions.height;\n            }\n            this.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */ clone: function(callback, propertiesToInclude) {\n            var objectForm = this.toObject(propertiesToInclude);\n            if (this.constructor.fromObject) {\n                this.constructor.fromObject(objectForm, callback);\n            } else {\n                fabric.Object._fromObject(\"Object\", objectForm, callback);\n            }\n        },\n        /**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */ cloneAsImage: function(callback, options) {\n            var canvasEl = this.toCanvasElement(options);\n            if (callback) {\n                callback(new fabric.Image(canvasEl));\n            }\n            return this;\n        },\n        /**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */ toCanvasElement: function(options) {\n            options || (options = {});\n            var utils = fabric.util, origParams = utils.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);\n            delete this.group;\n            if (options.withoutTransform) {\n                utils.resetObjectTransform(this);\n            }\n            if (options.withoutShadow) {\n                this.shadow = null;\n            }\n            var el = fabric.util.createCanvasElement(), // skip canvas zoom and calculate with setCoords now.\n            boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = {\n                x: 0,\n                y: 0\n            }, shadowBlur, width, height;\n            if (shadow) {\n                shadowBlur = shadow.blur;\n                if (shadow.nonScaling) {\n                    scaling = {\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                } else {\n                    scaling = this.getObjectScaling();\n                }\n                // consider non scaling shadow.\n                shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);\n                shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);\n            }\n            width = boundingRect.width + shadowOffset.x;\n            height = boundingRect.height + shadowOffset.y;\n            // if the current width/height is not an integer\n            // we need to make it so.\n            el.width = Math.ceil(width);\n            el.height = Math.ceil(height);\n            var canvas = new fabric.StaticCanvas(el, {\n                enableRetinaScaling: false,\n                renderOnAddRemove: false,\n                skipOffscreen: false\n            });\n            if (options.format === \"jpeg\") {\n                canvas.backgroundColor = \"#fff\";\n            }\n            this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), \"center\", \"center\");\n            var originalCanvas = this.canvas;\n            canvas.add(this);\n            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);\n            this.shadow = originalShadow;\n            this.set(\"canvas\", originalCanvas);\n            if (originalGroup) {\n                this.group = originalGroup;\n            }\n            this.set(origParams).setCoords();\n            // canvas.dispose will call image.dispose that will nullify the elements\n            // since this canvas is a simple element for the process, we remove references\n            // to objects in this way in order to avoid object trashing.\n            canvas._objects = [];\n            canvas.dispose();\n            canvas = null;\n            return canvasEl;\n        },\n        /**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */ toDataURL: function(options) {\n            options || (options = {});\n            return fabric.util.toDataURL(this.toCanvasElement(options), options.format || \"png\", options.quality || 1);\n        },\n        /**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */ isType: function(type) {\n            return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */ complexity: function() {\n            return 1;\n        },\n        /**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */ toJSON: function(propertiesToInclude) {\n            // delegate, not alias\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ rotate: function(angle) {\n            var shouldCenterOrigin = (this.originX !== \"center\" || this.originY !== \"center\") && this.centeredRotation;\n            if (shouldCenterOrigin) {\n                this._setOriginToCenter();\n            }\n            this.set(\"angle\", angle);\n            if (shouldCenterOrigin) {\n                this._resetOrigin();\n            }\n            return this;\n        },\n        /**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerH: function() {\n            this.canvas && this.canvas.centerObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterH: function() {\n            this.canvas && this.canvas.viewportCenterObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerV: function() {\n            this.canvas && this.canvas.centerObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterV: function() {\n            this.canvas && this.canvas.viewportCenterObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ center: function() {\n            this.canvas && this.canvas.centerObject(this);\n            return this;\n        },\n        /**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenter: function() {\n            this.canvas && this.canvas.viewportCenterObject(this);\n            return this;\n        },\n        /**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */ getLocalPointer: function(e, pointer) {\n            pointer = pointer || this.canvas.getPointer(e);\n            var pClicked = new fabric.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();\n            if (this.angle) {\n                pClicked = fabric.util.rotatePoint(pClicked, objectLeftTop, degreesToRadians(-this.angle));\n            }\n            return {\n                x: pClicked.x - objectLeftTop.x,\n                y: pClicked.y - objectLeftTop.y\n            };\n        },\n        /**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */ _setupCompositeOperation: function(ctx) {\n            if (this.globalCompositeOperation) {\n                ctx.globalCompositeOperation = this.globalCompositeOperation;\n            }\n        },\n        /**\n     * cancel instance's running animations\n     * override if necessary to dispose artifacts such as `clipPath`\n     */ dispose: function() {\n            if (fabric.runningAnimations) {\n                fabric.runningAnimations.cancelByTarget(this);\n            }\n        }\n    });\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);\n    extend(fabric.Object.prototype, fabric.Observable);\n    /**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */ fabric.Object.NUM_FRACTION_DIGITS = 2;\n    /**\n   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type string[]\n   */ fabric.Object.ENLIVEN_PROPS = [\n        \"clipPath\"\n    ];\n    fabric.Object._fromObject = function(className, object, callback, extraParam) {\n        var klass = fabric[className];\n        object = clone(object, true);\n        fabric.util.enlivenPatterns([\n            object.fill,\n            object.stroke\n        ], function(patterns) {\n            if (typeof patterns[0] !== \"undefined\") {\n                object.fill = patterns[0];\n            }\n            if (typeof patterns[1] !== \"undefined\") {\n                object.stroke = patterns[1];\n            }\n            fabric.util.enlivenObjectEnlivables(object, object, function() {\n                var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);\n                callback && callback(instance);\n            });\n        });\n    };\n    /**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */ fabric.Object.__uid = 0;\n})( true ? exports : 0);\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {\n        left: -0.5,\n        center: 0,\n        right: 0.5\n    }, originYOffset = {\n        top: -0.5,\n        center: 0,\n        bottom: 0.5\n    };\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\n            var x = point.x, y = point.y, offsetX, offsetY, dim;\n            if (typeof fromOriginX === \"string\") {\n                fromOriginX = originXOffset[fromOriginX];\n            } else {\n                fromOriginX -= 0.5;\n            }\n            if (typeof toOriginX === \"string\") {\n                toOriginX = originXOffset[toOriginX];\n            } else {\n                toOriginX -= 0.5;\n            }\n            offsetX = toOriginX - fromOriginX;\n            if (typeof fromOriginY === \"string\") {\n                fromOriginY = originYOffset[fromOriginY];\n            } else {\n                fromOriginY -= 0.5;\n            }\n            if (typeof toOriginY === \"string\") {\n                toOriginY = originYOffset[toOriginY];\n            } else {\n                toOriginY -= 0.5;\n            }\n            offsetY = toOriginY - fromOriginY;\n            if (offsetX || offsetY) {\n                dim = this._getTransformedDimensions();\n                x = point.x + offsetX * dim.x;\n                y = point.y + offsetY * dim.y;\n            }\n            return new fabric.Point(x, y);\n        },\n        /**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToCenterPoint: function(point, originX, originY) {\n            var p = this.translateToGivenOrigin(point, originX, originY, \"center\", \"center\");\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToOriginPoint: function(center, originX, originY) {\n            var p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */ getCenterPoint: function() {\n            var leftTop = new fabric.Point(this.left, this.top);\n            return this.translateToCenterPoint(leftTop, this.originX, this.originY);\n        },\n        /**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n        //   return this.translateToOriginPoint(center, this.originX, this.originY);\n        // },\n        /**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ getPointByOrigin: function(originX, originY) {\n            var center = this.getCenterPoint();\n            return this.translateToOriginPoint(center, originX, originY);\n        },\n        /**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ toLocalPoint: function(point, originX, originY) {\n            var center = this.getCenterPoint(), p, p2;\n            if (typeof originX !== \"undefined\" && typeof originY !== \"undefined\") {\n                p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            } else {\n                p = new fabric.Point(this.left, this.top);\n            }\n            p2 = new fabric.Point(point.x, point.y);\n            if (this.angle) {\n                p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\n            }\n            return p2.subtractEquals(p);\n        },\n        /**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n        // },\n        /**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */ setPositionByOrigin: function(pos, originX, originY) {\n            var center = this.translateToCenterPoint(pos, originX, originY), position = this.translateToOriginPoint(center, this.originX, this.originY);\n            this.set(\"left\", position.x);\n            this.set(\"top\", position.y);\n        },\n        /**\n     * @param {String} to One of 'left', 'center', 'right'\n     */ adjustPosition: function(to) {\n            var angle = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle) * hypotFull, yFull = fabric.util.sin(angle) * hypotFull, offsetFrom, offsetTo;\n            //TODO: this function does not consider mixed situation like top, center.\n            if (typeof this.originX === \"string\") {\n                offsetFrom = originXOffset[this.originX];\n            } else {\n                offsetFrom = this.originX - 0.5;\n            }\n            if (typeof to === \"string\") {\n                offsetTo = originXOffset[to];\n            } else {\n                offsetTo = to - 0.5;\n            }\n            this.left += xFull * (offsetTo - offsetFrom);\n            this.top += yFull * (offsetTo - offsetFrom);\n            this.setCoords();\n            this.originX = to;\n        },\n        /**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */ _setOriginToCenter: function() {\n            this._originalOriginX = this.originX;\n            this._originalOriginY = this.originY;\n            var center = this.getCenterPoint();\n            this.originX = \"center\";\n            this.originY = \"center\";\n            this.left = center.x;\n            this.top = center.y;\n        },\n        /**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */ _resetOrigin: function() {\n            var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n            this.originX = this._originalOriginX;\n            this.originY = this._originalOriginY;\n            this.left = originPoint.x;\n            this.top = originPoint.y;\n            this._originalOriginX = null;\n            this._originalOriginY = null;\n        },\n        /**\n     * @private\n     */ _getLeftTopCoords: function() {\n            return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n    });\n})();\n(function() {\n    function arrayFromCoords(coords) {\n        return [\n            new fabric.Point(coords.tl.x, coords.tl.y),\n            new fabric.Point(coords.tr.x, coords.tr.y),\n            new fabric.Point(coords.br.x, coords.br.y),\n            new fabric.Point(coords.bl.x, coords.bl.y)\n        ];\n    }\n    var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;\n    util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */ oCoords: null,\n        /**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */ aCoords: null,\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords.\n     * @memberOf fabric.Object.prototype\n     */ lineCoords: null,\n        /**\n     * storage for object transform matrix\n     */ ownMatrixCache: null,\n        /**\n     * storage for object full transform matrix\n     */ matrixCache: null,\n        /**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */ controls: {},\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */ _getCoords: function(absolute, calculate) {\n            if (calculate) {\n                return absolute ? this.calcACoords() : this.calcLineCoords();\n            }\n            if (!this.aCoords || !this.lineCoords) {\n                this.setCoords(true);\n            }\n            return absolute ? this.aCoords : this.lineCoords;\n        },\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */ getCoords: function(absolute, calculate) {\n            return arrayFromCoords(this._getCoords(absolute, calculate));\n        },\n        /**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */ intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate), intersection = fabric.Intersection.intersectPolygonRectangle(coords, pointTL, pointBR);\n            return intersection.status === \"Intersection\";\n        },\n        /**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */ intersectsWithObject: function(other, absolute, calculate) {\n            var intersection = fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute, calculate), other.getCoords(absolute, calculate));\n            return intersection.status === \"Intersection\" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);\n        },\n        /**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */ isContainedWithinObject: function(other, absolute, calculate) {\n            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);\n            for(; i < 4; i++){\n                if (!other.containsPoint(points[i], lines)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */ isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {\n            var boundingRect = this.getBoundingRect(absolute, calculate);\n            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;\n        },\n        /**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */ containsPoint: function(point, lines, absolute, calculate) {\n            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);\n            // if xPoints is odd then point is inside the object\n            return xPoints !== 0 && xPoints % 2 === 1;\n        },\n        /**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */ isOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            var points = this.getCoords(true, calculate);\n            // if some point is on screen, the object is on screen.\n            if (points.some(function(point) {\n                return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;\n            })) {\n                return true;\n            }\n            // no points on screen, check intersection with absolute coordinates\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */ _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {\n            // worst case scenario the object is so big that contains the screen\n            var centerPoint = {\n                x: (pointTL.x + pointBR.x) / 2,\n                y: (pointTL.y + pointBR.y) / 2\n            };\n            if (this.containsPoint(centerPoint, null, true, calculate)) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */ isPartiallyOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {\n                return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);\n            });\n            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */ _getImageLines: function(oCoords) {\n            var lines = {\n                topline: {\n                    o: oCoords.tl,\n                    d: oCoords.tr\n                },\n                rightline: {\n                    o: oCoords.tr,\n                    d: oCoords.br\n                },\n                bottomline: {\n                    o: oCoords.br,\n                    d: oCoords.bl\n                },\n                leftline: {\n                    o: oCoords.bl,\n                    d: oCoords.tl\n                }\n            };\n            // // debugging\n            // if (this.canvas.contextTop) {\n            //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n            // }\n            return lines;\n        },\n        /**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n        _findCrossPoints: function(point, lines) {\n            var b1, b2, a1, a2, xi, xcount = 0, iLine;\n            for(var lineKey in lines){\n                iLine = lines[lineKey];\n                // optimisation 1: line below point. no cross\n                if (iLine.o.y < point.y && iLine.d.y < point.y) {\n                    continue;\n                }\n                // optimisation 2: line above point. no cross\n                if (iLine.o.y >= point.y && iLine.d.y >= point.y) {\n                    continue;\n                }\n                // optimisation 3: vertical line case\n                if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {\n                    xi = iLine.o.x;\n                // yi = point.y;\n                } else {\n                    b1 = 0;\n                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\n                    a1 = point.y - b1 * point.x;\n                    a2 = iLine.o.y - b2 * iLine.o.x;\n                    xi = -(a1 - a2) / (b1 - b2);\n                // yi = a1 + b1 * xi;\n                }\n                // dont count xi < point.x cases\n                if (xi >= point.x) {\n                    xcount += 1;\n                }\n                // optimisation 4: specific for square images\n                if (xcount === 2) {\n                    break;\n                }\n            }\n            return xcount;\n        },\n        /**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */ getBoundingRect: function(absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate);\n            return util.makeBoundingBoxFromPoints(coords);\n        },\n        /**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */ getScaledWidth: function() {\n            return this._getTransformedDimensions().x;\n        },\n        /**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */ getScaledHeight: function() {\n            return this._getTransformedDimensions().y;\n        },\n        /**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */ _constrainScale: function(value) {\n            if (Math.abs(value) < this.minScaleLimit) {\n                if (value < 0) {\n                    return -this.minScaleLimit;\n                } else {\n                    return this.minScaleLimit;\n                }\n            } else if (value === 0) {\n                return 0.0001;\n            }\n            return value;\n        },\n        /**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scale: function(value) {\n            this._set(\"scaleX\", value);\n            this._set(\"scaleY\", value);\n            return this.setCoords();\n        },\n        /**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToWidth: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();\n            return this.scale(value / this.width / boundingRectFactor);\n        },\n        /**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToHeight: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();\n            return this.scale(value / this.height / boundingRectFactor);\n        },\n        calcLineCoords: function() {\n            var vpt = this.getViewportTransform(), padding = this.padding, angle = degreesToRadians(this.angle), cos = util.cos(angle), sin = util.sin(angle), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();\n            var lineCoords = {\n                tl: transformPoint(aCoords.tl, vpt),\n                tr: transformPoint(aCoords.tr, vpt),\n                bl: transformPoint(aCoords.bl, vpt),\n                br: transformPoint(aCoords.br, vpt)\n            };\n            if (padding) {\n                lineCoords.tl.x -= cosPMinusSinP;\n                lineCoords.tl.y -= cosPSinP;\n                lineCoords.tr.x += cosPSinP;\n                lineCoords.tr.y -= cosPMinusSinP;\n                lineCoords.bl.x -= cosPSinP;\n                lineCoords.bl.y += cosPMinusSinP;\n                lineCoords.br.x += cosPMinusSinP;\n                lineCoords.br.y += cosPSinP;\n            }\n            return lineCoords;\n        },\n        calcOCoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [\n                1 / vpt[0],\n                0,\n                0,\n                1 / vpt[3],\n                0,\n                0\n            ]), dim = this._calculateCurrentDimensions(), coords = {};\n            this.forEachControl(function(control, key, fabricObject) {\n                coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);\n            });\n            // debug code\n            // var canvas = this.canvas;\n            // setTimeout(function() {\n            //   canvas.contextTop.clearRect(0, 0, 700, 700);\n            //   canvas.contextTop.fillStyle = 'green';\n            //   Object.keys(coords).forEach(function(key) {\n            //     var control = coords[key];\n            //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n            //   });\n            // }, 50);\n            return coords;\n        },\n        calcACoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h = dim.y / 2;\n            return {\n                // corners\n                tl: transformPoint({\n                    x: -w,\n                    y: -h\n                }, finalMatrix),\n                tr: transformPoint({\n                    x: w,\n                    y: -h\n                }, finalMatrix),\n                bl: transformPoint({\n                    x: -w,\n                    y: h\n                }, finalMatrix),\n                br: transformPoint({\n                    x: w,\n                    y: h\n                }, finalMatrix)\n            };\n        },\n        /**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n     *\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setCoords: function(skipCorners) {\n            this.aCoords = this.calcACoords();\n            // in case we are in a group, for how the inner group target check works,\n            // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\n            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();\n            if (skipCorners) {\n                return this;\n            }\n            // set coordinates of the draggable boxes in the corners used to scale/rotate the image\n            this.oCoords = this.calcOCoords();\n            this._setCornerCoords && this._setCornerCoords();\n            return this;\n        },\n        /**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */ _calcRotateMatrix: function() {\n            return util.calcRotateMatrix(this);\n        },\n        /**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */ _calcTranslateMatrix: function() {\n            var center = this.getCenterPoint();\n            return [\n                1,\n                0,\n                0,\n                1,\n                center.x,\n                center.y\n            ];\n        },\n        transformMatrixKey: function(skipGroup) {\n            var sep = \"_\", prefix = \"\";\n            if (!skipGroup && this.group) {\n                prefix = this.group.transformMatrixKey(skipGroup) + sep;\n            }\n            ;\n            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */ calcTransformMatrix: function(skipGroup) {\n            var matrix = this.calcOwnMatrix();\n            if (skipGroup || !this.group) {\n                return matrix;\n            }\n            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            if (this.group) {\n                matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);\n            }\n            cache.key = key;\n            cache.value = matrix;\n            return matrix;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */ calcOwnMatrix: function() {\n            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            var tMatrix = this._calcTranslateMatrix(), options = {\n                angle: this.angle,\n                translateX: tMatrix[4],\n                translateY: tMatrix[5],\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: this.skewX,\n                skewY: this.skewY,\n                flipX: this.flipX,\n                flipY: this.flipY\n            };\n            cache.key = key;\n            cache.value = util.composeMatrix(options);\n            return cache.value;\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getNonTransformedDimensions: function() {\n            var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h = this.height + strokeWidth;\n            return {\n                x: w,\n                y: h\n            };\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getTransformedDimensions: function(skewX, skewY) {\n            if (typeof skewX === \"undefined\") {\n                skewX = this.skewX;\n            }\n            if (typeof skewY === \"undefined\") {\n                skewY = this.skewY;\n            }\n            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;\n            if (this.strokeUniform) {\n                dimX = this.width;\n                dimY = this.height;\n            } else {\n                dimensions = this._getNonTransformedDimensions();\n                dimX = dimensions.x;\n                dimY = dimensions.y;\n            }\n            if (noSkew) {\n                return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);\n            }\n            var bbox = util.sizeAfterTransform(dimX, dimY, {\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: skewX,\n                skewY: skewY\n            });\n            return this._finalizeDimensions(bbox.x, bbox.y);\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */ _finalizeDimensions: function(width, height) {\n            return this.strokeUniform ? {\n                x: width + this.strokeWidth,\n                y: height + this.strokeWidth\n            } : {\n                x: width,\n                y: height\n            };\n        },\n        /*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */ _calculateCurrentDimensions: function() {\n            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);\n            return p.scalarAdd(2 * this.padding);\n        }\n    });\n})();\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendToBack: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.sendToBack(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringToFront: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.bringToFront(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendBackwards: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.sendBackwards(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringForward: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.bringForward(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ moveTo: function(index) {\n        if (this.group && this.group.type !== \"activeSelection\") {\n            fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\n        } else if (this.canvas) {\n            this.canvas.moveTo(this, index);\n        }\n        return this;\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    function getSvgColorString(prop, value) {\n        if (!value) {\n            return prop + \": none; \";\n        } else if (value.toLive) {\n            return prop + \": url(#SVGID_\" + value.id + \"); \";\n        } else {\n            var color = new fabric.Color(value), str = prop + \": \" + color.toRgb() + \"; \", opacity = color.getAlpha();\n            if (opacity !== 1) {\n                //change the color in rgb + opacity\n                str += prop + \"-opacity: \" + opacity.toString() + \"; \";\n            }\n            return str;\n        }\n    }\n    var toFixed = fabric.util.toFixed;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var fillRule = this.fillRule ? this.fillRule : \"nonzero\", strokeWidth = this.strokeWidth ? this.strokeWidth : \"0\", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : \"0\", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : \"butt\", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", opacity = typeof this.opacity !== \"undefined\" ? this.opacity : \"1\", visibility = this.visible ? \"\" : \" visibility: hidden;\", filter = skipShadow ? \"\" : this.getSvgFilter(), fill = getSvgColorString(\"fill\", this.fill), stroke = getSvgColorString(\"stroke\", this.stroke);\n            return [\n                stroke,\n                \"stroke-width: \",\n                strokeWidth,\n                \"; \",\n                \"stroke-dasharray: \",\n                strokeDashArray,\n                \"; \",\n                \"stroke-linecap: \",\n                strokeLineCap,\n                \"; \",\n                \"stroke-dashoffset: \",\n                strokeDashOffset,\n                \"; \",\n                \"stroke-linejoin: \",\n                strokeLineJoin,\n                \"; \",\n                \"stroke-miterlimit: \",\n                strokeMiterLimit,\n                \"; \",\n                fill,\n                \"fill-rule: \",\n                fillRule,\n                \"; \",\n                \"opacity: \",\n                opacity,\n                \";\",\n                filter,\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */ getSvgSpanStyles: function(style, useWhiteSpace) {\n            var term = \"; \";\n            var fontFamily = style.fontFamily ? \"font-family: \" + (style.fontFamily.indexOf(\"'\") === -1 && style.fontFamily.indexOf('\"') === -1 ? \"'\" + style.fontFamily + \"'\" : style.fontFamily) + term : \"\";\n            var strokeWidth = style.strokeWidth ? \"stroke-width: \" + style.strokeWidth + term : \"\", fontFamily = fontFamily, fontSize = style.fontSize ? \"font-size: \" + style.fontSize + \"px\" + term : \"\", fontStyle = style.fontStyle ? \"font-style: \" + style.fontStyle + term : \"\", fontWeight = style.fontWeight ? \"font-weight: \" + style.fontWeight + term : \"\", fill = style.fill ? getSvgColorString(\"fill\", style.fill) : \"\", stroke = style.stroke ? getSvgColorString(\"stroke\", style.stroke) : \"\", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? \"baseline-shift: \" + -style.deltaY + \"; \" : \"\";\n            if (textDecoration) {\n                textDecoration = \"text-decoration: \" + textDecoration + term;\n            }\n            return [\n                stroke,\n                strokeWidth,\n                fontFamily,\n                fontSize,\n                fontStyle,\n                fontWeight,\n                textDecoration,\n                fill,\n                deltaY,\n                useWhiteSpace ? \"white-space: pre; \" : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */ getSvgTextDecoration: function(style) {\n            return [\n                \"overline\",\n                \"underline\",\n                \"line-through\"\n            ].filter(function(decoration) {\n                return style[decoration.replace(\"-\", \"\")];\n            }).join(\" \");\n        },\n        /**\n     * Returns filter for svg shadow\n     * @return {String}\n     */ getSvgFilter: function() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n        },\n        /**\n     * Returns id attribute for svg output\n     * @return {String}\n     */ getSvgCommons: function() {\n            return [\n                this.id ? 'id=\"' + this.id + '\" ' : \"\",\n                this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */ getSvgTransform: function(full, additionalTransform) {\n            var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform=\"' + fabric.util.matrixToSVG(transform);\n            return svgTransform + (additionalTransform || \"\") + '\" ';\n        },\n        _setSVGBg: function(textBgRects) {\n            if (this.backgroundColor) {\n                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n                textBgRects.push(\"\t\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', toFixed(-this.width / 2, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(-this.height / 2, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(this.width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(this.height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n            }\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * @private\n     */ _createBaseClipPathSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var reviver = options.reviver, additionalTransform = options.additionalTransform || \"\", commonPieces = [\n                this.getSvgTransform(true, additionalTransform),\n                this.getSvgCommons()\n            ].join(\"\"), // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\");\n            objectMarkup[index] = commonPieces;\n            return reviver ? reviver(objectMarkup.join(\"\")) : objectMarkup.join(\"\");\n        },\n        /**\n     * @private\n     */ _createBaseSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ', shadowInfo = options.withShadow ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\"), additionalTransform = options.additionalTransform;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                clipPathMarkup = '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + clipPath.toClipPathSVG(reviver) + \"</clipPath>\\n\";\n            }\n            if (absoluteClipPath) {\n                markup.push(\"<g \", shadowInfo, this.getSvgCommons(), \" >\\n\");\n            }\n            markup.push(\"<g \", this.getSvgTransform(false), !absoluteClipPath ? shadowInfo + this.getSvgCommons() : \"\", \" >\\n\");\n            commonPieces = [\n                styleInfo,\n                vectorEffect,\n                noStyle ? \"\" : this.addPaintOrder(),\n                \" \",\n                additionalTransform ? 'transform=\"' + additionalTransform + '\" ' : \"\"\n            ].join(\"\");\n            objectMarkup[index] = commonPieces;\n            if (fill && fill.toLive) {\n                markup.push(fill.toSVG(this));\n            }\n            if (stroke && stroke.toLive) {\n                markup.push(stroke.toSVG(this));\n            }\n            if (shadow) {\n                markup.push(shadow.toSVG(this));\n            }\n            if (clipPath) {\n                markup.push(clipPathMarkup);\n            }\n            markup.push(objectMarkup.join(\"\"));\n            markup.push(\"</g>\\n\");\n            absoluteClipPath && markup.push(\"</g>\\n\");\n            return reviver ? reviver(markup.join(\"\")) : markup.join(\"\");\n        },\n        addPaintOrder: function() {\n            return this.paintFirst !== \"fill\" ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function() {\n    var extend = fabric.util.object.extend, originalSet = \"stateProperties\";\n    /*\n    Depends on `stateProperties`\n  */ function saveProps(origin, destination, props) {\n        var tmpObj = {}, deep = true;\n        props.forEach(function(prop) {\n            tmpObj[prop] = origin[prop];\n        });\n        extend(origin[destination], tmpObj, deep);\n    }\n    function _isEqual(origValue, currentValue, firstPass) {\n        if (origValue === currentValue) {\n            // if the objects are identical, return\n            return true;\n        } else if (Array.isArray(origValue)) {\n            if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {\n                return false;\n            }\n            for(var i = 0, len = origValue.length; i < len; i++){\n                if (!_isEqual(origValue[i], currentValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (origValue && typeof origValue === \"object\") {\n            var keys = Object.keys(origValue), key;\n            if (!currentValue || typeof currentValue !== \"object\" || !firstPass && keys.length !== Object.keys(currentValue).length) {\n                return false;\n            }\n            for(var i = 0, len = keys.length; i < len; i++){\n                key = keys[i];\n                // since clipPath is in the statefull cache list and the clipPath objects\n                // would be iterated as an object, this would lead to possible infinite recursion\n                // we do not want to compare those.\n                if (key === \"canvas\" || key === \"group\") {\n                    continue;\n                }\n                if (!_isEqual(origValue[key], currentValue[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */ hasStateChanged: function(propertySet) {\n            propertySet = propertySet || originalSet;\n            var dashedPropertySet = \"_\" + propertySet;\n            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {\n                return true;\n            }\n            return !_isEqual(this[dashedPropertySet], this, true);\n        },\n        /**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ saveState: function(options) {\n            var propertySet = options && options.propertySet || originalSet, destination = \"_\" + propertySet;\n            if (!this[destination]) {\n                return this.setupState(options);\n            }\n            saveProps(this, destination, this[propertySet]);\n            if (options && options.stateProperties) {\n                saveProps(this, destination, options.stateProperties);\n            }\n            return this;\n        },\n        /**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ setupState: function(options) {\n            options = options || {};\n            var propertySet = options.propertySet || originalSet;\n            options.propertySet = propertySet;\n            this[\"_\" + propertySet] = {};\n            this.saveState(options);\n            return this;\n        }\n    });\n})();\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */ _findTargetCorner: function(pointer, forTouch) {\n            // objects in group, anykind, are not self modificable,\n            // must not return an hovered corner.\n            if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) {\n                return false;\n            }\n            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys = Object.keys(this.oCoords), j = keys.length - 1, i;\n            this.__corner = 0;\n            // cycle in reverse order so we pick first the one on top\n            for(; j >= 0; j--){\n                i = keys[j];\n                if (!this.isControlVisible(i)) {\n                    continue;\n                }\n                lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);\n                // // debugging\n                //\n                // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n                xPoints = this._findCrossPoints({\n                    x: ex,\n                    y: ey\n                }, lines);\n                if (xPoints !== 0 && xPoints % 2 === 1) {\n                    this.__corner = i;\n                    return i;\n                }\n            }\n            return false;\n        },\n        /**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */ forEachControl: function(fn) {\n            for(var i in this.controls){\n                fn(this.controls[i], i, this);\n            }\n            ;\n        },\n        /**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */ _setCornerCoords: function() {\n            var coords = this.oCoords;\n            for(var control in coords){\n                var controlObject = this.controls[control];\n                coords[control].corner = controlObject.calcCornerCoords(this.angle, this.cornerSize, coords[control].x, coords[control].y, false);\n                coords[control].touchCorner = controlObject.calcCornerCoords(this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);\n            }\n        },\n        /**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawSelectionBackground: function(ctx) {\n            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {\n                return this;\n            }\n            ctx.save();\n            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;\n            ctx.translate(center.x, center.y);\n            ctx.scale(1 / vpt[0], 1 / vpt[3]);\n            ctx.rotate(degreesToRadians(this.angle));\n            ctx.fillStyle = this.selectionBackgroundColor;\n            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBorders: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;\n            ctx.save();\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            if (hasControls) {\n                ctx.beginPath();\n                this.forEachControl(function(control, key, fabricObject) {\n                    // in this moment, the ctx is centered on the object.\n                    // width and height of the above function are the size of the bbox.\n                    if (control.withConnection && control.getVisibility(fabricObject, key)) {\n                        // reset movement for each control\n                        shouldStroke = true;\n                        ctx.moveTo(control.x * width, control.y * height);\n                        ctx.lineTo(control.x * width + control.offsetX, control.y * height + control.offsetY);\n                    }\n                });\n                if (shouldStroke) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBordersInGroup: function(ctx, options, styleOverride) {\n            styleOverride = styleOverride || {};\n            var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;\n            ctx.save();\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawControls: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            ctx.save();\n            var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;\n            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);\n            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;\n            if (!this.transparentCorners) {\n                ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;\n            }\n            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);\n            this.setCoords();\n            if (this.group) {\n                // fabricJS does not really support drawing controls inside groups,\n                // this piece of code here helps having at least the control in places.\n                // If an application needs to show some objects as selected because of some UI state\n                // can still call Object._renderControls() on any object they desire, independently of groups.\n                // using no padding, circular controls and hiding the rotating cursor is higly suggested,\n                matrix = this.group.calcTransformMatrix();\n            }\n            this.forEachControl(function(control, key, fabricObject) {\n                p = fabricObject.oCoords[key];\n                if (control.getVisibility(fabricObject, key)) {\n                    if (matrix) {\n                        p = fabric.util.transformPoint(p, matrix);\n                    }\n                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);\n                }\n            });\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */ isControlVisible: function(controlKey) {\n            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);\n        },\n        /**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlVisible: function(controlKey, visible) {\n            if (!this._controlsVisibility) {\n                this._controlsVisibility = {};\n            }\n            this._controlsVisibility[controlKey] = visible;\n            return this;\n        },\n        /**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlsVisibility: function(options) {\n            options || (options = {});\n            for(var p in options){\n                this.setControlVisible(p, options[p]);\n            }\n            return this;\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onDeselect: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onSelect: function() {\n        // implemented by sub-classes, as needed.\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */ FX_DURATION: 500,\n    /**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectH: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.left,\n            endValue: this.getCenterPoint().x,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"left\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectV: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.top,\n            endValue: this.getCenterPoint().y,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"top\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxRemove: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"opacity\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                _this.remove(object);\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)\n   *\n   * As object  multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string  one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */ animate: function() {\n        if (arguments[0] && typeof arguments[0] === \"object\") {\n            var propsToAnimate = [], prop, skipCallbacks, out = [];\n            for(prop in arguments[0]){\n                propsToAnimate.push(prop);\n            }\n            for(var i = 0, len = propsToAnimate.length; i < len; i++){\n                prop = propsToAnimate[i];\n                skipCallbacks = i !== len - 1;\n                out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));\n            }\n            return out;\n        } else {\n            return this._animate.apply(this, arguments);\n        }\n    },\n    /**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */ _animate: function(property, to, options, skipCallbacks) {\n        var _this = this, propPair;\n        to = to.toString();\n        if (!options) {\n            options = {};\n        } else {\n            options = fabric.util.object.clone(options);\n        }\n        if (~property.indexOf(\".\")) {\n            propPair = property.split(\".\");\n        }\n        var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;\n        var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);\n        if (!(\"from\" in options)) {\n            options.from = currentValue;\n        }\n        if (!propIsColor) {\n            if (~to.indexOf(\"=\")) {\n                to = currentValue + parseFloat(to.replace(\"=\", \"\"));\n            } else {\n                to = parseFloat(to);\n            }\n        }\n        var _options = {\n            target: this,\n            startValue: options.from,\n            endValue: to,\n            byValue: options.by,\n            easing: options.easing,\n            duration: options.duration,\n            abort: options.abort && function(value, valueProgress, timeProgress) {\n                return options.abort.call(_this, value, valueProgress, timeProgress);\n            },\n            onChange: function(value, valueProgress, timeProgress) {\n                if (propPair) {\n                    _this[propPair[0]][propPair[1]] = value;\n                } else {\n                    _this.set(property, value);\n                }\n                if (skipCallbacks) {\n                    return;\n                }\n                options.onChange && options.onChange(value, valueProgress, timeProgress);\n            },\n            onComplete: function(value, valueProgress, timeProgress) {\n                if (skipCallbacks) {\n                    return;\n                }\n                _this.setCoords();\n                options.onComplete && options.onComplete(value, valueProgress, timeProgress);\n            }\n        };\n        if (propIsColor) {\n            return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);\n        } else {\n            return fabric.util.animate(_options);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, coordProps = {\n        x1: 1,\n        x2: 1,\n        y1: 1,\n        y2: 1\n    };\n    if (fabric.Line) {\n        fabric.warn(\"fabric.Line is already defined\");\n        return;\n    }\n    /**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */ fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"line\",\n        /**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */ x1: 0,\n        /**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */ y1: 0,\n        /**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */ x2: 0,\n        /**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */ y2: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n        /**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */ initialize: function(points, options) {\n            if (!points) {\n                points = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            this.callSuper(\"initialize\", options);\n            this.set(\"x1\", points[0]);\n            this.set(\"y1\", points[1]);\n            this.set(\"x2\", points[2]);\n            this.set(\"y2\", points[3]);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            this.width = Math.abs(this.x2 - this.x1);\n            this.height = Math.abs(this.y2 - this.y1);\n            this.left = \"left\" in options ? options.left : this._getLeftToOriginX();\n            this.top = \"top\" in options ? options.top : this._getTopToOriginY();\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (typeof coordProps[key] !== \"undefined\") {\n                this._setWidthHeight();\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */ _getLeftToOriginX: makeEdgeToOriginGetter({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n        }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n        }),\n        /**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */ _getTopToOriginY: makeEdgeToOriginGetter({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n        }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n        }),\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            var p = this.calcLinePoints();\n            ctx.moveTo(p.x1, p.y1);\n            ctx.lineTo(p.x2, p.y2);\n            ctx.lineWidth = this.strokeWidth;\n            // TODO: test this\n            // make sure setting \"fill\" changes color of a line\n            // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\n            var origStrokeStyle = ctx.strokeStyle;\n            ctx.strokeStyle = this.stroke || ctx.fillStyle;\n            this.stroke && this._renderStroke(ctx);\n            ctx.strokeStyle = origStrokeStyle;\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: (this.x1 + this.x2) / 2,\n                y: (this.y1 + this.y2) / 2\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), this.calcLinePoints());\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     */ _getNonTransformedDimensions: function() {\n            var dim = this.callSuper(\"_getNonTransformedDimensions\");\n            if (this.strokeLineCap === \"butt\") {\n                if (this.width === 0) {\n                    dim.y -= this.strokeWidth;\n                }\n                if (this.height === 0) {\n                    dim.x -= this.strokeWidth;\n                }\n            }\n            return dim;\n        },\n        /**\n     * Recalculates line points given width and height\n     * @private\n     */ calcLinePoints: function() {\n            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;\n            return {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var p = this.calcLinePoints();\n            return [\n                \"<line \",\n                \"COMMON_PARTS\",\n                'x1=\"',\n                p.x1,\n                '\" y1=\"',\n                p.y1,\n                '\" x2=\"',\n                p.x2,\n                '\" y2=\"',\n                p.y2,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */ fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \"));\n    /**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */ fabric.Line.fromElement = function(element, callback, options) {\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES), points = [\n            parsedAttributes.x1 || 0,\n            parsedAttributes.y1 || 0,\n            parsedAttributes.x2 || 0,\n            parsedAttributes.y2 || 0\n        ];\n        callback(new fabric.Line(points, extend(parsedAttributes, options)));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Line.fromObject = function(object, callback) {\n        function _callback(instance) {\n            delete instance.points;\n            callback && callback(instance);\n        }\n        ;\n        var options = clone(object, true);\n        options.points = [\n            object.x1,\n            object.y1,\n            object.x2,\n            object.y2\n        ];\n        fabric.Object._fromObject(\"Line\", options, _callback, \"points\");\n    };\n    /**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */ function makeEdgeToOriginGetter(propertyNames, originValues) {\n        var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;\n        return function() {\n            switch(this.get(origin)){\n                case nearest:\n                    return Math.min(this.get(axis1), this.get(axis2));\n                case center:\n                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);\n                case farthest:\n                    return Math.max(this.get(axis1), this.get(axis2));\n            }\n        };\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians;\n    if (fabric.Circle) {\n        fabric.warn(\"fabric.Circle is already defined.\");\n        return;\n    }\n    /**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */ fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"circle\",\n        /**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */ radius: 0,\n        /**\n     * degrees of start of the circle.\n     * probably will change to degrees in next major version\n     * @type Number 0 - 359\n     * @default 0\n     */ startAngle: 0,\n        /**\n     * End angle of the circle\n     * probably will change to degrees in next major version\n     * @type Number 1 - 360\n     * @default 360\n     */ endAngle: 360,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (key === \"radius\") {\n                this.setRadius(value);\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"radius\",\n                \"startAngle\",\n                \"endAngle\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString, x = 0, y = 0, angle = (this.endAngle - this.startAngle) % 360;\n            if (angle === 0) {\n                svgString = [\n                    \"<circle \",\n                    \"COMMON_PARTS\",\n                    'cx=\"' + x + '\" cy=\"' + y + '\" ',\n                    'r=\"',\n                    this.radius,\n                    '\" />\\n'\n                ];\n            } else {\n                var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric.util.cos(start) * radius, startY = fabric.util.sin(start) * radius, endX = fabric.util.cos(end) * radius, endY = fabric.util.sin(end) * radius, largeFlag = angle > 180 ? \"1\" : \"0\";\n                svgString = [\n                    '<path d=\"M ' + startX + \" \" + startY,\n                    \" A \" + radius + \" \" + radius,\n                    \" 0 \",\n                    +largeFlag + \" 1\",\n                    \" \" + endX + \" \" + endY,\n                    '\" ',\n                    \"COMMON_PARTS\",\n                    \" />\\n\"\n                ];\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, degreesToRadians(this.startAngle), degreesToRadians(this.endAngle), false);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusX: function() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusY: function() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n        },\n        /**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */ setRadius: function(value) {\n            this.radius = value;\n            return this.set(\"width\", value * 2).set(\"height\", value * 2);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */ fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \"));\n    /**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */ fabric.Circle.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\n        if (!isValidRadius(parsedAttributes)) {\n            throw new Error(\"value of `r` attribute is required and can not be negative\");\n        }\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;\n        callback(new fabric.Circle(parsedAttributes));\n    };\n    /**\n   * @private\n   */ function isValidRadius(attributes) {\n        return \"radius\" in attributes && attributes.radius >= 0;\n    }\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Circle.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Circle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Triangle) {\n        fabric.warn(\"fabric.Triangle is already defined\");\n        return;\n    }\n    /**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */ fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"triangle\",\n        /**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ width: 100,\n        /**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ height: 100,\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-widthBy2, heightBy2);\n            ctx.lineTo(0, -heightBy2);\n            ctx.lineTo(widthBy2, heightBy2);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [\n                -widthBy2 + \" \" + heightBy2,\n                \"0 \" + -heightBy2,\n                widthBy2 + \" \" + heightBy2\n            ].join(\",\");\n            return [\n                \"<polygon \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points,\n                '\" />'\n            ];\n        }\n    });\n    /**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Triangle.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Triangle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), piBy2 = Math.PI * 2;\n    if (fabric.Ellipse) {\n        fabric.warn(\"fabric.Ellipse is already defined.\");\n        return;\n    }\n    /**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */ fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"ellipse\",\n        /**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this.set(\"rx\", options && options.rx || 0);\n            this.set(\"ry\", options && options.ry || 0);\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            switch(key){\n                case \"rx\":\n                    this.rx = value;\n                    this.set(\"width\", value * 2);\n                    break;\n                case \"ry\":\n                    this.ry = value;\n                    this.set(\"height\", value * 2);\n                    break;\n            }\n            return this;\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRx: function() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRy: function() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            return [\n                \"<ellipse \",\n                \"COMMON_PARTS\",\n                'cx=\"0\" cy=\"0\" ',\n                'rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.save();\n            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\n            ctx.arc(0, 0, this.rx, 0, piBy2, false);\n            ctx.restore();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */ fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \"));\n    /**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */ fabric.Ellipse.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;\n        callback(new fabric.Ellipse(parsedAttributes));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Ellipse.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Ellipse\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend;\n    if (fabric.Rect) {\n        fabric.warn(\"fabric.Rect is already defined\");\n        return;\n    }\n    /**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */ fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\n        /**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"rect\",\n        /**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this._initRxRy();\n        },\n        /**\n     * Initializes rx/ry attributes\n     * @private\n     */ _initRxRy: function() {\n            if (this.rx && !this.ry) {\n                this.ry = this.rx;\n            } else if (this.ry && !this.rx) {\n                this.rx = this.ry;\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            // 1x1 case (used in spray brush) optimization was removed because\n            // with caching and higher zoom level this makes more damage than help\n            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */ k = 1 - 0.5522847498;\n            ctx.beginPath();\n            ctx.moveTo(x + rx, y);\n            ctx.lineTo(x + w - rx, y);\n            isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\n            ctx.lineTo(x + w, y + h - ry);\n            isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\n            ctx.lineTo(x + rx, y + h);\n            isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\n            ctx.lineTo(x, y + ry);\n            isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var x = -this.width / 2, y = -this.height / 2;\n            return [\n                \"<rect \",\n                \"COMMON_PARTS\",\n                'x=\"',\n                x,\n                '\" y=\"',\n                y,\n                '\" rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" width=\"',\n                this.width,\n                '\" height=\"',\n                this.height,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */ fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \"));\n    /**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Rect.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\n        parsedAttributes.left = parsedAttributes.left || 0;\n        parsedAttributes.top = parsedAttributes.top || 0;\n        parsedAttributes.height = parsedAttributes.height || 0;\n        parsedAttributes.width = parsedAttributes.width || 0;\n        var rect = new fabric.Rect(extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\n        callback(rect);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */ fabric.Rect.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Rect\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, min = fabric.util.array.min, max = fabric.util.array.max, toFixed = fabric.util.toFixed, projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polyline) {\n        fabric.warn(\"fabric.Polyline is already defined\");\n        return;\n    }\n    /**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */ fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polyline\",\n        /**\n     * Points array\n     * @type Array\n     * @default\n     */ points: null,\n        /**\n     * WARNING: Feature in progress\n     * Calculate the exact bounding box taking in account strokeWidth on acute angles\n     * this will be turned to true by default on fabric 6.0\n     * maybe will be left in as an optimization since calculations may be slow\n     * @deprecated\n     * @type Boolean\n     * @default false\n     */ exactBoundingBox: false,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"points\"),\n        /**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */ initialize: function(points, options) {\n            options = options || {};\n            this.points = points || [];\n            this.callSuper(\"initialize\", options);\n            this._setPositionDimensions(options);\n        },\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this, true);\n        },\n        _setPositionDimensions: function(options) {\n            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;\n            this.width = calcDim.width - correctSize;\n            this.height = calcDim.height - correctSize;\n            if (!options.fromSVG) {\n                correctLeftTop = this.translateToGivenOrigin({\n                    // this looks bad, but is one way to keep it optional for now.\n                    x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,\n                    y: calcDim.top - this.strokeWidth / 2 + correctSize / 2\n                }, \"left\", \"top\", this.originX, this.originY);\n            }\n            if (typeof options.left === \"undefined\") {\n                this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;\n            }\n            if (typeof options.top === \"undefined\") {\n                this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;\n            }\n            this.pathOffset = {\n                x: calcDim.left + this.width / 2 + correctSize / 2,\n                y: calcDim.top + this.height / 2 + correctSize / 2\n            };\n        },\n        /**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */ _calcDimensions: function() {\n            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, \"x\") || 0, minY = min(points, \"y\") || 0, maxX = max(points, \"x\") || 0, maxY = max(points, \"y\") || 0, width = maxX - minX, height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                points: this.points.concat()\n            });\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            for(var i = 0, len = this.points.length; i < len; i++){\n                points.push(toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), \",\", toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), \" \");\n            }\n            return [\n                \"<\" + this.type + \" \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points.join(\"\"),\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ commonRender: function(ctx) {\n            var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;\n            if (!len || isNaN(this.points[len - 1].y)) {\n                // do not draw if no points or odd points\n                // NaN comes from parseFloat of a empty string in parser\n                return false;\n            }\n            ctx.beginPath();\n            ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n            for(var i = 0; i < len; i++){\n                point = this.points[i];\n                ctx.lineTo(point.x - x, point.y - y);\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.get(\"points\").length;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */ fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polyline.fromElementGenerator = function(_class) {\n        return function(element, callback, options) {\n            if (!element) {\n                return callback(null);\n            }\n            options || (options = {});\n            var points = fabric.parsePointsAttribute(element.getAttribute(\"points\")), parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);\n            parsedAttributes.fromSVG = true;\n            callback(new fabric[_class](points, extend(parsedAttributes, options)));\n        };\n    };\n    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator(\"Polyline\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Polyline.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Polyline\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polygon) {\n        fabric.warn(\"fabric.Polygon is already defined\");\n        return;\n    }\n    /**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */ fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polygon\",\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */ fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator(\"Polygon\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */ fabric.Polygon.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Polygon\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max, extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed;\n    if (fabric.Path) {\n        fabric.warn(\"fabric.Path is already defined\");\n        return;\n    }\n    /**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */ fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"path\",\n        /**\n     * Array of path points\n     * @type Array\n     * @default\n     */ path: null,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n        stateProperties: fabric.Object.prototype.stateProperties.concat(\"path\"),\n        /**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */ initialize: function(path, options) {\n            options = clone(options || {});\n            delete options.path;\n            this.callSuper(\"initialize\", options);\n            this._setPath(path || [], options);\n        },\n        /**\n    * @private\n    * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n    * @param {Object} [options] Options object\n    */ _setPath: function(path, options) {\n            this.path = fabric.util.makePathSimpler(Array.isArray(path) ? path : fabric.util.parsePath(path));\n            fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _renderPathCommands: function(ctx) {\n            var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;\n            ctx.beginPath();\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        ctx.lineTo(x + l, y + t);\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        ctx.moveTo(x + l, y + t);\n                        break;\n                    case \"C\":\n                        x = current[5];\n                        y = current[6];\n                        controlX = current[3];\n                        controlY = current[4];\n                        ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(current[1] + l, current[2] + t, current[3] + l, current[4] + t);\n                        x = current[3];\n                        y = current[4];\n                        controlX = current[1];\n                        controlY = current[2];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        ctx.closePath();\n                        break;\n                }\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _render: function(ctx) {\n            this._renderPathCommands(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                path: this.path.map(function(item) {\n                    return item.slice();\n                })\n            });\n        },\n        /**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var o = this.toObject([\n                \"sourcePath\"\n            ].concat(propertiesToInclude));\n            if (o.sourcePath) {\n                delete o.path;\n            }\n            return o;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var path = fabric.util.joinPath(this.path);\n            return [\n                \"<path \",\n                \"COMMON_PARTS\",\n                'd=\"',\n                path,\n                '\" stroke-linecap=\"round\" ',\n                \"/>\\n\"\n            ];\n        },\n        _getOffsetTransform: function() {\n            var digits = fabric.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + toFixed(-this.pathOffset.x, digits) + \", \" + toFixed(-this.pathOffset.y, digits) + \")\";\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.path.length;\n        },\n        /**\n     * @private\n     */ _calcDimensions: function() {\n            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        bounds = [];\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        bounds = [];\n                        break;\n                    case \"C\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[3], current[4], current[5], current[6]);\n                        x = current[5];\n                        y = current[6];\n                        break;\n                    case \"Q\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[1], current[2], current[3], current[4]);\n                        x = current[3];\n                        y = current[4];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        break;\n                }\n                bounds.forEach(function(point) {\n                    aX.push(point.x);\n                    aY.push(point.y);\n                });\n                aX.push(x);\n                aY.push(y);\n            }\n            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: deltaX,\n                height: deltaY\n            };\n        }\n    });\n    /**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Path.fromObject = function(object, callback) {\n        if (typeof object.sourcePath === \"string\") {\n            var pathUrl = object.sourcePath;\n            fabric.loadSVGFromURL(pathUrl, function(elements) {\n                var path = elements[0];\n                path.setOptions(object);\n                if (object.clipPath) {\n                    fabric.util.enlivenObjects([\n                        object.clipPath\n                    ], function(elivenedObjects) {\n                        path.clipPath = elivenedObjects[0];\n                        callback && callback(path);\n                    });\n                } else {\n                    callback && callback(path);\n                }\n            });\n        } else {\n            fabric.Object._fromObject(\"Path\", object, callback, \"path\");\n        }\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */ fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat([\n        \"d\"\n    ]);\n    /**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */ fabric.Path.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\n        parsedAttributes.fromSVG = true;\n        callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max;\n    if (fabric.Group) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */ fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"group\",\n        /**\n     * Width of stroke\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */ subTargetCheck: false,\n        /**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */ cacheProperties: [],\n        /**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */ useSetOnGroup: false,\n        /**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */ initialize: function(objects, options, isAlreadyGrouped) {\n            options = options || {};\n            this._objects = [];\n            // if objects enclosed in a group have been grouped already,\n            // we cannot change properties of objects.\n            // Thus we need to set options to group without objects,\n            isAlreadyGrouped && this.callSuper(\"initialize\", options);\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (!isAlreadyGrouped) {\n                var center = options && options.centerPoint;\n                // we want to set origins before calculating the bounding box.\n                // so that the topleft can be set with that in mind.\n                // if specific top and left are passed, are overwritten later\n                // with the callSuper('initialize', options)\n                if (options.originX !== undefined) {\n                    this.originX = options.originX;\n                }\n                if (options.originY !== undefined) {\n                    this.originY = options.originY;\n                }\n                // if coming from svg i do not want to calc bounds.\n                // i assume width and height are passed along options\n                center || this._calcBounds();\n                this._updateObjectsCoords(center);\n                delete options.centerPoint;\n                this.callSuper(\"initialize\", options);\n            } else {\n                this._updateObjectsACoords();\n            }\n            this.setCoords();\n        },\n        /**\n     * @private\n     */ _updateObjectsACoords: function() {\n            var skipControls = true;\n            for(var i = this._objects.length; i--;){\n                this._objects[i].setCoords(skipControls);\n            }\n        },\n        /**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */ _updateObjectsCoords: function(center) {\n            var center = center || this.getCenterPoint();\n            for(var i = this._objects.length; i--;){\n                this._updateObjectCoords(this._objects[i], center);\n            }\n        },\n        /**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */ _updateObjectCoords: function(object, center) {\n            var objectLeft = object.left, objectTop = object.top, skipControls = true;\n            object.set({\n                left: objectLeft - center.x,\n                top: objectTop - center.y\n            });\n            object.group = this;\n            object.setCoords(skipControls);\n        },\n        /**\n     * Returns string represenation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ addWithUpdate: function(object) {\n            var nested = !!this.group;\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            if (object) {\n                if (nested) {\n                    // if this group is inside another group, we need to pre transform the object\n                    fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());\n                }\n                this._objects.push(object);\n                object.group = this;\n                object._set(\"canvas\", this.canvas);\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.dirty = true;\n            if (nested) {\n                this.group.addWithUpdate();\n            } else {\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ removeWithUpdate: function(object) {\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            this.remove(object);\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.setCoords();\n            this.dirty = true;\n            return this;\n        },\n        /**\n     * @private\n     */ _onObjectAdded: function(object) {\n            this.dirty = true;\n            object.group = this;\n            object._set(\"canvas\", this.canvas);\n        },\n        /**\n     * @private\n     */ _onObjectRemoved: function(object) {\n            this.dirty = true;\n            delete object.group;\n        },\n        /**\n     * @private\n     */ _set: function(key, value) {\n            var i = this._objects.length;\n            if (this.useSetOnGroup) {\n                while(i--){\n                    this._objects[i].setOnGroup(key, value);\n                }\n            }\n            if (key === \"canvas\") {\n                while(i--){\n                    this._objects[i]._set(key, value);\n                }\n            }\n            fabric.Object.prototype._set.call(this, key, value);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var _includeDefaultValues = this.includeDefaultValues;\n            var objsToObject = this._objects.filter(function(obj) {\n                return !obj.excludeFromExport;\n            }).map(function(obj) {\n                var originalDefaults = obj.includeDefaultValues;\n                obj.includeDefaultValues = _includeDefaultValues;\n                var _obj = obj.toObject(propertiesToInclude);\n                obj.includeDefaultValues = originalDefaults;\n                return _obj;\n            });\n            var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var objsToObject, sourcePath = this.sourcePath;\n            if (sourcePath) {\n                objsToObject = sourcePath;\n            } else {\n                var _includeDefaultValues = this.includeDefaultValues;\n                objsToObject = this._objects.map(function(obj) {\n                    var originalDefaults = obj.includeDefaultValues;\n                    obj.includeDefaultValues = _includeDefaultValues;\n                    var _obj = obj.toDatalessObject(propertiesToInclude);\n                    obj.includeDefaultValues = originalDefaults;\n                    return _obj;\n                });\n            }\n            var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */ render: function(ctx) {\n            this._transformDone = true;\n            this.callSuper(\"render\", ctx);\n            this._transformDone = false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            var ownCache = fabric.Object.prototype.shouldCache.call(this);\n            if (ownCache) {\n                for(var i = 0, len = this._objects.length; i < len; i++){\n                    if (this._objects[i].willDrawShadow()) {\n                        this.ownCaching = false;\n                        return false;\n                    }\n                }\n            }\n            return ownCache;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            if (fabric.Object.prototype.willDrawShadow.call(this)) {\n                return true;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].willDrawShadow()) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx) {\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i].render(ctx);\n            }\n            this._drawClipPath(ctx, this.clipPath);\n        },\n        /**\n     * Check if cache is dirty\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.callSuper(\"isCacheDirty\", skipCanvas)) {\n                return true;\n            }\n            if (!this.statefullCache) {\n                return false;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].isCacheDirty(true)) {\n                    if (this._cacheCanvas) {\n                        // if this group has not a cache canvas there is nothing to clean\n                        var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-x / 2, -y / 2, x, y);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ _restoreObjectsState: function() {\n            var groupMatrix = this.calcOwnMatrix();\n            this._objects.forEach(function(object) {\n                // instead of using _this = this;\n                fabric.util.addTransformToObject(object, groupMatrix);\n                delete object.group;\n                object.setCoords();\n            });\n            return this;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ destroy: function() {\n            // when group is destroyed objects needs to get a repaint to be eventually\n            // displayed on canvas.\n            this._objects.forEach(function(object) {\n                object.set(\"dirty\", true);\n            });\n            return this._restoreObjectsState();\n        },\n        dispose: function() {\n            this.callSuper(\"dispose\");\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n        },\n        /**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */ toActiveSelection: function() {\n            if (!this.canvas) {\n                return;\n            }\n            var objects = this._objects, canvas = this.canvas;\n            this._objects = [];\n            var options = this.toObject();\n            delete options.objects;\n            var activeSelection = new fabric.ActiveSelection([]);\n            activeSelection.set(options);\n            activeSelection.type = \"activeSelection\";\n            canvas.remove(this);\n            objects.forEach(function(object) {\n                object.group = activeSelection;\n                object.dirty = true;\n                canvas.add(object);\n            });\n            activeSelection.canvas = canvas;\n            activeSelection._objects = objects;\n            canvas._activeObject = activeSelection;\n            activeSelection.setCoords();\n            return activeSelection;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ ungroupOnCanvas: function() {\n            return this._restoreObjectsState();\n        },\n        /**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ setObjectsCoords: function() {\n            var skipControls = true;\n            this.forEachObject(function(object) {\n                object.setCoords(skipControls);\n            });\n            return this;\n        },\n        /**\n     * @private\n     */ _calcBounds: function(onlyWidthHeight) {\n            var aX = [], aY = [], o, prop, coords, props = [\n                \"tr\",\n                \"br\",\n                \"bl\",\n                \"tl\"\n            ], i = 0, iLen = this._objects.length, j, jLen = props.length;\n            for(; i < iLen; ++i){\n                o = this._objects[i];\n                coords = o.calcACoords();\n                for(j = 0; j < jLen; j++){\n                    prop = props[j];\n                    aX.push(coords[prop].x);\n                    aY.push(coords[prop].y);\n                }\n                o.aCoords = coords;\n            }\n            this._getBounds(aX, aY, onlyWidthHeight);\n        },\n        /**\n     * @private\n     */ _getBounds: function(aX, aY, onlyWidthHeight) {\n            var minXY = new fabric.Point(min(aX), min(aY)), maxXY = new fabric.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;\n            this.width = width;\n            this.height = height;\n            if (!onlyWidthHeight) {\n                // the bounding box always finds the topleft most corner.\n                // whatever is the group origin, we set up here the left/top position.\n                this.setPositionByOrigin({\n                    x: left,\n                    y: top\n                }, \"left\", \"top\");\n            }\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function(reviver) {\n            var svgString = [\n                \"<g \",\n                \"COMMON_PARTS\",\n                \" >\\n\"\n            ];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\t\", this._objects[i].toSVG(reviver));\n            }\n            svgString.push(\"</g>\\n\");\n            return svgString;\n        },\n        /**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */ getSvgStyles: function() {\n            var opacity = typeof this.opacity !== \"undefined\" && this.opacity !== 1 ? \"opacity: \" + this.opacity + \";\" : \"\", visibility = this.visible ? \"\" : \" visibility: hidden;\";\n            return [\n                opacity,\n                this.getSvgFilter(),\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var svgString = [];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\", this._objects[i].toClipPathSVG(reviver));\n            }\n            return this._createBaseClipPathSVGMarkup(svgString, {\n                reviver: reviver\n            });\n        }\n    });\n    /**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */ fabric.Group.fromObject = function(object, callback) {\n        var objects = object.objects, options = fabric.util.object.clone(object, true);\n        delete options.objects;\n        if (typeof objects === \"string\") {\n            // it has to be an url or something went wrong.\n            fabric.loadSVGFromURL(objects, function(elements) {\n                var group = fabric.util.groupSVGElements(elements, object, objects);\n                var clipPath = options.clipPath;\n                delete options.clipPath;\n                group.set(options);\n                if (clipPath) {\n                    fabric.util.enlivenObjects([\n                        clipPath\n                    ], function(elivenedObjects) {\n                        group.clipPath = elivenedObjects[0];\n                        callback && callback(group);\n                    });\n                } else {\n                    callback && callback(group);\n                }\n            });\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            fabric.util.enlivenObjectEnlivables(object, options, function() {\n                callback && callback(new fabric.Group(enlivenedObjects, options, true));\n            });\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.ActiveSelection) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */ fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"activeSelection\",\n        /**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(objects, options) {\n            options = options || {};\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (options.originX) {\n                this.originX = options.originX;\n            }\n            if (options.originY) {\n                this.originY = options.originY;\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            fabric.Object.prototype.initialize.call(this, options);\n            this.setCoords();\n        },\n        /**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */ toGroup: function() {\n            var objects = this._objects.concat();\n            this._objects = [];\n            var options = fabric.Object.prototype.toObject.call(this);\n            var newGroup = new fabric.Group([]);\n            delete options.type;\n            newGroup.set(options);\n            objects.forEach(function(object) {\n                object.canvas.remove(object);\n                object.group = newGroup;\n            });\n            newGroup._objects = objects;\n            if (!this.canvas) {\n                return newGroup;\n            }\n            var canvas = this.canvas;\n            canvas.add(newGroup);\n            canvas._activeObject = newGroup;\n            newGroup.setCoords();\n            return newGroup;\n        },\n        /**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */ onDeselect: function() {\n            this.destroy();\n            return false;\n        },\n        /**\n     * Returns string representation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return false;\n        },\n        /**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */ _renderControls: function(ctx, styleOverride, childrenOverride) {\n            ctx.save();\n            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            this.callSuper(\"_renderControls\", ctx, styleOverride);\n            childrenOverride = childrenOverride || {};\n            if (typeof childrenOverride.hasControls === \"undefined\") {\n                childrenOverride.hasControls = false;\n            }\n            childrenOverride.forActiveSelection = true;\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i]._renderControls(ctx, childrenOverride);\n            }\n            ctx.restore();\n        }\n    });\n    /**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */ fabric.ActiveSelection.fromObject = function(object, callback) {\n        fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\n            delete object.objects;\n            callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var extend = fabric.util.object.extend;\n    if (!global.fabric) {\n        global.fabric = {};\n    }\n    if (global.fabric.Image) {\n        fabric.warn(\"fabric.Image is already defined.\");\n        return;\n    }\n    /**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */ fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"image\",\n        /**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */ srcFromAttribute: false,\n        /**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleX: 1,\n        /**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleY: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingX: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingY: 1,\n        /**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */ minimumScaleTrigger: 0.5,\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */ cacheKey: \"\",\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropX: 0,\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropY: 0,\n        /**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */ imageSmoothing: true,\n        /**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */ initialize: function(element, options) {\n            options || (options = {});\n            this.filters = [];\n            this.cacheKey = \"texture\" + fabric.Object.__uid++;\n            this.callSuper(\"initialize\", options);\n            this._initElement(element, options);\n        },\n        /**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */ getElement: function() {\n            return this._element || {};\n        },\n        /**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setElement: function(element, options) {\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._element = element;\n            this._originalElement = element;\n            this._initConfig(options);\n            if (this.filters.length !== 0) {\n                this.applyFilters();\n            }\n            // resizeFilters work on the already filtered copy.\n            // we need to apply resizeFilters AFTER normal filters.\n            // applyResizeFilters is run more often than normal filters\n            // and is triggered by user interactions rather than dev code\n            if (this.resizeFilter) {\n                this.applyResizeFilters();\n            }\n            return this;\n        },\n        /**\n     * Delete a single texture if in webgl mode\n     */ removeTexture: function(key) {\n            var backend = fabric.filterBackend;\n            if (backend && backend.evictCachesForKey) {\n                backend.evictCachesForKey(key);\n            }\n        },\n        /**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */ dispose: function() {\n            this.callSuper(\"dispose\");\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._cacheContext = undefined;\n            [\n                \"_originalElement\",\n                \"_element\",\n                \"_filteredEl\",\n                \"_cacheCanvas\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n        },\n        /**\n     * Get the crossOrigin value (of the corresponding image element)\n     */ getCrossOrigin: function() {\n            return this._originalElement && (this._originalElement.crossOrigin || null);\n        },\n        /**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */ getOriginalSize: function() {\n            var element = this.getElement();\n            return {\n                width: element.naturalWidth || element.width,\n                height: element.naturalHeight || element.height\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _stroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            var w = this.width / 2, h = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-w, -h);\n            ctx.lineTo(w, -h);\n            ctx.lineTo(w, h);\n            ctx.lineTo(-w, h);\n            ctx.lineTo(-w, -h);\n            ctx.closePath();\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var filters = [];\n            this.filters.forEach(function(filterObj) {\n                if (filterObj) {\n                    filters.push(filterObj.toObject());\n                }\n            });\n            var object = extend(this.callSuper(\"toObject\", [\n                \"cropX\",\n                \"cropY\"\n            ].concat(propertiesToInclude)), {\n                src: this.getSrc(),\n                crossOrigin: this.getCrossOrigin(),\n                filters: filters\n            });\n            if (this.resizeFilter) {\n                object.resizeFilter = this.resizeFilter.toObject();\n            }\n            return object;\n        },\n        /**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */ hasCrop: function() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = \"\", imageRendering = \"\";\n            if (!element) {\n                return [];\n            }\n            if (this.hasCrop()) {\n                var clipPathId = fabric.Object.__uid++;\n                svgString.push('<clipPath id=\"imageCrop_' + clipPathId + '\">\\n', '\t<rect x=\"' + x + '\" y=\"' + y + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\");\n                clipPath = ' clip-path=\"url(#imageCrop_' + clipPathId + ')\" ';\n            }\n            if (!this.imageSmoothing) {\n                imageRendering = '\" image-rendering=\"optimizeSpeed';\n            }\n            imageMarkup.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(true), '\" x=\"', x - this.cropX, '\" y=\"', y - this.cropY, // we're essentially moving origin of transformation from top/left corner to the center of the shape\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n            // so that object's center aligns with container's left/top\n            '\" width=\"', element.width || element.naturalWidth, '\" height=\"', element.height || element.height, imageRendering, '\"', clipPath, \"></image>\\n\");\n            if (this.stroke || this.strokeDashArray) {\n                var origFill = this.fill;\n                this.fill = null;\n                strokeSvg = [\n                    \"\t<rect \",\n                    'x=\"',\n                    x,\n                    '\" y=\"',\n                    y,\n                    '\" width=\"',\n                    this.width,\n                    '\" height=\"',\n                    this.height,\n                    '\" style=\"',\n                    this.getSvgStyles(),\n                    '\"/>\\n'\n                ];\n                this.fill = origFill;\n            }\n            if (this.paintFirst !== \"fill\") {\n                svgString = svgString.concat(strokeSvg, imageMarkup);\n            } else {\n                svgString = svgString.concat(imageMarkup, strokeSvg);\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */ getSrc: function(filtered) {\n            var element = filtered ? this._element : this._originalElement;\n            if (element) {\n                if (element.toDataURL) {\n                    return element.toDataURL();\n                }\n                if (this.srcFromAttribute) {\n                    return element.getAttribute(\"src\");\n                } else {\n                    return element.src;\n                }\n            } else {\n                return this.src || \"\";\n            }\n        },\n        /**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setSrc: function(src, callback, options) {\n            fabric.util.loadImage(src, function(img, isError) {\n                this.setElement(img, options);\n                this._setWidthHeight();\n                callback && callback(this, isError);\n            }, this, options && options.crossOrigin);\n            return this;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */ toString: function() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n        },\n        applyResizeFilters: function() {\n            var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;\n            if (this.group) {\n                this.set(\"dirty\", true);\n            }\n            if (!filter || scaleX > minimumScale && scaleY > minimumScale) {\n                this._element = elementToFilter;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                this._lastScaleX = scaleX;\n                this._lastScaleY = scaleY;\n                return;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;\n            canvasEl.width = sourceWidth;\n            canvasEl.height = sourceHeight;\n            this._element = canvasEl;\n            this._lastScaleX = filter.scaleX = scaleX;\n            this._lastScaleY = filter.scaleY = scaleY;\n            fabric.filterBackend.applyFilters([\n                filter\n            ], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);\n            this._filterScalingX = canvasEl.width / this._originalElement.width;\n            this._filterScalingY = canvasEl.height / this._originalElement.height;\n        },\n        /**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */ applyFilters: function(filters) {\n            filters = filters || this.filters || [];\n            filters = filters.filter(function(filter) {\n                return filter && !filter.isNeutralState();\n            });\n            this.set(\"dirty\", true);\n            // needs to clear out or WEBGL will not resize correctly\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            if (filters.length === 0) {\n                this._element = this._originalElement;\n                this._filteredEl = null;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                return this;\n            }\n            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;\n            if (this._element === this._originalElement) {\n                // if the element is the same we need to create a new element\n                var canvasEl = fabric.util.createCanvasElement();\n                canvasEl.width = sourceWidth;\n                canvasEl.height = sourceHeight;\n                this._element = canvasEl;\n                this._filteredEl = canvasEl;\n            } else {\n                // clear the existing element to get new filter data\n                // also dereference the eventual resized _element\n                this._element = this._filteredEl;\n                this._filteredEl.getContext(\"2d\").clearRect(0, 0, sourceWidth, sourceHeight);\n                // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\n                this._lastScaleX = 1;\n                this._lastScaleY = 1;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            fabric.filterBackend.applyFilters(filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);\n            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {\n                this._filterScalingX = this._element.width / this._originalElement.width;\n                this._filterScalingY = this._element.height / this._originalElement.height;\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {\n                this.applyResizeFilters();\n            }\n            this._stroke(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return this.needsItsOwnCache();\n        },\n        _renderFill: function(ctx) {\n            var elementToDraw = this._element;\n            if (!elementToDraw) {\n                return;\n            }\n            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h = this.height, min = Math.min, max = Math.max, // crop values cannot be lesser than 0.\n            cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, // the width height cannot exceed element width/height, starting from the crop offset.\n            sW = min(w * scaleX, elWidth - sX), sH = min(h * scaleY, elHeight - sY), x = -w / 2, y = -h / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h, elHeight / scaleY - cropY);\n            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);\n        },\n        /**\n     * needed to check if image needs resize\n     * @private\n     */ _needsResize: function() {\n            var scale = this.getTotalObjectScaling();\n            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;\n        },\n        /**\n     * @private\n     */ _resetWidthHeight: function() {\n            this.set(this.getOriginalSize());\n        },\n        /**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */ _initElement: function(element, options) {\n            this.setElement(fabric.util.getById(element), options);\n            fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initConfig: function(options) {\n            options || (options = {});\n            this.setOptions(options);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */ _initFilters: function(filters, callback) {\n            if (filters && filters.length) {\n                fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\n                    callback && callback(enlivenedObjects);\n                }, \"fabric.Image.filters\");\n            } else {\n                callback && callback();\n            }\n        },\n        /**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            var el = this.getElement();\n            this.width = options.width || el.naturalWidth || el.width || 0;\n            this.height = options.height || el.naturalHeight || el.height || 0;\n        },\n        /**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */ parsePreserveAspectRatioAttribute: function() {\n            var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = {\n                width: pWidth,\n                height: pHeight\n            };\n            if (pAR && (pAR.alignX !== \"none\" || pAR.alignY !== \"none\")) {\n                if (pAR.meetOrSlice === \"meet\") {\n                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);\n                    offset = (pWidth - rWidth * scaleX) / 2;\n                    if (pAR.alignX === \"Min\") {\n                        offsetLeft = -offset;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        offsetLeft = offset;\n                    }\n                    offset = (pHeight - rHeight * scaleY) / 2;\n                    if (pAR.alignY === \"Min\") {\n                        offsetTop = -offset;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        offsetTop = offset;\n                    }\n                }\n                if (pAR.meetOrSlice === \"slice\") {\n                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);\n                    offset = rWidth - pWidth / scaleX;\n                    if (pAR.alignX === \"Mid\") {\n                        cropX = offset / 2;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        cropX = offset;\n                    }\n                    offset = rHeight - pHeight / scaleY;\n                    if (pAR.alignY === \"Mid\") {\n                        cropY = offset / 2;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        cropY = offset;\n                    }\n                    rWidth = pWidth / scaleX;\n                    rHeight = pHeight / scaleY;\n                }\n            } else {\n                scaleX = pWidth / rWidth;\n                scaleY = pHeight / rHeight;\n            }\n            return {\n                width: rWidth,\n                height: rHeight,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                offsetLeft: offsetLeft,\n                offsetTop: offsetTop,\n                cropX: cropX,\n                cropY: cropY\n            };\n        }\n    });\n    /**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */ fabric.Image.CSS_CANVAS = \"canvas-img\";\n    /**\n   * Alias for getSrc\n   * @static\n   */ fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\n    /**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */ fabric.Image.fromObject = function(_object, callback) {\n        var object = fabric.util.object.clone(_object);\n        fabric.util.loadImage(object.src, function(img, isError) {\n            if (isError) {\n                callback && callback(null, true);\n                return;\n            }\n            fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\n                object.filters = filters || [];\n                fabric.Image.prototype._initFilters.call(object, [\n                    object.resizeFilter\n                ], function(resizeFilters) {\n                    object.resizeFilter = resizeFilters[0];\n                    fabric.util.enlivenObjectEnlivables(object, object, function() {\n                        var image = new fabric.Image(img, object);\n                        callback(image, false);\n                    });\n                });\n            });\n        }, null, object.crossOrigin);\n    };\n    /**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */ fabric.Image.fromURL = function(url, callback, imgOptions) {\n        fabric.util.loadImage(url, function(img, isError) {\n            callback && callback(new fabric.Image(img, imgOptions), isError);\n        }, null, imgOptions && imgOptions.crossOrigin);\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */ fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin image-rendering\".split(\" \"));\n    /**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */ fabric.Image.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);\n        fabric.Image.fromURL(parsedAttributes[\"xlink:href\"], callback, extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * @private\n   * @return {Number} angle value\n   */ _getAngleValueForStraighten: function() {\n        var angle = this.angle % 360;\n        if (angle > 0) {\n            return Math.round((angle - 1) / 90) * 90;\n        }\n        return Math.round(angle / 90) * 90;\n    },\n    /**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ straighten: function() {\n        return this.rotate(this._getAngleValueForStraighten());\n    },\n    /**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   */ fxStraighten: function(callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                _this.rotate(value);\n                onChange();\n            },\n            onComplete: function() {\n                _this.setCoords();\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */ straightenObject: function(object) {\n        object.straighten();\n        this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   */ fxStraightenObject: function(object) {\n        return object.fxStraighten({\n            onChange: this.requestRenderAllBound\n        });\n    }\n});\n(function() {\n    \"use strict\";\n    /**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */ function testPrecision(gl, precision) {\n        var fragmentSource = \"precision \" + precision + \" float;\\nvoid main(){}\";\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */ fabric.isWebglSupported = function(tileSize) {\n        if (fabric.isLikelyNode) {\n            return false;\n        }\n        tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        var isSupported = false;\n        // eslint-disable-next-line\n        if (gl) {\n            fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            isSupported = fabric.maxTextureSize >= tileSize;\n            var precisions = [\n                \"highp\",\n                \"mediump\",\n                \"lowp\"\n            ];\n            for(var i = 0; i < 3; i++){\n                if (testPrecision(gl, precisions[i])) {\n                    fabric.webGlPrecision = precisions[i];\n                    break;\n                }\n                ;\n            }\n        }\n        this.isSupported = isSupported;\n        return isSupported;\n    };\n    fabric.WebglFilterBackend = WebglFilterBackend;\n    /**\n   * WebGL filter backend.\n   */ function WebglFilterBackend(options) {\n        if (options && options.tileSize) {\n            this.tileSize = options.tileSize;\n        }\n        this.setupGLContext(this.tileSize, this.tileSize);\n        this.captureGPUInfo();\n    }\n    ;\n    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {\n        tileSize: 2048,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */ setupGLContext: function(width, height) {\n            this.dispose();\n            this.createWebGLCanvas(width, height);\n            // eslint-disable-next-line\n            this.aPosition = new Float32Array([\n                0,\n                0,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1\n            ]);\n            this.chooseFastestCopyGLTo2DMethod(width, height);\n        },\n        /**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */ chooseFastestCopyGLTo2DMethod: function(width, height) {\n            var canMeasurePerf = typeof window.performance !== \"undefined\", canUseImageData;\n            try {\n                new ImageData(1, 1);\n                canUseImageData = true;\n            } catch (e) {\n                canUseImageData = false;\n            }\n            // eslint-disable-next-line no-undef\n            var canUseArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n            // eslint-disable-next-line no-undef\n            var canUseUint8Clamped = typeof Uint8ClampedArray !== \"undefined\";\n            if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {\n                return;\n            }\n            var targetCanvas = fabric.util.createCanvasElement();\n            // eslint-disable-next-line no-undef\n            var imageBuffer = new ArrayBuffer(width * height * 4);\n            if (fabric.forceGLPutImageData) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n                return;\n            }\n            var testContext = {\n                imageBuffer: imageBuffer,\n                destinationWidth: width,\n                destinationHeight: height,\n                targetCanvas: targetCanvas\n            };\n            var startTime, drawImageTime, putImageDataTime;\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            startTime = window.performance.now();\n            copyGLTo2DDrawImage.call(testContext, this.gl, testContext);\n            drawImageTime = window.performance.now() - startTime;\n            startTime = window.performance.now();\n            copyGLTo2DPutImageData.call(testContext, this.gl, testContext);\n            putImageDataTime = window.performance.now() - startTime;\n            if (drawImageTime > putImageDataTime) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n            } else {\n                this.copyGLTo2D = copyGLTo2DDrawImage;\n            }\n        },\n        /**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */ createWebGLCanvas: function(width, height) {\n            var canvas = fabric.util.createCanvasElement();\n            canvas.width = width;\n            canvas.height = height;\n            var glOptions = {\n                alpha: true,\n                premultipliedAlpha: false,\n                depth: false,\n                stencil: false,\n                antialias: false\n            }, gl = canvas.getContext(\"webgl\", glOptions);\n            if (!gl) {\n                gl = canvas.getContext(\"experimental-webgl\", glOptions);\n            }\n            if (!gl) {\n                return;\n            }\n            gl.clearColor(0, 0, 0, 0);\n            // this canvas can fire webglcontextlost and webglcontextrestored\n            this.canvas = canvas;\n            this.gl = gl;\n        },\n        /**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */ applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {\n            var gl = this.gl;\n            var cachedTexture;\n            if (cacheKey) {\n                cachedTexture = this.getCachedTexture(cacheKey, source);\n            }\n            var pipelineState = {\n                originalWidth: source.width || source.originalWidth,\n                originalHeight: source.height || source.originalHeight,\n                sourceWidth: width,\n                sourceHeight: height,\n                destinationWidth: width,\n                destinationHeight: height,\n                context: gl,\n                sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),\n                targetTexture: this.createTexture(gl, width, height),\n                originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),\n                passes: filters.length,\n                webgl: true,\n                aPosition: this.aPosition,\n                programCache: this.programCache,\n                pass: 0,\n                filterBackend: this,\n                targetCanvas: targetCanvas\n            };\n            var tempFbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);\n            filters.forEach(function(filter) {\n                filter && filter.applyTo(pipelineState);\n            });\n            resizeCanvasIfNeeded(pipelineState);\n            this.copyGLTo2D(gl, pipelineState);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.deleteTexture(pipelineState.sourceTexture);\n            gl.deleteTexture(pipelineState.targetTexture);\n            gl.deleteFramebuffer(tempFbo);\n            targetCanvas.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0);\n            return pipelineState;\n        },\n        /**\n     * Detach event listeners, remove references, and clean up caches.\n     */ dispose: function() {\n            if (this.canvas) {\n                this.canvas = null;\n                this.gl = null;\n            }\n            this.clearWebGLCaches();\n        },\n        /**\n     * Wipe out WebGL-related caches.\n     */ clearWebGLCaches: function() {\n            this.programCache = {};\n            this.textureCache = {};\n        },\n        /**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants\n     * @returns {WebGLTexture}\n     */ createTexture: function(gl, width, height, textureImageSource, filterType) {\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (textureImageSource) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            return texture;\n        },\n        /**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */ getCachedTexture: function(uniqueId, textureImageSource) {\n            if (this.textureCache[uniqueId]) {\n                return this.textureCache[uniqueId];\n            } else {\n                var texture = this.createTexture(this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);\n                this.textureCache[uniqueId] = texture;\n                return texture;\n            }\n        },\n        /**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */ evictCachesForKey: function(cacheKey) {\n            if (this.textureCache[cacheKey]) {\n                this.gl.deleteTexture(this.textureCache[cacheKey]);\n                delete this.textureCache[cacheKey];\n            }\n        },\n        copyGLTo2D: copyGLTo2DDrawImage,\n        /**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */ captureGPUInfo: function() {\n            if (this.gpuInfo) {\n                return this.gpuInfo;\n            }\n            var gl = this.gl, gpuInfo = {\n                renderer: \"\",\n                vendor: \"\"\n            };\n            if (!gl) {\n                return gpuInfo;\n            }\n            var ext = gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (ext) {\n                var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n                var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);\n                if (renderer) {\n                    gpuInfo.renderer = renderer.toLowerCase();\n                }\n                if (vendor) {\n                    gpuInfo.vendor = vendor.toLowerCase();\n                }\n            }\n            this.gpuInfo = gpuInfo;\n            return gpuInfo;\n        }\n    };\n})();\nfunction resizeCanvasIfNeeded(pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;\n    if (width !== dWidth || height !== dHeight) {\n        targetCanvas.width = dWidth;\n        targetCanvas.height = dHeight;\n    }\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DDrawImage(gl, pipelineState) {\n    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\");\n    ctx.translate(0, targetCanvas.height); // move it down again\n    ctx.scale(1, -1); // vertical flip\n    // where is my image on the big glcanvas?\n    var sourceY = glCanvas.height - targetCanvas.height;\n    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0, targetCanvas.width, targetCanvas.height);\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DPutImageData(gl, pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;\n    // eslint-disable-next-line no-undef\n    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);\n    // eslint-disable-next-line no-undef\n    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);\n    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);\n    var imgData = new ImageData(u8Clamped, dWidth, dHeight);\n    ctx.putImageData(imgData, 0, 0);\n}\n(function() {\n    \"use strict\";\n    var noop = function() {};\n    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;\n    /**\n   * Canvas 2D filter backend.\n   */ function Canvas2dFilterBackend() {}\n    ;\n    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {\n        evictCachesForKey: noop,\n        dispose: noop,\n        clearWebGLCaches: noop,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */ applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {\n            var ctx = targetCanvas.getContext(\"2d\");\n            ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n            var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var pipelineState = {\n                sourceWidth: sourceWidth,\n                sourceHeight: sourceHeight,\n                imageData: imageData,\n                originalEl: sourceElement,\n                originalImageData: originalImageData,\n                canvasEl: targetCanvas,\n                ctx: ctx,\n                filterBackend: this\n            };\n            filters.forEach(function(filter) {\n                filter.applyTo(pipelineState);\n            });\n            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {\n                targetCanvas.width = pipelineState.imageData.width;\n                targetCanvas.height = pipelineState.imageData.height;\n            }\n            ctx.putImageData(pipelineState.imageData, 0, 0);\n            return pipelineState;\n        }\n    };\n})();\n/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */ fabric.Image = fabric.Image || {};\nfabric.Image.filters = fabric.Image.filters || {};\n/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */ fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\n    /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */ type: \"BaseFilter\",\n    /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */ vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n    fragmentSource: \"precision highp float;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"}\",\n    /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */ initialize: function(options) {\n        if (options) {\n            this.setOptions(options);\n        }\n    },\n    /**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */ setOptions: function(options) {\n        for(var prop in options){\n            this[prop] = options[prop];\n        }\n    },\n    /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */ createProgram: function(gl, fragmentSource, vertexSource) {\n        fragmentSource = fragmentSource || this.fragmentSource;\n        vertexSource = vertexSource || this.vertexSource;\n        if (fabric.webGlPrecision !== \"highp\") {\n            fragmentSource = fragmentSource.replace(/precision highp float/g, \"precision \" + fabric.webGlPrecision + \" float\");\n        }\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexSource);\n        gl.compileShader(vertexShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Vertex shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(vertexShader));\n        }\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Fragment shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(fragmentShader));\n        }\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            'Shader link error for \"${this.type}\" ' + gl.getProgramInfoLog(program));\n        }\n        var attributeLocations = this.getAttributeLocations(gl, program);\n        var uniformLocations = this.getUniformLocations(gl, program) || {};\n        uniformLocations.uStepW = gl.getUniformLocation(program, \"uStepW\");\n        uniformLocations.uStepH = gl.getUniformLocation(program, \"uStepH\");\n        return {\n            program: program,\n            attributeLocations: attributeLocations,\n            uniformLocations: uniformLocations\n        };\n    },\n    /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */ getAttributeLocations: function(gl, program) {\n        return {\n            aPosition: gl.getAttribLocation(program, \"aPosition\")\n        };\n    },\n    /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */ getUniformLocations: function() {\n        // in case i do not need any special uniform i need to return an empty object\n        return {};\n    },\n    /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */ sendAttributeData: function(gl, attributeLocations, aPositionData) {\n        var attributeLocation = attributeLocations.aPosition;\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(attributeLocation);\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n    },\n    _setupFrameBuffer: function(options) {\n        var gl = options.context, width, height;\n        if (options.passes > 1) {\n            width = options.destinationWidth;\n            height = options.destinationHeight;\n            if (options.sourceWidth !== width || options.sourceHeight !== height) {\n                gl.deleteTexture(options.targetTexture);\n                options.targetTexture = options.filterBackend.createTexture(gl, width, height);\n            }\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, options.targetTexture, 0);\n        } else {\n            // draw last filter on canvas and not to framebuffer.\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.finish();\n        }\n    },\n    _swapTextures: function(options) {\n        options.passes--;\n        options.pass++;\n        var temp = options.targetTexture;\n        options.targetTexture = options.sourceTexture;\n        options.sourceTexture = temp;\n    },\n    /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/ isNeutralState: function() {\n        var main = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;\n        if (main) {\n            if (Array.isArray(_class[main])) {\n                for(var i = _class[main].length; i--;){\n                    if (this[main][i] !== _class[main][i]) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return _class[main] === this[main];\n            }\n        } else {\n            return false;\n        }\n    },\n    /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyTo: function(options) {\n        if (options.webgl) {\n            this._setupFrameBuffer(options);\n            this.applyToWebGL(options);\n            this._swapTextures(options);\n        } else {\n            this.applyTo2d(options);\n        }\n    },\n    /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ retrieveShader: function(options) {\n        if (!options.programCache.hasOwnProperty(this.type)) {\n            options.programCache[this.type] = this.createProgram(options.context);\n        }\n        return options.programCache[this.type];\n    },\n    /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyToWebGL: function(options) {\n        var gl = options.context;\n        var shader = this.retrieveShader(options);\n        if (options.pass === 0 && options.originalTexture) {\n            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n        } else {\n            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n        }\n        gl.useProgram(shader.program);\n        this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n        gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n        gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n        this.sendUniformData(gl, shader.uniformLocations);\n        gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    },\n    bindAdditionalTexture: function(gl, texture, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // reset active texture to 0 as usual\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    unbindAdditionalTexture: function(gl, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    getMainParameter: function() {\n        return this[this.mainParameter];\n    },\n    setMainParameter: function(value) {\n        this[this.mainParameter] = value;\n    },\n    /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */ sendUniformData: function() {\n    // Intentionally left blank.  Override me in subclasses.\n    },\n    /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */ createHelpLayer: function(options) {\n        if (!options.helpLayer) {\n            var helpLayer = document.createElement(\"canvas\");\n            helpLayer.width = options.sourceWidth;\n            helpLayer.height = options.sourceHeight;\n            options.helpLayer = helpLayer;\n        }\n    },\n    /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */ toObject: function() {\n        var object = {\n            type: this.type\n        }, mainP = this.mainParameter;\n        if (mainP) {\n            object[mainP] = this[mainP];\n        }\n        return object;\n    },\n    /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */ toJSON: function() {\n        // delegate, not alias\n        return this.toObject();\n    }\n});\nfabric.Image.filters.BaseFilter.fromObject = function(object, callback) {\n    var filter = new fabric.Image.filters[object.type](object);\n    callback && callback(filter);\n    return filter;\n};\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"ColorMatrix\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform mat4 uColorMatrix;\\n\" + \"uniform vec4 uConstants;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color *= uColorMatrix;\\n\" + \"color += uConstants;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */ matrix: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        mainParameter: \"matrix\",\n        /**\n     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario\n     * to save some calculation\n     * @type Boolean\n     * @default true\n     */ colorsOnly: true,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.matrix = this.matrix.slice(0);\n        },\n        /**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a, i, colorsOnly = this.colorsOnly;\n            for(i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (colorsOnly) {\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;\n                } else {\n                    a = data[i + 3];\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;\n                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColorMatrix: gl.getUniformLocation(program, \"uColorMatrix\"),\n                uConstants: gl.getUniformLocation(program, \"uConstants\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var m = this.matrix, matrix = [\n                m[0],\n                m[1],\n                m[2],\n                m[3],\n                m[5],\n                m[6],\n                m[7],\n                m[8],\n                m[10],\n                m[11],\n                m[12],\n                m[13],\n                m[15],\n                m[16],\n                m[17],\n                m[18]\n            ], constants = [\n                m[4],\n                m[9],\n                m[14],\n                m[19]\n            ];\n            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);\n            gl.uniform4fv(uniformLocations.uConstants, constants);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */ fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Brightness\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBrightness;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += uBrightness;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */ brightness: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"brightness\",\n        /**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */ applyTo2d: function(options) {\n            if (this.brightness === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);\n            for(i = 0; i < len; i += 4){\n                data[i] = data[i] + brightness;\n                data[i + 1] = data[i + 1] + brightness;\n                data[i + 2] = data[i + 2] + brightness;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBrightness: gl.getUniformLocation(program, \"uBrightness\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBrightness, this.brightness);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */ fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Convolute\",\n        /*\n     * Opaque value (true/false)\n     */ opaque: false,\n        /*\n     * matrix for the filter, max 9x9\n     */ matrix: [\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0\n        ],\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_3_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_5_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_5_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_7_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_7_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_9_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_9_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\"\n        },\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */ retrieveShader: function(options) {\n            var size = Math.sqrt(this.matrix.length);\n            var cacheKey = this.type + \"_\" + size + \"_\" + (this.opaque ? 1 : 0);\n            var shaderSource = this.fragmentSource[cacheKey];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, // go through the destination image pixels\n            alphaFac = this.opaque ? 1 : 0, r, g, b, a, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;\n            for(y = 0; y < sh; y++){\n                for(x = 0; x < sw; x++){\n                    dstOff = (y * sw + x) * 4;\n                    // calculate the weighed sum of the source image pixels that\n                    // fall under the convolution matrix\n                    r = 0;\n                    g = 0;\n                    b = 0;\n                    a = 0;\n                    for(cy = 0; cy < side; cy++){\n                        for(cx = 0; cx < side; cx++){\n                            scy = y + cy - halfSide;\n                            scx = x + cx - halfSide;\n                            // eslint-disable-next-line max-depth\n                            if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {\n                                continue;\n                            }\n                            srcOff = (scy * sw + scx) * 4;\n                            wt = weights[cy * side + cx];\n                            r += data[srcOff] * wt;\n                            g += data[srcOff + 1] * wt;\n                            b += data[srcOff + 2] * wt;\n                            // eslint-disable-next-line max-depth\n                            if (!alphaFac) {\n                                a += data[srcOff + 3] * wt;\n                            }\n                        }\n                    }\n                    dst[dstOff] = r;\n                    dst[dstOff + 1] = g;\n                    dst[dstOff + 2] = b;\n                    if (!alphaFac) {\n                        dst[dstOff + 3] = a;\n                    } else {\n                        dst[dstOff + 3] = data[dstOff + 3];\n                    }\n                }\n            }\n            options.imageData = output;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMatrix: gl.getUniformLocation(program, \"uMatrix\"),\n                uOpaque: gl.getUniformLocation(program, \"uOpaque\"),\n                uHalfSize: gl.getUniformLocation(program, \"uHalfSize\"),\n                uSize: gl.getUniformLocation(program, \"uSize\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                opaque: this.opaque,\n                matrix: this.matrix\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */ fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Grayscale\",\n        fragmentSource: {\n            average: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (color.r + color.b + color.g) / 3.0;\\n\" + \"gl_FragColor = vec4(average, average, average, color.a);\\n\" + \"}\",\n            lightness: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\",\n            luminosity: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\"\n        },\n        /**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */ mode: \"average\",\n        mainParameter: \"mode\",\n        /**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;\n            for(i = 0; i < len; i += 4){\n                if (mode === \"average\") {\n                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                } else if (mode === \"lightness\") {\n                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;\n                } else if (mode === \"luminosity\") {\n                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];\n                }\n                data[i] = value;\n                data[i + 1] = value;\n                data[i + 2] = value;\n            }\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var shaderSource = this.fragmentSource[this.mode];\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMode: gl.getUniformLocation(program, \"uMode\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            // default average mode.\n            var mode = 1;\n            gl.uniform1i(uniformLocations.uMode, mode);\n        },\n        /**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/ isNeutralState: function() {\n            return false;\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */ fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Invert\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uInvert;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"if (uInvert == 1) {\\n\" + \"gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n\" + \"} else {\\n\" + \"gl_FragColor = color;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */ invert: true,\n        mainParameter: \"invert\",\n        /**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length;\n            for(i = 0; i < len; i += 4){\n                data[i] = 255 - data[i];\n                data[i + 1] = 255 - data[i + 1];\n                data[i + 2] = 255 - data[i + 2];\n            }\n        },\n        /**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function() {\n            return !this.invert;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uInvert: gl.getUniformLocation(program, \"uInvert\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1i(uniformLocations.uInvert, this.invert);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */ fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Noise\",\n        /**\n     * Fragment source for the noise program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uStepH;\\n\" + \"uniform float uNoise;\\n\" + \"uniform float uSeed;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"float rand(vec2 co, float seed, float vScale) {\\n\" + \"return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"noise\",\n        /**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */ noise: 0,\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.noise === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;\n            for(i = 0, len = data.length; i < len; i += 4){\n                rand = (0.5 - Math.random()) * noise;\n                data[i] += rand;\n                data[i + 1] += rand;\n                data[i + 2] += rand;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uNoise: gl.getUniformLocation(program, \"uNoise\"),\n                uSeed: gl.getUniformLocation(program, \"uSeed\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);\n            gl.uniform1f(uniformLocations.uSeed, Math.random());\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                noise: this.noise\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */ fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Pixelate\",\n        blocksize: 4,\n        mainParameter: \"blocksize\",\n        /**\n     * Fragment source for the Pixelate program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBlocksize;\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"float blockW = uBlocksize * uStepW;\\n\" + \"float blockH = uBlocksize * uStepW;\\n\" + \"int posX = int(vTexCoord.x / blockW);\\n\" + \"int posY = int(vTexCoord.y / blockH);\\n\" + \"float fposX = float(posX);\\n\" + \"float fposY = float(posY);\\n\" + \"vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n\" + \"vec4 color = texture2D(uTexture, squareCoords);\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index, i, j, r, g, b, a, _i, _j, _iLen, _jLen;\n            for(i = 0; i < iLen; i += this.blocksize){\n                for(j = 0; j < jLen; j += this.blocksize){\n                    index = i * 4 * jLen + j * 4;\n                    r = data[index];\n                    g = data[index + 1];\n                    b = data[index + 2];\n                    a = data[index + 3];\n                    _iLen = Math.min(i + this.blocksize, iLen);\n                    _jLen = Math.min(j + this.blocksize, jLen);\n                    for(_i = i; _i < _iLen; _i++){\n                        for(_j = j; _j < _jLen; _j++){\n                            index = _i * 4 * jLen + _j * 4;\n                            data[index] = r;\n                            data[index + 1] = g;\n                            data[index + 2] = b;\n                            data[index + 3] = a;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/ isNeutralState: function() {\n            return this.blocksize === 1;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBlocksize: gl.getUniformLocation(program, \"uBlocksize\"),\n                uStepW: gl.getUniformLocation(program, \"uStepW\"),\n                uStepH: gl.getUniformLocation(program, \"uStepH\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */ fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"RemoveColor\",\n        /**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */ color: \"#FFFFFF\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uLow;\\n\" + \"uniform vec4 uHigh;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n\" + \"gl_FragColor.a = 0.0;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/ distance: 0.02,\n        /**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/ useAlpha: false,\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, distance = this.distance * 255, r, g, b, source = new fabric.Color(this.color).getSource(), lowC = [\n                source[0] - distance,\n                source[1] - distance,\n                source[2] - distance\n            ], highC = [\n                source[0] + distance,\n                source[1] + distance,\n                source[2] + distance\n            ];\n            for(i = 0; i < data.length; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {\n                    data[i + 3] = 0;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uLow: gl.getUniformLocation(program, \"uLow\"),\n                uHigh: gl.getUniformLocation(program, \"uHigh\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource(), distance = parseFloat(this.distance), lowC = [\n                0 + source[0] / 255 - distance,\n                0 + source[1] / 255 - distance,\n                0 + source[2] / 255 - distance,\n                1\n            ], highC = [\n                source[0] / 255 + distance,\n                source[1] / 255 + distance,\n                source[2] / 255 + distance,\n                1\n            ];\n            gl.uniform4fv(uniformLocations.uLow, lowC);\n            gl.uniform4fv(uniformLocations.uHigh, highC);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                color: this.color,\n                distance: this.distance\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */ fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    var matrices = {\n        Brownie: [\n            0.59970,\n            0.34553,\n            -0.27082,\n            0,\n            0.186,\n            -0.03770,\n            0.86095,\n            0.15059,\n            0,\n            -0.1449,\n            0.24113,\n            -0.07441,\n            0.44972,\n            0,\n            -0.02965,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Vintage: [\n            0.62793,\n            0.32021,\n            -0.03965,\n            0,\n            0.03784,\n            0.02578,\n            0.64411,\n            0.03259,\n            0,\n            0.02926,\n            0.04660,\n            -0.08512,\n            0.52416,\n            0,\n            0.02023,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Kodachrome: [\n            1.12855,\n            -0.39673,\n            -0.03992,\n            0,\n            0.24991,\n            -0.16404,\n            1.08352,\n            -0.05498,\n            0,\n            0.09698,\n            -0.16786,\n            -0.56034,\n            1.60148,\n            0,\n            0.13972,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Technicolor: [\n            1.91252,\n            -0.85453,\n            -0.09155,\n            0,\n            0.04624,\n            -0.30878,\n            1.76589,\n            -0.10601,\n            0,\n            -0.27589,\n            -0.23110,\n            -0.75018,\n            1.84759,\n            0,\n            0.12137,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Polaroid: [\n            1.438,\n            -0.062,\n            -0.062,\n            0,\n            0,\n            -0.122,\n            1.378,\n            -0.122,\n            0,\n            0,\n            -0.016,\n            -0.016,\n            1.483,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Sepia: [\n            0.393,\n            0.769,\n            0.189,\n            0,\n            0,\n            0.349,\n            0.686,\n            0.168,\n            0,\n            0,\n            0.272,\n            0.534,\n            0.131,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        BlackWhite: [\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0\n        ]\n    };\n    for(var key in matrices){\n        filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {\n            /**\n       * Filter type\n       * @param {String} type\n       * @default\n       */ type: key,\n            /**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */ matrix: matrices[key],\n            /**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */ mainParameter: false,\n            /**\n       * Lock the colormatrix on the color part, skipping alpha\n       */ colorsOnly: true\n        });\n        fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\n        type: \"BlendColor\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     * @type String\n     * @default\n     **/ color: \"#F95C63\",\n        /**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend color operation.\n     * @type Number\n     * @default\n     **/ alpha: 1,\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\n\" + \"gl_FragColor.r *= 2.0 * uColor.r;\\n\" + \"} else {\\n\" + \"gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n\" + \"}\\n\" + \"if (uColor.g < 0.5) {\\n\" + \"gl_FragColor.g *= 2.0 * uColor.g;\\n\" + \"} else {\\n\" + \"gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n\" + \"}\\n\" + \"if (uColor.b < 0.5) {\\n\" + \"gl_FragColor.b *= 2.0 * uColor.b;\\n\" + \"} else {\\n\" + \"gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n\" + \"}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\n\" + \"gl_FragColor.rgb += uColor.rgb;\\n\"\n        },\n        /**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */ buildSource: function(mode) {\n            return \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"gl_FragColor = color;\\n\" + \"if (color.a > 0.0) {\\n\" + this.fragmentSource[mode] + \"}\\n\" + \"}\";\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode, shaderSource;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                shaderSource = this.buildSource(this.mode);\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source, alpha1 = 1 - this.alpha;\n            source = new fabric.Color(this.color).getSource();\n            tr = source[0] * this.alpha;\n            tg = source[1] * this.alpha;\n            tb = source[2] * this.alpha;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        break;\n                    case \"screen\":\n                        data[i] = 255 - (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"add\":\n                        data[i] = r + tr;\n                        data[i + 1] = g + tg;\n                        data[i + 2] = b + tb;\n                        break;\n                    case \"diff\":\n                    case \"difference\":\n                        data[i] = Math.abs(r - tr);\n                        data[i + 1] = Math.abs(g - tg);\n                        data[i + 2] = Math.abs(b - tb);\n                        break;\n                    case \"subtract\":\n                        data[i] = r - tr;\n                        data[i + 1] = g - tg;\n                        data[i + 2] = b - tb;\n                        break;\n                    case \"darken\":\n                        data[i] = Math.min(r, tr);\n                        data[i + 1] = Math.min(g, tg);\n                        data[i + 2] = Math.min(b, tb);\n                        break;\n                    case \"lighten\":\n                        data[i] = Math.max(r, tr);\n                        data[i + 1] = Math.max(g, tg);\n                        data[i + 2] = Math.max(b, tb);\n                        break;\n                    case \"overlay\":\n                        data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"exclusion\":\n                        data[i] = tr + r - 2 * tr * r / 255;\n                        data[i + 1] = tg + g - 2 * tg * g / 255;\n                        data[i + 2] = tb + b - 2 * tb * b / 255;\n                        break;\n                    case \"tint\":\n                        data[i] = tr + r * alpha1;\n                        data[i + 1] = tg + g * alpha1;\n                        data[i + 2] = tb + b * alpha1;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColor: gl.getUniformLocation(program, \"uColor\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource();\n            source[0] = this.alpha * source[0] / 255;\n            source[1] = this.alpha * source[1] / 255;\n            source[2] = this.alpha * source[2] / 255;\n            source[3] = this.alpha;\n            gl.uniform4fv(uniformLocations.uColor, source);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                color: this.color,\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */ fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {\n        type: \"BlendImage\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/ image: null,\n        /**\n     * Blend mode for the filter (one of \"multiply\", \"mask\")\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/ alpha: 1,\n        vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"uniform mat3 uTransformMatrix;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.rgba *= color2.rgba;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            mask: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.a = color2.a;\\n\" + \"gl_FragColor = color;\\n\" + \"}\"\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            var shaderSource = this.fragmentSource[this.mode];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        applyToWebGL: function(options) {\n            // load texture to blend.\n            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);\n            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);\n            this.callSuper(\"applyToWebGL\", options);\n            this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n        },\n        createTexture: function(backend, image) {\n            return backend.getCachedTexture(image.cacheKey, image._element);\n        },\n        /**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ calculateMatrix: function() {\n            var image = this.image, width = image._element.width, height = image._element.height;\n            return [\n                1 / image.scaleX,\n                0,\n                0,\n                0,\n                1 / image.scaleY,\n                0,\n                -image.left / width,\n                -image.top / height,\n                1\n            ];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a, canvas1, context, image = this.image, blendData;\n            if (!resources.blendImage) {\n                resources.blendImage = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blendImage;\n            context = canvas1.getContext(\"2d\");\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas1.width = width;\n                canvas1.height = height;\n            } else {\n                context.clearRect(0, 0, width, height);\n            }\n            context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);\n            context.drawImage(image._element, 0, 0, width, height);\n            blendData = context.getImageData(0, 0, width, height).data;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                a = data[i + 3];\n                tr = blendData[i];\n                tg = blendData[i + 1];\n                tb = blendData[i + 2];\n                ta = blendData[i + 3];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        data[i + 3] = a * ta / 255;\n                        break;\n                    case \"mask\":\n                        data[i + 3] = ta;\n                        break;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uTransformMatrix: gl.getUniformLocation(program, \"uTransformMatrix\"),\n                uImage: gl.getUniformLocation(program, \"uImage\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var matrix = this.calculateMatrix();\n            gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                image: this.image && this.image.toObject(),\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */ fabric.Image.filters.BlendImage.fromObject = function(object, callback) {\n        fabric.Image.fromObject(object.image, function(image) {\n            var options = fabric.util.object.clone(object);\n            options.image = image;\n            callback(new fabric.Image.filters.BlendImage(options));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Resize\",\n        /**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */ resizeType: \"hermite\",\n        /**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */ scaleX: 1,\n        /**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */ scaleY: 1,\n        /**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */ lanczosLobes: 3,\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uDelta: gl.getUniformLocation(program, \"uDelta\"),\n                uTaps: gl.getUniformLocation(program, \"uTaps\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [\n                1 / this.width,\n                0\n            ] : [\n                0,\n                1 / this.height\n            ]);\n            gl.uniform1fv(uniformLocations.uTaps, this.taps);\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var filterWindow = this.getFilterWindow(), cacheKey = this.type + \"_\" + filterWindow;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var fragmentShader = this.generateShader(filterWindow);\n                options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);\n            }\n            return options.programCache[cacheKey];\n        },\n        getFilterWindow: function() {\n            var scale = this.tempScale;\n            return Math.ceil(this.lanczosLobes / scale);\n        },\n        getTaps: function() {\n            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);\n            for(var i = 1; i <= filterWindow; i++){\n                taps[i - 1] = lobeFunction(i * scale);\n            }\n            return taps;\n        },\n        /**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */ generateShader: function(filterWindow) {\n            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;\n            for(var i = 1; i <= filterWindow; i++){\n                offsets[i - 1] = i + \".0 * uDelta\";\n            }\n            fragmentShader += \"uniform float uTaps[\" + filterWindow + \"];\\n\";\n            fragmentShader += \"void main() {\\n\";\n            fragmentShader += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\";\n            fragmentShader += \"  float sum = 1.0;\\n\";\n            offsets.forEach(function(offset, i) {\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord + \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord - \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  sum += 2.0 * uTaps[\" + i + \"];\\n\";\n            });\n            fragmentShader += \"  gl_FragColor = color / sum;\\n\";\n            fragmentShader += \"}\";\n            return fragmentShader;\n        },\n        fragmentSourceTOP: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\",\n        /**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            if (options.webgl) {\n                options.passes++;\n                this.width = options.sourceWidth;\n                this.horizontal = true;\n                this.dW = Math.round(this.width * this.scaleX);\n                this.dH = options.sourceHeight;\n                this.tempScale = this.dW / this.width;\n                this.taps = this.getTaps();\n                options.destinationWidth = this.dW;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceWidth = options.destinationWidth;\n                this.height = options.sourceHeight;\n                this.horizontal = false;\n                this.dH = Math.round(this.height * this.scaleY);\n                this.tempScale = this.dH / this.height;\n                this.taps = this.getTaps();\n                options.destinationHeight = this.dH;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceHeight = options.destinationHeight;\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        isNeutralState: function() {\n            return this.scaleX === 1 && this.scaleY === 1;\n        },\n        lanczosCreate: function(lobes) {\n            return function(x) {\n                if (x >= lobes || x <= -lobes) {\n                    return 0.0;\n                }\n                if (x < 1.19209290E-07 && x > -1.19209290E-07) {\n                    return 1.0;\n                }\n                x *= Math.PI;\n                var xx = x / lobes;\n                return sin(x) / x * sin(xx) / xx;\n            };\n        },\n        /**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;\n            this.rcpScaleX = 1 / scaleX;\n            this.rcpScaleY = 1 / scaleY;\n            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;\n            if (this.resizeType === \"sliceHack\") {\n                newData = this.sliceByTwo(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"hermite\") {\n                newData = this.hermiteFastResize(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"bilinear\") {\n                newData = this.bilinearFiltering(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"lanczos\") {\n                newData = this.lanczosResize(options, oW, oH, dW, dH);\n            }\n            options.imageData = newData;\n        },\n        /**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ sliceByTwo: function(options, oW, oH, dW, dH) {\n            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;\n            if (!resources.sliceByTwo) {\n                resources.sliceByTwo = document.createElement(\"canvas\");\n            }\n            tmpCanvas = resources.sliceByTwo;\n            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {\n                tmpCanvas.width = oW * 1.5;\n                tmpCanvas.height = oH;\n            }\n            ctx = tmpCanvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, oW * 1.5, oH);\n            ctx.putImageData(imageData, 0, 0);\n            dW = floor(dW);\n            dH = floor(dH);\n            while(!doneW || !doneH){\n                oW = stepW;\n                oH = stepH;\n                if (dW < floor(stepW * mult)) {\n                    stepW = floor(stepW * mult);\n                } else {\n                    stepW = dW;\n                    doneW = true;\n                }\n                if (dH < floor(stepH * mult)) {\n                    stepH = floor(stepH * mult);\n                } else {\n                    stepH = dH;\n                    doneH = true;\n                }\n                ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);\n                sX = dX;\n                sY = dY;\n                dY += stepH;\n            }\n            return ctx.getImageData(sX, sY, dW, dH);\n        },\n        /**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ lanczosResize: function(options, oW, oH, dW, dH) {\n            function process(u) {\n                var v, i, weight, idx, a, red, green, blue, alpha, fX, fY;\n                center.x = (u + 0.5) * ratioX;\n                icenter.x = floor(center.x);\n                for(v = 0; v < dH; v++){\n                    center.y = (v + 0.5) * ratioY;\n                    icenter.y = floor(center.y);\n                    a = 0;\n                    red = 0;\n                    green = 0;\n                    blue = 0;\n                    alpha = 0;\n                    for(i = icenter.x - range2X; i <= icenter.x + range2X; i++){\n                        if (i < 0 || i >= oW) {\n                            continue;\n                        }\n                        fX = floor(1000 * abs(i - center.x));\n                        if (!cacheLanc[fX]) {\n                            cacheLanc[fX] = {};\n                        }\n                        for(var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++){\n                            if (j < 0 || j >= oH) {\n                                continue;\n                            }\n                            fY = floor(1000 * abs(j - center.y));\n                            if (!cacheLanc[fX][fY]) {\n                                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\n                            }\n                            weight = cacheLanc[fX][fY];\n                            if (weight > 0) {\n                                idx = (j * oW + i) * 4;\n                                a += weight;\n                                red += weight * srcData[idx];\n                                green += weight * srcData[idx + 1];\n                                blue += weight * srcData[idx + 2];\n                                alpha += weight * srcData[idx + 3];\n                            }\n                        }\n                    }\n                    idx = (v * dW + u) * 4;\n                    destData[idx] = red / a;\n                    destData[idx + 1] = green / a;\n                    destData[idx + 2] = blue / a;\n                    destData[idx + 3] = alpha / a;\n                }\n                if (++u < dW) {\n                    return process(u);\n                } else {\n                    return destImg;\n                }\n            }\n            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};\n            return process(0);\n        },\n        /**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ bilinearFiltering: function(options, oW, oH, dW, dH) {\n            var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl, color, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;\n            for(i = 0; i < dH; i++){\n                for(j = 0; j < dW; j++){\n                    x = floor(ratioX * j);\n                    y = floor(ratioY * i);\n                    xDiff = ratioX * j - x;\n                    yDiff = ratioY * i - y;\n                    origPix = 4 * (y * oW + x);\n                    for(chnl = 0; chnl < 4; chnl++){\n                        a = pixels[origPix + chnl];\n                        b = pixels[origPix + 4 + chnl];\n                        c = pixels[origPix + w4 + chnl];\n                        d = pixels[origPix + w4 + 4 + chnl];\n                        color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\n                        destPixels[offset++] = color;\n                    }\n                }\n            }\n            return destImage;\n        },\n        /**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ hermiteFastResize: function(options, oW, oH, dW, dH) {\n            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;\n            for(var j = 0; j < dH; j++){\n                for(var i = 0; i < dW; i++){\n                    var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\n                    for(var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++){\n                        var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;\n                        for(var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++){\n                            var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt(w0 + dx * dx);\n                            /* eslint-disable max-depth */ if (w > 1 && w < -1) {\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            if (weight > 0) {\n                                dx = 4 * (xx + yy * oW);\n                                //alpha\n                                gxA += weight * data[dx + 3];\n                                weightsAlpha += weight;\n                                //colors\n                                if (data[dx + 3] < 255) {\n                                    weight = weight * data[dx + 3] / 250;\n                                }\n                                gxR += weight * data[dx];\n                                gxG += weight * data[dx + 1];\n                                gxB += weight * data[dx + 2];\n                                weights += weight;\n                            }\n                        /* eslint-enable max-depth */ }\n                    }\n                    data2[x2] = gxR / weights;\n                    data2[x2 + 1] = gxG / weights;\n                    data2[x2 + 2] = gxB / weights;\n                    data2[x2 + 3] = gxA / weightsAlpha;\n                }\n            }\n            return img2;\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                resizeType: this.resizeType,\n                lanczosLobes: this.lanczosLobes\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */ fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Contrast\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uContrast;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n\" + \"color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */ contrast: 0,\n        mainParameter: \"contrast\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */ applyTo2d: function(options) {\n            if (this.contrast === 0) {\n                return;\n            }\n            var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));\n            for(i = 0; i < len; i += 4){\n                data[i] = contrastF * (data[i] - 128) + 128;\n                data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\n                data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uContrast: gl.getUniformLocation(program, \"uContrast\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uContrast, this.contrast);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */ fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Saturation\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uSaturation;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float rgMax = max(color.r, color.g);\\n\" + \"float rgbMax = max(rgMax, color.b);\\n\" + \"color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n\" + \"color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n\" + \"color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */ saturation: 0,\n        mainParameter: \"saturation\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.saturation === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uSaturation: gl.getUniformLocation(program, \"uSaturation\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */ fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Vibrance = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Vibrance.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Vibrance\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uVibrance;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float max = max(color.r, max(color.g, color.b));\\n\" + \"float avg = (color.r + color.g + color.b) / 3.0;\\n\" + \"float amt = (abs(max - avg) * 2.0) * uVibrance;\\n\" + \"color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n\" + \"color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n\" + \"color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */ vibrance: 0,\n        mainParameter: \"vibrance\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.vibrance === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max, avg, amt;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                amt = Math.abs(max - avg) * 2 / 255 * adjust;\n                data[i] += max !== data[i] ? (max - data[i]) * amt : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * amt : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * amt : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uVibrance: gl.getUniformLocation(program, \"uVibrance\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */ fabric.Image.filters.Vibrance.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {\n        type: \"Blur\",\n        /*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"const float nSamples = 15.0;\\n\" + \"vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n\" + \"float random(vec3 scale) {\\n\" + /* use the fragment position for a different seed per-pixel */ \"return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0.0);\\n\" + \"float total = 0.0;\\n\" + \"float offset = random(v3offset);\\n\" + \"for (float t = -nSamples; t <= nSamples; t++) {\\n\" + \"float percent = (t + offset - 0.5) / nSamples;\\n\" + \"float weight = 1.0 - abs(percent);\\n\" + \"color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n\" + \"total += weight;\\n\" + \"}\\n\" + \"gl_FragColor = color / total;\\n\" + \"}\",\n        /* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     * @type Number\n     * @default\n     */ blur: 0,\n        mainParameter: \"blur\",\n        applyTo: function(options) {\n            if (options.webgl) {\n                // this aspectRatio is used to give the same blur to vertical and horizontal\n                this.aspectRatio = options.sourceWidth / options.sourceHeight;\n                options.passes++;\n                this._setupFrameBuffer(options);\n                this.horizontal = true;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                this._setupFrameBuffer(options);\n                this.horizontal = false;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        applyTo2d: function(options) {\n            // paint canvasEl with current image data.\n            //options.ctx.putImageData(options.imageData, 0, 0);\n            options.imageData = this.simpleBlur(options);\n        },\n        simpleBlur: function(options) {\n            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;\n            if (!resources.blurLayer1) {\n                resources.blurLayer1 = fabric.util.createCanvasElement();\n                resources.blurLayer2 = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blurLayer1;\n            canvas2 = resources.blurLayer2;\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas2.width = canvas1.width = width;\n                canvas2.height = canvas1.height = height;\n            }\n            var ctx1 = canvas1.getContext(\"2d\"), ctx2 = canvas2.getContext(\"2d\"), nSamples = 15, random, percent, j, i, blur = this.blur * 0.06 * 0.5;\n            // load first canvas\n            ctx1.putImageData(options.imageData, 0, 0);\n            ctx2.clearRect(0, 0, width, height);\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * width + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, j, random);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * height + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, random, j);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            options.ctx.drawImage(canvas1, 0, 0);\n            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);\n            ctx1.globalAlpha = 1;\n            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n            return newImageData;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                delta: gl.getUniformLocation(program, \"uDelta\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var delta = this.chooseRightDelta();\n            gl.uniform2fv(uniformLocations.delta, delta);\n        },\n        /**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */ chooseRightDelta: function() {\n            var blurScale = 1, delta = [\n                0,\n                0\n            ], blur;\n            if (this.horizontal) {\n                if (this.aspectRatio > 1) {\n                    // image is wide, i want to shrink radius horizontal\n                    blurScale = 1 / this.aspectRatio;\n                }\n            } else {\n                if (this.aspectRatio < 1) {\n                    // image is tall, i want to shrink radius vertical\n                    blurScale = this.aspectRatio;\n                }\n            }\n            blur = blurScale * this.blur * 0.12;\n            if (this.horizontal) {\n                delta[0] = blur;\n            } else {\n                delta[1] = blur;\n            }\n            return delta;\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */ filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Gamma\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec3 uGamma;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec3 correction = (1.0 / uGamma);\\n\" + \"color.r = pow(color.r, correction.r);\\n\" + \"color.g = pow(color.g, correction.g);\\n\" + \"color.b = pow(color.b, correction.b);\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.rgb *= color.a;\\n\" + \"}\",\n        /**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */ gamma: [\n            1,\n            1,\n            1\n        ],\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"gamma\",\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.gamma = [\n                1,\n                1,\n                1\n            ];\n            filters.BaseFilter.prototype.initialize.call(this, options);\n        },\n        /**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;\n            if (!this.rVals) {\n                // eslint-disable-next-line\n                this.rVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.gVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.bVals = new Uint8Array(256);\n            }\n            // This is an optimization - pre-compute a look-up table for each color channel\n            // instead of performing these pow calls for each pixel in the image.\n            for(i = 0, len = 256; i < len; i++){\n                this.rVals[i] = Math.pow(i / 255, rInv) * 255;\n                this.gVals[i] = Math.pow(i / 255, gInv) * 255;\n                this.bVals[i] = Math.pow(i / 255, bInv) * 255;\n            }\n            for(i = 0, len = data.length; i < len; i += 4){\n                data[i] = this.rVals[data[i]];\n                data[i + 1] = this.gVals[data[i + 1]];\n                data[i + 2] = this.bVals[data[i + 2]];\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uGamma: gl.getUniformLocation(program, \"uGamma\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform3fv(uniformLocations.uGamma, this.gamma);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */ fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */ filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {\n        type: \"Composed\",\n        /**\n     * A non sparse array of filters to apply\n     */ subFilters: [],\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.subFilters = this.subFilters.slice(0);\n        },\n        /**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */ applyTo: function(options) {\n            options.passes += this.subFilters.length - 1;\n            this.subFilters.forEach(function(filter) {\n                filter.applyTo(options);\n            });\n        },\n        /**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */ toObject: function() {\n            return fabric.util.object.extend(this.callSuper(\"toObject\"), {\n                subFilters: this.subFilters.map(function(filter) {\n                    return filter.toObject();\n                })\n            });\n        },\n        isNeutralState: function() {\n            return !this.subFilters.some(function(filter) {\n                return !filter.isNeutralState();\n            });\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */ fabric.Image.filters.Composed.fromObject = function(object, callback) {\n        var filters = object.subFilters || [], subFilters = filters.map(function(filter) {\n            return new fabric.Image.filters[filter.type](filter);\n        }), instance = new fabric.Image.filters.Composed({\n            subFilters: subFilters\n        });\n        callback && callback(instance);\n        return instance;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"HueRotation\",\n        /**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */ rotation: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"rotation\",\n        calculateMatrix: function() {\n            var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;\n            this.matrix = [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0\n            ];\n            this.matrix[0] = cos + OneMinusCos / 3;\n            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[6] = cos + aThird * OneMinusCos;\n            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[12] = cos + aThird * OneMinusCos;\n        },\n        /**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function(options) {\n            this.calculateMatrix();\n            return filters.BaseFilter.prototype.isNeutralState.call(this, options);\n        },\n        /**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            this.calculateMatrix();\n            filters.BaseFilter.prototype.applyTo.call(this, options);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */ fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), clone = fabric.util.object.clone;\n    if (fabric.Text) {\n        fabric.warn(\"fabric.Text is already defined\");\n        return;\n    }\n    var additionalProps = (\"fontFamily fontWeight fontSize text underline overline linethrough\" + \" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles\" + \" direction path pathStartOffset pathSide pathAlign\").split(\" \");\n    /**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */ fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */ _dimensionAffectingProps: [\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"lineHeight\",\n            \"text\",\n            \"charSpacing\",\n            \"textAlign\",\n            \"styles\",\n            \"path\",\n            \"pathStartOffset\",\n            \"pathSide\",\n            \"pathAlign\"\n        ],\n        /**\n     * @private\n     */ _reNewline: /\\r?\\n/,\n        /**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpacesAndTabs: /[ \\t\\r]/g,\n        /**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpaceAndTab: /[ \\t\\r]/,\n        /**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reWords: /\\S+/g,\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"text\",\n        /**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */ fontSize: 40,\n        /**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */ fontWeight: \"normal\",\n        /**\n     * Font family\n     * @type String\n     * @default\n     */ fontFamily: \"Times New Roman\",\n        /**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */ underline: false,\n        /**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */ overline: false,\n        /**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */ linethrough: false,\n        /**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */ textAlign: \"left\",\n        /**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */ fontStyle: \"normal\",\n        /**\n     * Line height\n     * @type Number\n     * @default\n     */ lineHeight: 1.16,\n        /**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ superscript: {\n            size: 0.60,\n            baseline: -0.35 // baseline-shift factor (upwards)\n        },\n        /**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ subscript: {\n            size: 0.60,\n            baseline: 0.11 // baseline-shift factor (downwards)\n        },\n        /**\n     * Background color of text lines\n     * @type String\n     * @default\n     */ textBackgroundColor: \"\",\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */ path: null,\n        /**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */ pathStartOffset: 0,\n        /**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */ pathSide: \"left\",\n        /**\n     * How text is aligned to the path. This property determines\n     * the perpendicular position of each character relative to the path.\n     * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n     * This feature is in BETA, and its behavior may change\n     * @type String\n     * @default\n     */ pathAlign: \"baseline\",\n        /**\n     * @private\n     */ _fontSizeFraction: 0.222,\n        /**\n     * @private\n     */ offsets: {\n            underline: 0.10,\n            linethrough: -0.315,\n            overline: -0.88\n        },\n        /**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */ _fontSizeMult: 1.13,\n        /**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */ charSpacing: 0,\n        /**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */ styles: null,\n        /**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */ _measuringContext: null,\n        /**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */ deltaY: 0,\n        /**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */ direction: \"ltr\",\n        /**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */ _styleProperties: [\n            \"stroke\",\n            \"strokeWidth\",\n            \"fill\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontStyle\",\n            \"underline\",\n            \"overline\",\n            \"linethrough\",\n            \"deltaY\",\n            \"textBackgroundColor\"\n        ],\n        /**\n     * contains characters bounding boxes\n     */ __charBounds: [],\n        /**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */ CACHE_FONT_SIZE: 400,\n        /**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */ MIN_TEXT_WIDTH: 2,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ initialize: function(text, options) {\n            this.styles = options ? options.styles || {} : {};\n            this.text = text;\n            this.__skipDimension = true;\n            this.callSuper(\"initialize\", options);\n            if (this.path) {\n                this.setPathInfo();\n            }\n            this.__skipDimension = false;\n            this.initDimensions();\n            this.setCoords();\n            this.setupState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */ setPathInfo: function() {\n            var path = this.path;\n            if (path) {\n                path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);\n            }\n        },\n        /**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * this is for internal use, please do not use it\n     * @private\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ getMeasuringContext: function() {\n            // if we did not return we have to measure something.\n            if (!fabric._measuringContext) {\n                fabric._measuringContext = this.canvas && this.canvas.contextCache || fabric.util.createCanvasElement().getContext(\"2d\");\n            }\n            return fabric._measuringContext;\n        },\n        /**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */ _splitText: function() {\n            var newLines = this._splitTextIntoLines(this.text);\n            this.textLines = newLines.lines;\n            this._textLines = newLines.graphemeLines;\n            this._unwrappedTextLines = newLines._unwrappedLines;\n            this._text = newLines.graphemeText;\n            return newLines;\n        },\n        /**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this._splitText();\n            this._clearCache();\n            if (this.path) {\n                this.width = this.path.width;\n                this.height = this.path.height;\n            } else {\n                this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n                this.height = this.calcTextHeight();\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Enlarge space boxes and shift the others\n     */ enlargeSpaces: function() {\n            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                if (this.textAlign !== \"justify\" && (i === len - 1 || this.isEndOfWrapping(i))) {\n                    continue;\n                }\n                accumulatedSpace = 0;\n                line = this._textLines[i];\n                currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {\n                    numberOfSpaces = spaces.length;\n                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n                    for(var j = 0, jlen = line.length; j <= jlen; j++){\n                        charBound = this.__charBounds[i][j];\n                        if (this._reSpaceAndTab.test(line[j])) {\n                            charBound.width += diffSpace;\n                            charBound.kernedWidth += diffSpace;\n                            charBound.left += accumulatedSpace;\n                            accumulatedSpace += diffSpace;\n                        } else {\n                            charBound.left += accumulatedSpace;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            return lineIndex === this._textLines.length - 1;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */ missingNewlineOffset: function() {\n            return 1;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */ toString: function() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var dims = this.callSuper(\"_getCacheCanvasDimensions\");\n            var fontSize = this.fontSize;\n            dims.width += fontSize * dims.zoomX;\n            dims.height += fontSize * dims.zoomY;\n            return dims;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var path = this.path;\n            path && !path.isNotVisible() && path._render(ctx);\n            this._setTextStyles(ctx);\n            this._renderTextLinesBackground(ctx);\n            this._renderTextDecoration(ctx, \"underline\");\n            this._renderText(ctx);\n            this._renderTextDecoration(ctx, \"overline\");\n            this._renderTextDecoration(ctx, \"linethrough\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderText: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderTextStroke(ctx);\n                this._renderTextFill(ctx);\n            } else {\n                this._renderTextFill(ctx);\n                this._renderTextStroke(ctx);\n            }\n        },\n        /**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */ _setTextStyles: function(ctx, charStyle, forMeasuring) {\n            ctx.textBaseline = \"alphabetical\";\n            if (this.path) {\n                switch(this.pathAlign){\n                    case \"center\":\n                        ctx.textBaseline = \"middle\";\n                        break;\n                    case \"ascender\":\n                        ctx.textBaseline = \"top\";\n                        break;\n                    case \"descender\":\n                        ctx.textBaseline = \"bottom\";\n                        break;\n                }\n            }\n            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n        },\n        /**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */ calcTextWidth: function() {\n            var maxWidth = this.getLineWidth(0);\n            for(var i = 1, len = this._textLines.length; i < len; i++){\n                var currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth > maxWidth) {\n                    maxWidth = currentLineWidth;\n                }\n            }\n            return maxWidth;\n        },\n        /**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */ _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\n            this._renderChars(method, ctx, line, left, top, lineIndex);\n        },\n        /**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextLinesBackground: function(ctx) {\n            if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) {\n                return;\n            }\n            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", i)) {\n                    lineTopOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxWidth = 0;\n                boxStart = 0;\n                lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillStyle = currentColor;\n                        currentColor && ctx.fillRect(-charBox.width / 2, -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction), charBox.width, heightOfLine / this.lineHeight);\n                        ctx.restore();\n                    } else if (currentColor !== lastColor) {\n                        drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        ctx.fillStyle = lastColor;\n                        lastColor && ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastColor = currentColor;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                if (currentColor && !path) {\n                    drawStart = leftOffset + lineLeftOffset + boxStart;\n                    if (this.direction === \"rtl\") {\n                        drawStart = this.width - drawStart - boxWidth;\n                    }\n                    ctx.fillStyle = currentColor;\n                    ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                }\n                lineTopOffset += heightOfLine;\n            }\n            ctx.fillStyle = originalFill;\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */ getFontCache: function(decl) {\n            var fontFamily = decl.fontFamily.toLowerCase();\n            if (!fabric.charWidthsCache[fontFamily]) {\n                fabric.charWidthsCache[fontFamily] = {};\n            }\n            var cache = fabric.charWidthsCache[fontFamily], cacheProp = decl.fontStyle.toLowerCase() + \"_\" + (decl.fontWeight + \"\").toLowerCase();\n            if (!cache[cacheProp]) {\n                cache[cacheProp] = {};\n            }\n            return cache[cacheProp];\n        },\n        /**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */ _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {\n            // first i try to return from cache\n            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;\n            if (previousChar && fontCache[previousChar] !== undefined) {\n                previousWidth = fontCache[previousChar];\n            }\n            if (fontCache[_char] !== undefined) {\n                kernedWidth = width = fontCache[_char];\n            }\n            if (stylesAreEqual && fontCache[couple] !== undefined) {\n                coupleWidth = fontCache[couple];\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {\n                var ctx = this.getMeasuringContext();\n                // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n                this._setTextStyles(ctx, charStyle, true);\n            }\n            if (width === undefined) {\n                kernedWidth = width = ctx.measureText(_char).width;\n                fontCache[_char] = width;\n            }\n            if (previousWidth === undefined && stylesAreEqual && previousChar) {\n                previousWidth = ctx.measureText(previousChar).width;\n                fontCache[previousChar] = previousWidth;\n            }\n            if (stylesAreEqual && coupleWidth === undefined) {\n                // we can measure the kerning couple and subtract the width of the previous character\n                coupleWidth = ctx.measureText(couple).width;\n                fontCache[couple] = coupleWidth;\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            return {\n                width: width * fontMultiplier,\n                kernedWidth: kernedWidth * fontMultiplier\n            };\n        },\n        /**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */ getHeightOfChar: function(line, _char) {\n            return this.getValueOfPropertyAt(line, _char, \"fontSize\");\n        },\n        /**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ measureLine: function(lineIndex) {\n            var lineInfo = this._measureLine(lineIndex);\n            if (this.charSpacing !== 0) {\n                lineInfo.width -= this._getWidthOfCharSpacing();\n            }\n            if (lineInfo.width < 0) {\n                lineInfo.width = 0;\n            }\n            return lineInfo;\n        },\n        /**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */ _measureLine: function(lineIndex) {\n            var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === \"right\";\n            this.__charBounds[lineIndex] = lineBounds;\n            for(i = 0; i < line.length; i++){\n                grapheme = line[i];\n                graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n                lineBounds[i] = graphemeInfo;\n                width += graphemeInfo.kernedWidth;\n                prevGrapheme = grapheme;\n            }\n            // this latest bound box represent the last character of the line\n            // to simplify cursor handling in interactive mode.\n            lineBounds[i] = {\n                left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n                width: 0,\n                kernedWidth: 0,\n                height: this.fontSize\n            };\n            if (path) {\n                totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;\n                startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);\n                startingPoint.x += path.pathOffset.x;\n                startingPoint.y += path.pathOffset.y;\n                switch(this.textAlign){\n                    case \"left\":\n                        positionInPath = reverse ? totalPathLength - width : 0;\n                        break;\n                    case \"center\":\n                        positionInPath = (totalPathLength - width) / 2;\n                        break;\n                    case \"right\":\n                        positionInPath = reverse ? 0 : totalPathLength - width;\n                        break;\n                }\n                positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n                for(i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++){\n                    graphemeInfo = lineBounds[i];\n                    if (positionInPath > totalPathLength) {\n                        positionInPath %= totalPathLength;\n                    } else if (positionInPath < 0) {\n                        positionInPath += totalPathLength;\n                    }\n                    // it would probably much faster to send all the grapheme position for a line\n                    // and calculate path position/angle at once.\n                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);\n                    positionInPath += graphemeInfo.kernedWidth;\n                }\n            }\n            return {\n                width: width,\n                numOfSpaces: numOfSpaces\n            };\n        },\n        /**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */ _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {\n            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;\n            // we are at currentPositionOnPath. we want to know what point on the path is.\n            var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);\n            graphemeInfo.renderLeft = info.x - startingPoint.x;\n            graphemeInfo.renderTop = info.y - startingPoint.y;\n            graphemeInfo.angle = info.angle + (this.pathSide === \"right\" ? Math.PI : 0);\n        },\n        /**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */ _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {\n            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;\n            if (this.charSpacing !== 0) {\n                charSpacing = this._getWidthOfCharSpacing();\n                width += charSpacing;\n                kernedWidth += charSpacing;\n            }\n            var box = {\n                width: width,\n                left: 0,\n                height: style.fontSize,\n                kernedWidth: kernedWidth,\n                deltaY: style.deltaY\n            };\n            if (charIndex > 0 && !skipLeft) {\n                var previousBox = this.__charBounds[lineIndex][charIndex - 1];\n                box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;\n            }\n            return box;\n        },\n        /**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */ getHeightOfLine: function(lineIndex) {\n            if (this.__lineHeights[lineIndex]) {\n                return this.__lineHeights[lineIndex];\n            }\n            var line = this._textLines[lineIndex], // char 0 is measured before the line cycle because it nneds to char\n            // emptylines\n            maxHeight = this.getHeightOfChar(lineIndex, 0);\n            for(var i = 1, len = line.length; i < len; i++){\n                maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n            }\n            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\n        },\n        /**\n     * Calculate text box height\n     */ calcTextHeight: function() {\n            var lineHeight, height = 0;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineHeight = this.getHeightOfLine(i);\n                height += i === len - 1 ? lineHeight / this.lineHeight : lineHeight;\n            }\n            return height;\n        },\n        /**\n     * @private\n     * @return {Number} Left offset\n     */ _getLeftOffset: function() {\n            return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n        },\n        /**\n     * @private\n     * @return {Number} Top offset\n     */ _getTopOffset: function() {\n            return -this.height / 2;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */ _renderTextCommon: function(ctx, method) {\n            ctx.save();\n            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);\n                this._renderTextLine(method, ctx, this._textLines[i], left + leftOffset, top + lineHeights + maxHeight, i);\n                lineHeights += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextFill: function(ctx) {\n            if (!this.fill && !this.styleHas(\"fill\")) {\n                return;\n            }\n            this._renderTextCommon(ctx, \"fillText\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextStroke: function(ctx) {\n            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            this._setLineDash(ctx, this.strokeDashArray);\n            ctx.beginPath();\n            this._renderTextCommon(ctx, \"strokeText\");\n            ctx.closePath();\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */ _renderChars: function(method, ctx, line, left, top, lineIndex) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === \"ltr\", sign = this.direction === \"ltr\" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute(\"dir\");\n            ctx.save();\n            if (currentDirection !== this.direction) {\n                ctx.canvas.setAttribute(\"dir\", isLtr ? \"ltr\" : \"rtl\");\n                ctx.direction = isLtr ? \"ltr\" : \"rtl\";\n                ctx.textAlign = isLtr ? \"left\" : \"right\";\n            }\n            top -= lineHeight * this._fontSizeFraction / this.lineHeight;\n            if (shortCut) {\n                // render all the line in one pass without checking\n                // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n                this._renderChar(method, ctx, lineIndex, 0, line.join(\"\"), left, top, lineHeight);\n                ctx.restore();\n                return;\n            }\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    left += sign * (charBox.kernedWidth - charBox.width);\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, false);\n                }\n                if (timeToRender) {\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);\n                        ctx.restore();\n                    } else {\n                        drawingLeft = left;\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);\n                    }\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    left += sign * boxWidth;\n                    boxWidth = 0;\n                }\n            }\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */ _applyPatternGradientTransformText: function(filler) {\n            var pCanvas = fabric.util.createCanvasElement(), pCtx, // TODO: verify compatibility with strokeUniform\n            width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.fillStyle = filler.toLive(pCtx);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fill();\n            return pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        handleFiller: function(ctx, property, filler) {\n            var offsetX, offsetY;\n            if (filler.toLive) {\n                if (filler.gradientUnits === \"percentage\" || filler.gradientTransform || filler.patternTransform) {\n                    // need to transform gradient in a pattern.\n                    // this is a slow process. If you are hitting this codepath, and the object\n                    // is not using caching, you should consider switching it on.\n                    // we need a canvas as big as the current object caching canvas.\n                    offsetX = -this.width / 2;\n                    offsetY = -this.height / 2;\n                    ctx.translate(offsetX, offsetY);\n                    ctx[property] = this._applyPatternGradientTransformText(filler);\n                    return {\n                        offsetX: offsetX,\n                        offsetY: offsetY\n                    };\n                } else {\n                    // is a simple gradient or pattern\n                    ctx[property] = filler.toLive(ctx, this);\n                    return this._applyPatternGradientTransform(ctx, filler);\n                }\n            } else {\n                // is a color\n                ctx[property] = filler;\n            }\n            return {\n                offsetX: 0,\n                offsetY: 0\n            };\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            ctx.lineWidth = decl.strokeWidth;\n            ctx.lineCap = this.strokeLineCap;\n            ctx.lineDashOffset = this.strokeDashOffset;\n            ctx.lineJoin = this.strokeLineJoin;\n            ctx.miterLimit = this.strokeMiterLimit;\n            return this.handleFiller(ctx, \"strokeStyle\", decl.stroke);\n        },\n        _setFillStyles: function(ctx, decl) {\n            return this.handleFiller(ctx, \"fillStyle\", decl.fill);\n        },\n        /**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */ _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {\n            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === \"fillText\" && fullDecl.fill, shouldStroke = method === \"strokeText\" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;\n            if (!shouldStroke && !shouldFill) {\n                return;\n            }\n            ctx.save();\n            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));\n            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));\n            ctx.font = this._getFontDeclaration(fullDecl);\n            if (decl && decl.textBackgroundColor) {\n                this._removeShadow(ctx);\n            }\n            if (decl && decl.deltaY) {\n                top += decl.deltaY;\n            }\n            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);\n            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);\n            ctx.restore();\n        },\n        /**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSuperscript: function(start, end) {\n            return this._setScript(start, end, this.superscript);\n        },\n        /**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSubscript: function(start, end) {\n            return this._setScript(start, end, this.subscript);\n        },\n        /**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ _setScript: function(start, end, schema) {\n            var loc = this.get2DCursorLocation(start, true), fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"fontSize\"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"deltaY\"), style = {\n                fontSize: fontSize * schema.size,\n                deltaY: dy + fontSize * schema.baseline\n            };\n            this.setSelectionStyles(style, start, end);\n            return this;\n        },\n        /**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */ _getLineLeftOffset: function(lineIndex) {\n            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n            if (textAlign === \"justify\" || textAlign === \"justify-center\" && !isEndOfWrapping || textAlign === \"justify-right\" && !isEndOfWrapping || textAlign === \"justify-left\" && !isEndOfWrapping) {\n                return 0;\n            }\n            if (textAlign === \"center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"right\") {\n                leftOffset = lineDiff;\n            }\n            if (textAlign === \"justify-center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"justify-right\") {\n                leftOffset = lineDiff;\n            }\n            if (direction === \"rtl\") {\n                leftOffset -= lineDiff;\n            }\n            return leftOffset;\n        },\n        /**\n     * @private\n     */ _clearCache: function() {\n            this.__lineWidths = [];\n            this.__lineHeights = [];\n            this.__charBounds = [];\n        },\n        /**\n     * @private\n     */ _shouldClearDimensionCache: function() {\n            var shouldClear = this._forceClearCache;\n            shouldClear || (shouldClear = this.hasStateChanged(\"_dimensionAffectingProps\"));\n            if (shouldClear) {\n                this.dirty = true;\n                this._forceClearCache = false;\n            }\n            return shouldClear;\n        },\n        /**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ getLineWidth: function(lineIndex) {\n            if (this.__lineWidths[lineIndex] !== undefined) {\n                return this.__lineWidths[lineIndex];\n            }\n            var lineInfo = this.measureLine(lineIndex);\n            var width = lineInfo.width;\n            this.__lineWidths[lineIndex] = width;\n            return width;\n        },\n        _getWidthOfCharSpacing: function() {\n            if (this.charSpacing !== 0) {\n                return this.fontSize * this.charSpacing / 1000;\n            }\n            return 0;\n        },\n        /**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */ getValueOfPropertyAt: function(lineIndex, charIndex, property) {\n            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n            if (charStyle && typeof charStyle[property] !== \"undefined\") {\n                return charStyle[property];\n            }\n            return this[property];\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextDecoration: function(ctx, type) {\n            if (!this[type] && !this.styleHas(type)) {\n                return;\n            }\n            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this[type] && !this.styleHas(type, i)) {\n                    topOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                maxHeight = heightOfLine / this.lineHeight;\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxStart = 0;\n                boxWidth = 0;\n                lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n                lastFill = this.getValueOfPropertyAt(i, 0, \"fill\");\n                top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n                size = this.getHeightOfChar(i, 0);\n                dy = this.getValueOfPropertyAt(i, 0, \"deltaY\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentDecoration = this.getValueOfPropertyAt(i, j, type);\n                    currentFill = this.getValueOfPropertyAt(i, j, \"fill\");\n                    _size = this.getHeightOfChar(i, j);\n                    _dy = this.getValueOfPropertyAt(i, j, \"deltaY\");\n                    if (path && currentDecoration && currentFill) {\n                        ctx.save();\n                        ctx.fillStyle = lastFill;\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillRect(-charBox.kernedWidth / 2, offsetY * _size + _dy, charBox.kernedWidth, this.fontSize / 15);\n                        ctx.restore();\n                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {\n                        var drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        if (lastDecoration && lastFill) {\n                            ctx.fillStyle = lastFill;\n                            ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth, this.fontSize / 15);\n                        }\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastDecoration = currentDecoration;\n                        lastFill = currentFill;\n                        size = _size;\n                        dy = _dy;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                var drawStart = leftOffset + lineLeftOffset + boxStart;\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - boxWidth;\n                }\n                ctx.fillStyle = currentFill;\n                currentDecoration && currentFill && ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth - charSpacing, this.fontSize / 15);\n                topOffset += heightOfLine;\n            }\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */ _getFontDeclaration: function(styleObject, forMeasuring) {\n            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;\n            var fontFamily = family === undefined || family.indexOf(\"'\") > -1 || family.indexOf(\",\") > -1 || family.indexOf('\"') > -1 || fontIsGeneric ? style.fontFamily : '\"' + style.fontFamily + '\"';\n            return [\n                // node-canvas needs \"weight style\", while browsers need \"style weight\"\n                // verify if this can be fixed in JSDOM\n                fabric.isLikelyNode ? style.fontWeight : style.fontStyle,\n                fabric.isLikelyNode ? style.fontStyle : style.fontWeight,\n                forMeasuring ? this.CACHE_FONT_SIZE + \"px\" : style.fontSize + \"px\",\n                fontFamily\n            ].join(\" \");\n        },\n        /**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if object is not visible\n            if (!this.visible) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n            }\n            this.callSuper(\"render\", ctx);\n        },\n        /**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */ _splitTextIntoLines: function(text) {\n            var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = [\n                \"\\n\"\n            ], newText = [];\n            for(var i = 0; i < lines.length; i++){\n                newLines[i] = fabric.util.string.graphemeSplit(lines[i]);\n                newText = newText.concat(newLines[i], newLine);\n            }\n            newText.pop();\n            return {\n                _unwrappedLines: newLines,\n                lines: lines,\n                graphemeText: newText,\n                graphemeLines: newLines\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var allProperties = additionalProps.concat(propertiesToInclude);\n            var obj = this.callSuper(\"toObject\", allProperties);\n            obj.styles = fabric.util.stylesToArray(this.styles, this.text);\n            if (obj.path) {\n                obj.path = this.path.toObject();\n            }\n            return obj;\n        },\n        /**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ set: function(key, value) {\n            this.callSuper(\"set\", key, value);\n            var needsDims = false;\n            var isAddingPath = false;\n            if (typeof key === \"object\") {\n                for(var _key in key){\n                    if (_key === \"path\") {\n                        this.setPathInfo();\n                    }\n                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;\n                    isAddingPath = isAddingPath || _key === \"path\";\n                }\n            } else {\n                needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;\n                isAddingPath = key === \"path\";\n            }\n            if (isAddingPath) {\n                this.setPathInfo();\n            }\n            if (needsDims) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */ complexity: function() {\n            return 1;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */ fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \"));\n    /**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */ fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\n    /**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Text.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || \"left\";\n        options = fabric.util.object.extend(options ? clone(options) : {}, parsedAttributes);\n        options.top = options.top || 0;\n        options.left = options.left || 0;\n        if (parsedAttributes.textDecoration) {\n            var textDecoration = parsedAttributes.textDecoration;\n            if (textDecoration.indexOf(\"underline\") !== -1) {\n                options.underline = true;\n            }\n            if (textDecoration.indexOf(\"overline\") !== -1) {\n                options.overline = true;\n            }\n            if (textDecoration.indexOf(\"line-through\") !== -1) {\n                options.linethrough = true;\n            }\n            delete options.textDecoration;\n        }\n        if (\"dx\" in parsedAttributes) {\n            options.left += parsedAttributes.dx;\n        }\n        if (\"dy\" in parsedAttributes) {\n            options.top += parsedAttributes.dy;\n        }\n        if (!(\"fontSize\" in options)) {\n            options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n        }\n        var textContent = \"\";\n        // The XML is not properly parsed in IE9 so a workaround to get\n        // textContent is through firstChild.data. Another workaround would be\n        // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\n        if (!(\"textContent\" in element)) {\n            if (\"firstChild\" in element && element.firstChild !== null) {\n                if (\"data\" in element.firstChild && element.firstChild.data !== null) {\n                    textContent = element.firstChild.data;\n                }\n            }\n        } else {\n            textContent = element.textContent;\n        }\n        textContent = textContent.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n        var originalStrokeWidth = options.strokeWidth;\n        options.strokeWidth = 0;\n        var text = new fabric.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;\n        /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */ if (parsedAnchor === \"center\") {\n            offX = text.getScaledWidth() / 2;\n        }\n        if (parsedAnchor === \"right\") {\n            offX = text.getScaledWidth();\n        }\n        text.set({\n            left: text.left - offX,\n            top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n            strokeWidth: typeof originalStrokeWidth !== \"undefined\" ? originalStrokeWidth : 1\n        });\n        callback(text);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */ fabric.Text.fromObject = function(object, callback) {\n        var objectCopy = clone(object), path = object.path;\n        delete objectCopy.path;\n        return fabric.Object._fromObject(\"Text\", objectCopy, function(textInstance) {\n            textInstance.styles = fabric.util.stylesFromArray(object.styles, object.text);\n            if (path) {\n                fabric.Object._fromObject(\"Path\", path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n    fabric.Text.genericFonts = [\n        \"sans-serif\",\n        \"serif\",\n        \"cursive\",\n        \"fantasy\",\n        \"monospace\"\n    ];\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);\n})( true ? exports : 0);\n(function() {\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return true;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    // eslint-disable-next-line no-unused-vars\n                    for(var p3 in obj[p1][p2]){\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return false;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                0: this.styles[lineIndex]\n            };\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    if (typeof obj[p1][p2][property] !== \"undefined\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */ cleanStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                letterCount = 0;\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);\n                    stylesCount++;\n                    if (stylePropertyHasBeenSet) {\n                        if (!stylePropertyValue) {\n                            stylePropertyValue = styleObject[property];\n                        } else if (styleObject[property] !== stylePropertyValue) {\n                            allStyleObjectPropertiesMatch = false;\n                        }\n                        if (styleObject[property] === this[property]) {\n                            delete styleObject[property];\n                        }\n                    } else {\n                        allStyleObjectPropertiesMatch = false;\n                    }\n                    if (Object.keys(styleObject).length !== 0) {\n                        letterCount++;\n                    } else {\n                        delete obj[p1][p2];\n                    }\n                }\n                if (letterCount === 0) {\n                    delete obj[p1];\n                }\n            }\n            // if every grapheme has the same style set then\n            // delete those styles and set it on the parent\n            for(var i = 0; i < this._textLines.length; i++){\n                graphemeCount += this._textLines[i].length;\n            }\n            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {\n                this[property] = stylePropertyValue;\n                this.removeStyle(property);\n            }\n        },\n        /**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */ removeStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return;\n            }\n            var obj = this.styles, line, lineNum, charNum;\n            for(lineNum in obj){\n                line = obj[lineNum];\n                for(charNum in line){\n                    delete line[charNum][property];\n                    if (Object.keys(line[charNum]).length === 0) {\n                        delete line[charNum];\n                    }\n                }\n                if (Object.keys(line).length === 0) {\n                    delete obj[lineNum];\n                }\n            }\n        },\n        /**\n     * @private\n     */ _extendStyles: function(index, styles) {\n            var loc = this.get2DCursorLocation(index);\n            if (!this._getLineStyle(loc.lineIndex)) {\n                this._setLineStyle(loc.lineIndex);\n            }\n            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\n                this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\n            }\n            fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\n        },\n        /**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */ get2DCursorLocation: function(selectionStart, skipWrapping) {\n            if (typeof selectionStart === \"undefined\") {\n                selectionStart = this.selectionStart;\n            }\n            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;\n            for(var i = 0; i < len; i++){\n                if (selectionStart <= lines[i].length) {\n                    return {\n                        lineIndex: i,\n                        charIndex: selectionStart\n                    };\n                }\n                selectionStart -= lines[i].length + this.missingNewlineOffset(i);\n            }\n            return {\n                lineIndex: i - 1,\n                charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart\n            };\n        },\n        /**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */ getSelectionStyles: function(startIndex, endIndex, complete) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            var styles = [];\n            for(var i = startIndex; i < endIndex; i++){\n                styles.push(this.getStyleAtPosition(i, complete));\n            }\n            return styles;\n        },\n        /**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */ getStyleAtPosition: function(position, complete) {\n            var loc = this.get2DCursorLocation(position), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\n            return style || {};\n        },\n        /**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ setSelectionStyles: function(styles, startIndex, endIndex) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            for(var i = startIndex; i < endIndex; i++){\n                this._extendStyles(i, styles);\n            }\n            /* not included in _extendStyles to avoid clearing cache more than once */ this._forceClearCache = true;\n            return this;\n        },\n        /**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            var lineStyle = this.styles && this.styles[lineIndex];\n            if (!lineStyle) {\n                return null;\n            }\n            return lineStyle[charIndex];\n        },\n        /**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */ getCompleteStyleDeclaration: function(lineIndex, charIndex) {\n            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;\n            for(var i = 0; i < this._styleProperties.length; i++){\n                prop = this._styleProperties[i];\n                styleObject[prop] = typeof style[prop] === \"undefined\" ? this[prop] : style[prop];\n            }\n            return styleObject;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            return !!this.styles[lineIndex];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            this.styles[lineIndex] = {};\n        },\n        /**\n     * @param {Number} lineIndex\n     * @private\n     */ _deleteLineStyle: function(lineIndex) {\n            delete this.styles[lineIndex];\n        }\n    });\n})();\n(function() {\n    function parseDecoration(object) {\n        if (object.textDecoration) {\n            object.textDecoration.indexOf(\"underline\") > -1 && (object.underline = true);\n            object.textDecoration.indexOf(\"line-through\") > -1 && (object.linethrough = true);\n            object.textDecoration.indexOf(\"overline\") > -1 && (object.overline = true);\n            delete object.textDecoration;\n        }\n    }\n    /**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */ fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"i-text\",\n        /**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */ selectionStart: 0,\n        /**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */ selectionEnd: 0,\n        /**\n     * Color of text selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(17,119,255,0.3)\",\n        /**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */ isEditing: false,\n        /**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */ editable: true,\n        /**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */ editingBorderColor: \"rgba(102,153,255,0.25)\",\n        /**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */ cursorWidth: 2,\n        /**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */ cursorColor: \"\",\n        /**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */ cursorDelay: 1000,\n        /**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */ cursorDuration: 600,\n        /**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */ caching: true,\n        /**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */ hiddenTextareaContainer: null,\n        /**\n     * @private\n     */ _reSpace: /\\s|\\n/,\n        /**\n     * @private\n     */ _currentCursorOpacity: 0,\n        /**\n     * @private\n     */ _selectionDirection: null,\n        /**\n     * @private\n     */ _abortCursorAnimation: false,\n        /**\n     * @private\n     */ __widthOfSpace: [],\n        /**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */ inCompositionMode: false,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */ initialize: function(text, options) {\n            this.callSuper(\"initialize\", text, options);\n            this.initBehavior();\n        },\n        /**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */ setSelectionStart: function(index) {\n            index = Math.max(index, 0);\n            this._updateAndFire(\"selectionStart\", index);\n        },\n        /**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */ setSelectionEnd: function(index) {\n            index = Math.min(index, this.text.length);\n            this._updateAndFire(\"selectionEnd\", index);\n        },\n        /**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */ _updateAndFire: function(property, index) {\n            if (this[property] !== index) {\n                this._fireSelectionChanged();\n                this[property] = index;\n            }\n            this._updateTextarea();\n        },\n        /**\n     * Fires the even of selection changed\n     * @private\n     */ _fireSelectionChanged: function() {\n            this.fire(\"selection:changed\");\n            this.canvas && this.canvas.fire(\"text:selection:changed\", {\n                target: this\n            });\n        },\n        /**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */ initDimensions: function() {\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this.callSuper(\"initDimensions\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            this.clearContextTop();\n            this.callSuper(\"render\", ctx);\n            // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n            // the correct position but not at every cursor animation.\n            this.cursorOffsetCache = {};\n            this.renderCursorOrSelection();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            this.callSuper(\"_render\", ctx);\n        },\n        /**\n     * Prepare and clean the contextTop\n     */ clearContextTop: function(skipRestore) {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this.transform(ctx);\n            this._clearTextArea(ctx);\n            skipRestore || ctx.restore();\n        },\n        /**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */ renderCursorOrSelection: function() {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;\n            this.clearContextTop(true);\n            if (this.selectionStart === this.selectionEnd) {\n                this.renderCursor(boundaries, ctx);\n            } else {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.restore();\n        },\n        _clearTextArea: function(ctx) {\n            // we add 4 pixel, to be sure to do not leave any pixel out\n            var width = this.width + 4, height = this.height + 4;\n            ctx.clearRect(-width / 2, -height / 2, width, height);\n        },\n        /**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */ _getCursorBoundaries: function(position) {\n            // left/top are left/top of entire text box\n            // leftOffset/topOffset are offset from that left/top point of a text box\n            if (typeof position === \"undefined\") {\n                position = this.selectionStart;\n            }\n            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position);\n            return {\n                left: left,\n                top: top,\n                leftOffset: offsets.left,\n                topOffset: offsets.top\n            };\n        },\n        /**\n     * @private\n     */ _getCursorBoundariesOffsets: function(position) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) {\n                return this.cursorOffsetCache;\n            }\n            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position);\n            charIndex = cursorPosition.charIndex;\n            lineIndex = cursorPosition.lineIndex;\n            for(var i = 0; i < lineIndex; i++){\n                topOffset += this.getHeightOfLine(i);\n            }\n            lineLeftOffset = this._getLineLeftOffset(lineIndex);\n            var bound = this.__charBounds[lineIndex][charIndex];\n            bound && (leftOffset = bound.left);\n            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\n                leftOffset -= this._getWidthOfCharSpacing();\n            }\n            boundaries = {\n                top: topOffset,\n                left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)\n            };\n            if (this.direction === \"rtl\") {\n                boundaries.left *= -1;\n            }\n            this.cursorOffsetCache = boundaries;\n            return this.cursorOffsetCache;\n        },\n        /**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderCursor: function(boundaries, ctx) {\n            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, \"deltaY\");\n            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);\n            if (this.inCompositionMode) {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, \"fill\");\n            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\n            ctx.fillRect(boundaries.left + boundaries.leftOffset - cursorWidth / 2, topOffset + boundaries.top + dy, cursorWidth, charHeight);\n        },\n        /**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderSelection: function(boundaries, ctx) {\n            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf(\"justify\") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;\n            for(var i = startLine; i <= endLine; i++){\n                var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;\n                if (i === startLine) {\n                    boxStart = this.__charBounds[startLine][startChar].left;\n                }\n                if (i >= startLine && i < endLine) {\n                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?\n                } else if (i === endLine) {\n                    if (endChar === 0) {\n                        boxEnd = this.__charBounds[endLine][endChar].left;\n                    } else {\n                        var charSpacing = this._getWidthOfCharSpacing();\n                        boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;\n                    }\n                }\n                realLineHeight = lineHeight;\n                if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {\n                    lineHeight /= this.lineHeight;\n                }\n                var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight, extraTop = 0;\n                if (this.inCompositionMode) {\n                    ctx.fillStyle = this.compositionColor || \"black\";\n                    drawHeight = 1;\n                    extraTop = lineHeight;\n                } else {\n                    ctx.fillStyle = this.selectionColor;\n                }\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - drawWidth;\n                }\n                ctx.fillRect(drawStart, boundaries.top + boundaries.topOffset + extraTop, drawWidth, drawHeight);\n                boundaries.topOffset += realLineHeight;\n            }\n        },\n        /**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */ getCurrentCharFontSize: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fontSize\");\n        },\n        /**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */ getCurrentCharColor: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fill\");\n        },\n        /**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */ _getCurrentCharIndex: function() {\n            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;\n            return {\n                l: cursorPosition.lineIndex,\n                c: charIndex\n            };\n        }\n    });\n    /**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */ fabric.IText.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        parseDecoration(objCopy);\n        if (objCopy.styles) {\n            for(var i in objCopy.styles){\n                for(var j in objCopy.styles[i]){\n                    parseDecoration(objCopy.styles[i][j]);\n                }\n            }\n        }\n        fabric.Object._fromObject(\"IText\", objCopy, callback, \"text\");\n    };\n})();\n(function() {\n    var clone = fabric.util.object.clone;\n    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n        /**\n     * Initializes all the interactive behavior of IText\n     */ initBehavior: function() {\n            this.initAddedHandler();\n            this.initRemovedHandler();\n            this.initCursorSelectionHandlers();\n            this.initDoubleClickSimulation();\n            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function() {\n            this.isEditing && this.exitEditing();\n            this.selected = false;\n        },\n        /**\n     * Initializes \"added\" event handler\n     */ initAddedHandler: function() {\n            var _this = this;\n            this.on(\"added\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    if (!canvas._hasITextHandlers) {\n                        canvas._hasITextHandlers = true;\n                        _this._initCanvasHandlers(canvas);\n                    }\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    canvas._iTextInstances.push(_this);\n                }\n            });\n        },\n        initRemovedHandler: function() {\n            var _this = this;\n            this.on(\"removed\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    fabric.util.removeFromArray(canvas._iTextInstances, _this);\n                    if (canvas._iTextInstances.length === 0) {\n                        canvas._hasITextHandlers = false;\n                        _this._removeCanvasHandlers(canvas);\n                    }\n                }\n            });\n        },\n        /**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */ _initCanvasHandlers: function(canvas) {\n            canvas._mouseUpITextHandler = function() {\n                if (canvas._iTextInstances) {\n                    canvas._iTextInstances.forEach(function(obj) {\n                        obj.__isMousedown = false;\n                    });\n                }\n            };\n            canvas.on(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */ _removeCanvasHandlers: function(canvas) {\n            canvas.off(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * @private\n     */ _tick: function() {\n            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        /**\n     * @private\n     */ _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\n            var tickState;\n            tickState = {\n                isAborted: false,\n                abort: function() {\n                    this.isAborted = true;\n                }\n            };\n            obj.animate(\"_currentCursorOpacity\", targetOpacity, {\n                duration: duration,\n                onComplete: function() {\n                    if (!tickState.isAborted) {\n                        obj[completeMethod]();\n                    }\n                },\n                onChange: function() {\n                    // we do not want to animate a selection, only cursor\n                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\n                        obj.renderCursorOrSelection();\n                    }\n                },\n                abort: function() {\n                    return tickState.isAborted;\n                }\n            });\n            return tickState;\n        },\n        /**\n     * @private\n     */ _onTickComplete: function() {\n            var _this = this;\n            if (this._cursorTimeout1) {\n                clearTimeout(this._cursorTimeout1);\n            }\n            this._cursorTimeout1 = setTimeout(function() {\n                _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, \"_tick\");\n            }, 100);\n        },\n        /**\n     * Initializes delayed cursor\n     */ initDelayedCursor: function(restart) {\n            var _this = this, delay = restart ? 0 : this.cursorDelay;\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this._cursorTimeout2 = setTimeout(function() {\n                _this._tick();\n            }, delay);\n        },\n        /**\n     * Aborts cursor animation and clears all timeouts\n     */ abortCursorAnimation: function() {\n            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;\n            this._currentTickState && this._currentTickState.abort();\n            this._currentTickCompleteState && this._currentTickCompleteState.abort();\n            clearTimeout(this._cursorTimeout1);\n            clearTimeout(this._cursorTimeout2);\n            this._currentCursorOpacity = 0;\n            // to clear just itext area we need to transform the context\n            // it may not be worth it\n            if (shouldClear && canvas) {\n                canvas.clearContext(canvas.contextTop || canvas.contextContainer);\n            }\n        },\n        /**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectAll: function() {\n            this.selectionStart = 0;\n            this.selectionEnd = this._text.length;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Returns selected text\n     * @return {String}\n     */ getSelectedText: function() {\n            return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        /**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            // remove space before cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index--;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            // remove space after cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index++;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            while(!/\\n/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            while(!/\\n/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */ searchWordBoundary: function(selectionStart, direction) {\n            var text = this._text, index = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index], // wrong\n            reNonWord = fabric.reNonWord;\n            while(!reNonWord.test(_char) && index > 0 && index < text.length){\n                index += direction;\n                _char = text[index];\n            }\n            if (reNonWord.test(_char)) {\n                index += direction === 1 ? 0 : 1;\n            }\n            return index;\n        },\n        /**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */ selectWord: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */ newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */ \n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            this.renderCursorOrSelection();\n        },\n        /**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectLine: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);\n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ enterEditing: function(e) {\n            if (this.isEditing || !this.editable) {\n                return;\n            }\n            if (this.canvas) {\n                this.canvas.calcOffset();\n                this.exitEditingOnOthers(this.canvas);\n            }\n            this.isEditing = true;\n            this.initHiddenTextarea(e);\n            this.hiddenTextarea.focus();\n            this.hiddenTextarea.value = this.text;\n            this._updateTextarea();\n            this._saveEditingProps();\n            this._setEditingProps();\n            this._textBeforeEdit = this.text;\n            this._tick();\n            this.fire(\"editing:entered\");\n            this._fireSelectionChanged();\n            if (!this.canvas) {\n                return this;\n            }\n            this.canvas.fire(\"text:editing:entered\", {\n                target: this\n            });\n            this.initMouseMoveHandler();\n            this.canvas.requestRenderAll();\n            return this;\n        },\n        exitEditingOnOthers: function(canvas) {\n            if (canvas._iTextInstances) {\n                canvas._iTextInstances.forEach(function(obj) {\n                    obj.selected = false;\n                    if (obj.isEditing) {\n                        obj.exitEditing();\n                    }\n                });\n            }\n        },\n        /**\n     * Initializes \"mousemove\" event handler\n     */ initMouseMoveHandler: function() {\n            this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        /**\n     * @private\n     */ mouseMoveHandler: function(options) {\n            if (!this.__isMousedown || !this.isEditing) {\n                return;\n            }\n            // regain focus\n            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();\n            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;\n            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {\n                return;\n            }\n            if (newSelectionStart > this.__selectionStartOnMouseDown) {\n                this.selectionStart = this.__selectionStartOnMouseDown;\n                this.selectionEnd = newSelectionStart;\n            } else {\n                this.selectionStart = newSelectionStart;\n                this.selectionEnd = this.__selectionStartOnMouseDown;\n            }\n            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\n                this.restartCursorIfNeeded();\n                this._fireSelectionChanged();\n                this._updateTextarea();\n                this.renderCursorOrSelection();\n            }\n        },\n        /**\n     * @private\n     */ _setEditingProps: function() {\n            this.hoverCursor = \"text\";\n            if (this.canvas) {\n                this.canvas.defaultCursor = this.canvas.moveCursor = \"text\";\n            }\n            this.borderColor = this.editingBorderColor;\n            this.hasControls = this.selectable = false;\n            this.lockMovementX = this.lockMovementY = true;\n        },\n        /**\n     * convert from textarea to grapheme indexes\n     */ fromStringToGraphemeSelection: function(start, end, text) {\n            var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * convert from fabric to textarea values\n     */ fromGraphemeToStringSelection: function(start, end, _text) {\n            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join(\"\").length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join(\"\").length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * @private\n     */ _updateTextarea: function() {\n            this.cursorOffsetCache = {};\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            if (!this.inCompositionMode) {\n                var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n                this.hiddenTextarea.selectionStart = newSelection.selectionStart;\n                this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateFromTextArea: function() {\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            this.cursorOffsetCache = {};\n            this.text = this.hiddenTextarea.value;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            var newSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;\n            if (!this.inCompositionMode) {\n                this.selectionStart = newSelection.selectionStart;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateTextareaPosition: function() {\n            if (this.selectionStart === this.selectionEnd) {\n                var style = this._calcTextareaPosition();\n                this.hiddenTextarea.style.left = style.left;\n                this.hiddenTextarea.style.top = style.top;\n            }\n        },\n        /**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */ _calcTextareaPosition: function() {\n            if (!this.canvas) {\n                return {\n                    x: 1,\n                    y: 1\n                };\n            }\n            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {\n                x: boundaries.left + leftOffset,\n                y: boundaries.top + boundaries.topOffset + charHeight\n            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;\n            p = fabric.util.transformPoint(p, m);\n            p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\n            p.x *= scaleX;\n            p.y *= scaleY;\n            if (p.x < 0) {\n                p.x = 0;\n            }\n            if (p.x > maxWidth) {\n                p.x = maxWidth;\n            }\n            if (p.y < 0) {\n                p.y = 0;\n            }\n            if (p.y > maxHeight) {\n                p.y = maxHeight;\n            }\n            // add canvas offset on document\n            p.x += this.canvas._offset.left;\n            p.y += this.canvas._offset.top;\n            return {\n                left: p.x + \"px\",\n                top: p.y + \"px\",\n                fontSize: charHeight + \"px\",\n                charHeight: charHeight\n            };\n        },\n        /**\n     * @private\n     */ _saveEditingProps: function() {\n            this._savedProps = {\n                hasControls: this.hasControls,\n                borderColor: this.borderColor,\n                lockMovementX: this.lockMovementX,\n                lockMovementY: this.lockMovementY,\n                hoverCursor: this.hoverCursor,\n                selectable: this.selectable,\n                defaultCursor: this.canvas && this.canvas.defaultCursor,\n                moveCursor: this.canvas && this.canvas.moveCursor\n            };\n        },\n        /**\n     * @private\n     */ _restoreEditingProps: function() {\n            if (!this._savedProps) {\n                return;\n            }\n            this.hoverCursor = this._savedProps.hoverCursor;\n            this.hasControls = this._savedProps.hasControls;\n            this.borderColor = this._savedProps.borderColor;\n            this.selectable = this._savedProps.selectable;\n            this.lockMovementX = this._savedProps.lockMovementX;\n            this.lockMovementY = this._savedProps.lockMovementY;\n            if (this.canvas) {\n                this.canvas.defaultCursor = this._savedProps.defaultCursor;\n                this.canvas.moveCursor = this._savedProps.moveCursor;\n            }\n        },\n        /**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ exitEditing: function() {\n            var isTextChanged = this._textBeforeEdit !== this.text;\n            var hiddenTextarea = this.hiddenTextarea;\n            this.selected = false;\n            this.isEditing = false;\n            this.selectionEnd = this.selectionStart;\n            if (hiddenTextarea) {\n                hiddenTextarea.blur && hiddenTextarea.blur();\n                hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);\n            }\n            this.hiddenTextarea = null;\n            this.abortCursorAnimation();\n            this._restoreEditingProps();\n            this._currentCursorOpacity = 0;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            this.fire(\"editing:exited\");\n            isTextChanged && this.fire(\"modified\");\n            if (this.canvas) {\n                this.canvas.off(\"mouse:move\", this.mouseMoveHandler);\n                this.canvas.fire(\"text:editing:exited\", {\n                    target: this\n                });\n                isTextChanged && this.canvas.fire(\"object:modified\", {\n                    target: this\n                });\n            }\n            return this;\n        },\n        /**\n     * @private\n     */ _removeExtraneousStyles: function() {\n            for(var prop in this.styles){\n                if (!this._textLines[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */ removeStyleFromTo: function(start, end) {\n            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;\n            if (lineStart !== lineEnd) {\n                // step1 remove the trailing of lineStart\n                if (this.styles[lineStart]) {\n                    for(i = charStart; i < this._unwrappedTextLines[lineStart].length; i++){\n                        delete this.styles[lineStart][i];\n                    }\n                }\n                // step2 move the trailing of lineEnd to lineStart if needed\n                if (this.styles[lineEnd]) {\n                    for(i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++){\n                        styleObj = this.styles[lineEnd][i];\n                        if (styleObj) {\n                            this.styles[lineStart] || (this.styles[lineStart] = {});\n                            this.styles[lineStart][charStart + i - charEnd] = styleObj;\n                        }\n                    }\n                }\n                // step3 detects lines will be completely removed.\n                for(i = lineStart + 1; i <= lineEnd; i++){\n                    delete this.styles[i];\n                }\n                // step4 shift remaining lines.\n                this.shiftLineStyles(lineEnd, lineStart - lineEnd);\n            } else {\n                // remove and shift left on the same line\n                if (this.styles[lineStart]) {\n                    styleObj = this.styles[lineStart];\n                    var diff = charEnd - charStart, numericChar, _char;\n                    for(i = charStart; i < charEnd; i++){\n                        delete styleObj[i];\n                    }\n                    for(_char in this.styles[lineStart]){\n                        numericChar = parseInt(_char, 10);\n                        if (numericChar >= charEnd) {\n                            styleObj[numericChar - diff] = styleObj[_char];\n                            delete styleObj[_char];\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */ shiftLineStyles: function(lineIndex, offset) {\n            // shift all line styles by offset upward or downward\n            // do not clone deep. we need new array, not new style objects\n            var clonedStyles = clone(this.styles);\n            for(var line in this.styles){\n                var numericLine = parseInt(line, 10);\n                if (numericLine > lineIndex) {\n                    this.styles[numericLine + offset] = clonedStyles[numericLine];\n                    if (!clonedStyles[numericLine - offset]) {\n                        delete this.styles[numericLine];\n                    }\n                }\n            }\n        },\n        restartCursorIfNeeded: function() {\n            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {\n                this.initDelayedCursor();\n            }\n        },\n        /**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */ insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {\n            var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;\n            qty || (qty = 1);\n            this.shiftLineStyles(lineIndex, qty);\n            if (this.styles[lineIndex]) {\n                currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];\n            }\n            // we clone styles of all chars\n            // after cursor onto the current line\n            for(var index in this.styles[lineIndex]){\n                var numIndex = parseInt(index, 10);\n                if (numIndex >= charIndex) {\n                    somethingAdded = true;\n                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];\n                    // remove lines from the previous line since they're on a new line now\n                    if (!(isEndOfLine && charIndex === 0)) {\n                        delete this.styles[lineIndex][index];\n                    }\n                }\n            }\n            var styleCarriedOver = false;\n            if (somethingAdded && !isEndOfLine) {\n                // if is end of line, the extra style we copied\n                // is probably not something we want\n                this.styles[lineIndex + qty] = newLineStyles;\n                styleCarriedOver = true;\n            }\n            if (styleCarriedOver) {\n                // skip the last line of since we already prepared it.\n                qty--;\n            }\n            // for the all the lines or all the other lines\n            // we clone current char style onto the next (otherwise empty) line\n            while(qty > 0){\n                if (copiedStyle && copiedStyle[qty - 1]) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(copiedStyle[qty - 1])\n                    };\n                } else if (currentCharStyle) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(currentCharStyle)\n                    };\n                } else {\n                    delete this.styles[lineIndex + qty];\n                }\n                qty--;\n            }\n            this._forceClearCache = true;\n        },\n        /**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */ insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {\n            if (!this.styles) {\n                this.styles = {};\n            }\n            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};\n            quantity || (quantity = 1);\n            // shift all char styles by quantity forward\n            // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\n            for(var index in currentLineStylesCloned){\n                var numericIndex = parseInt(index, 10);\n                if (numericIndex >= charIndex) {\n                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];\n                    // only delete the style if there was nothing moved there\n                    if (!currentLineStylesCloned[numericIndex - quantity]) {\n                        delete currentLineStyles[numericIndex];\n                    }\n                }\n            }\n            this._forceClearCache = true;\n            if (copiedStyle) {\n                while(quantity--){\n                    if (!Object.keys(copiedStyle[quantity]).length) {\n                        continue;\n                    }\n                    if (!this.styles[lineIndex]) {\n                        this.styles[lineIndex] = {};\n                    }\n                    this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);\n                }\n                return;\n            }\n            if (!currentLineStyles) {\n                return;\n            }\n            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];\n            while(newStyle && quantity--){\n                this.styles[lineIndex][charIndex + quantity] = clone(newStyle);\n            }\n        },\n        /**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */ insertNewStyleBlock: function(insertedText, start, copiedStyle) {\n            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [\n                0\n            ], linesLength = 0;\n            // get an array of how many char per lines are being added.\n            for(var i = 0; i < insertedText.length; i++){\n                if (insertedText[i] === \"\\n\") {\n                    linesLength++;\n                    addedLines[linesLength] = 0;\n                } else {\n                    addedLines[linesLength]++;\n                }\n            }\n            // for the first line copy the style from the current char position.\n            if (addedLines[0] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);\n            }\n            linesLength && this.insertNewlineStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);\n            for(var i = 1; i < linesLength; i++){\n                if (addedLines[i] > 0) {\n                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n                } else if (copiedStyle) {\n                    // this test is required in order to close #6841\n                    // when a pasted buffer begins with a newline then\n                    // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]\n                    // may be undefined for some reason\n                    if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {\n                        this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];\n                    }\n                }\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);\n            }\n            // we use i outside the loop to get it like linesLength\n            if (addedLines[i] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n            }\n        },\n        /**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */ setSelectionStartEndWithShift: function(start, end, newSelection) {\n            if (newSelection <= start) {\n                if (end === start) {\n                    this._selectionDirection = \"left\";\n                } else if (this._selectionDirection === \"right\") {\n                    this._selectionDirection = \"left\";\n                    this.selectionEnd = start;\n                }\n                this.selectionStart = newSelection;\n            } else if (newSelection > start && newSelection < end) {\n                if (this._selectionDirection === \"right\") {\n                    this.selectionEnd = newSelection;\n                } else {\n                    this.selectionStart = newSelection;\n                }\n            } else {\n                // newSelection is > selection start and end\n                if (end === start) {\n                    this._selectionDirection = \"right\";\n                } else if (this._selectionDirection === \"left\") {\n                    this._selectionDirection = \"right\";\n                    this.selectionStart = end;\n                }\n                this.selectionEnd = newSelection;\n            }\n        },\n        setSelectionInBoundaries: function() {\n            var length = this.text.length;\n            if (this.selectionStart > length) {\n                this.selectionStart = length;\n            } else if (this.selectionStart < 0) {\n                this.selectionStart = 0;\n            }\n            if (this.selectionEnd > length) {\n                this.selectionEnd = length;\n            } else if (this.selectionEnd < 0) {\n                this.selectionEnd = 0;\n            }\n        }\n    });\n})();\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes \"dbclick\" event handler\n   */ initDoubleClickSimulation: function() {\n        // for double click\n        this.__lastClickTime = +new Date();\n        // for triple click\n        this.__lastLastClickTime = +new Date();\n        this.__lastPointer = {};\n        this.on(\"mousedown\", this.onMouseDown);\n    },\n    /**\n   * Default event handler to simulate triple click\n   * @private\n   */ onMouseDown: function(options) {\n        if (!this.canvas) {\n            return;\n        }\n        this.__newClickTime = +new Date();\n        var newPointer = options.pointer;\n        if (this.isTripleClick(newPointer)) {\n            this.fire(\"tripleclick\", options);\n            this._stopEvent(options.e);\n        }\n        this.__lastLastClickTime = this.__lastClickTime;\n        this.__lastClickTime = this.__newClickTime;\n        this.__lastPointer = newPointer;\n        this.__lastIsEditing = this.isEditing;\n        this.__lastSelected = this.selected;\n    },\n    isTripleClick: function(newPointer) {\n        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;\n    },\n    /**\n   * @private\n   */ _stopEvent: function(e) {\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n    },\n    /**\n   * Initializes event handlers related to cursor or selection\n   */ initCursorSelectionHandlers: function() {\n        this.initMousedownHandler();\n        this.initMouseupHandler();\n        this.initClicks();\n    },\n    /**\n   * Default handler for double click, select a word\n   */ doubleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectWord(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Default handler for triple click, select a line\n   */ tripleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectLine(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Initializes double and triple click event handlers\n   */ initClicks: function() {\n        this.on(\"mousedblclick\", this.doubleClickHandler);\n        this.on(\"tripleclick\", this.tripleClickHandler);\n    },\n    /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */ _mouseDownHandler: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        this.__isMousedown = true;\n        if (this.selected) {\n            this.inCompositionMode = false;\n            this.setCursorByClick(options.e);\n        }\n        if (this.isEditing) {\n            this.__selectionStartOnMouseDown = this.selectionStart;\n            if (this.selectionStart === this.selectionEnd) {\n                this.abortCursorAnimation();\n            }\n            this.renderCursorOrSelection();\n        }\n    },\n    /**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */ _mouseDownHandlerBefore: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        // we want to avoid that an object that was selected and then becomes unselectable,\n        // may trigger editing mode in some way.\n        this.selected = this === this.canvas._activeObject;\n    },\n    /**\n   * Initializes \"mousedown\" event handler\n   */ initMousedownHandler: function() {\n        this.on(\"mousedown\", this._mouseDownHandler);\n        this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n    },\n    /**\n   * Initializes \"mouseup\" event handler\n   */ initMouseupHandler: function() {\n        this.on(\"mouseup\", this.mouseUpHandler);\n    },\n    /**\n   * standard handler for mouse up, overridable\n   * @private\n   */ mouseUpHandler: function(options) {\n        this.__isMousedown = false;\n        if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        if (this.canvas) {\n            var currentActive = this.canvas._activeObject;\n            if (currentActive && currentActive !== this) {\n                // avoid running this logic when there is an active object\n                // this because is possible with shift click and fast clicks,\n                // to rapidly deselect and reselect this object and trigger an enterEdit\n                return;\n            }\n        }\n        if (this.__lastSelected && !this.__corner) {\n            this.selected = false;\n            this.__lastSelected = false;\n            this.enterEditing(options.e);\n            if (this.selectionStart === this.selectionEnd) {\n                this.initDelayedCursor(true);\n            } else {\n                this.renderCursorOrSelection();\n            }\n        } else {\n            this.selected = true;\n        }\n    },\n    /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */ setCursorByClick: function(e) {\n        var newSelection = this.getSelectionStartFromPointer(e), start = this.selectionStart, end = this.selectionEnd;\n        if (e.shiftKey) {\n            this.setSelectionStartEndWithShift(start, end, newSelection);\n        } else {\n            this.selectionStart = newSelection;\n            this.selectionEnd = newSelection;\n        }\n        if (this.isEditing) {\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */ getSelectionStartFromPointer: function(e) {\n        var mouseOffset = this.getLocalPointer(e), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;\n        for(var i = 0, len = this._textLines.length; i < len; i++){\n            if (height <= mouseOffset.y) {\n                height += this.getHeightOfLine(i) * this.scaleY;\n                lineIndex = i;\n                if (i > 0) {\n                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n                }\n            } else {\n                break;\n            }\n        }\n        lineLeftOffset = this._getLineLeftOffset(lineIndex);\n        width = lineLeftOffset * this.scaleX;\n        line = this._textLines[lineIndex];\n        // handling of RTL: in order to get things work correctly,\n        // we assume RTL writing is mirrored compared to LTR writing.\n        // so in position detection we mirror the X offset, and when is time\n        // of rendering it, we mirror it again.\n        if (this.direction === \"rtl\") {\n            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;\n        }\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            prevWidth = width;\n            // i removed something about flipX here, check.\n            width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;\n            if (width <= mouseOffset.x) {\n                charIndex++;\n            } else {\n                break;\n            }\n        }\n        return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);\n    },\n    /**\n   * @private\n   */ _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\n        // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\n        var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index + offset;\n        // if object is horizontally flipped, mirror cursor location from the end\n        if (this.flipX) {\n            newSelectionStart = jlen - newSelectionStart;\n        }\n        if (newSelectionStart > this._text.length) {\n            newSelectionStart = this._text.length;\n        }\n        return newSelectionStart;\n    }\n});\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */ initHiddenTextarea: function() {\n        this.hiddenTextarea = fabric.document.createElement(\"textarea\");\n        this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\");\n        this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\");\n        this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\");\n        this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n        var style = this._calcTextareaPosition();\n        // line-height: 1px; was removed from the style to fix this:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n        this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + style.top + \"; left: \" + style.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;\" + \" padding-top: \" + style.fontSize + \";\";\n        if (this.hiddenTextareaContainer) {\n            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);\n        } else {\n            fabric.document.body.appendChild(this.hiddenTextarea);\n        }\n        fabric.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this));\n        if (!this._clickHandlerInitialized && this.canvas) {\n            fabric.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this));\n            this._clickHandlerInitialized = true;\n        }\n    },\n    /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */ keysMap: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorRight\",\n        36: \"moveCursorLeft\",\n        37: \"moveCursorLeft\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorRight\",\n        40: \"moveCursorDown\"\n    },\n    keysMapRtl: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorLeft\",\n        36: \"moveCursorRight\",\n        37: \"moveCursorRight\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorLeft\",\n        40: \"moveCursorDown\"\n    },\n    /**\n   * For functionalities on keyUp + ctrl || cmd\n   */ ctrlKeysMapUp: {\n        67: \"copy\",\n        88: \"cut\"\n    },\n    /**\n   * For functionalities on keyDown + ctrl || cmd\n   */ ctrlKeysMapDown: {\n        65: \"selectAll\"\n    },\n    onClick: function() {\n        // No need to trigger click event here, focus is enough to have the keyboard appear on Android\n        this.hiddenTextarea && this.hiddenTextarea.focus();\n    },\n    /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */ onKeyDown: function(e) {\n        if (!this.isEditing) {\n            return;\n        }\n        var keyMap = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n        if (e.keyCode in keyMap) {\n            this[keyMap[e.keyCode]](e);\n        } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapDown[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        if (e.keyCode >= 33 && e.keyCode <= 40) {\n            // if i press an arrow key just update selection\n            this.inCompositionMode = false;\n            this.clearContextTop();\n            this.renderCursorOrSelection();\n        } else {\n            this.canvas && this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */ onKeyUp: function(e) {\n        if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n            this._copyDone = false;\n            return;\n        }\n        if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapUp[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        this.canvas && this.canvas.requestRenderAll();\n    },\n    /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */ onInput: function(e) {\n        var fromPaste = this.fromPaste;\n        this.fromPaste = false;\n        e && e.stopPropagation();\n        if (!this.isEditing) {\n            return;\n        }\n        // decisions about style changes.\n        var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;\n        if (this.hiddenTextarea.value === \"\") {\n            this.styles = {};\n            this.updateFromTextArea();\n            this.fire(\"changed\");\n            if (this.canvas) {\n                this.canvas.fire(\"text:changed\", {\n                    target: this\n                });\n                this.canvas.requestRenderAll();\n            }\n            return;\n        }\n        var textareaSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n        var backDelete = selectionStart > textareaSelection.selectionStart;\n        if (selection) {\n            removedText = this._text.slice(selectionStart, selectionEnd);\n            charDiff += selectionEnd - selectionStart;\n        } else if (nextCharCount < charCount) {\n            if (backDelete) {\n                removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);\n            } else {\n                removedText = this._text.slice(selectionStart, selectionStart - charDiff);\n            }\n        }\n        insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);\n        if (removedText && removedText.length) {\n            if (insertedText.length) {\n                // let's copy some style before deleting.\n                // we want to copy the style before the cursor OR the style at the cursor if selection\n                // is bigger than 0.\n                copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);\n                // now duplicate the style one for each inserted text.\n                copiedStyle = insertedText.map(function() {\n                    // this return an array of references, but that is fine since we are\n                    // copying the style later.\n                    return copiedStyle[0];\n                });\n            }\n            if (selection) {\n                removeFrom = selectionStart;\n                removeTo = selectionEnd;\n            } else if (backDelete) {\n                // detect differences between forwardDelete and backDelete\n                removeFrom = selectionEnd - removedText.length;\n                removeTo = selectionEnd;\n            } else {\n                removeFrom = selectionEnd;\n                removeTo = selectionEnd + removedText.length;\n            }\n            this.removeStyleFromTo(removeFrom, removeTo);\n        }\n        if (insertedText.length) {\n            if (fromPaste && insertedText.join(\"\") === fabric.copiedText && !fabric.disableStyleCopyPaste) {\n                copiedStyle = fabric.copiedTextStyle;\n            }\n            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);\n        }\n        this.updateFromTextArea();\n        this.fire(\"changed\");\n        if (this.canvas) {\n            this.canvas.fire(\"text:changed\", {\n                target: this\n            });\n            this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Composition start\n   */ onCompositionStart: function() {\n        this.inCompositionMode = true;\n    },\n    /**\n   * Composition end\n   */ onCompositionEnd: function() {\n        this.inCompositionMode = false;\n    },\n    // /**\n    //  * Composition update\n    //  */\n    onCompositionUpdate: function(e) {\n        this.compositionStart = e.target.selectionStart;\n        this.compositionEnd = e.target.selectionEnd;\n        this.updateTextareaPosition();\n    },\n    /**\n   * Copies selected text\n   * @param {Event} e Event object\n   */ copy: function() {\n        if (this.selectionStart === this.selectionEnd) {\n            //do not cut-copy if no selection\n            return;\n        }\n        fabric.copiedText = this.getSelectedText();\n        if (!fabric.disableStyleCopyPaste) {\n            fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);\n        } else {\n            fabric.copiedTextStyle = null;\n        }\n        this._copyDone = true;\n    },\n    /**\n   * Pastes text\n   * @param {Event} e Event object\n   */ paste: function() {\n        this.fromPaste = true;\n    },\n    /**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */ _getClipboardData: function(e) {\n        return e && e.clipboardData || fabric.window.clipboardData;\n    },\n    /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */ _getWidthBeforeCursor: function(lineIndex, charIndex) {\n        var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;\n        if (charIndex > 0) {\n            bound = this.__charBounds[lineIndex][charIndex - 1];\n            widthBeforeCursor += bound.left + bound.width;\n        }\n        return widthBeforeCursor;\n    },\n    /**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getDownCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        // if on last line, down cursor goes to end of line\n        if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\n            // move to the end of a text\n            return this._text.length - selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n        return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);\n    },\n    /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ _getSelectionForOffset: function(e, isRight) {\n        if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n            return this.selectionEnd;\n        } else {\n            return this.selectionStart;\n        }\n    },\n    /**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getUpCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n            // if on first line, up cursor goes to start of line\n            return -selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n        // return a negative offset\n        return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);\n    },\n    /**\n   * for a given width it founds the matching character.\n   * @private\n   */ _getIndexOnLine: function(lineIndex, width) {\n        var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            charWidth = this.__charBounds[lineIndex][j].width;\n            widthOfCharsOnLine += charWidth;\n            if (widthOfCharsOnLine > width) {\n                foundMatch = true;\n                var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);\n                indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n                break;\n            }\n        }\n        // reached end\n        if (!foundMatch) {\n            indexOnLine = line.length - 1;\n        }\n        return indexOnLine;\n    },\n    /**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */ moveCursorDown: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Down\", e);\n    },\n    /**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */ moveCursorUp: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Up\", e);\n    },\n    /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */ _moveCursorUpOrDown: function(direction, e) {\n        // getUpCursorOffset\n        // getDownCursorOffset\n        var action = \"get\" + direction + \"CursorOffset\", offset = this[action](e, this._selectionDirection === \"right\");\n        if (e.shiftKey) {\n            this.moveCursorWithShift(offset);\n        } else {\n            this.moveCursorWithoutShift(offset);\n        }\n        if (offset !== 0) {\n            this.setSelectionInBoundaries();\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */ moveCursorWithShift: function(offset) {\n        var newSelection = this._selectionDirection === \"left\" ? this.selectionStart + offset : this.selectionEnd + offset;\n        this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */ moveCursorWithoutShift: function(offset) {\n        if (offset < 0) {\n            this.selectionStart += offset;\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionEnd += offset;\n            this.selectionStart = this.selectionEnd;\n        }\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */ moveCursorLeft: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Left\", e);\n    },\n    /**\n   * @private\n   * @return {Boolean} true if a change happened\n   */ _move: function(e, prop, direction) {\n        var newValue;\n        if (e.altKey) {\n            newValue = this[\"findWordBoundary\" + direction](this[prop]);\n        } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n            newValue = this[\"findLineBoundary\" + direction](this[prop]);\n        } else {\n            this[prop] += direction === \"Left\" ? -1 : 1;\n            return true;\n        }\n        if (typeof newValue !== \"undefined\" && this[prop] !== newValue) {\n            this[prop] = newValue;\n            return true;\n        }\n    },\n    /**\n   * @private\n   */ _moveLeft: function(e, prop) {\n        return this._move(e, prop, \"Left\");\n    },\n    /**\n   * @private\n   */ _moveRight: function(e, prop) {\n        return this._move(e, prop, \"Right\");\n    },\n    /**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithoutShift: function(e) {\n        var change = true;\n        this._selectionDirection = \"left\";\n        // only move cursor when there is no selection,\n        // otherwise we discard it, and leave cursor on same place\n        if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\n            change = this._moveLeft(e, \"selectionStart\");\n        }\n        this.selectionEnd = this.selectionStart;\n        return change;\n    },\n    /**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithShift: function(e) {\n        if (this._selectionDirection === \"right\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveLeft(e, \"selectionEnd\");\n        } else if (this.selectionStart !== 0) {\n            this._selectionDirection = \"left\";\n            return this._moveLeft(e, \"selectionStart\");\n        }\n    },\n    /**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */ moveCursorRight: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Right\", e);\n    },\n    /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */ _moveCursorLeftOrRight: function(direction, e) {\n        var actionName = \"moveCursor\" + direction + \"With\";\n        this._currentCursorOpacity = 1;\n        if (e.shiftKey) {\n            actionName += \"Shift\";\n        } else {\n            actionName += \"outShift\";\n        }\n        if (this[actionName](e)) {\n            this.abortCursorAnimation();\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */ moveCursorRightWithShift: function(e) {\n        if (this._selectionDirection === \"left\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveRight(e, \"selectionStart\");\n        } else if (this.selectionEnd !== this._text.length) {\n            this._selectionDirection = \"right\";\n            return this._moveRight(e, \"selectionEnd\");\n        }\n    },\n    /**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */ moveCursorRightWithoutShift: function(e) {\n        var changed = true;\n        this._selectionDirection = \"right\";\n        if (this.selectionStart === this.selectionEnd) {\n            changed = this._moveRight(e, \"selectionStart\");\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionStart = this.selectionEnd;\n        }\n        return changed;\n    },\n    /**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ removeChars: function(start, end) {\n        if (typeof end === \"undefined\") {\n            end = start + 1;\n        }\n        this.removeStyleFromTo(start, end);\n        this._text.splice(start, end - start);\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    },\n    /**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ insertChars: function(text, style, start, end) {\n        if (typeof end === \"undefined\") {\n            end = start;\n        }\n        if (end > start) {\n            this.removeStyleFromTo(start, end);\n        }\n        var graphemes = fabric.util.string.graphemeSplit(text);\n        this.insertNewStyleBlock(graphemes, start, style);\n        this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    var toFixed = fabric.util.toFixed, multipleSpacesRegex = /  +/g;\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function() {\n            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\n            return this._wrapSVGTextAndBg(textAndBg);\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                noStyle: true,\n                withShadow: true\n            });\n        },\n        /**\n     * @private\n     */ _getSVGLeftTopOffsets: function() {\n            return {\n                textLeft: -this.width / 2,\n                textTop: -this.height / 2,\n                lineTop: this.getHeightOfLine(0)\n            };\n        },\n        /**\n     * @private\n     */ _wrapSVGTextAndBg: function(textAndBg) {\n            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);\n            return [\n                textAndBg.textBgRects.join(\"\"),\n                '\t\t<text xml:space=\"preserve\" ',\n                this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\",\n                this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\",\n                this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\",\n                this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\",\n                textDecoration ? 'text-decoration=\"' + textDecoration + '\" ' : \"\",\n                'style=\"',\n                this.getSvgStyles(noShadow),\n                '\"',\n                this.addPaintOrder(),\n                \" >\",\n                textAndBg.textSpans.join(\"\"),\n                \"</text>\\n\"\n            ];\n        },\n        /**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */ _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\n            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;\n            // bounding-box background\n            this._setSVGBg(textBgRects);\n            // text and text-background\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineOffset = this._getLineLeftOffset(i);\n                if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", i)) {\n                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);\n                }\n                this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);\n                height += this.getHeightOfLine(i);\n            }\n            return {\n                textSpans: textSpans,\n                textBgRects: textBgRects\n            };\n        },\n        /**\n     * @private\n     */ _createTextCharSpan: function(_char, styleDecl, left, top) {\n            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style=\"' + styleProps + '\"' : \"\", dy = styleDecl.deltaY, dySpan = \"\", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (dy) {\n                dySpan = ' dy=\"' + toFixed(dy, NUM_FRACTION_DIGITS) + '\" ';\n            }\n            return [\n                '<tspan x=\"',\n                toFixed(left, NUM_FRACTION_DIGITS),\n                '\" y=\"',\n                toFixed(top, NUM_FRACTION_DIGITS),\n                '\" ',\n                dySpan,\n                fillStyles,\n                \">\",\n                fabric.util.string.escapeXml(_char),\n                \"</tspan>\"\n            ].join(\"\");\n        },\n        _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;\n            textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    textLeftOffset += charBox.kernedWidth - charBox.width;\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, true);\n                }\n                if (timeToRender) {\n                    style = this._getStyleDeclaration(lineIndex, i) || {};\n                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    textLeftOffset += boxWidth;\n                    boxWidth = 0;\n                }\n            }\n        },\n        _pushTextBgRect: function(textBgRects, color, left, top, width, height) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            textBgRects.push(\"\t\t<rect \", this._getFillAttributes(color), ' x=\"', toFixed(left, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(top, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {\n            var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n            for(var j = 0, jlen = line.length; j < jlen; j++){\n                charBox = this.__charBounds[i][j];\n                currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                if (currentColor !== lastColor) {\n                    lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n                    boxStart = charBox.left;\n                    boxWidth = charBox.width;\n                    lastColor = currentColor;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n            }\n            currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n        },\n        /**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */ _getFillAttributes: function(value) {\n            var fillColor = value && typeof value === \"string\" ? new fabric.Color(value) : \"\";\n            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\n                return 'fill=\"' + value + '\"';\n            }\n            return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\n        },\n        /**\n     * @private\n     */ _getSVGLineTopOffset: function(lineIndex) {\n            var lineTopOffset = 0, lastHeight = 0;\n            for(var j = 0; j < lineIndex; j++){\n                lineTopOffset += this.getHeightOfLine(j);\n            }\n            lastHeight = this.getHeightOfLine(j);\n            return {\n                lineTop: lineTopOffset,\n                offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\n            };\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);\n            return svgStyle + \" white-space: pre;\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    /**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */ fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"textbox\",\n        /**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */ minWidth: 20,\n        /**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */ dynamicMinWidth: 2,\n        /**\n     * Cached array of text wrapping.\n     * @type Array\n     */ __cachedLines: null,\n        /**\n     * Override standard Object class values\n     */ lockScalingFlip: true,\n        /**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */ noScaleCache: false,\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */ _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n        /**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */ _wordJoiners: /[ \\t\\r]/,\n        /**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */ splitByGrapheme: false,\n        /**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this._clearCache();\n            // clear dynamicMinWidth as it will be different after we re-wrap line\n            this.dynamicMinWidth = 0;\n            // wrap lines\n            this._styleMap = this._generateStyleMap(this._splitText());\n            // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n            if (this.dynamicMinWidth > this.width) {\n                this._set(\"width\", this.dynamicMinWidth);\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            // clear cache and re-calculate height\n            this.height = this.calcTextHeight();\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */ _generateStyleMap: function(textInfo) {\n            var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};\n            for(var i = 0; i < textInfo.graphemeLines.length; i++){\n                if (textInfo.graphemeText[charCount] === \"\\n\" && i > 0) {\n                    realLineCharCount = 0;\n                    charCount++;\n                    realLineCount++;\n                } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {\n                    // this case deals with space's that are removed from end of lines when wrapping\n                    realLineCharCount++;\n                    charCount++;\n                }\n                map[i] = {\n                    line: realLineCount,\n                    offset: realLineCharCount\n                };\n                charCount += textInfo.graphemeLines[i].length;\n                realLineCharCount += textInfo.graphemeLines[i].length;\n            }\n            return map;\n        },\n        /**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (map) {\n                    lineIndex = map.line;\n                }\n            }\n            return fabric.Text.prototype.styleHas.call(this, property, lineIndex);\n        },\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];\n            if (map) {\n                lineIndex = map.line;\n                offset = map.offset;\n            }\n            if (mapNextLine) {\n                nextLineIndex = mapNextLine.line;\n                shouldLimit = nextLineIndex === lineIndex;\n                nextOffset = mapNextLine.offset;\n            }\n            obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {\n                        // eslint-disable-next-line no-unused-vars\n                        for(var p3 in obj[p1][p2]){\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (!map) {\n                    return null;\n                }\n                lineIndex = map.line;\n                charIndex = map.offset + charIndex;\n            }\n            return this.callSuper(\"_getStyleDeclaration\", lineIndex, charIndex);\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            return !!this.styles[map.line];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            this.styles[map.line] = {};\n        },\n        /**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */ _wrapText: function(lines, desiredWidth) {\n            var wrapped = [], i;\n            this.isWrapping = true;\n            for(i = 0; i < lines.length; i++){\n                wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));\n            }\n            this.isWrapping = false;\n            return wrapped;\n        },\n        /**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */ _measureWord: function(word, lineIndex, charOffset) {\n            var width = 0, prevGrapheme, skipLeft = true;\n            charOffset = charOffset || 0;\n            for(var i = 0, len = word.length; i < len; i++){\n                var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);\n                width += box.kernedWidth;\n                prevGrapheme = word[i];\n            }\n            return width;\n        },\n        /**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */ _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {\n            var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], // spaces in different languages?\n            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = \"\", offset = 0, infix = splitByGrapheme ? \"\" : \" \", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;\n            // fix a difference between split and graphemeSplit\n            if (words.length === 0) {\n                words.push([]);\n            }\n            desiredWidth -= reservedSpace;\n            for(var i = 0; i < words.length; i++){\n                // if using splitByGrapheme words are already in graphemes.\n                word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);\n                wordWidth = this._measureWord(word, lineIndex, offset);\n                offset += word.length;\n                lineWidth += infixWidth + wordWidth - additionalSpace;\n                if (lineWidth > desiredWidth && !lineJustStarted) {\n                    graphemeLines.push(line);\n                    line = [];\n                    lineWidth = wordWidth;\n                    lineJustStarted = true;\n                } else {\n                    lineWidth += additionalSpace;\n                }\n                if (!lineJustStarted && !splitByGrapheme) {\n                    line.push(infix);\n                }\n                line = line.concat(word);\n                infixWidth = splitByGrapheme ? 0 : this._measureWord([\n                    infix\n                ], lineIndex, offset);\n                offset++;\n                lineJustStarted = false;\n                // keep track of largest word\n                if (wordWidth > largestWordWidth) {\n                    largestWordWidth = wordWidth;\n                }\n            }\n            i && graphemeLines.push(line);\n            if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n                this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n            }\n            return graphemeLines;\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            if (!this._styleMap[lineIndex + 1]) {\n                // is last line, return true;\n                return true;\n            }\n            if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n                // this is last line before a line break, return true;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * @return Number\n     */ missingNewlineOffset: function(lineIndex) {\n            if (this.splitByGrapheme) {\n                return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n            }\n            return 1;\n        },\n        /**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */ _splitTextIntoLines: function(text) {\n            var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);\n            for(var i = 0; i < graphemeLines.length; i++){\n                lines[i] = graphemeLines[i].join(\"\");\n            }\n            newText.lines = lines;\n            newText.graphemeLines = graphemeLines;\n            return newText;\n        },\n        getMinWidth: function() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n        },\n        _removeExtraneousStyles: function() {\n            var linesToKeep = {};\n            for(var prop in this._styleMap){\n                if (this._textLines[prop]) {\n                    linesToKeep[this._styleMap[prop].line] = 1;\n                }\n            }\n            for(var prop in this.styles){\n                if (!linesToKeep[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"minWidth\",\n                \"splitByGrapheme\"\n            ].concat(propertiesToInclude));\n        }\n    });\n    /**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */ fabric.Textbox.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        return fabric.Object._fromObject(\"Textbox\", objCopy, callback, \"text\");\n    };\n})( true ? exports : 0);\n(function() {\n    var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;\n    objectControls.ml = new fabric.Control({\n        x: -0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mr = new fabric.Control({\n        x: 0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mb = new fabric.Control({\n        x: 0,\n        y: 0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mt = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.tl = new fabric.Control({\n        x: -0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.tr = new fabric.Control({\n        x: 0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.bl = new fabric.Control({\n        x: -0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.br = new fabric.Control({\n        x: 0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.mtr = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        actionHandler: controlsUtils.rotationWithSnapping,\n        cursorStyleHandler: controlsUtils.rotationStyleHandler,\n        offsetY: -40,\n        withConnection: true,\n        actionName: \"rotate\"\n    });\n    if (fabric.Textbox) {\n        // this is breaking the prototype inheritance, no time / ideas to fix it.\n        // is important to document that if you want to have all objects to have a\n        // specific custom control, you have to add it to Object prototype and to Textbox\n        // prototype. The controls are shared as references. So changes to control `tr`\n        // can still apply to all objects if needed.\n        var textBoxControls = fabric.Textbox.prototype.controls = {};\n        textBoxControls.mtr = objectControls.mtr;\n        textBoxControls.tr = objectControls.tr;\n        textBoxControls.br = objectControls.br;\n        textBoxControls.tl = objectControls.tl;\n        textBoxControls.bl = objectControls.bl;\n        textBoxControls.mt = objectControls.mt;\n        textBoxControls.mb = objectControls.mb;\n        textBoxControls.mr = new fabric.Control({\n            x: 0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n        textBoxControls.ml = new fabric.Control({\n            x: -0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFHQUFxRyxHQUNyRywyRUFBMkUsR0FFM0UsSUFBSUEsU0FBU0EsVUFBVTtJQUFFQyxTQUFTO0FBQVE7QUFDMUMsSUFBSSxJQUFtQixFQUFhO0lBQ2xDQyxjQUFjLEdBQUdGO0FBQ25CLE9BRUssRUFFSjtBQUNELGFBQWEsR0FDYixJQUFJLE9BQU9LLGFBQWEsZUFBZSxnQkFBa0IsYUFBYSxFQVFyRSxNQUNJO0lBQ0gsMEVBQTBFO0lBQzFFLElBQUlNLFFBQVFDLG1CQUFPQSxDQUFDO0lBQ3BCLElBQUlDLGdCQUFnQixJQUFJRixNQUFNRyxLQUFLLENBQ2pDQyxtQkFBbUIsK0ZBQ25CO1FBQ0VDLFVBQVU7WUFDUkMsd0JBQXdCO2dCQUFDO2FBQU07UUFDakM7UUFDQUMsV0FBVztJQUNiLEdBQUdSLE1BQU07SUFDWFYsT0FBT0ssUUFBUSxHQUFHUSxjQUFjUixRQUFRO0lBQ3hDTCxPQUFPbUIsbUJBQW1CLEdBQUdQLG9KQUFnRTtJQUM3RlosT0FBT3FCLFVBQVUsR0FBR1QsMEdBQXVDO0lBQzNEWixPQUFPVSxNQUFNLEdBQUdHO0lBQ2hCVSxZQUFZdkIsT0FBT1UsTUFBTSxDQUFDYSxTQUFTO0FBQ3JDO0FBRUE7OztDQUdDLEdBQ0R2QixPQUFPd0IsZ0JBQWdCLEdBQUcsa0JBQWtCeEIsT0FBT1UsTUFBTSxJQUFJLGtCQUFrQlYsT0FBT0ssUUFBUSxJQUMzRkwsT0FBT1UsTUFBTSxJQUFJVixPQUFPVSxNQUFNLENBQUNlLFNBQVMsSUFBSXpCLE9BQU9VLE1BQU0sQ0FBQ2UsU0FBUyxDQUFDQyxjQUFjLEdBQUc7QUFFeEY7OztDQUdDLEdBQ0QxQixPQUFPMkIsWUFBWSxHQUFHLE9BQU9DLFdBQVcsZUFDbEIsZ0JBQWtCO0FBRXhDLG9CQUFvQixHQUNwQjs7O0NBR0MsR0FDRDVCLE9BQU82QixpQkFBaUIsR0FBRztJQUN6QjtJQUNBO0lBQ0E7SUFBUTtJQUFn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LFNBQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFFBQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLGNBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxzQkFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGNBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLGdCQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFFBQXNCO1FBQ3RCQyxrQkFBc0I7UUFD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aUZBQWlGO1FBQ2pGLCtFQUErRTtRQUMvRSw0Q0FBNEM7UUFDNUMsSUFBSXlDLGtCQUFrQi8xRyxPQUFPc3pHLE9BQU8sQ0FBQ3A1RixTQUFTLENBQUMwMUIsUUFBUSxHQUFHLENBQUU7UUFFNURtbUUsZ0JBQWdCRCxHQUFHLEdBQUdKLGVBQWVJLEdBQUc7UUFDeENDLGdCQUFnQi82RCxFQUFFLEdBQUcwNkQsZUFBZTE2RCxFQUFFO1FBQ3RDKzZELGdCQUFnQjc2RCxFQUFFLEdBQUd3NkQsZUFBZXg2RCxFQUFFO1FBQ3RDNjZELGdCQUFnQmg3RCxFQUFFLEdBQUcyNkQsZUFBZTM2RCxFQUFFO1FBQ3RDZzdELGdCQUFnQjk2RCxFQUFFLEdBQUd5NkQsZUFBZXo2RCxFQUFFO1FBQ3RDODZELGdCQUFnQm4zRixFQUFFLEdBQUc4MkYsZUFBZTkyRixFQUFFO1FBQ3RDbTNGLGdCQUFnQkYsRUFBRSxHQUFHSCxlQUFlRyxFQUFFO1FBRXRDRSxnQkFBZ0JILEVBQUUsR0FBRyxJQUFJNTFHLE9BQU84NEMsT0FBTyxDQUFDO1lBQ3RDdHVDLEdBQUc7WUFDSEMsR0FBRztZQUNIa29DLGVBQWUyRSxjQUFjWCxXQUFXO1lBQ3hDNkMsb0JBQW9CZzhEO1lBQ3BCejhELFlBQVk7UUFDZDtRQUVBZzlELGdCQUFnQkosRUFBRSxHQUFHLElBQUkzMUcsT0FBTzg0QyxPQUFPLENBQUM7WUFDdEN0dUMsR0FBRyxDQUFDO1lBQ0pDLEdBQUc7WUFDSGtvQyxlQUFlMkUsY0FBY1gsV0FBVztZQUN4QzZDLG9CQUFvQmc4RDtZQUNwQno4RCxZQUFZO1FBQ2Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlnbWEvLi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzP2I5NzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogYnVpbGQ6IGBub2RlIGJ1aWxkLmpzIG1vZHVsZXM9QUxMIGV4Y2x1ZGU9Z2VzdHVyZXMsYWNjZXNzb3JzLGVyYXNpbmcgcmVxdWlyZWpzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuLyohIEZhYnJpYy5qcyBDb3B5cmlnaHQgMjAwOC0yMDE1LCBQcmludGlvIChKdXJpeSBaYXl0c2V2LCBNYXhpbSBDaGVybnlhaykgKi9cblxudmFyIGZhYnJpYyA9IGZhYnJpYyB8fCB7IHZlcnNpb246ICc1LjMuMCcgfTtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5mYWJyaWMgPSBmYWJyaWM7XG59XG4vKiBfQU1EX1NUQVJUXyAqL1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWJyaWM7IH0pO1xufVxuLyogX0FNRF9FTkRfICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiAodHlwZW9mIEhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRG9jdW1lbnQgOiBEb2N1bWVudCkpIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgfVxuICBlbHNlIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICB9XG4gIGZhYnJpYy53aW5kb3cgPSB3aW5kb3c7XG59XG5lbHNlIHtcbiAgLy8gYXNzdW1lIHdlJ3JlIHJ1bm5pbmcgdW5kZXIgbm9kZS5qcyB3aGVuIGRvY3VtZW50L3dpbmRvdyBhcmUgbm90IHByZXNlbnRcbiAgdmFyIGpzZG9tID0gcmVxdWlyZSgnanNkb20nKTtcbiAgdmFyIHZpcnR1YWxXaW5kb3cgPSBuZXcganNkb20uSlNET00oXG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KCclM0MhRE9DVFlQRSUyMGh0bWwlM0UlM0NodG1sJTNFJTNDaGVhZCUzRSUzQyUyRmhlYWQlM0UlM0Nib2R5JTNFJTNDJTJGYm9keSUzRSUzQyUyRmh0bWwlM0UnKSxcbiAgICB7XG4gICAgICBmZWF0dXJlczoge1xuICAgICAgICBGZXRjaEV4dGVybmFsUmVzb3VyY2VzOiBbJ2ltZyddXG4gICAgICB9LFxuICAgICAgcmVzb3VyY2VzOiAndXNhYmxlJ1xuICAgIH0pLndpbmRvdztcbiAgZmFicmljLmRvY3VtZW50ID0gdmlydHVhbFdpbmRvdy5kb2N1bWVudDtcbiAgZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscycpLmltcGxGb3JXcmFwcGVyO1xuICBmYWJyaWMubm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS91dGlscycpLkNhbnZhcztcbiAgZmFicmljLndpbmRvdyA9IHZpcnR1YWxXaW5kb3c7XG4gIERPTVBhcnNlciA9IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyO1xufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy53aW5kb3cgfHwgJ29udG91Y2hzdGFydCcgaW4gZmFicmljLmRvY3VtZW50IHx8XG4gIChmYWJyaWMud2luZG93ICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCk7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICAnZGlzcGxheScsXG4gICd0cmFuc2Zvcm0nLFxuICAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJyxcbiAgJ29wYWNpdHknLFxuICAnc3Ryb2tlJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsXG4gICdpZCcsICdwYWludC1vcmRlcicsICd2ZWN0b3ItZWZmZWN0JyxcbiAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLCAnY2xpcC1wYXRoJyxcbl07XG4vKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4vKipcbiAqIFBpeGVsIHBlciBJbmNoIGFzIGEgZGVmYXVsdCB2YWx1ZSBzZXQgdG8gOTYuIENhbiBiZSBjaGFuZ2VkIGZvciBtb3JlIHJlYWxpc3RpYyBjb252ZXJzaW9uLlxuICovXG5mYWJyaWMuRFBJID0gOTY7XG5mYWJyaWMucmVOdW0gPSAnKD86Wy0rXT8oPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W2VFXVstK10/XFxcXGQrKT8pJztcbmZhYnJpYy5jb21tYVdzcCA9ICcoPzpcXFxccyssP1xcXFxzKnwsXFxcXHMqKSc7XG5mYWJyaWMucmVQYXRoQ29tbWFuZCA9IC8oWy0rXT8oKFxcZCtcXC5cXGQrKXwoKFxcZCspfChcXC5cXGQrKSkpKD86W2VFXVstK10/XFxkKyk/KS9pZztcbmZhYnJpYy5yZU5vbldvcmQgPSAvWyBcXG5cXC4sOyFcXD9cXC1dLztcbmZhYnJpYy5mb250UGF0aHMgPSB7IH07XG5mYWJyaWMuaU1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmZhYnJpYy5zdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBXaGVuICd0cnVlJywgc3R5bGUgaW5mb3JtYXRpb24gaXMgbm90IHJldGFpbmVkIHdoZW4gY29weS9wYXN0aW5nIHRleHQsIG1ha2luZ1xuICogcGFzdGVkIHRleHQgdXNlIGRlc3RpbmF0aW9uIHN0eWxlLlxuICogRGVmYXVsdHMgdG8gJ2ZhbHNlJy5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUgPSBmYWxzZTtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIGFyYyB0byBiZXppZXIgY29udmVyc2lvbiBmb3IgZmFzdGVyIHJldHJpZXZpbmcgaWYgdGhlIHNhbWUgYXJjIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCBhZ2Fpbi5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5hcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogVGhpcyBvYmplY3Qga2VlcHMgdGhlIHJlc3VsdHMgb2YgdGhlIGJvdW5kc09mQ3VydmUgY2FsY3VsYXRpb24gbWFwcGVkIGJ5IHRoZSBqb2luZWQgYXJndW1lbnRzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgaXQuXG4gKiBJdCBkb2VzIHNwZWVkIHVwIGNhbGN1bGF0aW9uLCBpZiB5b3UgcGFyc2UgYW5kIGFkZCBhbHdheXMgdGhlIHNhbWUgcGF0aHMsIGJ1dCBpbiBjYXNlIG9mIGhlYXZ5IHVzYWdlIG9mIGZyZWVkcmF3aW5nXG4gKiB5b3UgZG8gbm90IGdldCBhbnkgc3BlZWQgYmVuZWZpdCBhbmQgeW91IGdldCBhIGJpZyBvYmplY3QgaW4gbWVtb3J5LlxuICogVGhlIG9iamVjdCB3YXMgYSBwcml2YXRlIHZhcmlhYmxlIGJlZm9yZSwgd2hpbGUgbm93IGlzIGFwcGVuZGVkIHRvIHRoZSBsaWIgc28gdGhhdCB5b3UgaGF2ZSBhY2Nlc3MgdG8gaXQgYW5kIHlvdVxuICogY2FuIGV2ZW50dWFsbHkgY2xlYXIgaXQuXG4gKiBJdCB3YXMgYW4gaW50ZXJuYWwgdmFyaWFibGUsIGlzIGFjY2Vzc2libGUgc2luY2UgdmVyc2lvbiAyLjMuNFxuICovXG5mYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlID0geyB9O1xuXG4vKipcbiAqIElmIGRpc2FibGVkIGJvdW5kc09mQ3VydmVDYWNoZSBpcyBub3QgdXNlZC4gRm9yIGFwcHMgdGhhdCBtYWtlIGhlYXZ5IHVzYWdlIG9mIHBlbmNpbCBkcmF3aW5nIHByb2JhYmx5IGRpc2FibGluZyBpdCBpcyBiZXR0ZXJcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUgPSB0cnVlO1xuXG4vKipcbiAqIFNraXAgcGVyZm9ybWFuY2UgdGVzdGluZyBvZiBzZXR1cEdMQ29udGV4dCBhbmQgZm9yY2UgdGhlIHVzZSBvZiBwdXRJbWFnZURhdGEgdGhhdCBzZWVtcyB0byBiZSB0aGUgb25lIHRoYXQgd29ya3MgYmVzdCBvblxuICogQ2hyb21lICsgb2xkIGhhcmR3YXJlLiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZW1wdHkgaW1hZ2VzIGFmdGVyIGZpbHRlcmluZyB5b3UgbWF5IHRyeSB0byBmb3JjZSB0aGlzIHRvIHRydWVcbiAqIHRoaXMgaGFzIHRvIGJlIHNldCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgZmlsdGVyaW5nIGJhY2tlbmQgKCBiZWZvcmUgZmlsdGVyaW5nIHRoZSBmaXJzdCBpbWFnZSApXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5mYWJyaWMuZm9yY2VHTFB1dEltYWdlRGF0YSA9IGZhbHNlO1xuXG5mYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZChmYWJyaWMudGV4dHVyZVNpemUpKSB7XG4gICAgY29uc29sZS5sb2coJ21heCB0ZXh0dXJlIHNpemU6ICcgKyBmYWJyaWMubWF4VGV4dHVyZVNpemUpO1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQoeyB0aWxlU2l6ZTogZmFicmljLnRleHR1cmVTaXplIH0pKTtcbiAgfVxuICBlbHNlIGlmIChmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKSB7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCgpKTtcbiAgfVxufTtcblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBlbnN1cmUgZ2xvYmFsaXR5IGV2ZW4gaWYgZW50aXJlIGxpYnJhcnkgd2VyZSBmdW5jdGlvbiB3cmFwcGVkIChhcyBpbiBNZXRlb3IuanMgcGFja2FnaW5nIHN5c3RlbSlcbiAgd2luZG93LmZhYnJpYyA9IGZhYnJpYztcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBldmVudExpc3RlbmVyW2V2ZW50TGlzdGVuZXIuaW5kZXhPZihoYW5kbGVyKV0gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hcnJheS5maWxsKGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXMgc3BlY2lmaWVkIGV2ZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb25cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVycyA9IHsgfTtcbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24ocHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHZhciBfaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgX2hhbmRsZXIpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uKGV2ZW50TmFtZSwgX2hhbmRsZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgX29uY2UuY2FsbCh0aGlzLCBwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9vbmNlLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXZlbnQgb2JzZXJ2aW5nIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgaGFuZGxlci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB3aXRob3V0IGFyZ3VtZW50cyByZW1vdmVzIGFsbCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9mZlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gYmUgZGVsZXRlZCBmcm9tIEV2ZW50TGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIGtleS92YWx1ZSBwYWlycyAoZXZlbnQgbmFtZSAtPiBldmVudCBoYW5kbGVyKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBldmVudCB3aXRoIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZmlyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyZShldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVyc0ZvckV2ZW50ID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnNGb3JFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc0ZvckV2ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNGb3JFdmVudFtpXSAmJiBsaXN0ZW5lcnNGb3JFdmVudFtpXS5jYWxsKHRoaXMsIG9wdGlvbnMgfHwgeyB9KTtcbiAgICB9XG4gICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBsaXN0ZW5lcnNGb3JFdmVudC5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNldmVudHN9XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZXZlbnRzfEV2ZW50cyBkZW1vfVxuICAgKi9cbiAgZmFicmljLk9ic2VydmFibGUgPSB7XG4gICAgZmlyZTogZmlyZSxcbiAgICBvbjogb24sXG4gICAgb25jZTogb25jZSxcbiAgICBvZmY6IG9mZixcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db2xsZWN0aW9uXG4gKi9cbmZhYnJpYy5Db2xsZWN0aW9uID0ge1xuXG4gIF9vYmplY3RzOiBbXSxcblxuICAvKipcbiAgICogQWRkcyBvYmplY3RzIHRvIGNvbGxlY3Rpb24sIENhbnZhcyBvciBHcm91cCwgdGhlbiByZW5kZXJzIGNhbnZhc1xuICAgKiAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYCkuXG4gICAqIGluIGNhc2Ugb2YgR3JvdXAgbm8gY2hhbmdlcyB0byBib3VuZGluZyBib3ggYXJlIG1hZGUuXG4gICAqIE9iamVjdHMgc2hvdWxkIGJlIGluc3RhbmNlcyBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgYWRkIG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb2JqZWN0cy5wdXNoLmFwcGx5KHRoaXMuX29iamVjdHMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX29uT2JqZWN0QWRkZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb25PYmplY3RBZGRlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIGNvbGxlY3Rpb24gYXQgc3BlY2lmaWVkIGluZGV4LCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBBbiBvYmplY3Qgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBpbnNlcnRBdCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBvYmplY3QgYXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBub25TcGxpY2luZyBXaGVuIGB0cnVlYCwgbm8gc3BsaWNpbmcgKHNoaWZ0aW5nKSBvZiBvYmplY3RzIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGluc2VydEF0OiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgbm9uU3BsaWNpbmcpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgaWYgKG5vblNwbGljaW5nKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IG9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5fb25PYmplY3RBZGRlZCAmJiB0aGlzLl9vbk9iamVjdEFkZGVkKG9iamVjdCk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBvYmplY3RzIGZyb20gYSBjb2xsZWN0aW9uLCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogc2luY2UgMi4zLjUgdGhpcyBtZXRob2QgcmV0dXJuIGFsd2F5cyBhIENPUFkgb2YgdGhlIGFycmF5O1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFdoZW4gc3BlY2lmaWVkLCBvbmx5IG9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSByZXR1cm5lZFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldE9iamVjdHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IGF0IHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKi9cbiAgaXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHNbaW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBubyBvYmplY3RzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwPWZhbHNlXSBgdHJ1ZWAgdG8gY2hlY2sgYWxsIGRlc2NlbmRhbnRzLCBgZmFsc2VgIHRvIGNoZWNrIG9ubHkgYF9vYmplY3RzYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICovXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqZWN0LCBkZWVwKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWVwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5zb21lKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmouY29udGFpbnMgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnRhaW5zKG9iamVjdCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnJlbnQpIHtcbiAgICAgIG1lbW8gKz0gY3VycmVudC5jb21wbGV4aXR5ID8gY3VycmVudC5jb21wbGV4aXR5KCkgOiAwO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db21tb25NZXRob2RzXG4gKi9cbmZhYnJpYy5Db21tb25NZXRob2RzID0ge1xuXG4gIC8qKlxuICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIF9zZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldChwcm9wLCBvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIEdyYWRpZW50IHRvXG4gICAqL1xuICBfaW5pdEdyYWRpZW50OiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5KSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuY29sb3JTdG9wcyAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLkdyYWRpZW50KGZpbGxlcikpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgUGF0dGVybiB0b1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBwYXR0ZXJuIGxvYWRcbiAgICovXG4gIF9pbml0UGF0dGVybjogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5zb3VyY2UgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLlBhdHRlcm4oZmlsbGVyLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlcyBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBgdHJ1ZWAgdG8gYGZhbHNlYCBvciBmcm9tIGBmYWxzZWAgdG8gYHRydWVgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byB0b2dnbGVcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQocHJvcGVydHkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksICF2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCYXNpYyBnZXR0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Kn0gdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgfVxufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgIFBpQnkxODAgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgUGlCeTIgPSBNYXRoLlBJIC8gMjtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbFxuICAgKi9cbiAgZmFicmljLnV0aWwgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvcyBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNvczogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAvLyBjb3MoYSkgPSBjb3MoLWEpXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xuICAgICAgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyO1xuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogY2FzZSAzOiByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5jb3MoYW5nbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpbiBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNpbjogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyLCBzaWduID0gMTtcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gc2luKC1hKSA9IC1zaW4oYSlcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIHNpZ247XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIC1zaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc2luKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgICAqIFByZXNlbmNlIG9mIHZhbHVlIChhbmQgaXRzIHBvc2l0aW9uIGluIGFuIGFycmF5KSBpcyBkZXRlcm1pbmVkIHZpYSBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvcmlnaW5hbCBhcnJheVxuICAgICAqL1xuICAgIHJlbW92ZUZyb21BcnJheTogZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gbnVtYmVyIGJldHdlZW4gMiBzcGVjaWZpZWQgb25lcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBsb3dlciBsaW1pdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggdXBwZXIgbGltaXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJhbmRvbSB2YWx1ZSAoYmV0d2VlbiBtaW4gYW5kIG1heClcbiAgICAgKi9cbiAgICBnZXRSYW5kb21JbnQ6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzIHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBkZWdyZWVzVG9SYWRpYW5zOiBmdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgICByZXR1cm4gZGVncmVlcyAqIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICovXG4gICAgcmFkaWFuc1RvRGVncmVlczogZnVuY3Rpb24ocmFkaWFucykge1xuICAgICAgcmV0dXJuIHJhZGlhbnMgLyBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGBwb2ludGAgYXJvdW5kIGBvcmlnaW5gIHdpdGggYHJhZGlhbnNgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpbiwgcmFkaWFucykge1xuICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludC54IC0gb3JpZ2luLngsIHBvaW50LnkgLSBvcmlnaW4ueSksXG4gICAgICAgICAgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihuZXdQb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZXRvciBmcm9tIHBvaW50cyByZXByZXNlbnRlZCBhcyBhIHBvaW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBmcm9tXG4gICAgICogQHBhcmFtIHtQb2ludH0gdG9cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHZlY3RvclxuICAgICAqL1xuICAgIGNyZWF0ZVZlY3RvcjogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh0by54IC0gZnJvbS54LCB0by55IC0gZnJvbS55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmdsZSBiZXR3ZWVuIDIgdmVjdG9ycyB1c2luZyBkb3QgcHJvZHVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBhXG4gICAgICogQHBhcmFtIHtQb2ludH0gYlxuICAgICAqIEByZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW4gYmV0d2VlbiB0aGUgdmVjdG9yc1xuICAgICAqL1xuICAgIGNhbGNBbmdsZUJldHdlZW5WZWN0b3JzOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGguYWNvcygoYS54ICogYi54ICsgYS55ICogYi55KSAvIChNYXRoLmh5cG90KGEueCwgYS55KSAqIE1hdGguaHlwb3QoYi54LCBiLnkpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSB2XG4gICAgICogQHJldHVybnMge1BvaW50fSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB1bml0IHZlY3RvciBvZiBwb2ludGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIGB2YFxuICAgICAqL1xuICAgIGdldEhhdFZlY3RvcjogZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCwgdi55KS5tdWx0aXBseSgxIC8gTWF0aC5oeXBvdCh2LngsIHYueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludH0gQVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IEJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBDXG4gICAgICogQHJldHVybnMge3sgdmVjdG9yOiBQb2ludCwgYW5nbGU6IG51bWJlciB9fSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBiaXNlY3RvciBvZiBBIGFuZCBBJ3MgYW5nbGVcbiAgICAgKi9cbiAgICBnZXRCaXNlY3RvcjogZnVuY3Rpb24gKEEsIEIsIEMpIHtcbiAgICAgIHZhciBBQiA9IGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihBLCBCKSwgQUMgPSBmYWJyaWMudXRpbC5jcmVhdGVWZWN0b3IoQSwgQyk7XG4gICAgICB2YXIgYWxwaGEgPSBmYWJyaWMudXRpbC5jYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyhBQiwgQUMpO1xuICAgICAgLy8gIGNoZWNrIGlmIGFscGhhIGlzIHJlbGF0aXZlIHRvIEFCLT5CQ1xuICAgICAgdmFyIHJvID0gZmFicmljLnV0aWwuY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnMoZmFicmljLnV0aWwucm90YXRlVmVjdG9yKEFCLCBhbHBoYSksIEFDKTtcbiAgICAgIHZhciBwaGkgPSBhbHBoYSAqIChybyA9PT0gMCA/IDEgOiAtMSkgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVjdG9yOiBmYWJyaWMudXRpbC5nZXRIYXRWZWN0b3IoZmFicmljLnV0aWwucm90YXRlVmVjdG9yKEFCLCBwaGkpKSxcbiAgICAgICAgYW5nbGU6IGFscGhhXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IHN0cm9rZSB3aWR0aCBvbiBwb2ludHMgcmV0dXJuaW5nIDIgcHJvamVjdGlvbnMgZm9yIGVhY2ggcG9pbnQgYXMgZm9sbG93czpcbiAgICAgKiAtIGBtaXRlcmA6IDIgcG9pbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG91dGVyIGJvdW5kYXJ5IGFuZCB0aGUgaW5uZXIgYm91bmRhcnkgb2Ygc3Ryb2tlLlxuICAgICAqIC0gYGJldmVsYDogMiBwb2ludHMgY29ycmVzcG9uZGluZyB0byB0aGUgYmV2ZWwgYm91bmRhcmllcywgdGFuZ2VudCB0byB0aGUgYmlzZWN0b3IuXG4gICAgICogLSBgcm91bmRgOiBzYW1lIGFzIGBiZXZlbGBcbiAgICAgKiBVc2VkIHRvIGNhbGN1bGF0ZSBvYmplY3QncyBib3VuZGluZyBib3hcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludFtdfSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0cm9rZVdpZHRoXG4gICAgICogQHBhcmFtIHsnbWl0ZXInfCdiZXZlbCd8J3JvdW5kJ30gb3B0aW9ucy5zdHJva2VMaW5lSm9pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0cm9rZU1pdGVyTGltaXQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbWl0ZXJsaW1pdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zdHJva2VVbmlmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2NhbGVZXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3BlblBhdGhdIHdoZXRoZXIgdGhlIHNoYXBlIGlzIG9wZW4gb3Igbm90LCBhZmZlY3RzIHRoZSBjYWxjdWxhdGlvbnMgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuUG9pbnRbXX0gYXJyYXkgb2Ygc2l6ZSAybi80biBvZiBhbGwgc3VzcGVjdGVkIHBvaW50c1xuICAgICAqL1xuICAgIHByb2plY3RTdHJva2VPblBvaW50czogZnVuY3Rpb24gKHBvaW50cywgb3B0aW9ucywgb3BlblBhdGgpIHtcbiAgICAgIHZhciBjb29yZHMgPSBbXSwgcyA9IG9wdGlvbnMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgIHN0cm9rZVVuaWZvcm1TY2FsYXIgPSBvcHRpb25zLnN0cm9rZVVuaWZvcm0gP1xuICAgICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludCgxIC8gb3B0aW9ucy5zY2FsZVgsIDEgLyBvcHRpb25zLnNjYWxlWSkgOiBuZXcgZmFicmljLlBvaW50KDEsIDEpLFxuICAgICAgICAgIGdldFN0cm9rZUhhdFZlY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFyID0gcyAvIChNYXRoLmh5cG90KHYueCwgdi55KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LnggKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLngsIHYueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueSk7XG4gICAgICAgICAgfTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpIHtyZXR1cm4gY29vcmRzO31cbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICB2YXIgQSA9IG5ldyBmYWJyaWMuUG9pbnQocC54LCBwLnkpLCBCLCBDO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBDID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgQiA9IG9wZW5QYXRoID8gZ2V0U3Ryb2tlSGF0VmVjdG9yKGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihDLCBBKSkuYWRkRXF1YWxzKEEpIDogcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBCID0gcG9pbnRzW2luZGV4IC0gMV07XG4gICAgICAgICAgQyA9IG9wZW5QYXRoID8gZ2V0U3Ryb2tlSGF0VmVjdG9yKGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihCLCBBKSkuYWRkRXF1YWxzKEEpIDogcG9pbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIEIgPSBwb2ludHNbaW5kZXggLSAxXTtcbiAgICAgICAgICBDID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpc2VjdG9yID0gZmFicmljLnV0aWwuZ2V0QmlzZWN0b3IoQSwgQiwgQyksXG4gICAgICAgICAgICBiaXNlY3RvclZlY3RvciA9IGJpc2VjdG9yLnZlY3RvcixcbiAgICAgICAgICAgIGFscGhhID0gYmlzZWN0b3IuYW5nbGUsXG4gICAgICAgICAgICBzY2FsYXIsXG4gICAgICAgICAgICBtaXRlclZlY3RvcjtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlTGluZUpvaW4gPT09ICdtaXRlcicpIHtcbiAgICAgICAgICBzY2FsYXIgPSAtcyAvIE1hdGguc2luKGFscGhhIC8gMik7XG4gICAgICAgICAgbWl0ZXJWZWN0b3IgPSBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgICAgYmlzZWN0b3JWZWN0b3IueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCxcbiAgICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnkgKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLnlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChNYXRoLmh5cG90KG1pdGVyVmVjdG9yLngsIG1pdGVyVmVjdG9yLnkpIC8gcyA8PSBvcHRpb25zLnN0cm9rZU1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKEEuYWRkKG1pdGVyVmVjdG9yKSk7XG4gICAgICAgICAgICBjb29yZHMucHVzaChBLnN1YnRyYWN0KG1pdGVyVmVjdG9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjYWxhciA9IC1zICogTWF0aC5TUVJUMjtcbiAgICAgICAgbWl0ZXJWZWN0b3IgPSBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnggKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLngsXG4gICAgICAgICAgYmlzZWN0b3JWZWN0b3IueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueVxuICAgICAgICApO1xuICAgICAgICBjb29yZHMucHVzaChBLmFkZChtaXRlclZlY3RvcikpO1xuICAgICAgICBjb29yZHMucHVzaChBLnN1YnRyYWN0KG1pdGVyVmVjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmb3JtXSBhbiBhcnJheSBvZiA2IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgMngzIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB4UG9pbnRzID0gW3BvaW50c1swXS54LCBwb2ludHNbMV0ueCwgcG9pbnRzWzJdLngsIHBvaW50c1szXS54XSxcbiAgICAgICAgICBtaW5YID0gZmFicmljLnV0aWwuYXJyYXkubWluKHhQb2ludHMpLFxuICAgICAgICAgIG1heFggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeFBvaW50cyksXG4gICAgICAgICAgd2lkdGggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICB5UG9pbnRzID0gW3BvaW50c1swXS55LCBwb2ludHNbMV0ueSwgcG9pbnRzWzJdLnksIHBvaW50c1szXS55XSxcbiAgICAgICAgICBtaW5ZID0gZmFicmljLnV0aWwuYXJyYXkubWluKHlQb2ludHMpLFxuICAgICAgICAgIG1heFkgPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeVBvaW50cyksXG4gICAgICAgICAgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IHRyYW5zZm9ybWF0aW9uIHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBpbnZlcnRlZCB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBpbnZlcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBhID0gMSAvICh0WzBdICogdFszXSAtIHRbMV0gKiB0WzJdKSxcbiAgICAgICAgICByID0gW2EgKiB0WzNdLCAtYSAqIHRbMV0sIC1hICogdFsyXSwgYSAqIHRbMF1dLFxuICAgICAgICAgIG8gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh7IHg6IHRbNF0sIHk6IHRbNV0gfSwgciwgdHJ1ZSk7XG4gICAgICByWzRdID0gLW8ueDtcbiAgICAgIHJbNV0gPSAtby55O1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBhcm91bmQgTnVtYmVyI3RvRml4ZWQsIHdoaWNoIGNvbnRyYXJ5IHRvIG5hdGl2ZSBtZXRob2QgcmV0dXJucyBudW1iZXIsIG5vdCBzdHJpbmcuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYWN0aW9uRGlnaXRzIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gXCJsZWF2ZVwiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRvRml4ZWQ6IGZ1bmN0aW9uKG51bWJlciwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KE51bWJlcihudW1iZXIpLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZnJvbSBhdHRyaWJ1dGUgdmFsdWUgdG8gcGl4ZWwgdmFsdWUgaWYgYXBwbGljYWJsZS5cbiAgICAgKiBSZXR1cm5zIGNvbnZlcnRlZCBwaXhlbHMgb3Igb3JpZ2luYWwgdmFsdWUgbm90IGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplXG4gICAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAgICAgKi9cbiAgICBwYXJzZVVuaXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHVuaXQgPSAvXFxEezAsMn0kLy5leGVjKHZhbHVlKSxcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmICghZm9udFNpemUpIHtcbiAgICAgICAgZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHVuaXRbMF0pIHtcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMjUuNDtcblxuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyLjU0O1xuXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSTtcblxuICAgICAgICBjYXNlICdwdCc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MjsgLy8gb3IgKiA0IC8gM1xuXG4gICAgICAgIGNhc2UgJ3BjJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyICogMTI7IC8vIG9yICogMTZcblxuICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZvbnRTaXplO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmYWxzZUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygb2JqZWN0IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2xhc3MgXCJDbGFzc1wiXG4gICAgICovXG4gICAgZ2V0S2xhc3M6IGZ1bmN0aW9uKHR5cGUsIG5hbWVzcGFjZSkge1xuICAgICAgLy8gY2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb25seVxuICAgICAgdHlwZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYW1lbGl6ZSh0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UpW3R5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIGF0dHJpYnV0ZXMgZm9yIGdpdmVuIHN2ZyB0aGF0IGZhYnJpYyBwYXJzZXNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHN2ZyBlbGVtZW50IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0cmluZyBuYW1lcyBvZiBzdXBwb3J0ZWQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGdldFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAnaW5zdGFudGlhdGVkX2J5X3VzZScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdjbGFzcydcbiAgICAgIF07XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGluZWFyR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlhbEdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0b3AnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ29mZnNldCcsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSBzdHJpbmcgZS5nLiAnZmFicmljLkltYWdlLmZpbHRlcicgb3IgJ2ZhYnJpYydcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBmb3IgZ2l2ZW4gbmFtZXNwYWNlIChkZWZhdWx0IGZhYnJpYylcbiAgICAgKi9cbiAgICByZXNvbHZlTmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcbiAgICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0cyA9IG5hbWVzcGFjZS5zcGxpdCgnLicpLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aCwgaSxcbiAgICAgICAgICBvYmogPSBnbG9iYWwgfHwgZmFicmljLndpbmRvdztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWRzIGltYWdlIGVsZW1lbnQgZnJvbSBnaXZlbiB1cmwgYW5kIHBhc3NlcyBpdCB0byBhIGNhbGxiYWNrXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgcmVwcmVzZW50aW5nIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHNldCBpbWFnZSBlbGVtZW50IHRvXG4gICAgICovXG4gICAgbG9hZEltYWdlOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBjb250ZXh0LCBjcm9zc09yaWdpbikge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCB1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWcgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgdmFyIG9uTG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZywgZmFsc2UpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICAvLyBjcm9zc09yaWdpbiBudWxsIGlzIHRoZSBzYW1lIGFzIG5vdCBzZXQuXG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJlxuICAgICAgICBjcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICAvLyBJRTEwIC8gSUUxMS1GaXg6IFNWRyBjb250ZW50cyBmcm9tIGRhdGE6IFVSSVxuICAgICAgLy8gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgSU1HIGlzIHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSBET00gKGFuZCB2aXNpYmxlKVxuICAgICAgaWYgKHVybC5zdWJzdHJpbmcoMCwxNCkgPT09ICdkYXRhOmltYWdlL3N2ZycpIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZUluRG9tKGltZywgb25Mb2FkQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBTVkcgaW1hZ2Ugd2l0aCBkYXRhOiBVUkwgdG8gdGhlIGRvbVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWcgSW1hZ2Ugb2JqZWN0IHdpdGggZGF0YTppbWFnZS9zdmcgc3JjXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IERPTSBlbGVtZW50IChkaXYgY29udGFpbmluZyB0aGUgU1ZHIGltYWdlKVxuICAgICAqL1xuICAgIGxvYWRJbWFnZUluRG9tOiBmdW5jdGlvbihpbWcsIG9uTG9hZENhbGxiYWNrKSB7XG4gICAgICB2YXIgZGl2ID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgZGl2LnN0eWxlLmxlZnQgPSBkaXYuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIGZhYnJpYy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcCBpbiBmdW5jdGlvbiB0bzpcbiAgICAgICAqICAgMS4gQ2FsbCBleGlzdGluZyBjYWxsYmFja1xuICAgICAgICogICAyLiBDbGVhbnVwIERPTVxuICAgICAgICovXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWRDYWxsYmFjaygpO1xuICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZXNwb25kaW5nIGZhYnJpYyBpbnN0YW5jZXMgZnJvbSB0aGVpciBvYmplY3QgcmVwcmVzZW50YXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgT2JqZWN0cyB0byBlbmxpdmVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9iamVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmV2aXZlciBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBvYmplY3QgZWxlbWVudHMsXG4gICAgICogY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVubGl2ZW5PYmplY3RzOiBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaywgbmFtZXNwYWNlLCByZXZpdmVyKSB7XG4gICAgICBvYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcblxuICAgICAgdmFyIGVubGl2ZW5lZE9iamVjdHMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRPYmplY3RzID0gMCxcbiAgICAgICAgICBudW1Ub3RhbE9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZE9iamVjdHMgPT09IG51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB1bmRlZmluZWQgb2JqZWN0cyAob2JqZWN0cyB0aGF0IGdhdmUgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIHJlc2lkaW5nIGluIGFuIG9iamVjdCwgZS5nLiBgY2xpcFBhdGhgXG4gICAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIGFzc2lnbiBlbmxpdmVkIHByb3BzIHRvIHRoaXMgb2JqZWN0IChwYXNzIG51bGwgdG8gc2tpcCB0aGlzKVxuICAgICAqIEBwYXJhbSB7KG9iamVjdHM6ZmFicmljLk9iamVjdFtdKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGVubGl2ZW5PYmplY3RFbmxpdmFibGVzOiBmdW5jdGlvbiAob2JqZWN0LCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVubGl2ZW5Qcm9wcyA9IGZhYnJpYy5PYmplY3QuRU5MSVZFTl9QUk9QUy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gISFvYmplY3Rba2V5XTsgfSk7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhlbmxpdmVuUHJvcHMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9iamVjdFtrZXldOyB9KSwgZnVuY3Rpb24gKGVubGl2ZWRQcm9wcykge1xuICAgICAgICB2YXIgb2JqZWN0cyA9IHt9O1xuICAgICAgICBlbmxpdmVuUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICAgIG9iamVjdHNba2V5XSA9IGVubGl2ZWRQcm9wc1tpbmRleF07XG4gICAgICAgICAgY29udGV4dCAmJiAoY29udGV4dFtrZXldID0gZW5saXZlZFByb3BzW2luZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhvYmplY3RzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHdhaXQgZm9yIGxvYWRpbmcgb2YgcGF0dGVybnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0dGVybnMgT2JqZWN0cyB0byBlbmxpdmVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9iamVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlblBhdHRlcm5zOiBmdW5jdGlvbihwYXR0ZXJucywgY2FsbGJhY2spIHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRQYXR0ZXJucyA9PT0gbnVtUGF0dGVybnMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRQYXR0ZXJucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVubGl2ZW5lZFBhdHRlcm5zID0gW10sXG4gICAgICAgICAgbnVtTG9hZGVkUGF0dGVybnMgPSAwLFxuICAgICAgICAgIG51bVBhdHRlcm5zID0gcGF0dGVybnMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW51bVBhdHRlcm5zKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXR0ZXJucy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICBpZiAocCAmJiBwLnNvdXJjZSkge1xuICAgICAgICAgIG5ldyBmYWJyaWMuUGF0dGVybihwLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgICAgICBlbmxpdmVuZWRQYXR0ZXJuc1tpbmRleF0gPSBwYXR0ZXJuO1xuICAgICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbmxpdmVuZWRQYXR0ZXJuc1tpbmRleF0gPSBwO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgU1ZHIGVsZW1lbnRzICh1c3VhbGx5IHRob3NlIHJldHJpZXZlZCBmcm9tIFNWRyBkb2N1bWVudClcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgU1ZHIGVsZW1lbnRzIHRvIGdyb3VwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFZhbHVlIHRvIHNldCBzb3VyY2VQYXRoIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdHxmYWJyaWMuR3JvdXB9XG4gICAgICovXG4gICAgZ3JvdXBTVkdFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBvYmplY3Q7XG4gICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtZW50c1swXS5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHNbMF07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgIG9wdGlvbnMuY2VudGVyUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBvcHRpb25zLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IG9wdGlvbnMuaGVpZ2h0IC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMud2lkdGg7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBuZXcgZmFicmljLkdyb3VwKGVsZW1lbnRzLCBvcHRpb25zKTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnNvdXJjZVBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgbmFtZXMgdG8gaW5jbHVkZVxuICAgICAqL1xuICAgIHBvcHVsYXRlV2l0aFByb3BlcnRpZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24sIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQgdGhhdCBpcyBhIGNvcHkgb2YgYW5vdGhlciBhbmQgaXMgYWxzbyBwYWludGVkXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXMgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY29weUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdmFyIG5ld0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIG5ld0NhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgbmV3Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICByZXR1cm4gbmV3Q2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaW5jZSAyLjYuMCBtb3ZlZCBmcm9tIGNhbnZhcyBpbnN0YW5jZSB0byB1dGlsaXR5LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzRWwgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAnanBlZycgb3IgJ3BuZycsIGluIHNvbWUgYnJvd3NlcnMgJ3dlYnAnIGlzIG9rIHRvb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IDw9IDEgYW5kID4gMFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGEgdXJsXG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjYW52YXNFbCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgICByZXR1cm4gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBpbWFnZSBlbGVtZW50ICh3b3JrcyBvbiBjbGllbnQgYW5kIG5vZGUpXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEhUTUwgaW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IG1hdHJpeCBBIGJ5IG1hdHJpeCBCIHRvIG5lc3QgdHJhbnNmb3JtYXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIEZpcnN0IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiIFNlY29uZCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpczJ4MiBmbGFnIHRvIG11bHRpcGx5IG1hdHJpY2VzIGFzIDJ4MiBtYXRyaWNlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcHJvZHVjdCBvZiB0aGUgdHdvIHRyYW5zZm9ybSBtYXRyaWNlc1xuICAgICAqL1xuICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM6IGZ1bmN0aW9uKGEsIGIsIGlzMngyKSB7XG4gICAgICAvLyBNYXRyaXggbXVsdGlwbHkgYSAqIGJcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFbMF0gKiBiWzBdICsgYVsyXSAqIGJbMV0sXG4gICAgICAgIGFbMV0gKiBiWzBdICsgYVszXSAqIGJbMV0sXG4gICAgICAgIGFbMF0gKiBiWzJdICsgYVsyXSAqIGJbM10sXG4gICAgICAgIGFbMV0gKiBiWzJdICsgYVszXSAqIGJbM10sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMF0gKiBiWzRdICsgYVsyXSAqIGJbNV0gKyBhWzRdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzFdICogYls0XSArIGFbM10gKiBiWzVdICsgYVs1XVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBzdGFuZGFyZCAyeDMgbWF0cml4IGludG8gdHJhbnNmb3JtIGNvbXBvbmVudHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHFyRGVjb21wb3NlOiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhdGFuMihhWzFdLCBhWzBdKSxcbiAgICAgICAgICBkZW5vbSA9IHBvdyhhWzBdLCAyKSArIHBvdyhhWzFdLCAyKSxcbiAgICAgICAgICBzY2FsZVggPSBzcXJ0KGRlbm9tKSxcbiAgICAgICAgICBzY2FsZVkgPSAoYVswXSAqIGFbM10gLSBhWzJdICogYVsxXSkgLyBzY2FsZVgsXG4gICAgICAgICAgc2tld1ggPSBhdGFuMihhWzBdICogYVsyXSArIGFbMV0gKiBhIFszXSwgZGVub20pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlIC8gUGlCeTE4MCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1ggLyBQaUJ5MTgwLFxuICAgICAgICBza2V3WTogMCxcbiAgICAgICAgdHJhbnNsYXRlWDogYVs0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogYVs1XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY1JvdGF0ZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHRoZXRhKSxcbiAgICAgICAgICBzaW4gPSBmYWJyaWMudXRpbC5zaW4odGhldGEpO1xuICAgICAgcmV0dXJuIFtjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXQuXG4gICAgICogaXMgY2FsbGVkIERpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXggYmVjYXVzZSB0aG9zZSBwcm9wZXJ0aWVzIGFyZSB0aGUgb25lIHRoYXQgaW5mbHVlbmNlXG4gICAgICogdGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBib3ggb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVldXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFhdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFldXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY0RpbWVuc2lvbnNNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0eXBlb2Ygb3B0aW9ucy5zY2FsZVggPT09ICd1bmRlZmluZWQnID8gMSA6IG9wdGlvbnMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHR5cGVvZiBvcHRpb25zLnNjYWxlWSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0aW9ucy5zY2FsZVksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbXG4gICAgICAgICAgICBvcHRpb25zLmZsaXBYID8gLXNjYWxlWCA6IHNjYWxlWCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3B0aW9ucy5mbGlwWSA/IC1zY2FsZVkgOiBzY2FsZVksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMF0sXG4gICAgICAgICAgbXVsdGlwbHkgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuICAgICAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zO1xuICAgICAgaWYgKG9wdGlvbnMuc2tld1gpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdYKSksIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2tld1kpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdZKSksIDAsIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlTWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVZXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBYXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBZXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnRyYW5zbGF0ZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy50cmFuc2xhdGVZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY29tcG9zZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IFsxLCAwLCAwLCAxLCBvcHRpb25zLnRyYW5zbGF0ZVggfHwgMCwgb3B0aW9ucy50cmFuc2xhdGVZIHx8IDBdLFxuICAgICAgICAgIG11bHRpcGx5ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcztcbiAgICAgIGlmIChvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY1JvdGF0ZU1hdHJpeChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZVggIT09IDEgfHwgb3B0aW9ucy5zY2FsZVkgIT09IDEgfHxcbiAgICAgICAgICBvcHRpb25zLnNrZXdYIHx8IG9wdGlvbnMuc2tld1kgfHwgb3B0aW9ucy5mbGlwWCB8fCBvcHRpb25zLmZsaXBZKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY0RpbWVuc2lvbnNNYXRyaXgob3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSB0byBuZXV0cmFsLiBUb3AgYW5kIGxlZnQgYXJlIG5vdCBhY2NvdW50ZWQgZm9yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gdHJhbnNmb3JtXG4gICAgICovXG4gICAgcmVzZXRPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zY2FsZVggPSAxO1xuICAgICAgdGFyZ2V0LnNjYWxlWSA9IDE7XG4gICAgICB0YXJnZXQuc2tld1ggPSAwO1xuICAgICAgdGFyZ2V0LnNrZXdZID0gMDtcbiAgICAgIHRhcmdldC5mbGlwWCA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LmZsaXBZID0gZmFsc2U7XG4gICAgICB0YXJnZXQucm90YXRlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IE9iamVjdCB0cmFuc2Zvcm0gdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHNhdmVPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBhbmdsZTogdGFyZ2V0LmFuZ2xlLFxuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgZmxpcFg6IHRhcmdldC5mbGlwWCxcbiAgICAgICAgZmxpcFk6IHRhcmdldC5mbGlwWSxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY29udGV4dCBoYXMgdHJhbnNwYXJlbnQgcGl4ZWxcbiAgICAgKiBhdCBzcGVjaWZpZWQgbG9jYXRpb24gKHRha2luZyB0b2xlcmFuY2UgaW50byBhY2NvdW50KVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlXG4gICAgICovXG4gICAgaXNUcmFuc3BhcmVudDogZnVuY3Rpb24oY3R4LCB4LCB5LCB0b2xlcmFuY2UpIHtcblxuICAgICAgLy8gSWYgdG9sZXJhbmNlIGlzID4gMCBhZGp1c3Qgc3RhcnQgY29vcmRzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAgLy8gSWYgbW92ZXMgb2ZmIENhbnZhcyBmaXggdG8gMFxuICAgICAgaWYgKHRvbGVyYW5jZSA+IDApIHtcbiAgICAgICAgaWYgKHggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB4IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHkgLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNUcmFuc3BhcmVudCA9IHRydWUsIGksIHRlbXAsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAodG9sZXJhbmNlICogMikgfHwgMSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEpLFxuICAgICAgICAgIGwgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIFNwbGl0IGltYWdlIGRhdGEgLSBmb3IgdG9sZXJhbmNlID4gMSwgcGl4ZWxEYXRhU2l6ZSA9IDQ7XG4gICAgICBmb3IgKGkgPSAzOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHRlbXAgPSBpbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgX2lzVHJhbnNwYXJlbnQgPSB0ZW1wIDw9IDA7XG4gICAgICAgIGlmIChfaXNUcmFuc3BhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiBjb2xvdXIgZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICByZXR1cm4gX2lzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlIGZyb20gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGlnbiBhbmQgbWVldE9yU2xpY2UgYXR0cmlidXRlXG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9ICdtZWV0JywgYWxpZ25YID0gJ01pZCcsIGFsaWduWSA9ICdNaWQnLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQXR0cnMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKSwgYWxpZ247XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpb0F0dHJzICYmIGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlICE9PSAnbWVldCcgJiYgbWVldE9yU2xpY2UgIT09ICdzbGljZScpIHtcbiAgICAgICAgICBhbGlnbiA9IG1lZXRPclNsaWNlO1xuICAgICAgICAgIG1lZXRPclNsaWNlID0gJ21lZXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RpdmlkZSBhbGlnbiBpbiBhbGlnblggYW5kIGFsaWduWVxuICAgICAgYWxpZ25YID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDEsIDQpIDogJ25vbmUnO1xuICAgICAgYWxpZ25ZID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDUsIDgpIDogJ25vbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVldE9yU2xpY2U6IG1lZXRPclNsaWNlLFxuICAgICAgICBhbGlnblg6IGFsaWduWCxcbiAgICAgICAgYWxpZ25ZOiBhbGlnbllcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNoYXIgd2lkdGhzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gZm9udCBmYW1pbHkgb3IgYWxsIHRoZSBjYWNoZSBpZiBub1xuICAgICAqIGZvbnRGYW1pbHkgaXMgc3BlY2lmaWVkLlxuICAgICAqIFVzZSBpdCBpZiB5b3Uga25vdyB5b3UgYXJlIGxvYWRpbmcgZm9udHMgaW4gYSBsYXp5IHdheSBhbmQgeW91IGFyZSBub3Qgd2FpdGluZ1xuICAgICAqIGZvciBjdXN0b20gZm9udHMgdG8gbG9hZCBwcm9wZXJseSB3aGVuIGFkZGluZyB0ZXh0IG9iamVjdHMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBJZiBhIHRleHQgb2JqZWN0IGlzIGFkZGVkIHdoZW4gaXRzIG93biBmb250IGlzIG5vdCBsb2FkZWQgeWV0LCB5b3Ugd2lsbCBnZXQgd3JvbmdcbiAgICAgKiBtZWFzdXJlbWVudCBhbmQgc28gd3JvbmcgYm91bmRpbmcgYm94ZXMuXG4gICAgICogQWZ0ZXIgdGhlIGZvbnQgY2FjaGUgaXMgY2xlYXJlZCwgZWl0aGVyIGNoYW5nZSB0aGUgdGV4dE9iamVjdCB0ZXh0IGNvbnRlbnQgb3IgY2FsbFxuICAgICAqIGluaXREaW1lbnNpb25zKCkgdG8gdHJpZ2dlciBhIHJlY2FsY3VsYXRpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRGYW1pbHldIGZvbnQgZmFtaWx5IHRvIGNsZWFyXG4gICAgICovXG4gICAgY2xlYXJGYWJyaWNGb250Q2FjaGU6IGZ1bmN0aW9uKGZvbnRGYW1pbHkpIHtcbiAgICAgIGZvbnRGYW1pbHkgPSAoZm9udEZhbWlseSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBkZWxldGUgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gY3VycmVudCBhc3BlY3QgcmF0aW8sIGRldGVybWluZXMgdGhlIG1heCB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgY2FuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtQXJlYSBNYXhpbXVtIGFyZWEgeW91IHdhbnQgdG8gYWNoaWV2ZVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWFxuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIGxpbWl0RGltc0J5QXJlYTogZnVuY3Rpb24oYXIsIG1heGltdW1BcmVhKSB7XG4gICAgICB2YXIgcm91Z2hXaWR0aCA9IE1hdGguc3FydChtYXhpbXVtQXJlYSAqIGFyKSxcbiAgICAgICAgICBwZXJmTGltaXRTaXplWSA9IE1hdGguZmxvb3IobWF4aW11bUFyZWEgLyByb3VnaFdpZHRoKTtcbiAgICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3Iocm91Z2hXaWR0aCksIHk6IHBlcmZMaW1pdFNpemVZIH07XG4gICAgfSxcblxuICAgIGNhcFZhbHVlOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBmaXQgaW5zaWRlIHRoZSBvYmplY3QgZGVzdGluYXRpb24sXG4gICAgICoga2VlcGluZyBhc3BlY3QgcmF0aW8gaW50YWN0LlxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2Uud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlIGZhY3RvciB0byBhcHBseSB0byBzb3VyY2UgdG8gZml0IGludG8gZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBmaW5kU2NhbGVUb0ZpdDogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBjb3ZlciBlbnRpcmVseSB0aGUgb2JqZWN0IGRlc3RpbmF0aW9uLFxuICAgICAqIGtlZXBpbmcgYXNwZWN0IHJhdGlvIGludGFjdC5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2UuaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24uaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24ud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSBmYWN0b3IgdG8gYXBwbHkgdG8gc291cmNlIHRvIGNvdmVyIGRlc3RpbmF0aW9uXG4gICAgICovXG4gICAgZmluZFNjYWxlVG9Db3ZlcjogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYW4gYXJyYXkgb2YgNiBudW1iZXIgcmV0dXJucyBzb21ldGhpbmcgbGlrZSBgXCJtYXRyaXgoLi4ubnVtYmVycylcImBcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gYW4gYXJyYXkgd2l0aCA2IG51bWJlcnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIG1hdHJpeFRvU1ZHOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyB0cmFuc2Zvcm0ubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0ZpeGVkKHZhbHVlLCBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMpO1xuICAgICAgfSkuam9pbignICcpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBvYmplY3QgYW5kIGEgdHJhbnNmb3JtLCBhcHBseSB0aGUgaW52ZXJzZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdCxcbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlIGZyb20gdGhhdCBvYmplY3QgdGhhdCB0cmFuc2Zvcm1hdGlvbiwgc28gdGhhdFxuICAgICAqIGFkZGVkIGluIGEgc3BhY2Ugd2l0aCB0aGUgcmVtb3ZlZCB0cmFuc2Zvcm0sIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAxLzIuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zyb20gdGhhdCByb3RhdGUgYnkgMzBkZWcgaXMgbGlrZSByb3RhdGluZyBieSAzMGRlZ1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gYWRkIG9iamVjdHMgaW5zaWRlIHRyYW5zZm9ybWVkIGdyb3VwcyBvciBuZXN0ZWQgZ3JvdXBzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgeW91IHdhbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBkZXN0aW5hdGlvbiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIGludmVydGVkID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRyYW5zZm9ybSksXG4gICAgICAgICAgZmluYWxUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGludmVydGVkLCBvYmplY3QuY2FsY093bk1hdHJpeCgpKTtcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3Qob2JqZWN0LCBmaW5hbFRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIG9iamVjdCBhbmQgYSB0cmFuc2Zvcm0sIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdC5cbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gY2hhbmdlIHRoZSBzcGFjZSB3aGVyZSB0aGUgb2JqZWN0IGlzIGRyYXduLlxuICAgICAqIEFkZGluZyB0byBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAyLlxuICAgICAqIFRoaXMgaXMgdXNlZCB3aGVuIHJlbW92aW5nIGFuIG9iamVjdCBmcm9tIGFuIGFjdGl2ZSBzZWxlY3Rpb24gZm9yIGV4YW1wbGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFkZFRyYW5zZm9ybVRvT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgZmFicmljLnV0aWwuYXBwbHlUcmFuc2Zvcm1Ub09iamVjdChcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHRyYW5zZm9ybSwgb2JqZWN0LmNhbGNPd25NYXRyaXgoKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRpc2NhcmQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSBhbmQgYXBwbHkgdGhlIG9uZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFwcGx5VHJhbnNmb3JtVG9PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRyYW5zZm9ybSksXG4gICAgICAgICAgY2VudGVyID0gbmV3IGZhYnJpYy5Qb2ludChvcHRpb25zLnRyYW5zbGF0ZVgsIG9wdGlvbnMudHJhbnNsYXRlWSk7XG4gICAgICBvYmplY3QuZmxpcFggPSBmYWxzZTtcbiAgICAgIG9iamVjdC5mbGlwWSA9IGZhbHNlO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgb2JqZWN0LnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIG9iamVjdC5za2V3WSA9IG9wdGlvbnMuc2tld1k7XG4gICAgICBvYmplY3QuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhIHdpZHRoIGFuZCBoZWlnaHQsIHJldHVybiB0aGUgc2l6ZSBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICogdGhhdCBjYW4gY29udGFpbnMgdGhlIGJveCB3aXRoIHdpZHRoL2hlaWdodCB3aXRoIGFwcGxpZWQgdHJhbnNmb3JtXG4gICAgICogZGVzY3JpYmVkIGluIG9wdGlvbnMuXG4gICAgICogVXNlIHRvIGNhbGN1bGF0ZSB0aGUgYm94ZXMgYXJvdW5kIG9iamVjdHMgZm9yIGNvbnRyb2xzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNrZXdYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2tld1lcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueH0gd2lkdGggb2YgY29udGFpbmluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBoZWlnaHQgb2YgY29udGFpbmluZ1xuICAgICAqL1xuICAgIHNpemVBZnRlclRyYW5zZm9ybTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRpbVggPSB3aWR0aCAvIDIsIGRpbVkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGZhYnJpYy51dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KG9wdGlvbnMpLFxuICAgICAgICAgIGJib3ggPSBmYWJyaWMudXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJib3gud2lkdGgsXG4gICAgICAgIHk6IGJib3guaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIDIgY2xpcCBwYXRocyBpbnRvIG9uZSB2aXN1YWxseSBlcXVhbCBjbGlwIHBhdGhcbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UKio6XFxcbiAgICAgKiBEb2VzICoqTk9UKiogY2xvbmUgdGhlIGFyZ3VtZW50cywgY2xvbmUgdGhlbSBwcm9pciBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciAoZ3JvdXApIHRoYXQgY29udGFpbnMgb25lIGNsaXAgcGF0aCBhbmQgaXMgY2xpcHBlZCBieSB0aGUgb3RoZXIgc28gY29udGVudCBpcyBrZXB0IHdoZXJlIGJvdGggb3ZlcmxhcC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgYm90aCB0aGUgY2xpcCBwYXRocyBtYXkgaGF2ZSBuZXN0ZWQgY2xpcCBwYXRocyBvZiB0aGVpciBvd24sIHNvIGFzc2lnbmluZyBvbmUgdG8gdGhlIG90aGVyJ3MgY2xpcCBwYXRoIHByb3BlcnR5IGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGhhbmRsZSB0aGUgYGludmVydGVkYCBwcm9wZXJ0eSB3ZSBmb2xsb3cgbG9naWMgZGVzY3JpYmVkIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XFxcbiAgICAgKiAqKigxKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgaW52ZXJ0ZWQgLSB0aGUgY2xpcCBwYXRocyBwYXNzIHRoZSBpbnZlcnRlZCBwcm9wIHRvIHRoZSB3cmFwcGVyIGFuZCBsb29zZSBpdCB0aGVtc2VsdmVzLlxcXG4gICAgICogKiooMikqKiBvbmUgaXMgaW52ZXJ0ZWQgYW5kIHRoZSBvdGhlciBpc24ndCAtIHRoZSB3cmFwcGVyIHNob3VsZG4ndCBiZWNvbWUgaW52ZXJ0ZWQgYW5kIHRoZSBpbnZlcnRlZCBjbGlwIHBhdGggbXVzdCBjbGlwIHRoZSBub24gaW52ZXJ0ZWQgb25lIHRvIHByb2R1Y2UgYW4gaWRlbnRpY2FsIHZpc3VhbCBlZmZlY3QuXFxcbiAgICAgKiAqKigzKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgbm90IGludmVydGVkIC0gd3JhcHBlciBhbmQgY2xpcCBwYXRocyByZW1haW4gdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjMVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gYzJcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLk9iamVjdH0gbWVyZ2VkIGNsaXAgcGF0aFxuICAgICAqL1xuICAgIG1lcmdlQ2xpcFBhdGhzOiBmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICB2YXIgYSA9IGMxLCBiID0gYzI7XG4gICAgICBpZiAoYS5pbnZlcnRlZCAmJiAhYi5pbnZlcnRlZCkge1xuICAgICAgICAvLyAgY2FzZSAoMilcbiAgICAgICAgYSA9IGMyO1xuICAgICAgICBiID0gYzE7XG4gICAgICB9XG4gICAgICAvLyAgYGJgIGJlY29tZXMgYGFgJ3MgY2xpcCBwYXRoIHNvIHdlIHRyYW5zZm9ybSBgYmAgdG8gYGFgIGNvb3JkaW5hdGUgcGxhbmVcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3QoXG4gICAgICAgIGIsXG4gICAgICAgIGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKGEuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSxcbiAgICAgICAgICBiLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gIGFzc2lnbiB0aGUgYGludmVydGVkYCBwcm9wIHRvIHRoZSB3cmFwcGluZyBncm91cFxuICAgICAgdmFyIGludmVydGVkID0gYS5pbnZlcnRlZCAmJiBiLmludmVydGVkO1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIC8vICBjYXNlICgxKVxuICAgICAgICBhLmludmVydGVkID0gYi5pbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuR3JvdXAoW2FdLCB7IGNsaXBQYXRoOiBiLCBpbnZlcnRlZDogaW52ZXJ0ZWQgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGUgZmlyc3Qgc3R5bGUgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGUgc2Vjb25kIHN0eWxlIHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvclRleHRTcGFucyB3aGV0aGVyIHRvIGNoZWNrIG92ZXJsaW5lLCB1bmRlcmxpbmUsIGFuZCBsaW5lLXRocm91Z2ggcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0eWxlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBoYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlLCBmb3JUZXh0U3BhbnMpIHtcbiAgICAgIGZvclRleHRTcGFucyA9IGZvclRleHRTcGFucyB8fCBmYWxzZTtcbiAgICAgIHJldHVybiAocHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGggfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTaXplICE9PSB0aGlzU3R5bGUuZm9udFNpemUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yICE9PSB0aGlzU3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZGVsdGFZICE9PSB0aGlzU3R5bGUuZGVsdGFZKSB8fFxuICAgICAgICAgICAgICAoZm9yVGV4dFNwYW5zICYmXG4gICAgICAgICAgICAgICAgKHByZXZTdHlsZS5vdmVybGluZSAhPT0gdGhpc1N0eWxlLm92ZXJsaW5lIHx8XG4gICAgICAgICAgICAgICAgcHJldlN0eWxlLnVuZGVybGluZSAhPT0gdGhpc1N0eWxlLnVuZGVybGluZSB8fFxuICAgICAgICAgICAgICAgIHByZXZTdHlsZS5saW5ldGhyb3VnaCAhPT0gdGhpc1N0eWxlLmxpbmV0aHJvdWdoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IGZvcm0gb2YgYSB0ZXh0IG9iamVjdCdzIGlubGluZSBzdHlsZXMgcHJvcGVydHkgd2l0aCBzdHlsZXMgZ3JvdXBlZCBpbiByYW5nZXNcbiAgICAgKiByYXRoZXIgdGhhbiBwZXIgY2hhcmFjdGVyLiBUaGlzIGZvcm1hdCBpcyBsZXNzIHZlcmJvc2UsIGFuZCBpcyBiZXR0ZXIgc3VpdGVkIGZvciBzdG9yYWdlXG4gICAgICogc28gaXQgaXMgdXNlZCBpbiBzZXJpYWxpemF0aW9uIChub3QgZHVyaW5nIHJ1bnRpbWUpLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXMgcGVyIGNoYXJhY3RlciBzdHlsZXMgZm9yIGEgdGV4dCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCBzdHJpbmcgdGhhdCB0aGUgc3R5bGVzIGFyZSBhcHBsaWVkIHRvXG4gICAgICogQHJldHVybiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdHlsZTogb2JqZWN0fVtdfVxuICAgICAqL1xuICAgIHN0eWxlc1RvQXJyYXk6IGZ1bmN0aW9uKHN0eWxlcywgdGV4dCkge1xuICAgICAgLy8gY2xvbmUgc3R5bGUgc3RydWN0dXJlIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgIHZhciBzdHlsZXMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoc3R5bGVzLCB0cnVlKSxcbiAgICAgICAgICB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICBjaGFySW5kZXggPSAtMSwgcHJldlN0eWxlID0ge30sIHN0eWxlc0FycmF5ID0gW107XG4gICAgICAvL2xvb3AgdGhyb3VnaCBlYWNoIHRleHRMaW5lXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXN0eWxlc1tpXSkge1xuICAgICAgICAgIC8vbm8gc3R5bGVzIGV4aXN0IGZvciB0aGlzIGxpbmUsIHNvIGFkZCB0aGUgbGluZSdzIGxlbmd0aCB0byB0aGUgY2hhckluZGV4IHRvdGFsXG4gICAgICAgICAgY2hhckluZGV4ICs9IHRleHRMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgb2YgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRleHRMaW5lc1tpXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgICAgIHZhciB0aGlzU3R5bGUgPSBzdHlsZXNbaV1bY107XG4gICAgICAgICAgLy9jaGVjayBpZiBzdHlsZSBleGlzdHMgZm9yIHRoaXMgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKHRoaXNTdHlsZSAmJiBPYmplY3Qua2V5cyh0aGlzU3R5bGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUNoYW5nZWQgPSBmYWJyaWMudXRpbC5oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0eWxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICBzdHlsZXNBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogY2hhckluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogY2hhckluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogdGhpc1N0eWxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vaWYgc3R5bGUgaXMgdGhlIHNhbWUgYXMgcHJldmlvdXMgY2hhcmFjdGVyLCBpbmNyZWFzZSBlbmQgaW5kZXhcbiAgICAgICAgICAgICAgc3R5bGVzQXJyYXlbc3R5bGVzQXJyYXkubGVuZ3RoIC0gMV0uZW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZTdHlsZSA9IHRoaXNTdHlsZSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlc0FycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgc3R5bGVzIHByb3BlcnR5IHdpdGggc3R5bGVzIHRoYXQgYXJlIGFzc2lnbmVkIHBlclxuICAgICAqIGNoYXJhY3RlciByYXRoZXIgdGhhbiBncm91cGVkIGJ5IHJhbmdlLiBUaGlzIGZvcm1hdCBpcyBtb3JlIHZlcmJvc2UsIGFuZCBpc1xuICAgICAqIG9ubHkgdXNlZCBkdXJpbmcgcnVudGltZSAobm90IGZvciBzZXJpYWxpemF0aW9uL3N0b3JhZ2UpXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3R5bGVzIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgYSB0ZXh0IG9iamVjdCdzIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHN0cmluZyB0aGF0IHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgdG9cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgc3R5bGVzRnJvbUFycmF5OiBmdW5jdGlvbihzdHlsZXMsIHRleHQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG4gICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgY2hhckluZGV4ID0gLTEsIHN0eWxlSW5kZXggPSAwLCBzdHlsZXNPYmplY3QgPSB7fTtcbiAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggdGV4dExpbmVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0ZXh0TGluZXNbaV0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgICAgICAvL2NoZWNrIGlmIHRoZXJlJ3MgYSBzdHlsZSBjb2xsZWN0aW9uIHRoYXQgaW5jbHVkZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKHN0eWxlc1tzdHlsZUluZGV4XVxuICAgICAgICAgICAgJiYgc3R5bGVzW3N0eWxlSW5kZXhdLnN0YXJ0IDw9IGNoYXJJbmRleFxuICAgICAgICAgICAgJiYgY2hhckluZGV4IDwgc3R5bGVzW3N0eWxlSW5kZXhdLmVuZCkge1xuICAgICAgICAgICAgLy9jcmVhdGUgb2JqZWN0IGZvciBsaW5lIGluZGV4IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIHN0eWxlc09iamVjdFtpXSA9IHN0eWxlc09iamVjdFtpXSB8fCB7fTtcbiAgICAgICAgICAgIC8vYXNzaWduIGEgc3R5bGUgYXQgdGhpcyBjaGFyYWN0ZXIncyBpbmRleFxuICAgICAgICAgICAgc3R5bGVzT2JqZWN0W2ldW2NdID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzW3N0eWxlSW5kZXhdLnN0eWxlKTtcbiAgICAgICAgICAgIC8vaWYgY2hhcmFjdGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3R5bGUgY29sbGVjdGlvbiwgbW92ZSB0byB0aGUgbmV4dFxuICAgICAgICAgICAgaWYgKGNoYXJJbmRleCA9PT0gc3R5bGVzW3N0eWxlSW5kZXhdLmVuZCAtIDEpIHtcbiAgICAgICAgICAgICAgc3R5bGVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlc09iamVjdDtcbiAgICB9XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2pvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbixcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG4gIGZ1bmN0aW9uIHNlZ21lbnRUb0Jlemllcih0aDIsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKSB7XG4gICAgdmFyIGNvc3RoMiA9IGZhYnJpYy51dGlsLmNvcyh0aDIpLFxuICAgICAgICBzaW50aDIgPSBmYWJyaWMudXRpbC5zaW4odGgyKSxcbiAgICAgICAgY29zdGgzID0gZmFicmljLnV0aWwuY29zKHRoMyksXG4gICAgICAgIHNpbnRoMyA9IGZhYnJpYy51dGlsLnNpbih0aDMpLFxuICAgICAgICB0b1ggPSBjb3NUaCAqIHJ4ICogY29zdGgzIC0gc2luVGggKiByeSAqIHNpbnRoMyArIGN4MSxcbiAgICAgICAgdG9ZID0gc2luVGggKiByeCAqIGNvc3RoMyArIGNvc1RoICogcnkgKiBzaW50aDMgKyBjeTEsXG4gICAgICAgIGNwMVggPSBmcm9tWCArIG1UICogKCAtY29zVGggKiByeCAqIHNpbnRoMiAtIHNpblRoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDFZID0gZnJvbVkgKyBtVCAqICggLXNpblRoICogcnggKiBzaW50aDIgKyBjb3NUaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AyWCA9IHRvWCArIG1UICogKCBjb3NUaCAqIHJ4ICogc2ludGgzICsgc2luVGggKiByeSAqIGNvc3RoMyksXG4gICAgICAgIGNwMlkgPSB0b1kgKyBtVCAqICggc2luVGggKiByeCAqIHNpbnRoMyAtIGNvc1RoICogcnkgKiBjb3N0aDMpO1xuXG4gICAgcmV0dXJuIFsnQycsXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgfVxuXG4gIC8qIEFkYXB0ZWQgZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UvY29udGVudC9zdmcvY29udGVudC9zcmMvbnNTVkdQYXRoRGF0YVBhcnNlci5jcHBcbiAgICogYnkgQW5kcmVhIEJvZ2F6emkgY29kZSBpcyB1bmRlciBNUEwuIGlmIHlvdSBkb24ndCBoYXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSB5b3UgY2FuIHRha2UgaXQgaGVyZVxuICAgKiBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC9cbiAgICovXG4gIGZ1bmN0aW9uIGFyY1RvU2VnbWVudHModG9YLCB0b1ksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYKSB7XG4gICAgdmFyIFBJID0gTWF0aC5QSSwgdGggPSByb3RhdGVYICogUEkgLyAxODAsXG4gICAgICAgIHNpblRoID0gZmFicmljLnV0aWwuc2luKHRoKSxcbiAgICAgICAgY29zVGggPSBmYWJyaWMudXRpbC5jb3ModGgpLFxuICAgICAgICBmcm9tWCA9IDAsIGZyb21ZID0gMDtcblxuICAgIHJ4ID0gTWF0aC5hYnMocngpO1xuICAgIHJ5ID0gTWF0aC5hYnMocnkpO1xuXG4gICAgdmFyIHB4ID0gLWNvc1RoICogdG9YICogMC41IC0gc2luVGggKiB0b1kgKiAwLjUsXG4gICAgICAgIHB5ID0gLWNvc1RoICogdG9ZICogMC41ICsgc2luVGggKiB0b1ggKiAwLjUsXG4gICAgICAgIHJ4MiA9IHJ4ICogcngsIHJ5MiA9IHJ5ICogcnksIHB5MiA9IHB5ICogcHksIHB4MiA9IHB4ICogcHgsXG4gICAgICAgIHBsID0gcngyICogcnkyIC0gcngyICogcHkyIC0gcnkyICogcHgyLFxuICAgICAgICByb290ID0gMDtcblxuICAgIGlmIChwbCA8IDApIHtcbiAgICAgIHZhciBzID0gTWF0aC5zcXJ0KDEgLSBwbCAvIChyeDIgKiByeTIpKTtcbiAgICAgIHJ4ICo9IHM7XG4gICAgICByeSAqPSBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSAobGFyZ2UgPT09IHN3ZWVwID8gLTEuMCA6IDEuMCkgKlxuICAgICAgICAgICAgICBNYXRoLnNxcnQoIHBsIC8gKHJ4MiAqIHB5MiArIHJ5MiAqIHB4MikpO1xuICAgIH1cblxuICAgIHZhciBjeCA9IHJvb3QgKiByeCAqIHB5IC8gcnksXG4gICAgICAgIGN5ID0gLXJvb3QgKiByeSAqIHB4IC8gcngsXG4gICAgICAgIGN4MSA9IGNvc1RoICogY3ggLSBzaW5UaCAqIGN5ICsgdG9YICogMC41LFxuICAgICAgICBjeTEgPSBzaW5UaCAqIGN4ICsgY29zVGggKiBjeSArIHRvWSAqIDAuNSxcbiAgICAgICAgbVRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKDEsIDAsIChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSksXG4gICAgICAgIGR0aGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnksICgtcHggLSBjeCkgLyByeCwgKC1weSAtIGN5KSAvIHJ5KTtcblxuICAgIGlmIChzd2VlcCA9PT0gMCAmJiBkdGhldGEgPiAwKSB7XG4gICAgICBkdGhldGEgLT0gMiAqIFBJO1xuICAgIH1cbiAgICBlbHNlIGlmIChzd2VlcCA9PT0gMSAmJiBkdGhldGEgPCAwKSB7XG4gICAgICBkdGhldGEgKz0gMiAqIFBJO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW50byBjdWJpYyBiZXppZXIgc2VnbWVudHMgPD0gOTBkZWdcbiAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZHRoZXRhIC8gUEkgKiAyKSksXG4gICAgICAgIHJlc3VsdCA9IFtdLCBtRGVsdGEgPSBkdGhldGEgLyBzZWdtZW50cyxcbiAgICAgICAgbVQgPSA4IC8gMyAqIE1hdGguc2luKG1EZWx0YSAvIDQpICogTWF0aC5zaW4obURlbHRhIC8gNCkgLyBNYXRoLnNpbihtRGVsdGEgLyAyKSxcbiAgICAgICAgdGgzID0gbVRoZXRhICsgbURlbHRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBzZWdtZW50VG9CZXppZXIobVRoZXRhLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSk7XG4gICAgICBmcm9tWCA9IHJlc3VsdFtpXVs1XTtcbiAgICAgIGZyb21ZID0gcmVzdWx0W2ldWzZdO1xuICAgICAgbVRoZXRhID0gdGgzO1xuICAgICAgdGgzICs9IG1EZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qXG4gICAqIFByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNWZWN0b3JBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgIHZhciB0YSA9IE1hdGguYXRhbjIodXksIHV4KSxcbiAgICAgICAgdGIgPSBNYXRoLmF0YW4yKHZ5LCB2eCk7XG4gICAgaWYgKHRiID49IHRhKSB7XG4gICAgICByZXR1cm4gdGIgLSB0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLSAodGEgLSB0Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBiZXppZXJjdXJ2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0geDAgc3RhcnRpbmcgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSBmaXJzdCBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgc2Vjb25kbyBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKiBAcGFyYW0ge051bWJlcn0geDMgZW5kIG9mIGJlemllclxuICAgKiBAcGFyYW0ge051bWJlcn0geTNcbiAgICovXG4gIC8vIHRha2VuIGZyb20gaHR0cDovL2pzYmluLmNvbS9pdm9taXEvNTYvZWRpdCAgbm8gY3JlZGl0cyBhdmFpbGFibGUgZm9yIHRoYXQuXG4gIC8vIFRPRE86IGNhbiB3ZSBub3JtYWxpemUgdGhpcyB3aXRoIHRoZSBzdGFydGluZyBwb2ludHMgc2V0IGF0IDAgYW5kIHRoZW4gdHJhbnNsYXRlZCB0aGUgYmJveD9cbiAgZnVuY3Rpb24gZ2V0Qm91bmRzT2ZDdXJ2ZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgYXJnc1N0cmluZztcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBpZiAoZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICBhYnMgPSBNYXRoLmFicywgdHZhbHVlcyA9IFtdLFxuICAgICAgICBib3VuZHMgPSBbW10sIFtdXSxcbiAgICAgICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgIGMgPSAzICogeDEgLSAzICogeDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XG4gICAgICAgIGlmIChhYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNxcnRiMmFjID0gc3FydChiMmFjKTtcbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB4LCB5LCBqID0gdHZhbHVlcy5sZW5ndGgsIGpsZW4gPSBqLCBtdDtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICB4ID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgYm91bmRzWzBdW2pdID0geDtcblxuICAgICAgeSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICAgIGJvdW5kc1sxXVtqXSA9IHk7XG4gICAgfVxuXG4gICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAge1xuICAgICAgICB4OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IG1heC5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfVxuICAgIF07XG4gICAgaWYgKGZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlKSB7XG4gICAgICBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFyYyB0byBhIGJ1bmNoIG9mIGJlemllciBjdXJ2ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ5IHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRzIEFyYyBjb21tYW5kXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tQXJjVG9CZXppZXJzKGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgdmFyIHJ4ID0gY29vcmRzWzFdLFxuICAgICAgICByeSA9IGNvb3Jkc1syXSxcbiAgICAgICAgcm90ID0gY29vcmRzWzNdLFxuICAgICAgICBsYXJnZSA9IGNvb3Jkc1s0XSxcbiAgICAgICAgc3dlZXAgPSBjb29yZHNbNV0sXG4gICAgICAgIHR4ID0gY29vcmRzWzZdLFxuICAgICAgICB0eSA9IGNvb3Jkc1s3XSxcbiAgICAgICAgc2Vnc05vcm0gPSBhcmNUb1NlZ21lbnRzKHR4IC0gZngsIHR5IC0gZnksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ3NOb3JtLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZWdzTm9ybVtpXVsxXSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzJdICs9IGZ5O1xuICAgICAgc2Vnc05vcm1baV1bM10gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVs0XSArPSBmeTtcbiAgICAgIHNlZ3NOb3JtW2ldWzVdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bNl0gKz0gZnk7XG4gICAgfVxuICAgIHJldHVybiBzZWdzTm9ybTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlIGEgcGFyc2VkIFNWRyBwYXRoIGFuZCBtYWtlIGl0IHNpbXBsZXIgZm9yIGZhYnJpY0pTIGxvZ2ljLlxuICAgKiBzaW1wbGlmaWNhdGlvbiBjb25zaXN0IG9mOiBvbmx5IFVQUEVSQ0FTRSBhYnNvbHV0ZSBjb21tYW5kcyAoIHJlbGF0aXZlIGNvbnZlcnRlZCB0byBhYnNvbHV0ZSApXG4gICAqIFMgY29udmVydGVkIGluIEMsIFQgY29udmVydGVkIGluIFEsIEEgY29udmVydGVkIGluIEMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIGFycmF5IG9mIGNvbW1hbmRzIG9mIGEgcGFyc2VkIHN2ZyBwYXRoIGZvciBmYWJyaWMuUGF0aFxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIHNpbXBsaWZpZWQgYXJyYXkgb2YgY29tbWFuZHMgb2YgYSBwYXJzZWQgc3ZnIHBhdGggZm9yIGZhYnJpYy5QYXRoXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlUGF0aFNpbXBsZXIocGF0aCkge1xuICAgIC8vIHggYW5kIHkgcmVwcmVzZW50IHRoZSBsYXN0IHBvaW50IG9mIHRoZSBwYXRoLiB0aGUgcHJldmlvdXMgY29tbWFuZCBwb2ludC5cbiAgICAvLyB3ZSBhZGQgdGhlbSB0byBlYWNoIHJlbGF0aXZlIGNvbW1hbmQgdG8gbWFrZSBpdCBhbiBhYnNvbHV0ZSBjb21tZW50LlxuICAgIC8vIHdlIGFsc28gc3dhcCB0aGUgdiBWIGggSCB3aXRoIEwsIGJlY2F1c2UgYXJlIGVhc2llciB0byB0cmFuc2Zvcm0uXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgbGVuID0gcGF0aC5sZW5ndGgsXG4gICAgICAgIC8vIHgxIGFuZCB5MSByZXByZXNlbnQgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHN1YnBhdGguIHRoZSBzdWJwYXRoIGlzIHN0YXJ0ZWQgd2l0aFxuICAgICAgICAvLyBtIG9yIE0gY29tbWFuZC4gV2hlbiBhIHogb3IgWiBjb21tYW5kIGlzIGRyYXduLCB4IGFuZCB5IG5lZWQgdG8gYmUgcmVzZXR0ZWQgdG9cbiAgICAgICAgLy8gdGhlIGxhc3QgeDEgYW5kIHkxLlxuICAgICAgICB4MSA9IDAsIHkxID0gMCwgY3VycmVudCwgaSwgY29udmVydGVkLFxuICAgICAgICAvLyBwcmV2aW91cyB3aWxsIGhvc3QgdGhlIGxldHRlciBvZiB0aGUgcHJldmlvdXMgY29tbWFuZCwgdG8gaGFuZGxlIFMgYW5kIFQuXG4gICAgICAgIC8vIGNvbnRyb2xYIGFuZCBjb250cm9sWSB3aWxsIGhvc3QgdGhlIHByZXZpb3VzIHJlZmxlY3RlZCBjb250cm9sIHBvaW50XG4gICAgICAgIGRlc3RpbmF0aW9uUGF0aCA9IFtdLCBwcmV2aW91cywgY29udHJvbFgsIGNvbnRyb2xZO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29udmVydGVkID0gZmFsc2U7XG4gICAgICBjdXJyZW50ID0gcGF0aFtpXS5zbGljZSgwKTtcbiAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcbiAgICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgY3VycmVudFsyXSA9IHk7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFsxXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0geDtcbiAgICAgICAgICBjdXJyZW50WzJdID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ00nO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0MnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzVdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs2XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUyc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgLy8gd291bGQgYmUgc1NjQyBidXQgc2luY2Ugd2UgYXJlIHN3YXBwaW5nIHNTYyBmb3IgQywgd2UgY2hlY2sganVzdCB0aGF0LlxuICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAvLyB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgY3VycmVudFswXSA9ICdDJztcbiAgICAgICAgICBjdXJyZW50WzVdID0gY3VycmVudFszXTtcbiAgICAgICAgICBjdXJyZW50WzZdID0gY3VycmVudFs0XTtcbiAgICAgICAgICBjdXJyZW50WzNdID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjdXJyZW50WzRdID0gY3VycmVudFsyXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0gY29udHJvbFg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IGNvbnRyb2xZO1xuICAgICAgICAgIC8vIGN1cnJlbnRbM10gYW5kIGN1cnJlbnRbNF0gYXJlIE5PVyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgLy8gd2Uga2VlcCBpdCBmb3IgdGhlIG5leHQgcmVmbGVjdGlvbi5cbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1EnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1QnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBpZiAocHJldmlvdXMgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFswXSA9ICdRJztcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0gY29udHJvbFg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IGNvbnRyb2xZO1xuICAgICAgICAgIGN1cnJlbnRbM10gPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0EnO1xuICAgICAgICAgIGN1cnJlbnRbNl0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzddICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICBjb252ZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGRlc3RpbmF0aW9uUGF0aCA9IGRlc3RpbmF0aW9uUGF0aC5jb25jYXQoZnJvbUFyY1RvQmV6aWVycyh4LCB5LCBjdXJyZW50KSk7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgeSA9IHkxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgICAgaWYgKCFjb252ZXJ0ZWQpIHtcbiAgICAgICAgZGVzdGluYXRpb25QYXRoLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnRbMF07XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvblBhdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGMgbGVuZ3RoIGZyb20gcG9pbnQgeDEseTEgdG8geDIseTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxIHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2Ygc2VnbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH1cblxuICAvLyBmdW5jdGlvbnMgZm9yIHRoZSBDdWJpYyBiZWl6ZXJcbiAgLy8gdGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMva29udmEvYmxvYi83LjAuNS9zcmMvc2hhcGVzL1BhdGgudHMjTDM1MFxuICBmdW5jdGlvbiBDQjEodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gQ0IyKHQpIHtcbiAgICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbiAgfVxuICBmdW5jdGlvbiBDQjModCkge1xuICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG4gIGZ1bmN0aW9uIENCNCh0KSB7XG4gICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBjdCkge1xuICAgICAgdmFyIGMxID0gQ0IxKHBjdCksIGMyID0gQ0IyKHBjdCksIGMzID0gQ0IzKHBjdCksIGM0ID0gQ0I0KHBjdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwNHggKiBjMSArIHAzeCAqIGMyICsgcDJ4ICogYzMgKyBwMXggKiBjNCxcbiAgICAgICAgeTogcDR5ICogYzEgKyBwM3kgKiBjMiArIHAyeSAqIGMzICsgcDF5ICogYzRcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhbmdlbnRDdWJpY0l0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwY3QpIHtcbiAgICAgIHZhciBpbnZUID0gMSAtIHBjdCxcbiAgICAgICAgICB0YW5nZW50WCA9ICgzICogaW52VCAqIGludlQgKiAocDJ4IC0gcDF4KSkgKyAoNiAqIGludlQgKiBwY3QgKiAocDN4IC0gcDJ4KSkgK1xuICAgICAgICAgICgzICogcGN0ICogcGN0ICogKHA0eCAtIHAzeCkpLFxuICAgICAgICAgIHRhbmdlbnRZID0gKDMgKiBpbnZUICogaW52VCAqIChwMnkgLSBwMXkpKSArICg2ICogaW52VCAqIHBjdCAqIChwM3kgLSBwMnkpKSArXG4gICAgICAgICAgKDMgKiBwY3QgKiBwY3QgKiAocDR5IC0gcDN5KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0YW5nZW50WSwgdGFuZ2VudFgpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBRQjEodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMih0KSB7XG4gICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMyh0KSB7XG4gICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGN0KSB7XG4gICAgICB2YXIgYzEgPSBRQjEocGN0KSwgYzIgPSBRQjIocGN0KSwgYzMgPSBRQjMocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAzeCAqIGMxICsgcDJ4ICogYzIgKyBwMXggKiBjMyxcbiAgICAgICAgeTogcDN5ICogYzEgKyBwMnkgKiBjMiArIHAxeSAqIGMzXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGN0KSB7XG4gICAgICB2YXIgaW52VCA9IDEgLSBwY3QsXG4gICAgICAgICAgdGFuZ2VudFggPSAoMiAqIGludlQgKiAocDJ4IC0gcDF4KSkgKyAoMiAqIHBjdCAqIChwM3ggLSBwMngpKSxcbiAgICAgICAgICB0YW5nZW50WSA9ICgyICogaW52VCAqIChwMnkgLSBwMXkpKSArICgyICogcGN0ICogKHAzeSAtIHAyeSkpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGFuZ2VudFksIHRhbmdlbnRYKTtcbiAgICB9O1xuICB9XG5cblxuICAvLyB0aGlzIHdpbGwgcnVuIG92ZXIgYSBwYXRoIHNlZ21lbnQgKCBhIGN1YmljIG9yIHF1YWRyYXRpYyBzZWdtZW50KSBhbmQgYXBwcm94aW1hdGUgaXRcbiAgLy8gd2l0aCAxMDAgc2VnZW1udHMuIFRoaXMgd2lsbCBnb29kIGVub3VnaCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgY3VydmVcbiAgZnVuY3Rpb24gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpIHtcbiAgICB2YXIgdGVtcFAgPSB7IHg6IHgxLCB5OiB5MSB9LCBwLCB0bXBMZW4gPSAwLCBwZXJjO1xuICAgIGZvciAocGVyYyA9IDE7IHBlcmMgPD0gMTAwOyBwZXJjICs9IDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjIC8gMTAwKTtcbiAgICAgIHRtcExlbiArPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICB0ZW1wUCA9IHA7XG4gICAgfVxuICAgIHJldHVybiB0bXBMZW47XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYXRoSW5mbywgYW5kIGEgZGlzdGFuY2UgaW4gcGl4ZWxzLCBmaW5kIHRoZSBwZXJjZW50YWdlIGZyb20gMCB0byAxXG4gICAqIHRoYXQgY29ycmVzcG9uZCB0byB0aGF0IHBpeGVscyBydW4gb3ZlciB0aGUgcGF0aC5cbiAgICogVGhlIHBlcmNlbnRhZ2Ugd2lsbCBiZSB0aGVuIHVzZWQgdG8gZmluZCB0aGUgY29ycmVjdCBwb2ludCBvbiB0aGUgY2FudmFzIGZvciB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtBcnJheX0gc2VnSW5mbyBmYWJyaWNKUyBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIG9uIGEgcGFyc2VkIHBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIGZyb20gc3RhcnRpbmcgcG9pbnQsIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBpbmZvIG9iamVjdCB3aXRoIHggYW5kIHkgKCB0aGUgcG9pbnQgb24gY2FudmFzICkgYW5kIGFuZ2xlLCB0aGUgdGFuZ2VudCBvbiB0aGF0IHBvaW50O1xuICAgKi9cbiAgZnVuY3Rpb24gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSkge1xuICAgIHZhciBwZXJjID0gMCwgdG1wTGVuID0gMCwgaXRlcmF0b3IgPSBzZWdJbmZvLml0ZXJhdG9yLCB0ZW1wUCA9IHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnkgfSxcbiAgICAgICAgcCwgbmV4dExlbiwgbmV4dFN0ZXAgPSAwLjAxLCBhbmdsZUZpbmRlciA9IHNlZ0luZm8uYW5nbGVGaW5kZXIsIGxhc3RQZXJjO1xuICAgIC8vIG5leHRTdGVwID4gMC4wMDAxIGNvdmVycyAwLjAwMDE1NjI1IHRoYXQgMS82NHRoIG9mIDEvMTAwXG4gICAgLy8gdGhlIHBhdGhcbiAgICB3aGlsZSAodG1wTGVuIDwgZGlzdGFuY2UgJiYgbmV4dFN0ZXAgPiAwLjAwMDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjKTtcbiAgICAgIGxhc3RQZXJjID0gcGVyYztcbiAgICAgIG5leHRMZW4gPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICAvLyBjb21wYXJlIHRtcExlbiBlYWNoIGN5Y2xlIHdpdGggZGlzdGFuY2UsIGRlY2lkZSBuZXh0IHBlcmMgdG8gdGVzdC5cbiAgICAgIGlmICgobmV4dExlbiArIHRtcExlbikgPiBkaXN0YW5jZSkge1xuICAgICAgICAvLyB3ZSBkaXNjYXJkIHRoaXMgc3RlcCBhbmQgd2UgbWFrZSBzbWFsbGVyIHN0ZXBzLlxuICAgICAgICBwZXJjIC09IG5leHRTdGVwO1xuICAgICAgICBuZXh0U3RlcCAvPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRlbXBQID0gcDtcbiAgICAgICAgcGVyYyArPSBuZXh0U3RlcDtcbiAgICAgICAgdG1wTGVuICs9IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHAuYW5nbGUgPSBhbmdsZUZpbmRlcihsYXN0UGVyYyk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG92ZXIgYSBwYXJzZWQgYW5kIHNpbXBsaWZlZCBwYXRoIGFuZCBleHRyYWMgc29tZSBpbmZvcm1hdGlvbnMuXG4gICAqIGluZm9ybWF0aW9ucyBhcmUgbGVuZ3RoIG9mIGVhY2ggY29tbWFuZCBhbmQgc3RhcnRpbmcgcG9pbnRcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBmYWJyaWNKUyBwYXJzZWQgcGF0aCBjb21tYW5kc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gcGF0aCBjb21tYW5kcyBpbmZvcm1hdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCkge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoLCBjdXJyZW50LFxuICAgICAgICAvL3gyIGFuZCB5MiBhcmUgdGhlIGNvb3JkcyBvZiBzZWdtZW50IHN0YXJ0XG4gICAgICAgIC8veDEgYW5kIHkxIGFyZSB0aGUgY29vcmRzIG9mIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCB4MiA9IDAsIHkyID0gMCwgaW5mbyA9IFtdLCBpdGVyYXRvciwgdGVtcEluZm8sIGFuZ2xlRmluZGVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuICAgICAgdGVtcEluZm8gPSB7XG4gICAgICAgIHg6IHgxLFxuICAgICAgICB5OiB5MSxcbiAgICAgICAgY29tbWFuZDogY3VycmVudFswXSxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy9maXJzdCBsZXR0ZXJcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gMDtcbiAgICAgICAgICB4MiA9IHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MiA9IHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCBjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBpdGVyYXRvciA9IGdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50Q3ViaWNJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRlbXBJbmZvLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgICAgdGVtcEluZm8uYW5nbGVGaW5kZXIgPSBhbmdsZUZpbmRlcjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkxID0gY3VycmVudFs2XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgaXRlcmF0b3IgPSBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVtcEluZm8uaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgICB0ZW1wSW5mby5hbmdsZUZpbmRlciA9IGFuZ2xlRmluZGVyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgLy8gd2UgYWRkIHRob3NlIGluIG9yZGVyIHRvIGVhc2UgY2FsY3VsYXRpb25zIGxhdGVyXG4gICAgICAgICAgdGVtcEluZm8uZGVzdFggPSB4MjtcbiAgICAgICAgICB0ZW1wSW5mby5kZXN0WSA9IHkyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICB4MSA9IHgyO1xuICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0b3RhbExlbmd0aCArPSB0ZW1wSW5mby5sZW5ndGg7XG4gICAgICBpbmZvLnB1c2godGVtcEluZm8pO1xuICAgIH1cbiAgICBpbmZvLnB1c2goeyBsZW5ndGg6IHRvdGFsTGVuZ3RoLCB4OiB4MSwgeTogeTEgfSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUGF0aChwYXRoLCBkaXN0YW5jZSwgaW5mb3MpIHtcbiAgICBpZiAoIWluZm9zKSB7XG4gICAgICBpbmZvcyA9IGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCk7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKGRpc3RhbmNlIC0gaW5mb3NbaV0ubGVuZ3RoID4gMCkgJiYgaSA8IChpbmZvcy5sZW5ndGggLSAyKSkge1xuICAgICAgZGlzdGFuY2UgLT0gaW5mb3NbaV0ubGVuZ3RoO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICAvLyB2YXIgZGlzdGFuY2UgPSBpbmZvc1tpbmZvcy5sZW5ndGggLSAxXSAqIHBlcmM7XG4gICAgdmFyIHNlZ0luZm8gPSBpbmZvc1tpXSwgc2VnUGVyY2VudCA9IGRpc3RhbmNlIC8gc2VnSW5mby5sZW5ndGgsXG4gICAgICAgIGNvbW1hbmQgPSBzZWdJbmZvLmNvbW1hbmQsIHNlZ21lbnQgPSBwYXRoW2ldLCBpbmZvO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgcmV0dXJuIHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnksIGFuZ2xlOiAwIH07XG4gICAgICBjYXNlICdaJzpcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBpbmZvID0gbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLngsIHNlZ0luZm8ueSkubGVycChcbiAgICAgICAgICBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8uZGVzdFgsIHNlZ0luZm8uZGVzdFkpLFxuICAgICAgICAgIHNlZ1BlcmNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby5hbmdsZSA9IE1hdGguYXRhbjIoc2VnSW5mby5kZXN0WSAtIHNlZ0luZm8ueSwgc2VnSW5mby5kZXN0WCAtIHNlZ0luZm8ueCk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIGluZm8gPSBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8ueCwgc2VnSW5mby55KS5sZXJwKFxuICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoc2VnbWVudFsxXSwgc2VnbWVudFsyXSksXG4gICAgICAgICAgc2VnUGVyY2VudFxuICAgICAgICApO1xuICAgICAgICBpbmZvLmFuZ2xlID0gTWF0aC5hdGFuMihzZWdtZW50WzJdIC0gc2VnSW5mby55LCBzZWdtZW50WzFdIC0gc2VnSW5mby54KTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgcmV0dXJuIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpO1xuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICogQHJldHVybiB7KHN0cmluZ3xudW1iZXIpW11bXX0gQW4gYXJyYXkgb2YgU1ZHIHBhdGggY29tbWFuZHNcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VXNhZ2U8L2NhcHRpb24+XG4gICAqIHBhcnNlUGF0aCgnTSAzIDQgUSAzIDUgMiAxIDQgMCBRIDkgMTIgMiAxIDQgMCcpID09PSBbXG4gICAqICAgWydNJywgMywgNF0sXG4gICAqICAgWydRJywgMywgNSwgMiwgMSwgNCwgMF0sXG4gICAqICAgWydRJywgOSwgMTIsIDIsIDEsIDQsIDBdLFxuICAgKiBdO1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGhTdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvb3JkcyA9IFtdLFxuICAgICAgICBjdXJyZW50UGF0aCxcbiAgICAgICAgcGFyc2VkLFxuICAgICAgICByZSA9IGZhYnJpYy5yZVBhdGhDb21tYW5kLFxuICAgICAgICByTnVtYmVyID0gJ1stK10/KD86XFxcXGQqXFxcXC5cXFxcZCt8XFxcXGQrXFxcXC4/KSg/OltlRV1bLStdP1xcXFxkKyk/XFxcXHMqJyxcbiAgICAgICAgck51bWJlckNvbW1hV3NwID0gJygnICsgck51bWJlciArICcpJyArIGZhYnJpYy5jb21tYVdzcCxcbiAgICAgICAgckZsYWdDb21tYVdzcCA9ICcoWzAxXSknICsgZmFicmljLmNvbW1hV3NwICsgJz8nLFxuICAgICAgICByQXJjU2VxID0gck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgckZsYWdDb21tYVdzcCArIHJGbGFnQ29tbWFXc3AgK1xuICAgICAgICAgIHJOdW1iZXJDb21tYVdzcCArICc/KCcgKyByTnVtYmVyICsgJyknLFxuICAgICAgICByZWdBcmNBcmd1bWVudFNlcXVlbmNlID0gbmV3IFJlZ0V4cChyQXJjU2VxLCAnZycpLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29vcmRzU3RyLFxuICAgICAgICAvLyBvbmUgb2YgY29tbWFuZHMgKG0sTSxsLEwscSxRLGMsQyxldGMuKSBmb2xsb3dlZCBieSBub24tY29tbWFuZCBjaGFyYWN0ZXJzIChpLmUuIGNvbW1hbmQgdmFsdWVzKVxuICAgICAgICBwYXRoO1xuICAgIGlmICghcGF0aFN0cmluZyB8fCAhcGF0aFN0cmluZy5tYXRjaCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGhTdHJpbmcubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjb29yZHNQYXJzZWQsIGxlbiA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnRQYXRoID0gcGF0aFtpXTtcblxuICAgICAgY29vcmRzU3RyID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpO1xuICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgIHZhciBjb21tYW5kID0gY3VycmVudFBhdGguY2hhckF0KDApO1xuICAgICAgY29vcmRzUGFyc2VkID0gW2NvbW1hbmRdO1xuXG4gICAgICBpZiAoY29tbWFuZC50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgLy8gYXJjcyBoYXZlIHNwZWNpYWwgZmxhZ3MgdGhhdCBhcHBhcmVudGx5IGRvbid0IHJlcXVpcmUgc3BhY2VzIHNvIGhhbmRsZSBzcGVjaWFsXG4gICAgICAgIGZvciAodmFyIGFyZ3M7IChhcmdzID0gcmVnQXJjQXJndW1lbnRTZXF1ZW5jZS5leGVjKGNvb3Jkc1N0cikpOykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29vcmRzLnB1c2goYXJnc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBjb29yZHMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgY29vcmRzUGFyc2VkLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgcmVwZWF0ZWRDb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kc1tjb21tYW5kXSB8fCBjb21tYW5kO1xuXG4gICAgICBpZiAoY29vcmRzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtjb21tYW5kXS5jb25jYXQoY29vcmRzUGFyc2VkLnNsaWNlKGssIGsgKyBjb21tYW5kTGVuZ3RoKSkpO1xuICAgICAgICAgIGNvbW1hbmQgPSByZXBlYXRlZENvbW1hbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIENvbnZlcnRzIHBvaW50cyB0byBhIHNtb290aCBTVkcgcGF0aFxuICAgKiBAcGFyYW0ge3sgeDogbnVtYmVyLHk6IG51bWJlciB9W119IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3JyZWN0aW9uXSBBcHBseSBhIGNvcnJlY3Rpb24gdG8gdGhlIHBhdGggKHVzdWFsbHkgd2UgdXNlIGB3aWR0aCAvIDEwMDBgKS4gSWYgdmFsdWUgaXMgdW5kZWZpbmVkIDAgaXMgdXNlZCBhcyB0aGUgY29ycmVjdGlvbiB2YWx1ZS5cbiAgICogQHJldHVybiB7KHN0cmluZ3xudW1iZXIpW11bXX0gQW4gYXJyYXkgb2YgU1ZHIHBhdGggY29tbWFuZHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNtb290aFBhdGhGcm9tUG9pbnRzKHBvaW50cywgY29ycmVjdGlvbikge1xuICAgIHZhciBwYXRoID0gW10sIGksXG4gICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpLFxuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KSxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCwgbXVsdFNpZ25YID0gMSwgbXVsdFNpZ25ZID0gMCwgbWFueVBvaW50cyA9IGxlbiA+IDI7XG4gICAgY29ycmVjdGlvbiA9IGNvcnJlY3Rpb24gfHwgMDtcblxuICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICBtdWx0U2lnblggPSBwb2ludHNbMl0ueCA8IHAyLnggPyAtMSA6IHBvaW50c1syXS54ID09PSBwMi54ID8gMCA6IDE7XG4gICAgICBtdWx0U2lnblkgPSBwb2ludHNbMl0ueSA8IHAyLnkgPyAtMSA6IHBvaW50c1syXS55ID09PSBwMi55ID8gMCA6IDE7XG4gICAgfVxuICAgIHBhdGgucHVzaChbJ00nLCBwMS54IC0gbXVsdFNpZ25YICogY29ycmVjdGlvbiwgcDEueSAtIG11bHRTaWduWSAqIGNvcnJlY3Rpb25dKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghcDEuZXEocDIpKSB7XG4gICAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICAgIC8vIHAxIGlzIG91ciBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgICAvLyBtaWRwb2ludCBpcyBvdXIgZW5kcG9pbnRcbiAgICAgICAgLy8gc3RhcnQgcG9pbnQgaXMgcChpLTEpIHZhbHVlLlxuICAgICAgICBwYXRoLnB1c2goWydRJywgcDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueV0pO1xuICAgICAgfVxuICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICBpZiAoKGkgKyAxKSA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgbXVsdFNpZ25YID0gcDEueCA+IHBvaW50c1tpIC0gMl0ueCA/IDEgOiBwMS54ID09PSBwb2ludHNbaSAtIDJdLnggPyAwIDogLTE7XG4gICAgICBtdWx0U2lnblkgPSBwMS55ID4gcG9pbnRzW2kgLSAyXS55ID8gMSA6IHAxLnkgPT09IHBvaW50c1tpIC0gMl0ueSA/IDAgOiAtMTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKFsnTCcsIHAxLnggKyBtdWx0U2lnblggKiBjb3JyZWN0aW9uLCBwMS55ICsgbXVsdFNpZ25ZICogY29ycmVjdGlvbl0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IHRyYW5zZm9ybWluZyBlYWNoIHNlZ21lbnQuXG4gICAqIGl0IGhhcyB0byBiZSBhIHNpbXBsaWZpZWQgcGF0aCBvciBpdCB3b24ndCB3b3JrLlxuICAgKiBXQVJOSU5HOiB0aGlzIGRlcGVuZHMgZnJvbSBwYXRoT2Zmc2V0IGZvciBjb3JyZWN0IG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGZhYnJpY0pTIHBhcnNlZCBhbmQgc2ltcGxpZmllZCBwYXRoIGNvbW1hbmRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnQgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGF0aE9mZnNldF0gdGhlIGZhYnJpYy5QYXRoIHBhdGhPZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhdGhPZmZzZXQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aE9mZnNldC55XG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHRyYW5zZm9ybWVkIHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgdHJhbnNmb3JtLCBwYXRoT2Zmc2V0KSB7XG4gICAgaWYgKHBhdGhPZmZzZXQpIHtcbiAgICAgIHRyYW5zZm9ybSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgWzEsIDAsIDAsIDEsIC1wYXRoT2Zmc2V0LngsIC1wYXRoT2Zmc2V0LnldXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24ocGF0aFNlZ21lbnQpIHtcbiAgICAgIHZhciBuZXdTZWdtZW50ID0gcGF0aFNlZ21lbnQuc2xpY2UoMCksIHBvaW50ID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGhTZWdtZW50Lmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcGF0aFNlZ21lbnRbaV07XG4gICAgICAgIHBvaW50LnkgPSBwYXRoU2VnbWVudFtpICsgMV07XG4gICAgICAgIHBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocG9pbnQsIHRyYW5zZm9ybSk7XG4gICAgICAgIG5ld1NlZ21lbnRbaV0gPSBwb2ludC54O1xuICAgICAgICBuZXdTZWdtZW50W2kgKyAxXSA9IHBvaW50Lnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U2VnbWVudDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHBhdGggY29tbWFuZHMgdG8gZ28gYmFjayB0byBzdmcgZm9ybWF0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGhEYXRhIGZhYnJpY0pTIHBhcnNlZCBwYXRoIGNvbW1hbmRzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gam9pbmVkIHBhdGggJ00gMCAwIEwgMjAgMzAnXG4gICAqL1xuICBmYWJyaWMudXRpbC5qb2luUGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgcmV0dXJuIHBhdGhEYXRhLm1hcChmdW5jdGlvbiAoc2VnbWVudCkgeyByZXR1cm4gc2VnbWVudC5qb2luKCcgJyk7IH0pLmpvaW4oJyAnKTtcbiAgfTtcbiAgZmFicmljLnV0aWwucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuICBmYWJyaWMudXRpbC5tYWtlUGF0aFNpbXBsZXIgPSBtYWtlUGF0aFNpbXBsZXI7XG4gIGZhYnJpYy51dGlsLmdldFNtb290aFBhdGhGcm9tUG9pbnRzID0gZ2V0U21vb3RoUGF0aEZyb21Qb2ludHM7XG4gIGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8gPSBnZXRQYXRoU2VnbWVudHNJbmZvO1xuICBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlID0gZ2V0Qm91bmRzT2ZDdXJ2ZTtcbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGggPSBnZXRQb2ludE9uUGF0aDtcbiAgZmFicmljLnV0aWwudHJhbnNmb3JtUGF0aCA9IHRyYW5zZm9ybVBhdGg7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEludm9rZXMgbWV0aG9kIG9uIGFsbCBpdGVtcyBpbiBhIGdpdmVuIGFycmF5XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIGEgbWV0aG9kIHRvIGludm9rZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZShhcnJheSwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYXJncy5sZW5ndGggPyBhcnJheVtpXVttZXRob2RdLmFwcGx5KGFycmF5W2ldLCBhcmdzKSA6IGFycmF5W2ldW21ldGhvZF0uY2FsbChhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWF4aW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1heChhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA+PSB2YWx1ZTI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWluaW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1pbihhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA8IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgayA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoay0tKSB7XG4gICAgICBhcnJheVtrXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGNvbmRpdGlvbikge1xuICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGggLSAxLFxuICAgICAgICByZXN1bHQgPSBieVByb3BlcnR5ID8gYXJyYXlbaV1bYnlQcm9wZXJ0eV0gOiBhcnJheVtpXTtcbiAgICBpZiAoYnlQcm9wZXJ0eSkge1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycmF5W2ldW2J5UHJvcGVydHldLCByZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXlbaV1bYnlQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuYXJyYXlcbiAgICovXG4gIGZhYnJpYy51dGlsLmFycmF5ID0ge1xuICAgIGZpbGw6IGZpbGwsXG4gICAgaW52b2tlOiBpbnZva2UsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBDb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBvbmUganMgb2JqZWN0IHRvIGFub3RoZXJcbiAgICogdGhpcyBkb2VzIG5vdCBhbmQgY2Fubm90IGNvbXBldGUgd2l0aCBnZW5lcmljIHV0aWxzLlxuICAgKiBEb2VzIG5vdCBjbG9uZSBvciBleHRlbmQgZmFicmljLk9iamVjdCBzdWJjbGFzc2VzLlxuICAgKiBUaGlzIGlzIG1vc3RseSBmb3IgaW50ZXJuYWwgdXNlIGFuZCBoYXMgZXh0cmEgaGFuZGxpbmcgZm9yIGZhYnJpY0pTIG9iamVjdHNcbiAgICogaXQgc2tpcHMgdGhlIGNhbnZhcyBhbmQgZ3JvdXAgcHJvcGVydGllcyBpbiBkZWVwIGNsb25pbmcuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIFdoZXJlIHRvIGNvcHkgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBXaGVyZSB0byBjb3B5IGZyb21cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcF0gV2hldGhlciB0byBleHRlbmQgbmVzdGVkIG9iamVjdHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCkge1xuICAgIC8vIEpTY3JpcHQgRG9udEVudW0gYnVnIGlzIG5vdCB0YWtlbiBjYXJlIG9mXG4gICAgLy8gdGhlIGRlZXAgY2xvbmUgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbm90IG1lYW50IHRvIGF2b2lkXG4gICAgLy8gamF2YXNjcmlwdCB0cmFwcyBvciBjbG9uaW5nIGh0bWwgZWxlbWVudCBvciBzZWxmIHJlZmVyZW5jZWQgb2JqZWN0cy5cbiAgICBpZiAoZGVlcCkge1xuICAgICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYXZvaWQgY2xvbmluZyBkZWVwIGltYWdlcywgY2FudmFzZXMsXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGVzdGluYXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2ldID0gZXh0ZW5kKHsgfSwgc291cmNlW2ldLCBkZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NhbnZhcycgfHwgcHJvcGVydHkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNsb25lIHRoaXMgcHJvcHMgYXQgYWxsLlxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHRoZSBrZXlzIGluIHRoZSBjb3B5XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbcHJvcGVydHldLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHNvdW5kcyBvZGQgZm9yIGFuIGV4dGVuZCBidXQgaXMgb2sgZm9yIHJlY3Vyc2l2ZSB1c2VcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBhbmQgY29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3QgdG8gaXRcbiAgICogVGhpcyBtZXRob2QgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UsIGFuZCBub3QgaW50ZW5kZWQgZm9yIGR1cGxpY2F0aW5nIHNoYXBlcyBpbiBjYW52YXMuIFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNsb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZXBdIFdoZXRoZXIgdG8gY2xvbmUgbmVzdGVkIG9iamVjdHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gcmV0dXJuIGFuIGVtcHR5IG9iamVjdCBpZiB5b3UgdHJ5IHRvIGNsb25lIG51bGxcbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0LCBkZWVwKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7IH0sIG9iamVjdCwgZGVlcCk7XG4gIH1cblxuICAvKiogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5vYmplY3QgKi9cbiAgZmFicmljLnV0aWwub2JqZWN0ID0ge1xuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNsb25lOiBjbG9uZVxuICB9O1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy51dGlsLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQ2FtZWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FtZWxpemVcbiAgICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYXBpdGFsaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpcnN0TGV0dGVyT25seV0gSWYgdHJ1ZSBvbmx5IGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBzdGF5IHVudG91Y2hlZCwgaWYgZmFsc2UgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhcGl0YWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nLCBmaXJzdExldHRlck9ubHkpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIChmaXJzdExldHRlck9ubHkgPyBzdHJpbmcuc2xpY2UoMSkgOiBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBYTUwgaW4gYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVhtbChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgYSBzdHJpbmcgaW4gdGhlIHVzZXIgcGVyY2VpdmVkIHNpbmdsZSB1bml0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0c3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IGNvbnRhaW5pbmcgdGhlIGdyYXBoZW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gZ3JhcGhlbWVTcGxpdCh0ZXh0c3RyaW5nKSB7XG4gICAgdmFyIGkgPSAwLCBjaHIsIGdyYXBoZW1lcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGNocjsgaSA8IHRleHRzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgoY2hyID0gZ2V0V2hvbGVDaGFyKHRleHRzdHJpbmcsIGkpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBncmFwaGVtZXMucHVzaChjaHIpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhlbWVzO1xuICB9XG5cbiAgLy8gdGFrZW4gZnJvbSBtZG4gaW4gdGhlIGNoYXJBdCBkb2MgcGFnZS5cbiAgZnVuY3Rpb24gZ2V0V2hvbGVDaGFyKHN0ciwgaSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHJldHVybiAnJzsgLy8gUG9zaXRpb24gbm90IGZvdW5kXG4gICAgfVxuICAgIGlmIChjb2RlIDwgMHhEODAwIHx8IGNvZGUgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIC8vIEhpZ2ggc3Vycm9nYXRlIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSAoaSArIDEpKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKDB4REMwMCA+IG5leHQgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKSArIHN0ci5jaGFyQXQoaSArIDEpO1xuICAgIH1cbiAgICAvLyBMb3cgc3Vycm9nYXRlICgweERDMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REZGRilcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IHN0ci5jaGFyQ29kZUF0KGkgLSAxKTtcblxuICAgIC8vIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA+IHByZXYgfHwgcHJldiA+IDB4REJGRikge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gcGFzcyBvdmVyIGxvdyBzdXJyb2dhdGVzIG5vdyBhcyB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICAgIC8vIGluIGEgcGFpciB3aGljaCB3ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogU3RyaW5nIHV0aWxpdGllc1xuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKi9cbiAgZmFicmljLnV0aWwuc3RyaW5nID0ge1xuICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICAgIGVzY2FwZVhtbDogZXNjYXBlWG1sLFxuICAgIGdyYXBoZW1lU3BsaXQ6IGdyYXBoZW1lU3BsaXRcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICBJU19ET05URU5VTV9CVUdHWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB7IHRvU3RyaW5nOiAxIH0pIHtcbiAgICAgICAgICBpZiAocCA9PT0gJ3RvU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBhZGRNZXRob2RzID0gZnVuY3Rpb24oa2xhc3MsIHNvdXJjZSwgcGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5IGluIGtsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICB0eXBlb2Yga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoc291cmNlW3Byb3BlcnR5XSArICcnKS5pbmRleE9mKCdjYWxsU3VwZXInKSA+IC0xKSB7XG5cbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnaW5pdGlhbGl6ZScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTX0RPTlRFTlVNX0JVR0dZKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS52YWx1ZU9mID0gc291cmNlLnZhbHVlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIFN1YmNsYXNzKCkgeyB9XG5cbiAgZnVuY3Rpb24gY2FsbFN1cGVyKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgcGFyZW50TWV0aG9kID0gbnVsbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gY2xpbWIgcHJvdG90eXBlIGNoYWluIHRvIGZpbmQgbWV0aG9kIG5vdCBlcXVhbCB0byBjYWxsZWUncyBtZXRob2RcbiAgICB3aGlsZSAoX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcykge1xuICAgICAgdmFyIHN1cGVyQ2xhc3NNZXRob2QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgIGlmIChfdGhpc1ttZXRob2ROYW1lXSAhPT0gc3VwZXJDbGFzc01ldGhvZCkge1xuICAgICAgICBwYXJlbnRNZXRob2QgPSBzdXBlckNsYXNzTWV0aG9kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgX3RoaXMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudE1ldGhvZCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCd0cmllZCB0byBjYWxsU3VwZXIgJyArIG1ldGhvZE5hbWUgKyAnLCBtZXRob2Qgbm90IGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbicsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICA/IHBhcmVudE1ldGhvZC5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICA6IHBhcmVudE1ldGhvZC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY3JlYXRpb24gb2YgXCJjbGFzc2VzXCIuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyZW50XSBvcHRpb25hbCBcIkNsYXNzXCIgdG8gaW5oZXJpdCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgKGJlIGNhcmVmdWwgbW9kaWZ5aW5nIG9iamVjdHMgZGVmaW5lZCBoZXJlIGFzIHRoaXMgd291bGQgYWZmZWN0IGFsbCBpbnN0YW5jZXMpXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcygpIHtcbiAgICB2YXIgcGFyZW50ID0gbnVsbCxcbiAgICAgICAgcHJvcGVydGllcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyZW50ID0gcHJvcGVydGllcy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbGFzcygpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGtsYXNzLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAga2xhc3Muc3ViY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgU3ViY2xhc3MucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIGtsYXNzLnByb3RvdHlwZSA9IG5ldyBTdWJjbGFzcygpO1xuICAgICAgcGFyZW50LnN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRNZXRob2RzKGtsYXNzLCBwcm9wZXJ0aWVzW2ldLCBwYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoIWtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGVtcHR5RnVuY3Rpb247XG4gICAgfVxuICAgIGtsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtsYXNzO1xuICAgIGtsYXNzLnByb3RvdHlwZS5jYWxsU3VwZXIgPSBjYWxsU3VwZXI7XG4gICAgcmV0dXJuIGtsYXNzO1xuICB9XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MgPSBjcmVhdGVDbGFzcztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2luY2UgaWUxMSBjYW4gdXNlIGFkZEV2ZW50TGlzdGVuZXIgYnV0IHRoZXkgZG8gbm90IHN1cHBvcnQgb3B0aW9ucywgaSBuZWVkIHRvIGNoZWNrXG4gIHZhciBjb3VsZFVzZUF0dGFjaEV2ZW50ID0gISFmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYXR0YWNoRXZlbnQsXG4gICAgICB0b3VjaEV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXTtcbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgY291bGRVc2VBdHRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBjb3VsZFVzZUF0dGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUb3VjaEluZm8oZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoUHJvcCAmJiB0b3VjaFByb3BbMF0pIHtcbiAgICAgIHJldHVybiB0b3VjaFByb3BbMF07XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmdldFBvaW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpLFxuICAgICAgICBfZXZ0ID0gZ2V0VG91Y2hJbmZvKGV2ZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogX2V2dC5jbGllbnRYICsgc2Nyb2xsLmxlZnQsXG4gICAgICB5OiBfZXZ0LmNsaWVudFkgKyBzY3JvbGwudG9wXG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50cy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3Igc2V0dGluZyBlbGVtZW50J3Mgc3R5bGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKCFlbGVtZW50U3R5bGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBzdHlsZXM7XG4gICAgICByZXR1cm4gc3R5bGVzLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xXG4gICAgICAgID8gc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXMubWF0Y2goL29wYWNpdHk6XFxzKihcXGQ/XFwuP1xcZCopLylbMV0pXG4gICAgICAgIDogZWxlbWVudDtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkgPT09ICdmbG9hdCcgfHwgcHJvcGVydHkgPT09ICdjc3NGbG9hdCcpXG4gICAgICAgICAgPyAodHlwZW9mIGVsZW1lbnRTdHlsZS5zdHlsZUZsb2F0ID09PSAndW5kZWZpbmVkJyA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcpXG4gICAgICAgICAgOiBwcm9wZXJ0eTtcbiAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wZXJ0eSwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvZmZzZXQgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgb2Zmc2V0IGZvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwibGVmdFwiIGFuZCBcInRvcFwiIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBkb2NFbGVtLFxuICAgICAgICBkb2MgPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm94ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgc2Nyb2xsTGVmdFRvcCxcbiAgICAgICAgb2Zmc2V0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICdsZWZ0JyxcbiAgICAgICAgICBib3JkZXJUb3BXaWR0aDogICd0b3AnLFxuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAgICAgJ2xlZnQnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICAgICAgJ3RvcCdcbiAgICAgICAgfTtcblxuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gb2Zmc2V0QXR0cmlidXRlcykge1xuICAgICAgb2Zmc2V0W29mZnNldEF0dHJpYnV0ZXNbYXR0cl1dICs9IHBhcnNlSW50KGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCBhdHRyKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBzY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnRUb3AubGVmdCAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMCkgKyBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbExlZnRUb3AudG9wIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApICArIG9mZnNldC50b3BcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzdHlsZSBhdHRyaWJ1dGUgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFN0eWxlIGF0dHJpYnV0ZSB0byBnZXQgZm9yIGVsZW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgZ2V0RWxlbWVudFN0eWxlO1xuICBpZiAoZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gc3R5bGUgPyBzdHlsZVthdHRyXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuc3R5bGVbYXR0cl07XG4gICAgICBpZiAoIXZhbHVlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgc2VsZWN0UHJvcCA9ICd1c2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgID8gJ3VzZXJTZWxlY3QnXG4gICAgICAgICAgOiAnTW96VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgID8gJ01velVzZXJTZWxlY3QnXG4gICAgICAgICAgICA6ICdXZWJraXRVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICA/ICdXZWJraXRVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICA6ICdLaHRtbFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgICAgPyAnS2h0bWxVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICAgIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHVuc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHVuc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWJyaWMudXRpbC5mYWxzZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCBzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2Ugc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGU7XG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRTZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRTZWxlY3RhYmxlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVDYW52YXMoZWxlbWVudCkge1xuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgcmV0dXJuIGltcGwuX2NhbnZhcyB8fCBpbXBsLl9pbWFnZTtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhblVwSnNkb21Ob2RlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGltcGwgPSBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlcihlbGVtZW50KTtcbiAgICBpZiAoaW1wbCkge1xuICAgICAgaW1wbC5faW1hZ2UgPSBudWxsO1xuICAgICAgaW1wbC5fY2FudmFzID0gbnVsbDtcbiAgICAgIC8vIHVuc3VyZSBpZiBuZWNlc3NhcnlcbiAgICAgIGltcGwuX2N1cnJlbnRTcmMgPSBudWxsO1xuICAgICAgaW1wbC5fYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICBpbXBsLl9jbGFzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEltYWdlU21vb3RoaW5nKGN0eCwgdmFsdWUpIHtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXG4gICAgICB8fCBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgub0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogc2V0SW1hZ2VTbW9vdGhpbmcgc2V0cyB0aGUgY29udGV4dCBpbWFnZVNtb290aGluZ0VuYWJsZWQgcHJvcGVydHkuXG4gICAqIFVzZWQgYnkgY2FudmFzIGFuZCBieSBJbWFnZU9iamVjdC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcGFyYW0ge0hUTUxSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBzZXQgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSB0cnVlIG9yIGZhbHNlXG4gICAqL1xuICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyA9IHNldEltYWdlU21vb3RoaW5nO1xuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0Tm9kZUNhbnZhcyA9IGdldE5vZGVDYW52YXM7XG4gIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUgPSBjbGVhblVwSnNkb21Ob2RlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhZGRQYXJhbVRvVXJsKHVybCwgcGFyYW0pIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBwYXJhbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcsXG4gICAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIHhociA9IG5ldyBmYWJyaWMud2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJhbWV0ZXJzO1xuXG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgb25Db21wbGV0ZSh4aHIpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHVybCA9IGFkZFBhcmFtVG9VcmwodXJsLCBvcHRpb25zLnBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdQT1NUJyB8fCBtZXRob2QgPT09ICdQVVQnKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICBmYWJyaWMudXRpbC5yZXF1ZXN0ID0gcmVxdWVzdDtcbn0pKCk7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS5sb2dgICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZ1xuICovXG5mYWJyaWMubG9nID0gY29uc29sZS5sb2c7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUud2FybmAgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nIGFzIGEgd2FybmluZ1xuICovXG5mYWJyaWMud2FybiA9IGNvbnNvbGUud2FybjtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAgICogQW5pbWF0aW9uIG9mIGEgdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMuXG4gICAqIFdoZW4gdXNpbmcgbGlzdHMsIHRoaW5rIG9mIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgKiAgIHN0YXJ0VmFsdWU6IFsxLCAyLCAzXSxcbiAgICogICBlbmRWYWx1ZTogWzIsIDQsIDZdLFxuICAgKiAgIG9uQ2hhbmdlOiBmdW5jdGlvbihbYSwgYiwgY10pIHtcbiAgICogICAgIGNhbnZhcy56b29tVG9Qb2ludCh7eDogYiwgeTogY30sIGEpXG4gICAqICAgICBjYW52YXMucmVuZGVyQWxsKClcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBAZXhhbXBsZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE5vdGU6IHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBhbmQgYnlWYWx1ZSBtdXN0IG1hdGNoIHRoZSB0eXBlXG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiAwLCBlbmRWYWx1ZTogMSwgYnlWYWx1ZTogMC4yNSB9XG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtzdGFydFZhbHVlPTBdIFN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtlbmRWYWx1ZT0xMDBdIEVuZGluZyB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBbYnlWYWx1ZT0xMDBdIFZhbHVlIHRvIG1vZGlmeSB0aGUgcHJvcGVydHkgYnlcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2Vhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZHVyYXRpb249NTAwXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBhbmltYXRpb24gYWJvcnRzLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7KCkgPT4gdm9pZH0gQ2FuY2VsRnVuY3Rpb25cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uQ3VycmVudFN0YXRlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IGN1cnJlbnRWYWx1ZSB2YWx1ZSBpbiByYW5nZSBbYHN0YXJ0VmFsdWVgLCBgZW5kVmFsdWVgXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY29tcGxldGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqXG4gICAqIEB0eXBlZGVmIHsoQW5pbWF0aW9uT3B0aW9ucyAmIEFuaW1hdGlvbkN1cnJlbnRTdGF0ZSAmIHsgY2FuY2VsOiBDYW5jZWxGdW5jdGlvbiB9fSBBbmltYXRpb25Db250ZXh0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBcnJheSBob2xkaW5nIGFsbCBydW5uaW5nIGFuaW1hdGlvbnNcbiAgICogQG1lbWJlcm9mIGZhYnJpY1xuICAgKiBAdHlwZSB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgKi9cbiAgdmFyIFJVTk5JTkdfQU5JTUFUSU9OUyA9IFtdO1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKFJVTk5JTkdfQU5JTUFUSU9OUywge1xuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuc3BsaWNlKDApO1xuICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXR0YWNoZWQgdG8gY2FudmFzIGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltRnJhbWVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQnlDYW52YXM6IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW5jZWxsZWQgPSB0aGlzLmZpbHRlcihmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYW5pbWF0aW9uLnRhcmdldCA9PT0gJ29iamVjdCcgJiYgYW5pbWF0aW9uLnRhcmdldC5jYW52YXMgPT09IGNhbnZhcztcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBhbGwgcnVubmluZyBhbmltYXRpb25zIGZvciB0YXJnZXQgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICAgKi9cbiAgICBjYW5jZWxCeVRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdmFyIGNhbmNlbGxlZCA9IHRoaXMuZmluZEFuaW1hdGlvbnNCeVRhcmdldCh0YXJnZXQpO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW5jZWxGdW5jdGlvbn0gY2FuY2VsRnVuYyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYW5pbWF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmluZEFuaW1hdGlvbkluZGV4OiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih0aGlzLmZpbmRBbmltYXRpb24oY2FuY2VsRnVuYykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbEZ1bmMgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dCB8IHVuZGVmaW5lZH0gYW5pbWF0aW9uJ3Mgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uOiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24uY2FuY2VsID09PSBjYW5jZWxGdW5jO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgdGhlIG9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQgcHJvcGVydHkgb2YgdGhlIGFuaW1hdGlvbiBjb250ZXh0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX0gYXJyYXkgb2YgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0YXJnZXRcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uc0J5VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRhcmdldCA9PT0gdGFyZ2V0O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTm90ZTogc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGFuZCBieVZhbHVlIG11c3QgbWF0Y2ggdGhlIHR5cGVcbiAgICogZmFicmljLnV0aWwuYW5pbWF0ZSh7IHN0YXJ0VmFsdWU6IDAsIGVuZFZhbHVlOiAxLCBieVZhbHVlOiAwLjI1IH0pXG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoeyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9KVxuICAgKiBAcmV0dXJucyB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgY2FuY2VsID0gZmFsc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuaW5kZXhPZihjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSAmJiBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgfTtcblxuICAgIGNvbnRleHQgPSBleHRlbmQoY2xvbmUob3B0aW9ucyksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVJlZ2lzdHJ5KCk7XG4gICAgICB9LFxuICAgICAgY3VycmVudFZhbHVlOiAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICBjb21wbGV0aW9uUmF0ZTogMCxcbiAgICAgIGR1cmF0aW9uUmF0ZTogMFxuICAgIH0pO1xuICAgIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5wdXNoKGNvbnRleHQpO1xuXG4gICAgcmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgIHZhciBzdGFydCA9IHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLFxuICAgICAgICAgIGZpbmlzaCA9IHN0YXJ0ICsgZHVyYXRpb24sIHRpbWUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlIHx8IG5vb3AsXG4gICAgICAgICAgYWJvcnQgPSBvcHRpb25zLmFib3J0IHx8IG5vb3AsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8IGRlZmF1bHRFYXNpbmcsXG4gICAgICAgICAgaXNNYW55ID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUubGVuZ3RoID4gMCA6IGZhbHNlLFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgKGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWVbaV0gLSBzdGFydFZhbHVlW2ldO1xuICAgICAgICAgIH0pIDogZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICB0aW1lID0gdGlja3RpbWUgfHwgK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRpbWUgPiBmaW5pc2ggPyBkdXJhdGlvbiA6ICh0aW1lIC0gc3RhcnQpLFxuICAgICAgICAgICAgdGltZVBlcmMgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uLFxuICAgICAgICAgICAgY3VycmVudCA9IGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKF92YWx1ZSwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlW2ldLCBieVZhbHVlW2ldLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9KSA6IGVhc2luZyhjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pLFxuICAgICAgICAgICAgdmFsdWVQZXJjID0gaXNNYW55ID8gTWF0aC5hYnMoKGN1cnJlbnRbMF0gLSBzdGFydFZhbHVlWzBdKSAvIGJ5VmFsdWVbMF0pXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoKGN1cnJlbnQgLSBzdGFydFZhbHVlKSAvIGJ5VmFsdWUpO1xuICAgICAgICAvLyAgdXBkYXRlIGNvbnRleHRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VmFsdWUgPSBpc01hbnkgPyBjdXJyZW50LnNsaWNlKCkgOiBjdXJyZW50O1xuICAgICAgICBjb250ZXh0LmNvbXBsZXRpb25SYXRlID0gdmFsdWVQZXJjO1xuICAgICAgICBjb250ZXh0LmR1cmF0aW9uUmF0ZSA9IHRpbWVQZXJjO1xuICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYm9ydChjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSkge1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIC8vICB1cGRhdGUgY29udGV4dFxuICAgICAgICAgIGNvbnRleHQuY3VycmVudFZhbHVlID0gaXNNYW55ID8gZW5kVmFsdWUuc2xpY2UoKSA6IGVuZFZhbHVlO1xuICAgICAgICAgIGNvbnRleHQuY29tcGxldGlvblJhdGUgPSAxO1xuICAgICAgICAgIGNvbnRleHQuZHVyYXRpb25SYXRlID0gMTtcbiAgICAgICAgICAvLyAgZXhlY3V0ZSBjYWxsYmFja3NcbiAgICAgICAgICBvbkNoYW5nZShpc01hbnkgPyBlbmRWYWx1ZS5zbGljZSgpIDogZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIG9uQ29tcGxldGUoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9KShzdGFydCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dC5jYW5jZWw7XG4gIH1cblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWJyaWMud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgdmFyIF9jYW5jZWxBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZhYnJpYy53aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIC8qKlxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYmFzZWQgb24gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICogSW4gb3JkZXIgdG8gZ2V0IGEgcHJlY2lzZSBzdGFydCB0aW1lLCBgcmVxdWVzdEFuaW1GcmFtZWAgc2hvdWxkIGJlIGNhbGxlZCBhcyBhbiBlbnRyeSBpbnRvIHRoZSBtZXRob2RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgb3B0aW9uYWwgRWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCBhbmltYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0QW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9jYW5jZWxBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGUgPSBhbmltYXRlO1xuICBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZTtcbiAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lID0gY2FuY2VsQW5pbUZyYW1lO1xuICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMgPSBSVU5OSU5HX0FOSU1BVElPTlM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLy8gQ2FsY3VsYXRlIGFuIGluLWJldHdlZW4gY29sb3IuIFJldHVybnMgYSBcInJnYmEoKVwiIHN0cmluZy5cbiAgLy8gQ3JlZGl0OiBFZHdpbiBNYXJ0aW4gPGVkd2luQGJpdHN0b3JtLm9yZz5cbiAgLy8gICAgICAgICBodHRwOi8vd3d3LmJpdHN0b3JtLm9yZy9qcXVlcnkvY29sb3ItYW5pbWF0aW9uL2pxdWVyeS5hbmltYXRlLWNvbG9ycy5qc1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcihiZWdpbiwgZW5kLCBwb3MpIHtcbiAgICB2YXIgY29sb3IgPSAncmdiYSgnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzBdICsgcG9zICogKGVuZFswXSAtIGJlZ2luWzBdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsxXSArIHBvcyAqIChlbmRbMV0gLSBiZWdpblsxXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMl0gKyBwb3MgKiAoZW5kWzJdIC0gYmVnaW5bMl0pKSwgMTApO1xuXG4gICAgY29sb3IgKz0gJywnICsgKGJlZ2luICYmIGVuZCA/IHBhcnNlRmxvYXQoYmVnaW5bM10gKyBwb3MgKiAoZW5kWzNdIC0gYmVnaW5bM10pKSA6IDEpO1xuICAgIGNvbG9yICs9ICcpJztcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY29sb3IgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbUNvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb2xvckVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHRha2UgdHdvIGFyZ3VtZW50cyAoY3VycmVudFRpbWUsIGR1cmF0aW9uKS4gVGh1cyB0aGUgcmVndWxhciBhbmltYXRpb24gZWFzaW5nIGZ1bmN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBvbkNvbXBsZXRlIGlzIGNhbGxlZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhYm9ydCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZUNvbG9yKGZyb21Db2xvciwgdG9Db2xvciwgZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoZnJvbUNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgZW5kQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRvQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBvcmlnaW5hbE9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUsXG4gICAgICAgIG9yaWdpbmFsT25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgNTAwLFxuICAgICAgc3RhcnRWYWx1ZTogc3RhcnRDb2xvcixcbiAgICAgIGVuZFZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGJ5VmFsdWU6IGVuZENvbG9yLFxuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBwb3NWYWx1ZSA9IG9wdGlvbnMuY29sb3JFYXNpbmdcbiAgICAgICAgICA/IG9wdGlvbnMuY29sb3JFYXNpbmcoY3VycmVudFRpbWUsIGR1cmF0aW9uKVxuICAgICAgICAgIDogMSAtIE1hdGguY29zKGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKiAoTWF0aC5QSSAvIDIpKTtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9yKHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIHBvc1ZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBoYXMgdG8gdGFrZSBpbiBhY2NvdW50IGZvciBjb2xvciByZXN0b3Jpbmc7XG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNvbXBsZXRlKFxuICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoZW5kQ29sb3IsIGVuZENvbG9yLCAwKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgIHRpbWVQZXJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uQ2hhbmdlKFxuICAgICAgICAgICAgICBjYWxjdWxhdGVDb2xvcihjdXJyZW50LCBjdXJyZW50LCAwKSxcbiAgICAgICAgICAgICAgdmFsdWVQZXJjLFxuICAgICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxPbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICBzdmdWYWxpZFRhZ05hbWVzID0gWydwYXRoJywgJ2NpcmNsZScsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ2VsbGlwc2UnLCAncmVjdCcsICdsaW5lJyxcbiAgICAgICAgJ2ltYWdlJywgJ3RleHQnXSxcbiAgICAgIHN2Z1ZpZXdCb3hFbGVtZW50cyA9IFsnc3ltYm9sJywgJ2ltYWdlJywgJ21hcmtlcicsICdwYXR0ZXJuJywgJ3ZpZXcnLCAnc3ZnJ10sXG4gICAgICBzdmdJbnZhbGlkQW5jZXN0b3JzID0gWydwYXR0ZXJuJywgJ2RlZnMnLCAnc3ltYm9sJywgJ21ldGFkYXRhJywgJ2NsaXBQYXRoJywgJ21hc2snLCAnZGVzYyddLFxuICAgICAgc3ZnVmFsaWRQYXJlbnRzID0gWydzeW1ib2wnLCAnZycsICdhJywgJ3N2ZycsICdjbGlwUGF0aCcsICdkZWZzJ10sXG5cbiAgICAgIGF0dHJpYnV0ZXNNYXAgPSB7XG4gICAgICAgIGN4OiAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHI6ICAgICAgICAgICAgICAgICAgICAncmFkaXVzJyxcbiAgICAgICAgY3k6ICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICB5OiAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGRpc3BsYXk6ICAgICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHZpc2liaWxpdHk6ICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHRyYW5zZm9ybTogICAgICAgICAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdmaWxsLXJ1bGUnOiAgICAgICAgICAnZmlsbFJ1bGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udC1zaXplJzogICAgICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgICdmb250U3R5bGUnLFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICAgJ3BhaW50LW9yZGVyJzogICAgICAgICdwYWludEZpcnN0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ3RleHRBbmNob3InLFxuICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnY2xpcC1wYXRoJzogICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgICdjbGlwUnVsZScsXG4gICAgICAgICd2ZWN0b3ItZWZmZWN0JzogICAgICAnc3Ryb2tlVW5pZm9ybScsXG4gICAgICAgICdpbWFnZS1yZW5kZXJpbmcnOiAgICAnaW1hZ2VTbW9vdGhpbmcnLFxuICAgICAgfSxcblxuICAgICAgY29sb3JBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzdHJva2U6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgZmlsbDogICAnZmlsbE9wYWNpdHknXG4gICAgICB9LFxuXG4gICAgICBmU2l6ZSA9ICdmb250LXNpemUnLCBjUGF0aCA9ICdjbGlwLXBhdGgnO1xuXG4gIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFRhZ05hbWVzKTtcbiAgZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmlld0JveEVsZW1lbnRzKTtcbiAgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z0ludmFsaWRBbmNlc3RvcnMpO1xuICBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFBhcmVudHMpO1xuXG4gIGZhYnJpYy5jc3NSdWxlcyA9IHsgfTtcbiAgZmFicmljLmdyYWRpZW50RGVmcyA9IHsgfTtcbiAgZmFicmljLmNsaXBQYXRocyA9IHsgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVBdHRyKGF0dHIpIHtcbiAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIG5hbWVzXG4gICAgaWYgKGF0dHIgaW4gYXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNNYXBbYXR0cl07XG4gICAgfVxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUoYXR0ciwgdmFsdWUsIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKSB7XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSwgcGFyc2VkO1xuXG4gICAgaWYgKChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpICYmIHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VVbmlmb3JtJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ25vbi1zY2FsaW5nLXN0cm9rZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLC9nLCAnICcpLnNwbGl0KC9cXHMrLykubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndHJhbnNmb3JtTWF0cml4Jykge1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFsdWUgPSBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4LCBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd2aXNpYmxlJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gJ25vbmUnICYmIHZhbHVlICE9PSAnaGlkZGVuJztcbiAgICAgIC8vIGRpc3BsYXk9bm9uZSBvbiBwYXJlbnQgZWxlbWVudCBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNoaWxkIGVsZW1lbnRcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ29wYWNpdHknKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgKj0gcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndGV4dEFuY2hvcicgLyogdGV4dC1hbmNob3IgKi8pIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdzdGFydCcgPyAnbGVmdCcgOiB2YWx1ZSA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdjaGFyU3BhY2luZycpIHtcbiAgICAgIC8vIHBhcnNlVW5pdCByZXR1cm5zIHB4IGFuZCB3ZSBjb252ZXJ0IGl0IHRvIGVtXG4gICAgICBwYXJzZWQgPSBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKSAvIGZvbnRTaXplICogMTAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3BhaW50Rmlyc3QnKSB7XG4gICAgICB2YXIgZmlsbEluZGV4ID0gdmFsdWUuaW5kZXhPZignZmlsbCcpO1xuICAgICAgdmFyIHN0cm9rZUluZGV4ID0gdmFsdWUuaW5kZXhPZignc3Ryb2tlJyk7XG4gICAgICB2YXIgdmFsdWUgPSAnZmlsbCc7XG4gICAgICBpZiAoZmlsbEluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA8IGZpbGxJbmRleCkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsbEluZGV4ID09PSAtMSAmJiBzdHJva2VJbmRleCA+IC0xKSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdocmVmJyB8fCBhdHRyID09PSAneGxpbms6aHJlZicgfHwgYXR0ciA9PT0gJ2ZvbnQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdpbWFnZVNtb290aGluZycpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09ICdvcHRpbWl6ZVF1YWxpdHknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWQgPSBpc0FycmF5ID8gdmFsdWUubWFwKHBhcnNlVW5pdCkgOiBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCFpc0FycmF5ICYmIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZCk7XG4gIH1cblxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3ZnUmVnZXgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIGFyci5qb2luKCd8JykgKyAnKVxcXFxiJywgJ2knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3Ryb2tlRmlsbE9wYWNpdHkoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIGF0dHIgaW4gY29sb3JBdHRyaWJ1dGVzKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dID09PSAndW5kZWZpbmVkJyB8fCBhdHRyaWJ1dGVzW2F0dHJdID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2F0dHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKCd1cmwoJykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gY29sb3Iuc2V0QWxwaGEodG9GaXhlZChjb2xvci5nZXRBbHBoYSgpICogYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dLCAyKSkudG9SZ2JhKCk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIG5vZGVOYW1lcykge1xuICAgIHZhciBub2RlTmFtZSwgbm9kZUFycmF5ID0gW10sIG5vZGVMaXN0LCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlTmFtZSA9IG5vZGVOYW1lc1tpXTtcbiAgICAgIG5vZGVMaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgIG5vZGVBcnJheSA9IG5vZGVBcnJheS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlVmFsdWUgU3RyaW5nIGNvbnRhaW5pbmcgYXR0cmlidXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiA2IGVsZW1lbnRzIHJlcHJlc2VudGluZyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICovXG4gIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgY29zID0gZmFicmljLnV0aWwuY29zKGFyZ3NbMF0pLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYXJnc1swXSksXG4gICAgICAgICAgeCA9IDAsIHkgPSAwO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHggPSBhcmdzWzFdO1xuICAgICAgICB5ID0gYXJnc1syXTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4WzBdID0gY29zO1xuICAgICAgbWF0cml4WzFdID0gc2luO1xuICAgICAgbWF0cml4WzJdID0gLXNpbjtcbiAgICAgIG1hdHJpeFszXSA9IGNvcztcbiAgICAgIG1hdHJpeFs0XSA9IHggLSAoY29zICogeCAtIHNpbiAqIHkpO1xuICAgICAgbWF0cml4WzVdID0geSAtIChzaW4gKiB4ICsgY29zICogeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgbXVsdGlwbGllclggPSBhcmdzWzBdLFxuICAgICAgICAgIG11bHRpcGxpZXJZID0gKGFyZ3MubGVuZ3RoID09PSAyKSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuXG4gICAgICBtYXRyaXhbMF0gPSBtdWx0aXBsaWVyWDtcbiAgICAgIG1hdHJpeFszXSA9IG11bHRpcGxpZXJZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCBwb3MpIHtcbiAgICAgIG1hdHJpeFtwb3NdID0gTWF0aC50YW4oZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgbWF0cml4WzRdID0gYXJnc1swXTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtYXRyaXhbNV0gPSBhcmdzWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBpTWF0cml4ID0gZmFicmljLmlNYXRyaXgsXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSBmYWJyaWMuY29tbWFXc3AsXG5cbiAgICAgICAgc2tld1ggPSAnKD86KHNrZXdYKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2tld1kgPSAnKD86KHNrZXdZKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgcm90YXRlID0gJyg/Oihyb3RhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBzY2FsZSA9ICcoPzooc2NhbGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNsYXRlID0gJyg/Oih0cmFuc2xhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgbWF0cml4ID0gJyg/OihtYXRyaXgpXFxcXHMqXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAnXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2Zvcm0gPSAnKD86JyArXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1ggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WSArXG4gICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1zID0gJyg/OicgKyB0cmFuc2Zvcm0gKyAnKD86JyArIGNvbW1hV3NwICsgJyonICsgdHJhbnNmb3JtICsgJykqJyArICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1MaXN0ID0gJ15cXFxccyooPzonICsgdHJhbnNmb3JtcyArICc/KVxcXFxzKiQnLFxuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNUcmFuc2Zvcm1BdHRyaWJ1dGVcbiAgICAgICAgcmVUcmFuc2Zvcm1MaXN0ID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm1MaXN0KSxcbiAgICAgICAgLy8gPT0gZW5kIHRyYW5zZm9ybSByZWdleHBcblxuICAgICAgICByZVRyYW5zZm9ybSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtLCAnZycpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggaWRlbnRpdHkgbWF0cml4XG4gICAgICB2YXIgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBtYXRyaWNlcyA9IFtdO1xuXG4gICAgICAvLyByZXR1cm4gaWYgbm8gYXJndW1lbnQgd2FzIGdpdmVuIG9yXG4gICAgICAvLyBhbiBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCB0cmFuc2Zvcm0gYXR0cmlidXRlIHJlZ2V4cFxuICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAoYXR0cmlidXRlVmFsdWUgJiYgIXJlVHJhbnNmb3JtTGlzdC50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlVmFsdWUucmVwbGFjZShyZVRyYW5zZm9ybSwgZnVuY3Rpb24obWF0Y2gpIHtcblxuICAgICAgICB2YXIgbSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtKS5leGVjKG1hdGNoKS5maWx0ZXIoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIG1hdGNoICE9PSAnJyAmJiBtYXRjaCAhPSBudWxsXG4gICAgICAgICAgICAgIHJldHVybiAoISFtYXRjaCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1bMV0sXG4gICAgICAgICAgICBhcmdzID0gbS5zbGljZSgyKS5tYXAocGFyc2VGbG9hdCk7XG5cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgYXJnc1swXSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSk7XG4gICAgICAgICAgICByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgIHNjYWxlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgbWF0cml4ID0gYXJncztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc25hcHNob3QgY3VycmVudCBtYXRyaXggaW50byBtYXRyaWNlcyBhcnJheVxuICAgICAgICBtYXRyaWNlcy5wdXNoKG1hdHJpeC5jb25jYXQoKSk7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNvbWJpbmVkTWF0cml4ID0gbWF0cmljZXNbMF07XG4gICAgICB3aGlsZSAobWF0cmljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtYXRyaWNlcy5zaGlmdCgpO1xuICAgICAgICBjb21iaW5lZE1hdHJpeCA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoY29tYmluZWRNYXRyaXgsIG1hdHJpY2VzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZE1hdHJpeDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIHN0eWxlLnJlcGxhY2UoLztcXHMqJC8sICcnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB2YXIgcGFpciA9IGNodW5rLnNwbGl0KCc6Jyk7XG5cbiAgICAgIGF0dHIgPSBwYWlyWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAgcGFpclsxXS50cmltKCk7XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGF0dHIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSB7XG4gICAgdmFyIHN0eWxlcyA9IHsgfTtcbiAgICBmb3IgKHZhciBydWxlIGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdKSB7XG4gICAgICBpZiAoZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHJ1bGUuc3BsaXQoJyAnKSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV0pIHtcbiAgICAgICAgICBzdHlsZXNbcHJvcGVydHldID0gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgZmlyc3RNYXRjaGluZywgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIC8vc3RhcnQgZnJvbSByaWdodG1vc3Qgc2VsZWN0b3IuXG4gICAgZmlyc3RNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcnMucG9wKCkpO1xuICAgIGlmIChmaXJzdE1hdGNoaW5nICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZyAmJiBwYXJlbnRNYXRjaGluZyAmJiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBzZWxlY3RvciwgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYXJlbnRNYXRjaGluZykge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLFxuICAgICAgICBjbGFzc05hbWVzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksIG1hdGNoZXIsIGk7XG4gICAgLy8gaSBjaGVjayBpZiBhIHNlbGVjdG9yIG1hdGNoZXMgc2xpY2luZyBhd2F5IHBhcnQgZnJvbSBpdC5cbiAgICAvLyBpZiBpIGdldCBlbXB0eSBzdHJpbmcgaSBzaG91bGQgbWF0Y2hcbiAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXicgKyBub2RlTmFtZSwgJ2knKTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIGlmIChpZCAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCcjJyArIGlkICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGkgPSBjbGFzc05hbWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXFxcXC4nICsgY2xhc3NOYW1lc1tpXSArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRvIHN1cHBvcnQgSUU4IG1pc3NpbmcgZ2V0RWxlbWVudEJ5SWQgb24gU1ZHZG9jdW1lbnQgYW5kIG9uIG5vZGUgeG1sRE9NXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIGxlbiwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVsaXN0W2ldO1xuICAgICAgaWYgKGlkID09PSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIFsndXNlJywgJ3N2Zzp1c2UnXSksIGkgPSAwO1xuICAgIHdoaWxlIChub2RlbGlzdC5sZW5ndGggJiYgaSA8IG5vZGVsaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGVsID0gbm9kZWxpc3RbaV0sXG4gICAgICAgICAgeGxpbmtBdHRyaWJ1dGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgaWYgKHhsaW5rQXR0cmlidXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhsaW5rID0geGxpbmtBdHRyaWJ1dGUuc2xpY2UoMSksXG4gICAgICAgICAgeCA9IGVsLmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgICAgeSA9IGVsLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgICAgZWwyID0gZWxlbWVudEJ5SWQoZG9jLCB4bGluaykuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IChlbDIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyAnIHRyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknLFxuICAgICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgICAgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLFxuICAgICAgICAgIGosXG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgbGVuLFxuICAgICAgICAgIG5hbWVzcGFjZSA9IGZhYnJpYy5zdmdOUztcblxuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsMik7XG4gICAgICBpZiAoL15zdmckL2kudGVzdChlbDIubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBlbDMgPSBlbDIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnZycpO1xuICAgICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsMi5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICAgIGVsMy5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fFxuICAgICAgICAgIGF0dHIubm9kZU5hbWUgPT09ICd4bGluazpocmVmJyB8fCBhdHRyLm5vZGVOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgISh2aWV3Qm94QXR0ciA9IHZpZXdCb3hBdHRyLm1hdGNoKHJlVmlld0JveEF0dHJWYWx1ZSkpKSxcbiAgICAgICAgbWlzc2luZ0RpbUF0dHIgPSAoIXdpZHRoQXR0ciB8fCAhaGVpZ2h0QXR0ciB8fCB3aWR0aEF0dHIgPT09ICcxMDAlJyB8fCBoZWlnaHRBdHRyID09PSAnMTAwJScpLFxuICAgICAgICB0b0JlUGFyc2VkID0gbWlzc2luZ1ZpZXdCb3ggJiYgbWlzc2luZ0RpbUF0dHIsXG4gICAgICAgIHBhcnNlZERpbSA9IHsgfSwgdHJhbnNsYXRlTWF0cml4ID0gJycsIHdpZHRoRGlmZiA9IDAsIGhlaWdodERpZmYgPSAwO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIGlmICgoKHggfHwgeSkgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpKSB7XG4gICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgICAgICBtYXRyaXggPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArIHRyYW5zbGF0ZU1hdHJpeDtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvQmVQYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICAvLyBzZXQgYSB0cmFuc2Zvcm0gZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB4IHkgYW5kIGFyZSBpbm5lcihvbmx5KSBTVkdzXG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuICAgIHBhcnNlZERpbS5taW5YID0gbWluWDtcbiAgICBwYXJzZWREaW0ubWluWSA9IG1pblk7XG4gICAgcGFyc2VkRGltLnZpZXdCb3hXaWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICBwYXJzZWREaW0udmlld0JveEhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIGlmICgoeCB8fCB5KSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQnKSB7XG4gICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0cmFuc2xhdGVNYXRyaXggKyAnIG1hdHJpeCgnICsgc2NhbGVYICtcbiAgICAgICAgICAgICAgICAgICcgMCcgK1xuICAgICAgICAgICAgICAgICAgJyAwICcgK1xuICAgICAgICAgICAgICAgICAgc2NhbGVZICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5YICogc2NhbGVYICsgd2lkdGhEaWZmKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWSAqIHNjYWxlWSArIGhlaWdodERpZmYpICsgJykgJztcbiAgICAvLyBzZWVtcyB1bnVzZWQuXG4gICAgLy8gcGFyc2VkRGltLnZpZXdib3hUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUobWF0cml4KTtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmYWJyaWMuc3ZnTlMsICdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIG1hdHJpeCA9IGVsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgKyBtYXRyaXg7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAoIWVsZW1lbnRzIHx8IChlbGVtZW50cyAmJiAhZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10sIHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsaXBQYXRocyA9IHsgfTtcbiAgICBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpID09PSAnY2xpcFBhdGgnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIGNsaXBQYXRoc1tpZF0gPSBmYWJyaWMudXRpbC50b0FycmF5KGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdID0gZmFicmljLmdldEdyYWRpZW50RGVmcyhkb2MpO1xuICAgIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdID0gZmFicmljLmdldENTU1J1bGVzKGRvYyk7XG4gICAgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdID0gY2xpcFBhdGhzO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgICBkZWxldGUgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF07XG4gICAgICB9XG4gICAgfSwgY2xvbmUob3B0aW9ucyksIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBncmFkaWVudCkge1xuICAgIHZhciBncmFkaWVudHNBdHRycyA9IFsnZ3JhZGllbnRUcmFuc2Zvcm0nLCAneDEnLCAneDInLCAneTEnLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5J10sXG4gICAgICAgIHhsaW5rQXR0ciA9ICd4bGluazpocmVmJyxcbiAgICAgICAgeExpbmsgPSBncmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKS5zbGljZSgxKSxcbiAgICAgICAgcmVmZXJlbmNlZEdyYWRpZW50ID0gZWxlbWVudEJ5SWQoZG9jLCB4TGluayk7XG4gICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKHhsaW5rQXR0cikpIHtcbiAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIHJlZmVyZW5jZWRHcmFkaWVudCk7XG4gICAgfVxuICAgIGdyYWRpZW50c0F0dHJzLmZvckVhY2goZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiAhZ3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpICYmIHJlZmVyZW5jZWRHcmFkaWVudC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlKGF0dHIsIHJlZmVyZW5jZWRHcmFkaWVudC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZ3JhZGllbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlQ2xvbmUgPSByZWZlcmVuY2VkR3JhZGllbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZ3JhZGllbnQuYXBwZW5kQ2hpbGQocmVmZXJlbmNlQ2xvbmUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyYWRpZW50LnJlbW92ZUF0dHJpYnV0ZSh4bGlua0F0dHIpO1xuICB9XG5cbiAgdmFyIHJlRm9udERlY2xhcmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAnKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqJyArXG4gICAgJyhub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMCk/XFxcXHMqKCcgK1xuICAgICAgZmFicmljLnJlTnVtICtcbiAgICAnKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8JyArIGZhYnJpYy5yZU51bSArICcpKT9cXFxccysoLiopJyk7XG5cbiAgZXh0ZW5kKGZhYnJpYywge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNob3J0IGZvbnQgZGVjbGFyYXRpb24sIGJ1aWxkaW5nIGFkZGluZyBpdHMgcHJvcGVydGllcyB0byBhIHN0eWxlIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGZvbnQgZGVjbGFyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1N0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBwYXJzZUZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24odmFsdWUsIG9TdHlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVGb250RGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U3R5bGUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAvLyBmb250IHZhcmlhbnQgaXMgbm90IHVzZWRcbiAgICAgICAgICAvLyBmb250VmFyaWFudCA9IG1hdGNoWzJdLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBtYXRjaFszXSxcbiAgICAgICAgICBmb250U2l6ZSA9IG1hdGNoWzRdLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSBtYXRjaFs1XSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gbWF0Y2hbNl07XG5cbiAgICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChmb250V2VpZ2h0KSkgPyBmb250V2VpZ2h0IDogcGFyc2VGbG9hdChmb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBvU3R5bGUuZm9udFNpemUgPSBwYXJzZVVuaXQoZm9udFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/IDEgOiBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCByZXR1cm5pbmcgYWxsIG9mIHRoZSBncmFkaWVudCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEdyYWRpZW50IGRlZmluaXRpb25zOyBrZXkgY29ycmVzcG9uZHMgdG8gZWxlbWVudCBpZCwgdmFsdWUgLS0gdG8gZ3JhZGllbnQgZGVmaW5pdGlvbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JhZGllbnREZWZzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciB0YWdBcnJheSA9IFtcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOnJhZGlhbEdyYWRpZW50J10sXG4gICAgICAgICAgZWxMaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCB0YWdBcnJheSksXG4gICAgICAgICAgZWwsIGogPSAwLCBncmFkaWVudERlZnMgPSB7IH07XG4gICAgICBqID0gZWxMaXN0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgZWwgPSBlbExpc3Rbal07XG4gICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudERlZnNbZWwuZ2V0QXR0cmlidXRlKCdpZCcpXSA9IGVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50RGVmcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcycgbmFtZS92YWx1ZSwgZ2l2ZW4gZWxlbWVudCBhbmQgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzO1xuICAgICAqIFBhcnNlcyBwYXJlbnQgXCJnXCIgbm9kZXMgcmVjdXJzaXZlbHkgdXB3YXJkcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYXR0cmlidXRlcycgbmFtZXMvdmFsdWVzXG4gICAgICovXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzLCBzdmdVaWQpIHtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSB7IH0sXG4gICAgICAgICAgZm9udFNpemUsIHBhcmVudEZvbnRTaXplO1xuXG4gICAgICBpZiAodHlwZW9mIHN2Z1VpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3ZnVWlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcpO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUncyBhIHBhcmVudCBjb250YWluZXIgKGBnYCBvciBgYWAgb3IgYHN5bWJvbGAgbm9kZSksIHBhcnNlIGl0cyBhdHRyaWJ1dGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHNcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LnBhcmVudE5vZGUsIGF0dHJpYnV0ZXMsIHN2Z1VpZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvd25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgYXR0cikge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBpZiAodmFsdWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIG1lbW9bYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHsgfSk7XG4gICAgICAvLyBhZGQgdmFsdWVzIHBhcnNlZCBmcm9tIHN0eWxlLCB3aGljaCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhdHRyaWJ1dGVzXG4gICAgICAvLyAoc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3R5bGluZy5odG1sI1VzaW5nUHJlc2VudGF0aW9uQXR0cmlidXRlcylcbiAgICAgIHZhciBjc3NBdHRycyA9IGV4dGVuZChcbiAgICAgICAgZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLFxuICAgICAgICBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KVxuICAgICAgKTtcbiAgICAgIG93bkF0dHJpYnV0ZXMgPSBleHRlbmQoXG4gICAgICAgIG93bkF0dHJpYnV0ZXMsXG4gICAgICAgIGNzc0F0dHJzXG4gICAgICApO1xuICAgICAgaWYgKGNzc0F0dHJzW2NQYXRoXSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjUGF0aCwgY3NzQXR0cnNbY1BhdGhdKTtcbiAgICAgIH1cbiAgICAgIGZvbnRTaXplID0gcGFyZW50Rm9udFNpemUgPSBwYXJlbnRBdHRyaWJ1dGVzLmZvbnRTaXplIHx8IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIGlmIChvd25BdHRyaWJ1dGVzW2ZTaXplXSkge1xuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZSBtaW5pbXVtIHNob3VsZCBiZSA5cHggd2hlbiBkZWFsaW5nIHdpdGggZW1zLiB0aGlzIGlzIHdoYXQgbG9va3MgbGlrZSBpbiBicm93c2Vycy5cbiAgICAgICAgb3duQXR0cmlidXRlc1tmU2l6ZV0gPSBmb250U2l6ZSA9IHBhcnNlVW5pdChvd25BdHRyaWJ1dGVzW2ZTaXplXSwgcGFyZW50Rm9udFNpemUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplZEF0dHIsIG5vcm1hbGl6ZWRWYWx1ZSwgbm9ybWFsaXplZFN0eWxlID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZEF0dHIgPSBub3JtYWxpemVBdHRyKGF0dHIpO1xuICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZShub3JtYWxpemVkQXR0ciwgb3duQXR0cmlidXRlc1thdHRyXSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuICAgICAgICBub3JtYWxpemVkU3R5bGVbbm9ybWFsaXplZEF0dHJdID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vcm1hbGl6ZWRTdHlsZSAmJiBub3JtYWxpemVkU3R5bGUuZm9udCkge1xuICAgICAgICBmYWJyaWMucGFyc2VGb250RGVjbGFyYXRpb24obm9ybWFsaXplZFN0eWxlLmZvbnQsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVyZ2VkQXR0cnMgPSBleHRlbmQocGFyZW50QXR0cmlidXRlcywgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSA/IG1lcmdlZEF0dHJzIDogX3NldFN0cm9rZUZpbGxPcGFjaXR5KG1lcmdlZEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBzdmcgZWxlbWVudHMgdG8gY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIEFycmF5IG9mIGVsZW1lbnRzIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGZhYnJpYyBpbnN0YW5jZXMgKHRyYW5zZm9ybWVkIGZyb20gU1ZHIGVsZW1lbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcGFyc2VFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgICAgbmV3IGZhYnJpYy5FbGVtZW50c1BhcnNlcihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhcnNlZFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBvaW50c1tpXSksXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb2RkIG51bWJlciBvZiBwb2ludHMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIGlmIChwYXJzZWRQb2ludHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgcnVsZXMgZm9yIGEgZ2l2ZW4gU1ZHIGRvY3VtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDU1MgcnVsZXMgb2YgdGhpcyBkb2N1bWVudFxuICAgICAqL1xuICAgIGdldENTU1J1bGVzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksIGksIGxlbixcbiAgICAgICAgICBhbGxSdWxlcyA9IHsgfSwgcnVsZXM7XG5cbiAgICAgIC8vIHZlcnkgY3J1ZGUgcGFyc2luZyBvZiBzdHlsZSBjb250ZW50c1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY292ZXJzIGFsbCB0aGUgcnVsZSBpbiB0aGlzIGZvcm0gYGJvZHkgeyBzdHlsZSBjb2RlLi4uIH1gXG4gICAgICAgIC8vIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHN0eWxlQ29udGVudHMuc3BsaXQoJ30nKTtcbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHJ1bGVzLlxuICAgICAgICBydWxlcyA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBob3BlZnVsbHkgYW4gYXJyYXkgb2YgcnVsZXMgYGJvZHkgeyBzdHlsZSBjb2RlLi4uIGBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcblxuICAgICAgICAgIHZhciBtYXRjaCA9IHJ1bGUuc3BsaXQoJ3snKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnNwbGl0KCc7JykuZmlsdGVyKGZ1bmN0aW9uKHBhaXIpIHsgcmV0dXJuIHBhaXIudHJpbSgpOyB9KTtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3BlcnR5VmFsdWVQYWlycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwcm9wZXJ0eVZhbHVlUGFpcnNbaV0uc3BsaXQoJzonKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhaXJbMF0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXS50cmltKCk7XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMF0udHJpbSgpO1xuICAgICAgICAgIHJ1bGUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uKF9ydWxlKSB7XG4gICAgICAgICAgICBfcnVsZSA9IF9ydWxlLnJlcGxhY2UoL15zdmcvaSwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChfcnVsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbFJ1bGVzW19ydWxlXSkge1xuICAgICAgICAgICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGFsbFJ1bGVzW19ydWxlXSwgcnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsUnVsZXNbX3J1bGVdID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxSdWxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgdXJsIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHMuXG4gICAgICogTm90ZSB0aGF0IFNWRyBpcyBmZXRjaGVkIHZpYSBYTUxIdHRwUmVxdWVzdCwgc28gaXQgbmVlZHMgdG8gY29uZm9ybSB0byBTT1AgKFNhbWUgT3JpZ2luIFBvbGljeSlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tVVJMOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG5cbiAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9eXFxuXFxzKi8sICcnKS50cmltKCk7XG4gICAgICBuZXcgZmFicmljLnV0aWwucmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUocikge1xuXG4gICAgICAgIHZhciB4bWwgPSByLnJlc3BvbnNlWE1MO1xuICAgICAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KHhtbC5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICAgIH0sIHJldml2ZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cmluZywgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgZmFicmljLndpbmRvdy5ET01QYXJzZXIoKSxcbiAgICAgICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZy50cmltKCksICd0ZXh0L3htbCcpO1xuICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoZG9jLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLkVsZW1lbnRzUGFyc2VyID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucywgZG9jKSB7XG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnJldml2ZXIgPSByZXZpdmVyO1xuICB0aGlzLnN2Z1VpZCA9IChvcHRpb25zICYmIG9wdGlvbnMuc3ZnVWlkKSB8fCAwO1xuICB0aGlzLnBhcnNpbmdPcHRpb25zID0gcGFyc2luZ09wdGlvbnM7XG4gIHRoaXMucmVnZXhVcmwgPSAvXnVybFxcKFsnXCJdPyMoW14nXCJdKylbJ1wiXT9cXCkvZztcbiAgdGhpcy5kb2MgPSBkb2M7XG59O1xuXG4oZnVuY3Rpb24ocHJvdG8pIHtcbiAgcHJvdG8ucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBBcnJheSh0aGlzLmVsZW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5udW1FbGVtZW50cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIHRoaXMuY3JlYXRlT2JqZWN0cygpO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3ZnVWlkJywgX3RoaXMuc3ZnVWlkKTtcbiAgICAgIF90aGlzLmNyZWF0ZU9iamVjdChlbGVtZW50LCBpKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcm90by5maW5kVGFnID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZmFicmljW2ZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKGVsLnRhZ05hbWUucmVwbGFjZSgnc3ZnOicsICcnKSldO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgIHZhciBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbCk7XG4gICAgaWYgKGtsYXNzICYmIGtsYXNzLmZyb21FbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChlbCwgdGhpcy5jcmVhdGVDYWxsYmFjayhpbmRleCwgZWwpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICBmYWJyaWMubG9nKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKGluZGV4LCBlbCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIF9vcHRpb25zO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgZWwsICdmaWxsJyk7XG4gICAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCBlbCwgJ3N0cm9rZScpO1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIGZhYnJpYy5JbWFnZSAmJiBvYmouX29yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICBfb3B0aW9ucyA9IG9iai5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUoZWwpO1xuICAgICAgfVxuICAgICAgb2JqLl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgoX29wdGlvbnMpO1xuICAgICAgX3RoaXMucmVzb2x2ZUNsaXBQYXRoKG9iaiwgZWwpO1xuICAgICAgX3RoaXMucmV2aXZlciAmJiBfdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgICAgX3RoaXMuaW5zdGFuY2VzW2luZGV4XSA9IG9iajtcbiAgICAgIF90aGlzLmNoZWNrSWZEb25lKCk7XG4gICAgfTtcbiAgfTtcblxuICBwcm90by5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgc3RvcmFnZSkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wZXJ0eV0sIHJlZ2V4ID0gdGhpcy5yZWdleFVybDtcbiAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIGlkID0gcmVnZXguZXhlYyh2YWx1ZSlbMV07XG4gICAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZmFicmljW3N0b3JhZ2VdW3RoaXMuc3ZnVWlkXVtpZF07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBlbCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZ3JhZGllbnREZWYgPSB0aGlzLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24ob2JqLCBwcm9wZXJ0eSwgJ2dyYWRpZW50RGVmcycpO1xuICAgIGlmIChncmFkaWVudERlZikge1xuICAgICAgdmFyIG9wYWNpdHlBdHRyID0gZWwuZ2V0QXR0cmlidXRlKHByb3BlcnR5ICsgJy1vcGFjaXR5Jyk7XG4gICAgICB2YXIgZ3JhZGllbnQgPSBmYWJyaWMuR3JhZGllbnQuZnJvbUVsZW1lbnQoZ3JhZGllbnREZWYsIG9iaiwgb3BhY2l0eUF0dHIsIHRoaXMub3B0aW9ucyk7XG4gICAgICBvYmouc2V0KHByb3BlcnR5LCBncmFkaWVudCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihvYmosIGNvbnRhaW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbihfbmV3T2JqKSB7XG4gICAgICBfbmV3T2JqLl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIF9uZXdPYmouZmlsbFJ1bGUgPSBfbmV3T2JqLmNsaXBSdWxlO1xuICAgICAgY29udGFpbmVyLnB1c2goX25ld09iaik7XG4gICAgfTtcbiAgfTtcblxuICBwcm90by5yZXNvbHZlQ2xpcFBhdGggPSBmdW5jdGlvbihvYmosIHVzaW5nRWxlbWVudCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbihvYmosICdjbGlwUGF0aCcsICdjbGlwUGF0aHMnKSxcbiAgICAgICAgZWxlbWVudCwga2xhc3MsIG9ialRyYW5zZm9ybUludiwgY29udGFpbmVyLCBnVHJhbnNmb3JtLCBvcHRpb25zO1xuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgY29udGFpbmVyID0gW107XG4gICAgICBvYmpUcmFuc2Zvcm1JbnYgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0ob2JqLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAvLyBtb3ZlIHRoZSBjbGlwUGF0aCB0YWcgYXMgc2libGluZyB0byB0aGUgcmVhbCBlbGVtZW50IHRoYXQgaXMgdXNpbmcgaXRcbiAgICAgIHZhciBjbGlwUGF0aFRhZyA9IGNsaXBQYXRoWzBdLnBhcmVudE5vZGU7XG4gICAgICB2YXIgY2xpcFBhdGhPd25lciA9IHVzaW5nRWxlbWVudDtcbiAgICAgIHdoaWxlIChjbGlwUGF0aE93bmVyLnBhcmVudE5vZGUgJiYgY2xpcFBhdGhPd25lci5nZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpICE9PSBvYmouY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGhPd25lciA9IGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbGlwUGF0aFRhZyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBjbGlwUGF0aFtpXTtcbiAgICAgICAga2xhc3MgPSB0aGlzLmZpbmRUYWcoZWxlbWVudCk7XG4gICAgICAgIGtsYXNzLmZyb21FbGVtZW50KFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgdGhpcy5jcmVhdGVDbGlwUGF0aENhbGxiYWNrKG9iaiwgY29udGFpbmVyKSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNsaXBQYXRoID0gY29udGFpbmVyWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNsaXBQYXRoID0gbmV3IGZhYnJpYy5Hcm91cChjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgZ1RyYW5zZm9ybSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgIG9ialRyYW5zZm9ybUludixcbiAgICAgICAgY2xpcFBhdGguY2FsY1RyYW5zZm9ybU1hdHJpeCgpXG4gICAgICApO1xuICAgICAgaWYgKGNsaXBQYXRoLmNsaXBQYXRoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNsaXBQYXRoKGNsaXBQYXRoLCBjbGlwUGF0aE93bmVyKTtcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UoZ1RyYW5zZm9ybSk7XG4gICAgICBjbGlwUGF0aC5mbGlwWCA9IGZhbHNlO1xuICAgICAgY2xpcFBhdGguZmxpcFkgPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgY2xpcFBhdGguc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBjbGlwUGF0aC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBjbGlwUGF0aC5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICBjbGlwUGF0aC5za2V3WSA9IDA7XG4gICAgICBjbGlwUGF0aC5zZXRQb3NpdGlvbkJ5T3JpZ2luKHsgeDogb3B0aW9ucy50cmFuc2xhdGVYLCB5OiBvcHRpb25zLnRyYW5zbGF0ZVkgfSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIG9iai5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGlmIGNsaXAtcGF0aCBkb2VzIG5vdCByZXNvbHZlIHRvIGFueSBlbGVtZW50LCBkZWxldGUgdGhlIHByb3BlcnR5LlxuICAgICAgZGVsZXRlIG9iai5jbGlwUGF0aDtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY2hlY2tJZkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoLS10aGlzLm51bUVsZW1lbnRzID09PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG4gICAgICAgIHJldHVybiBlbCAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5zdGFuY2VzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH07XG59KShmYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvaW50KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2ludCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmYWJyaWMuUG9pbnQgPSBQb2ludDtcblxuICAvKipcbiAgICogUG9pbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2ludFxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBQb2ludC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Qb2ludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ3BvaW50JyxcblxuICAgIGNvbnN0cnVjdG9yOiBQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZSBhbmQgcmV0dXJucyBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgaW5zdGFuY2Ugd2l0aCBhZGRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoYXQueCwgdGhpcy55ICsgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkRXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ICs9IHRoYXQueDtcbiAgICAgIHRoaXMueSArPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCB3aXRoIGFkZGVkIHZhbHVlXG4gICAgICovXG4gICAgc2NhbGFyQWRkOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHNjYWxhciwgdGhpcy55ICsgc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGRFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCArPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IG9iamVjdCB3aXRoIHN1YnRyYWN0ZWQgdmFsdWVzXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggLT0gdGhhdC54O1xuICAgICAgdGhpcy55IC09IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3Q6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gc2NhbGFyLCB0aGlzLnkgLSBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC09IHNjYWxhcjtcbiAgICAgIHRoaXMueSAtPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5IGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG11bHRpcGx5RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHNjYWxhciwgdGhpcy55IC8gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlRXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGl2aWRlRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLz0gc2NhbGFyO1xuICAgICAgdGhpcy55IC89IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBlcTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID09PSB0aGF0LnggJiYgdGhpcy55ID09PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8IHRoYXQueCAmJiB0aGlzLnkgPCB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHRlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPD0gdGhhdC54ICYmIHRoaXMueSA8PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcblxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+IHRoYXQueCAmJiB0aGlzLnkgPiB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3RlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPj0gdGhhdC54ICYmIHRoaXMueSA+PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdGhpcyBvbmUgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCAsIHBvc2l0aW9uIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMSBkZWZhdWx0IDAuNVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBsZXJwOiBmdW5jdGlvbiAodGhhdCwgdCkge1xuICAgICAgaWYgKHR5cGVvZiB0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfVxuICAgICAgdCA9IE1hdGgubWF4KE1hdGgubWluKDEsIHQpLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgKHRoYXQueCAtIHRoaXMueCkgKiB0LCB0aGlzLnkgKyAodGhhdC55IC0gdGhpcy55KSAqIHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB0aGF0LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB0aGF0Lnk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pZFBvaW50RnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlcnAodGhhdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1pbiBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5taW4odGhpcy54LCB0aGF0LngpLCBNYXRoLm1pbih0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtYXggb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWF4KHRoaXMueCwgdGhhdC54KSwgTWF0aC5tYXgodGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcsJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WFk6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHggb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludCBmcm9tIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRGcm9tUG9pbnQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgeC95IG9mIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqL1xuICAgIHN3YXA6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgdGhhdC54ID0geDtcbiAgICAgIHRoYXQueSA9IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkludGVyc2VjdGlvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW50ZXJzZWN0aW9uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnNlY3Rpb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbnRlcnNlY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyc2VjdGlvbihzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9XG5cbiAgZmFicmljLkludGVyc2VjdGlvbiA9IEludGVyc2VjdGlvbjtcblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IEludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBwb2ludCB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgcG9pbnRzIHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChwb2ludHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIGxpbmUgaW50ZXJzZWN0cyBhbm90aGVyXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50U2VnbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZSA9IGZ1bmN0aW9uIChhMSwgYTIsIGIxLCBiMikge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHVhVCA9IChiMi54IC0gYjEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGIyLnkgLSBiMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHViVCA9IChhMi54IC0gYTEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGEyLnkgLSBhMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHVCID0gKGIyLnkgLSBiMS55KSAqIChhMi54IC0gYTEueCkgLSAoYjIueCAtIGIxLngpICogKGEyLnkgLSBhMS55KTtcbiAgICBpZiAodUIgIT09IDApIHtcbiAgICAgIHZhciB1YSA9IHVhVCAvIHVCLFxuICAgICAgICAgIHViID0gdWJUIC8gdUI7XG4gICAgICBpZiAoMCA8PSB1YSAmJiB1YSA8PSAxICYmIDAgPD0gdWIgJiYgdWIgPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdJbnRlcnNlY3Rpb24nKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoYTEueCArIHVhICogKGEyLnggLSBhMS54KSwgYTEueSArIHVhICogKGEyLnkgLSBhMS55KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodWFUID09PSAwIHx8IHViVCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdDb2luY2lkZW50Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignUGFyYWxsZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGxpbmUgaW50ZXJzZWN0cyBwb2x5Z29uXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50UG9seWdvblxuICAgKiBmaXggZGV0ZWN0aW9uIG9mIGNvaW5jaWRlbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbiA9IGZ1bmN0aW9uKGExLCBhMiwgcG9pbnRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgYjEsIGIyLCBpbnRlciwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYjEgPSBwb2ludHNbaV07XG4gICAgICBiMiA9IHBvaW50c1soaSArIDEpICUgbGVuZ3RoXTtcbiAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lKGExLCBhMiwgYjEsIGIyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgYW5vdGhlciBwb2x5Z29uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMVxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50czEsIHBvaW50czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMxLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGExID0gcG9pbnRzMVtpXSxcbiAgICAgICAgICBhMiA9IHBvaW50czFbKGkgKyAxKSAlIGxlbmd0aF0sXG4gICAgICAgICAgaW50ZXIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYTEsIGEyLCBwb2ludHMyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgcmVjdGFuZ2xlXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwb2ludHMsIHIxLCByMikge1xuICAgIHZhciBtaW4gPSByMS5taW4ocjIpLFxuICAgICAgICBtYXggPSByMS5tYXgocjIpLFxuICAgICAgICB0b3BSaWdodCA9IG5ldyBmYWJyaWMuUG9pbnQobWF4LngsIG1pbi55KSxcbiAgICAgICAgYm90dG9tTGVmdCA9IG5ldyBmYWJyaWMuUG9pbnQobWluLngsIG1heC55KSxcbiAgICAgICAgaW50ZXIxID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1pbiwgdG9wUmlnaHQsIHBvaW50cyksXG4gICAgICAgIGludGVyMiA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbih0b3BSaWdodCwgbWF4LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjMgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWF4LCBib3R0b21MZWZ0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjQgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYm90dG9tTGVmdCwgbWluLCBwb2ludHMpLFxuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG5cbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMS5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIyLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjMucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyNC5wb2ludHMpO1xuXG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Db2xvcikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuQ29sb3IgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xvciBjbGFzc1xuICAgKiBUaGUgcHVycG9zZSBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyB0byBhYnN0cmFjdCBhbmQgZW5jYXBzdWxhdGUgY29tbW9uIGNvbG9yIG9wZXJhdGlvbnM7XG4gICAqIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIGEgY29uc3RydWN0b3IgYW5kIGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IG9iamVjdHMuXG4gICAqXG4gICAqIEBjbGFzcyBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIG9wdGlvbmFsIGluIGhleCBvciByZ2IoYSkgb3IgaHNsIGZvcm1hdCBvciBmcm9tIGtub3duIGNvbG9yIGxpc3RcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yLyNjb2xvcnN9XG4gICAqL1xuICBmdW5jdGlvbiBDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHRoaXMuc2V0U291cmNlKFswLCAwLCAwLCAxXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fdHJ5UGFyc2luZ0NvbG9yKGNvbG9yKTtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMuQ29sb3IgPSBDb2xvcjtcblxuICBmYWJyaWMuQ29sb3IucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNvbG9yIENvbG9yIHZhbHVlIHRvIHBhcnNlXG4gICAgICovXG4gICAgX3RyeVBhcnNpbmdDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHZhciBzb3VyY2U7XG5cbiAgICAgIGlmIChjb2xvciBpbiBDb2xvci5jb2xvck5hbWVNYXApIHtcbiAgICAgICAgY29sb3IgPSBDb2xvci5jb2xvck5hbWVNYXBbY29sb3JdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgc291cmNlID0gWzI1NSwgMjU1LCAyNTUsIDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21SZ2IoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAvL2lmIGNvbG9yIGlzIG5vdCByZWNvZ25pemUgbGV0J3MgbWFrZSBibGFjayBhcyBjYW52YXMgZG9lc1xuICAgICAgICBzb3VyY2UgPSBbMCwgMCwgMCwgMV07XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgUmVkIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgR3JlZW4gY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBCbHVlIGNvbG9yIHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEhzbCBjb2xvclxuICAgICAqL1xuICAgIF9yZ2JUb0hzbDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgciAvPSAyNTU7IGcgLz0gMjU1OyBiIC89IDI1NTtcblxuICAgICAgdmFyIGgsIHMsIGwsXG4gICAgICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4KFtyLCBnLCBiXSksXG4gICAgICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluKFtyLCBnLCBiXSk7XG5cbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnJvdW5kKGggKiAzNjApLFxuICAgICAgICBNYXRoLnJvdW5kKHMgKiAxMDApLFxuICAgICAgICBNYXRoLnJvdW5kKGwgKiAxMDApXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICAgKi9cbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQiBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAgICovXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYignICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQkEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiYSgwLTI1NSwwLTI1NSwwLTI1NSwwLTEpXG4gICAgICovXG4gICAgdG9SZ2JhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAgICovXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsKCcgKyBoc2xbMF0gKyAnLCcgKyBoc2xbMV0gKyAnJSwnICsgaHNsWzJdICsgJyUpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIU0xBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLDAtMSlcbiAgICAgKi9cbiAgICB0b0hzbGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsYSgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSEVYIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NVxuICAgICAqL1xuICAgIHRvSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCByLCBnLCBiO1xuXG4gICAgICByID0gc291cmNlWzBdLnRvU3RyaW5nKDE2KTtcbiAgICAgIHIgPSAoci5sZW5ndGggPT09IDEpID8gKCcwJyArIHIpIDogcjtcblxuICAgICAgZyA9IHNvdXJjZVsxXS50b1N0cmluZygxNik7XG4gICAgICBnID0gKGcubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBnKSA6IGc7XG5cbiAgICAgIGIgPSBzb3VyY2VbMl0udG9TdHJpbmcoMTYpO1xuICAgICAgYiA9IChiLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYikgOiBiO1xuXG4gICAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpICsgZy50b1VwcGVyQ2FzZSgpICsgYi50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWEEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1Q0NcbiAgICAgKi9cbiAgICB0b0hleGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIGE7XG5cbiAgICAgIGEgPSBNYXRoLnJvdW5kKHNvdXJjZVszXSAqIDI1NSk7XG4gICAgICBhID0gYS50b1N0cmluZygxNik7XG4gICAgICBhID0gKGEubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBhKSA6IGE7XG5cbiAgICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBhLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gMC0xXG4gICAgICovXG4gICAgZ2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKClbM107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBBbHBoYSB2YWx1ZSAwLTFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGdyYXlzY2FsZSByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvR3JheXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSBwYXJzZUludCgoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksIDEwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgYmxhY2sgYW5kIHdoaXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvQmxhY2tXaGl0ZTogZnVuY3Rpb24odGhyZXNob2xkKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcblxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEyNztcblxuICAgICAgYXZlcmFnZSA9IChOdW1iZXIoYXZlcmFnZSkgPCBOdW1iZXIodGhyZXNob2xkKSkgPyAwIDogMjU1O1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXlzIGNvbG9yIHdpdGggYW5vdGhlciBjb2xvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfGZhYnJpYy5Db2xvcn0gb3RoZXJDb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIG92ZXJsYXlXaXRoOiBmdW5jdGlvbihvdGhlckNvbG9yKSB7XG4gICAgICBpZiAoIShvdGhlckNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgIG90aGVyQ29sb3IgPSBuZXcgQ29sb3Iob3RoZXJDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBhbHBoYSA9IHRoaXMuZ2V0QWxwaGEoKSxcbiAgICAgICAgICBvdGhlckFscGhhID0gMC41LFxuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgb3RoZXJTb3VyY2UgPSBvdGhlckNvbG9yLmdldFNvdXJjZSgpLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGgucm91bmQoKHNvdXJjZVtpXSAqICgxIC0gb3RoZXJBbHBoYSkpICsgKG90aGVyU291cmNlW2ldICogb3RoZXJBbHBoYSkpKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0WzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBSR0Igb3IgUkdCQSBmb3JtYXRzIChleDogcmdiKDAsIDAsIDApLCByZ2JhKDI1NSwgMTAwLCAxMCwgMC41KSwgcmdiYSggMjU1ICwgMTAwICwgMTAgLCAwLjUgKSwgcmdiKDEsMSwxKSwgcmdiYSgxMDAlLCA2MCUsIDEwJSwgMC41KSlcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLkNvbG9yLnJlUkdCYSA9IC9ecmdiYT9cXChcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKig/OlxccyosXFxzKigoPzpcXGQqXFwuP1xcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhTTCBvciBIU0xBIGZvcm1hdHMgKGV4OiBoc2woMjAwLCA4MCUsIDEwJSksIGhzbGEoMzAwLCA1MCUsIDgwJSwgMC41KSwgaHNsYSggMzAwICwgNTAlICwgODAlICwgMC41ICkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhTTGEgPSAvXmhzbGE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyooPzpcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhFWCBmb3JtYXQgKGV4OiAjRkY1NTQ0Q0MsICNGRjU1NTUsIDAxMDE1NSwgYWZmKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIZXggPSAvXiM/KFswLTlhLWZdezh9fFswLTlhLWZdezZ9fFswLTlhLWZdezR9fFswLTlhLWZdezN9KSQvaTtcblxuICAvKipcbiAgICogTWFwIG9mIHRoZSAxNDggY29sb3IgbmFtZXMgd2l0aCBIRVggY29kZVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5jb2xvck5hbWVNYXAgPSB7XG4gICAgYWxpY2VibHVlOiAgICAgICAgICAgICcjRjBGOEZGJyxcbiAgICBhbnRpcXVld2hpdGU6ICAgICAgICAgJyNGQUVCRDcnLFxuICAgIGFxdWE6ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgYXF1YW1hcmluZTogICAgICAgICAgICcjN0ZGRkQ0JyxcbiAgICBhenVyZTogICAgICAgICAgICAgICAgJyNGMEZGRkYnLFxuICAgIGJlaWdlOiAgICAgICAgICAgICAgICAnI0Y1RjVEQycsXG4gICAgYmlzcXVlOiAgICAgICAgICAgICAgICcjRkZFNEM0JyxcbiAgICBibGFjazogICAgICAgICAgICAgICAgJyMwMDAwMDAnLFxuICAgIGJsYW5jaGVkYWxtb25kOiAgICAgICAnI0ZGRUJDRCcsXG4gICAgYmx1ZTogICAgICAgICAgICAgICAgICcjMDAwMEZGJyxcbiAgICBibHVldmlvbGV0OiAgICAgICAgICAgJyM4QTJCRTInLFxuICAgIGJyb3duOiAgICAgICAgICAgICAgICAnI0E1MkEyQScsXG4gICAgYnVybHl3b29kOiAgICAgICAgICAgICcjREVCODg3JyxcbiAgICBjYWRldGJsdWU6ICAgICAgICAgICAgJyM1RjlFQTAnLFxuICAgIGNoYXJ0cmV1c2U6ICAgICAgICAgICAnIzdGRkYwMCcsXG4gICAgY2hvY29sYXRlOiAgICAgICAgICAgICcjRDI2OTFFJyxcbiAgICBjb3JhbDogICAgICAgICAgICAgICAgJyNGRjdGNTAnLFxuICAgIGNvcm5mbG93ZXJibHVlOiAgICAgICAnIzY0OTVFRCcsXG4gICAgY29ybnNpbGs6ICAgICAgICAgICAgICcjRkZGOERDJyxcbiAgICBjcmltc29uOiAgICAgICAgICAgICAgJyNEQzE0M0MnLFxuICAgIGN5YW46ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgZGFya2JsdWU6ICAgICAgICAgICAgICcjMDAwMDhCJyxcbiAgICBkYXJrY3lhbjogICAgICAgICAgICAgJyMwMDhCOEInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICAgICAgICAnI0I4ODYwQicsXG4gICAgZGFya2dyYXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JleTogICAgICAgICAgICAgJyNBOUE5QTknLFxuICAgIGRhcmtncmVlbjogICAgICAgICAgICAnIzAwNjQwMCcsXG4gICAgZGFya2toYWtpOiAgICAgICAgICAgICcjQkRCNzZCJyxcbiAgICBkYXJrbWFnZW50YTogICAgICAgICAgJyM4QjAwOEInLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgICAnIzU1NkIyRicsXG4gICAgZGFya29yYW5nZTogICAgICAgICAgICcjRkY4QzAwJyxcbiAgICBkYXJrb3JjaGlkOiAgICAgICAgICAgJyM5OTMyQ0MnLFxuICAgIGRhcmtyZWQ6ICAgICAgICAgICAgICAnIzhCMDAwMCcsXG4gICAgZGFya3NhbG1vbjogICAgICAgICAgICcjRTk5NjdBJyxcbiAgICBkYXJrc2VhZ3JlZW46ICAgICAgICAgJyM4RkJDOEYnLFxuICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgICAnIzQ4M0Q4QicsXG4gICAgZGFya3NsYXRlZ3JheTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrc2xhdGVncmV5OiAgICAgICAgJyMyRjRGNEYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgICAnIzAwQ0VEMScsXG4gICAgZGFya3Zpb2xldDogICAgICAgICAgICcjOTQwMEQzJyxcbiAgICBkZWVwcGluazogICAgICAgICAgICAgJyNGRjE0OTMnLFxuICAgIGRlZXBza3libHVlOiAgICAgICAgICAnIzAwQkZGRicsXG4gICAgZGltZ3JheTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkaW1ncmV5OiAgICAgICAgICAgICAgJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICAgICAgICAgICAnIzFFOTBGRicsXG4gICAgZmlyZWJyaWNrOiAgICAgICAgICAgICcjQjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogICAgICAgICAgJyNGRkZBRjAnLFxuICAgIGZvcmVzdGdyZWVuOiAgICAgICAgICAnIzIyOEIyMicsXG4gICAgZnVjaHNpYTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBnYWluc2Jvcm86ICAgICAgICAgICAgJyNEQ0RDREMnLFxuICAgIGdob3N0d2hpdGU6ICAgICAgICAgICAnI0Y4RjhGRicsXG4gICAgZ29sZDogICAgICAgICAgICAgICAgICcjRkZENzAwJyxcbiAgICBnb2xkZW5yb2Q6ICAgICAgICAgICAgJyNEQUE1MjAnLFxuICAgIGdyYXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JleTogICAgICAgICAgICAgICAgICcjODA4MDgwJyxcbiAgICBncmVlbjogICAgICAgICAgICAgICAgJyMwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAgICAgICAgICAnI0FERkYyRicsXG4gICAgaG9uZXlkZXc6ICAgICAgICAgICAgICcjRjBGRkYwJyxcbiAgICBob3RwaW5rOiAgICAgICAgICAgICAgJyNGRjY5QjQnLFxuICAgIGluZGlhbnJlZDogICAgICAgICAgICAnI0NENUM1QycsXG4gICAgaW5kaWdvOiAgICAgICAgICAgICAgICcjNEIwMDgyJyxcbiAgICBpdm9yeTogICAgICAgICAgICAgICAgJyNGRkZGRjAnLFxuICAgIGtoYWtpOiAgICAgICAgICAgICAgICAnI0YwRTY4QycsXG4gICAgbGF2ZW5kZXI6ICAgICAgICAgICAgICcjRTZFNkZBJyxcbiAgICBsYXZlbmRlcmJsdXNoOiAgICAgICAgJyNGRkYwRjUnLFxuICAgIGxhd25ncmVlbjogICAgICAgICAgICAnIzdDRkMwMCcsXG4gICAgbGVtb25jaGlmZm9uOiAgICAgICAgICcjRkZGQUNEJyxcbiAgICBsaWdodGJsdWU6ICAgICAgICAgICAgJyNBREQ4RTYnLFxuICAgIGxpZ2h0Y29yYWw6ICAgICAgICAgICAnI0YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAgICAgICAgICAgICcjRTBGRkZGJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLFxuICAgIGxpZ2h0Z3JheTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmV5OiAgICAgICAgICAgICcjRDNEM0QzJyxcbiAgICBsaWdodGdyZWVuOiAgICAgICAgICAgJyM5MEVFOTAnLFxuICAgIGxpZ2h0cGluazogICAgICAgICAgICAnI0ZGQjZDMScsXG4gICAgbGlnaHRzYWxtb246ICAgICAgICAgICcjRkZBMDdBJyxcbiAgICBsaWdodHNlYWdyZWVuOiAgICAgICAgJyMyMEIyQUEnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogICAgICAgICAnIzg3Q0VGQScsXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHNsYXRlZ3JleTogICAgICAgJyM3Nzg4OTknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgICAnI0IwQzRERScsXG4gICAgbGlnaHR5ZWxsb3c6ICAgICAgICAgICcjRkZGRkUwJyxcbiAgICBsaW1lOiAgICAgICAgICAgICAgICAgJyMwMEZGMDAnLFxuICAgIGxpbWVncmVlbjogICAgICAgICAgICAnIzMyQ0QzMicsXG4gICAgbGluZW46ICAgICAgICAgICAgICAgICcjRkFGMEU2JyxcbiAgICBtYWdlbnRhOiAgICAgICAgICAgICAgJyNGRjAwRkYnLFxuICAgIG1hcm9vbjogICAgICAgICAgICAgICAnIzgwMDAwMCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogICAgICcjNjZDREFBJyxcbiAgICBtZWRpdW1ibHVlOiAgICAgICAgICAgJyMwMDAwQ0QnLFxuICAgIG1lZGl1bW9yY2hpZDogICAgICAgICAnI0JBNTVEMycsXG4gICAgbWVkaXVtcHVycGxlOiAgICAgICAgICcjOTM3MERCJyxcbiAgICBtZWRpdW1zZWFncmVlbjogICAgICAgJyMzQ0IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogICAgICAnIzdCNjhFRScsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46ICAgICcjMDBGQTlBJyxcbiAgICBtZWRpdW10dXJxdW9pc2U6ICAgICAgJyM0OEQxQ0MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogICAgICAnI0M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAgICAgICAgICcjMTkxOTcwJyxcbiAgICBtaW50Y3JlYW06ICAgICAgICAgICAgJyNGNUZGRkEnLFxuICAgIG1pc3R5cm9zZTogICAgICAgICAgICAnI0ZGRTRFMScsXG4gICAgbW9jY2FzaW46ICAgICAgICAgICAgICcjRkZFNEI1JyxcbiAgICBuYXZham93aGl0ZTogICAgICAgICAgJyNGRkRFQUQnLFxuICAgIG5hdnk6ICAgICAgICAgICAgICAgICAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogICAgICAgICAgICAgICcjRkRGNUU2JyxcbiAgICBvbGl2ZTogICAgICAgICAgICAgICAgJyM4MDgwMDAnLFxuICAgIG9saXZlZHJhYjogICAgICAgICAgICAnIzZCOEUyMycsXG4gICAgb3JhbmdlOiAgICAgICAgICAgICAgICcjRkZBNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICAgICAgICAgICAgJyNGRjQ1MDAnLFxuICAgIG9yY2hpZDogICAgICAgICAgICAgICAnI0RBNzBENicsXG4gICAgcGFsZWdvbGRlbnJvZDogICAgICAgICcjRUVFOEFBJyxcbiAgICBwYWxlZ3JlZW46ICAgICAgICAgICAgJyM5OEZCOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICAgICAgICAnI0FGRUVFRScsXG4gICAgcGFsZXZpb2xldHJlZDogICAgICAgICcjREI3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAgICAgICAgICAgJyNGRkVGRDUnLFxuICAgIHBlYWNocHVmZjogICAgICAgICAgICAnI0ZGREFCOScsXG4gICAgcGVydTogICAgICAgICAgICAgICAgICcjQ0Q4NTNGJyxcbiAgICBwaW5rOiAgICAgICAgICAgICAgICAgJyNGRkMwQ0InLFxuICAgIHBsdW06ICAgICAgICAgICAgICAgICAnI0REQTBERCcsXG4gICAgcG93ZGVyYmx1ZTogICAgICAgICAgICcjQjBFMEU2JyxcbiAgICBwdXJwbGU6ICAgICAgICAgICAgICAgJyM4MDAwODAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICAgICAgICAnIzY2MzM5OScsXG4gICAgcmVkOiAgICAgICAgICAgICAgICAgICcjRkYwMDAwJyxcbiAgICByb3N5YnJvd246ICAgICAgICAgICAgJyNCQzhGOEYnLFxuICAgIHJveWFsYmx1ZTogICAgICAgICAgICAnIzQxNjlFMScsXG4gICAgc2FkZGxlYnJvd246ICAgICAgICAgICcjOEI0NTEzJyxcbiAgICBzYWxtb246ICAgICAgICAgICAgICAgJyNGQTgwNzInLFxuICAgIHNhbmR5YnJvd246ICAgICAgICAgICAnI0Y0QTQ2MCcsXG4gICAgc2VhZ3JlZW46ICAgICAgICAgICAgICcjMkU4QjU3JyxcbiAgICBzZWFzaGVsbDogICAgICAgICAgICAgJyNGRkY1RUUnLFxuICAgIHNpZW5uYTogICAgICAgICAgICAgICAnI0EwNTIyRCcsXG4gICAgc2lsdmVyOiAgICAgICAgICAgICAgICcjQzBDMEMwJyxcbiAgICBza3libHVlOiAgICAgICAgICAgICAgJyM4N0NFRUInLFxuICAgIHNsYXRlYmx1ZTogICAgICAgICAgICAnIzZBNUFDRCcsXG4gICAgc2xhdGVncmF5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbGF0ZWdyZXk6ICAgICAgICAgICAgJyM3MDgwOTAnLFxuICAgIHNub3c6ICAgICAgICAgICAgICAgICAnI0ZGRkFGQScsXG4gICAgc3ByaW5nZ3JlZW46ICAgICAgICAgICcjMDBGRjdGJyxcbiAgICBzdGVlbGJsdWU6ICAgICAgICAgICAgJyM0NjgyQjQnLFxuICAgIHRhbjogICAgICAgICAgICAgICAgICAnI0QyQjQ4QycsXG4gICAgdGVhbDogICAgICAgICAgICAgICAgICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAgICAgICAgICAgICAgJyNEOEJGRDgnLFxuICAgIHRvbWF0bzogICAgICAgICAgICAgICAnI0ZGNjM0NycsXG4gICAgdHVycXVvaXNlOiAgICAgICAgICAgICcjNDBFMEQwJyxcbiAgICB2aW9sZXQ6ICAgICAgICAgICAgICAgJyNFRTgyRUUnLFxuICAgIHdoZWF0OiAgICAgICAgICAgICAgICAnI0Y1REVCMycsXG4gICAgd2hpdGU6ICAgICAgICAgICAgICAgICcjRkZGRkZGJyxcbiAgICB3aGl0ZXNtb2tlOiAgICAgICAgICAgJyNGNUY1RjUnLFxuICAgIHllbGxvdzogICAgICAgICAgICAgICAnI0ZGRkYwMCcsXG4gICAgeWVsbG93Z3JlZW46ICAgICAgICAgICcjOUFDRDMyJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiBAcGFyYW0ge051bWJlcn0gcVxuICAgKiBAcGFyYW0ge051bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHQgKz0gMTtcbiAgICB9XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB0IC09IDE7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDYpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyAyKSB7XG4gICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMykge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0IgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIFJHQiBvciBSR0JBIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KSwgcmdiKDAlLTEwMCUsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVSR0JhKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMjU1IDogMSksXG4gICAgICAgICAgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFszXSkgPyAyNTUgOiAxKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTApLFxuICAgICAgICBwYXJzZUludChnLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGIsIDEwKSxcbiAgICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0JBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYmEgPSBDb2xvci5mcm9tUmdiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0wgZm9ybWF0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMjYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIU0wgb3IgSFNMQSBmb3JtYXQuXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSkgb3IgaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsIDAtMSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKiBAc2VlIGh0dHA6Ly9odHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNoc2wtY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZUhTTGEpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwLFxuICAgICAgICBzID0gcGFyc2VGbG9hdChtYXRjaFsyXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpLFxuICAgICAgICBsID0gcGFyc2VGbG9hdChtYXRjaFszXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpLFxuICAgICAgICByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcyxcbiAgICAgICAgICBwID0gbCAqIDIgLSBxO1xuXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChnICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoYiAqIDI1NSksXG4gICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTEEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsYSA9IENvbG9yLmZyb21Ic2w7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogRkY1NTU1XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBleDogRkY1NTU1IG9yIEZGNTU0NENDIChSR0JhKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yLm1hdGNoKENvbG9yLnJlSGV4KSkge1xuICAgICAgdmFyIHZhbHVlID0gY29sb3Iuc2xpY2UoY29sb3IuaW5kZXhPZignIycpICsgMSksXG4gICAgICAgICAgaXNTaG9ydE5vdGF0aW9uID0gKHZhbHVlLmxlbmd0aCA9PT0gMyB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIGlzUkdCYSA9ICh2YWx1ZS5sZW5ndGggPT09IDggfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICByID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgwKSArIHZhbHVlLmNoYXJBdCgwKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMCwgMiksXG4gICAgICAgICAgZyA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMSkgKyB2YWx1ZS5jaGFyQXQoMSkpIDogdmFsdWUuc3Vic3RyaW5nKDIsIDQpLFxuICAgICAgICAgIGIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDIpICsgdmFsdWUuY2hhckF0KDIpKSA6IHZhbHVlLnN1YnN0cmluZyg0LCA2KSxcbiAgICAgICAgICBhID0gaXNSR0JhID8gKGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMykgKyB2YWx1ZS5jaGFyQXQoMykpIDogdmFsdWUuc3Vic3RyaW5nKDYsIDgpKSA6ICdGRic7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBwYXJzZUludChiLCAxNiksXG4gICAgICAgIHBhcnNlRmxvYXQoKHBhcnNlSW50KGEsIDE2KSAvIDI1NSkudG9GaXhlZCgyKSlcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gY29sb3IgaW4gYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMjAwLCAxMDAsIDEwMCwgMC41XSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBvQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBvQ29sb3Iuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgcmV0dXJuIG9Db2xvcjtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgc2NhbGVNYXAgPSBbJ2UnLCAnc2UnLCAncycsICdzdycsICd3JywgJ253JywgJ24nLCAnbmUnLCAnZSddLFxuICAgICAgc2tld01hcCA9IFsnbnMnLCAnbmVzdycsICdldycsICdud3NlJ10sXG4gICAgICBjb250cm9scyA9IHt9LFxuICAgICAgTEVGVCA9ICdsZWZ0JywgVE9QID0gJ3RvcCcsIFJJR0hUID0gJ3JpZ2h0JywgQk9UVE9NID0gJ2JvdHRvbScsIENFTlRFUiA9ICdjZW50ZXInLFxuICAgICAgb3Bwb3NpdGUgPSB7XG4gICAgICAgIHRvcDogQk9UVE9NLFxuICAgICAgICBib3R0b206IFRPUCxcbiAgICAgICAgbGVmdDogUklHSFQsXG4gICAgICAgIHJpZ2h0OiBMRUZULFxuICAgICAgICBjZW50ZXI6IENFTlRFUixcbiAgICAgIH0sIHJhZGlhbnNUb0RlZ3JlZXMgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzLFxuICAgICAgc2lnbiA9IChNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDsgfSk7XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgY29udHJvbCBwb3NpdGlvbiBhbmQgb2JqZWN0IGFuZ2xlIHRvIGZpbmQgdGhlIGNvbnRyb2wgZGlyZWN0aW9uIGNvbXBhcmVkXG4gICAqIHRvIHRoZSBvYmplY3QgY2VudGVyLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIGNsYXNzXG4gICAqIEByZXR1cm4ge051bWJlcn0gMCAtIDcgYSBxdWFkcmFudCBudW1iZXJcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpIHtcbiAgICB2YXIgY29ybmVyQW5nbGUgPSBmYWJyaWNPYmplY3QuYW5nbGUgKyByYWRpYW5zVG9EZWdyZWVzKE1hdGguYXRhbjIoY29udHJvbC55LCBjb250cm9sLngpKSArIDM2MDtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoY29ybmVyQW5nbGUgJSAzNjApIC8gNDUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGNhbnZhcyA9IHRhcmdldC5jYW52YXMsXG4gICAgICAgIGNhbnZhc09wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucyk7XG4gICAgY2FudmFzT3B0aW9ucy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgY2FudmFzICYmIGNhbnZhcy5maXJlKCdvYmplY3Q6JyArIGV2ZW50TmFtZSwgY2FudmFzT3B0aW9ucyk7XG4gICAgdGFyZ2V0LmZpcmUoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGV2ZW50IGFuZCBmYWJyaWNPYmplY3QgcHJvcGVydGllcyB0byB1bmRlcnN0YW5kIGlmIHRoZSBzY2FsaW5nIGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgZnJvbSB0aGUgdXNlciBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgYWJvdXQgdG8gc2NhbGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2FsZSBpcyBwcm9wb3J0aW9uYWxcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgY2FudmFzID0gZmFicmljT2JqZWN0LmNhbnZhcywgdW5pU2NhbGVLZXkgPSBjYW52YXMudW5pU2NhbGVLZXksXG4gICAgICAgIHVuaWZvcm1Jc1RvZ2dsZWQgPSBldmVudERhdGFbdW5pU2NhbGVLZXldO1xuICAgIHJldHVybiAoY2FudmFzLnVuaWZvcm1TY2FsaW5nICYmICF1bmlmb3JtSXNUb2dnbGVkKSB8fFxuICAgICghY2FudmFzLnVuaWZvcm1TY2FsaW5nICYmIHVuaWZvcm1Jc1RvZ2dsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0cmFuc2Zvcm0gaXMgY2VudGVyZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB0cmFuc2Zvcm0gZGF0YVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRyYW5zZm9ybSBpcyBjZW50ZXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gaXNUcmFuc2Zvcm1DZW50ZXJlZCh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtLm9yaWdpblggPT09IENFTlRFUiAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQ0VOVEVSO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZmFicmljT2JqZWN0IHRvIHVuZGVyc3RhbmQgaWYgdGhlIGN1cnJlbnQgc2NhbGluZyBhY3Rpb24gaXMgYWxsb3dlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBhYm91dCB0byBzY2FsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnkgJ3gnIG9yICd5JyBvciAnJ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNjYWxlUHJvcG9ydGlvbmFsbHkgdHJ1ZSBpZiB3ZSBhcmUgdHJ5aW5nIHRvIHNjYWxlIHByb3BvcnRpb25hbGx5XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2NhbGluZyBpcyBub3QgYWxsb3dlZCBhdCBjdXJyZW50IGNvbmRpdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdJc0ZvcmJpZGRlbihmYWJyaWNPYmplY3QsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSB7XG4gICAgdmFyIGxvY2tYID0gZmFicmljT2JqZWN0LmxvY2tTY2FsaW5nWCwgbG9ja1kgPSBmYWJyaWNPYmplY3QubG9ja1NjYWxpbmdZO1xuICAgIGlmIChsb2NrWCAmJiBsb2NrWSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYnkgJiYgKGxvY2tYIHx8IGxvY2tZKSAmJiBzY2FsZVByb3BvcnRpb25hbGx5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxvY2tYICYmIGJ5ID09PSAneCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobG9ja1kgJiYgYnkgPT09ICd5Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGNvcnJlY3QgY3Vyc29yIHN0eWxlIGZvciB0aGUgc2NhbGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIG5vdEFsbG93ZWQgPSAnbm90LWFsbG93ZWQnLFxuICAgICAgICBzY2FsZVByb3BvcnRpb25hbGx5ID0gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIGZhYnJpY09iamVjdCksXG4gICAgICAgIGJ5ID0gJyc7XG4gICAgaWYgKGNvbnRyb2wueCAhPT0gMCAmJiBjb250cm9sLnkgPT09IDApIHtcbiAgICAgIGJ5ID0gJ3gnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sLnggPT09IDAgJiYgY29udHJvbC55ICE9PSAwKSB7XG4gICAgICBieSA9ICd5JztcbiAgICB9XG4gICAgaWYgKHNjYWxpbmdJc0ZvcmJpZGRlbihmYWJyaWNPYmplY3QsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIHZhciBuID0gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCk7XG4gICAgcmV0dXJuIHNjYWxlTWFwW25dICsgJy1yZXNpemUnO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgY29ycmVjdCBjdXJzb3Igc3R5bGUgZm9yIHRoZSBza2V3IGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBza2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIG5vdEFsbG93ZWQgPSAnbm90LWFsbG93ZWQnO1xuICAgIGlmIChjb250cm9sLnggIT09IDAgJiYgZmFicmljT2JqZWN0LmxvY2tTa2V3aW5nWSkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIGlmIChjb250cm9sLnkgIT09IDAgJiYgZmFicmljT2JqZWN0LmxvY2tTa2V3aW5nWCkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIHZhciBuID0gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCkgJSA0O1xuICAgIHJldHVybiBza2V3TWFwW25dICsgJy1yZXNpemUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgc2tldyBhbmQgc2NhbGUgc3R5bGUgaGFuZGxlcnMgdG8gY292ZXIgZmFicmljIHN0YW5kYXJkIHVzZSBjYXNlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIGlmIChldmVudERhdGFbZmFicmljT2JqZWN0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBldmVudCwgY29udHJvbCBhbmQgZmFicmljT2JqZWN0IHRvIHJldHVybiB0aGUgY29ycmVjdCBhY3Rpb24gbmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYW4gYWN0aW9uIG5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT3JTa2V3QWN0aW9uTmFtZShldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBpc0FsdGVybmF0aXZlID0gZXZlbnREYXRhW2ZhYnJpY09iamVjdC5jYW52YXMuYWx0QWN0aW9uS2V5XTtcbiAgICBpZiAoY29udHJvbC54ID09PSAwKSB7XG4gICAgICAvLyB0aGVuIGlzIHNjYWxlWSBvciBza2V3WFxuICAgICAgcmV0dXJuIGlzQWx0ZXJuYXRpdmUgPyAnc2tld1gnIDogJ3NjYWxlWSc7XG4gICAgfVxuICAgIGlmIChjb250cm9sLnkgPT09IDApIHtcbiAgICAgIC8vIHRoZW4gaXMgc2NhbGVZIG9yIHNrZXdYXG4gICAgICByZXR1cm4gaXNBbHRlcm5hdGl2ZSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgY29ycmVjdCBzdHlsZSBmb3IgdGhlIGNvbnRyb2wgdGhhdCBpcyB1c2VkIGZvciByb3RhdGlvbi5cbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbXBsZSBhbmQgaXQganVzdCB0YWtlIGNhcmUgb2Ygbm90LWFsbG93ZWQgb3Igc3RhbmRhcmQgY3Vyc29yXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHJvdGF0aW9uU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgaWYgKGZhYnJpY09iamVjdC5sb2NrUm90YXRpb24pIHtcbiAgICAgIHJldHVybiAnbm90LWFsbG93ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICBlOiBldmVudERhdGEsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHBvaW50ZXI6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYW4gYWN0aW9uIGhhbmRsZXIgd2l0aCBzYXZpbmcvcmVzdG9yaW5nIG9iamVjdCBwb3NpdGlvbiBvbiB0aGUgdHJhbnNmb3JtLlxuICAgKiB0aGlzIGlzIHRoZSBjb2RlIHRoYXQgcGVybWl0cyB0byBvYmplY3RzIHRvIGtlZXAgdGhlaXIgcG9zaXRpb24gd2hpbGUgdHJhbnNmb3JtaW5nLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25IYW5kbGVyIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHdpdGggYW4gYWN0aW9uIGhhbmRsZXIgc2lnbmF0dXJlXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwV2l0aEZpeGVkQW5jaG9yKGFjdGlvbkhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjZW50ZXJQb2ludCA9IHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIGNvbnN0cmFpbnQgPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXJQb2ludCwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZKSxcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIHRhcmdldC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNvbnN0cmFpbnQsIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSk7XG4gICAgICByZXR1cm4gYWN0aW9uUGVyZm9ybWVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbiBhY3Rpb24gaGFuZGxlciB3aXRoIGZpcmluZyBhbiBldmVudCBpZiB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25IYW5kbGVyIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHdpdGggYW4gYWN0aW9uIGhhbmRsZXIgc2lnbmF0dXJlXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwV2l0aEZpcmVFdmVudChldmVudE5hbWUsIGFjdGlvbkhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIHZhciBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIGlmIChhY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgZmlyZUV2ZW50KGV2ZW50TmFtZSwgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uUGVyZm9ybWVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIHBvaW50IGRlc2NyaWJlZCBieSB4IGFuZCB5IGluIGEgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBvYmplY3RcbiAgICogYm91bmRpbmcgYm94LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge0ZhYnJpYy5Qb2ludH0gdGhlIG5vcm1hbGl6ZWQgcG9pbnRcbiAgICovXG4gIGZ1bmN0aW9uIGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBvcmlnaW5YLCBvcmlnaW5ZLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbdHJhbnNmb3JtLmNvcm5lcl0sXG4gICAgICAgIHpvb20gPSB0YXJnZXQuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgcGFkZGluZyA9IHRhcmdldC5wYWRkaW5nIC8gem9vbSxcbiAgICAgICAgbG9jYWxQb2ludCA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgaWYgKGxvY2FsUG9pbnQueCA+PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnggLT0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueCA8PSAtcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC54ICs9IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnkgPj0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC55IC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnkgPD0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC55ICs9IHBhZGRpbmc7XG4gICAgfVxuICAgIGxvY2FsUG9pbnQueCAtPSBjb250cm9sLm9mZnNldFg7XG4gICAgbG9jYWxQb2ludC55IC09IGNvbnRyb2wub2Zmc2V0WTtcbiAgICByZXR1cm4gbG9jYWxQb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgdGhlIGZhYnJpYyBvYmplY3QgaXMgZmxpcHBlZCBvbiBvbmUgc2lkZS5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvbmUgZmxpcCwgYnV0IG5vdCB0d28uXG4gICAqL1xuICBmdW5jdGlvbiB0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuZmxpcFggIT09IHRhcmdldC5mbGlwWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbXBlbnNhdGUgdGhlIHNjYWxlIGZhY3RvciB3aGVuIHNrZXcgaXMgYXBwbGllZCBvbiBib3RoIGF4ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCBvcHBvc2l0ZVNrZXcsIHNjYWxlVG9Db21wZW5zYXRlLCBheGlzLCByZWZlcmVuY2UpIHtcbiAgICBpZiAodGFyZ2V0W29wcG9zaXRlU2tld10gIT09IDApIHtcbiAgICAgIHZhciBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpW2F4aXNdO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gcmVmZXJlbmNlIC8gbmV3RGltICogdGFyZ2V0W3NjYWxlVG9Db21wZW5zYXRlXTtcbiAgICAgIHRhcmdldC5zZXQoc2NhbGVUb0NvbXBlbnNhdGUsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFggYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2tld09iamVjdFgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgLy8gZmluZCBob3cgYmlnIHRoZSBvYmplY3Qgd291bGQgYmUsIGlmIHRoZXJlIHdhcyBubyBza2V3WC4gdGFrZXMgaW4gYWNjb3VudCBzY2FsaW5nXG4gICAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKDAsIHRhcmdldC5za2V3WSksXG4gICAgICAgIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgLy8gdGhlIG1vdXNlIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCwgYW5kIHdlIHdhbnQgaXQgdG8gc3RheSB0aGVyZS5cbiAgICAgICAgLy8gc28gdGhlIG9iamVjdCB3aWxsIGdyb3cgdHdpY2UgYXMgbXVjaCBhcyB0aGUgbW91c2UuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIHNrZXcgZ3Jvd3RoIHRvIGxvY2FsUG9pbnQgKiAyIC0gZGltTm9Ta2V3LlxuICAgICAgICB0b3RhbFNrZXdTaXplID0gTWF0aC5hYnMobG9jYWxQb2ludC54ICogMikgLSBkaW1Ob1NrZXcueCxcbiAgICAgICAgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1gsIG5ld1NrZXc7XG4gICAgaWYgKHRvdGFsU2tld1NpemUgPCAyKSB7XG4gICAgICAvLyBsZXQncyBtYWtlIGl0IGVhc3kgdG8gZ28gYmFjayB0byBwb3NpdGlvbiAwLlxuICAgICAgbmV3U2tldyA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3U2tldyA9IHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgIE1hdGguYXRhbjIoKHRvdGFsU2tld1NpemUgLyB0YXJnZXQuc2NhbGVYKSwgKGRpbU5vU2tldy55IC8gdGFyZ2V0LnNjYWxlWSkpXG4gICAgICApO1xuICAgICAgLy8gbm93IHdlIGhhdmUgdG8gZmluZCB0aGUgc2lnbiBvZiB0aGUgc2tldy5cbiAgICAgIC8vIGl0IG1vc3RseSBkZXBlbmQgb24gdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gTEVGVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQk9UVE9NKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gUklHSFQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IFRPUCkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc1NrZXdlZCA9IGN1cnJlbnRTa2V3ICE9PSBuZXdTa2V3O1xuICAgIGlmIChoYXNTa2V3ZWQpIHtcbiAgICAgIHZhciBkaW1CZWZvcmVTa2V3aW5nID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgICAgdGFyZ2V0LnNldCgnc2tld1gnLCBuZXdTa2V3KTtcbiAgICAgIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCAnc2tld1knLCAnc2NhbGVZJywgJ3knLCBkaW1CZWZvcmVTa2V3aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NrZXdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBza2V3T2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAvLyBmaW5kIGhvdyBiaWcgdGhlIG9iamVjdCB3b3VsZCBiZSwgaWYgdGhlcmUgd2FzIG5vIHNrZXdYLiB0YWtlcyBpbiBhY2NvdW50IHNjYWxpbmdcbiAgICAgICAgZGltTm9Ta2V3ID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnModGFyZ2V0LnNrZXdYLCAwKSxcbiAgICAgICAgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICAvLyB0aGUgbW91c2UgaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0LCBhbmQgd2Ugd2FudCBpdCB0byBzdGF5IHRoZXJlLlxuICAgICAgICAvLyBzbyB0aGUgb2JqZWN0IHdpbGwgZ3JvdyB0d2ljZSBhcyBtdWNoIGFzIHRoZSBtb3VzZS5cbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGUgc2tldyBncm93dGggdG8gbG9jYWxQb2ludCAqIDIgLSBkaW1Ob1NrZXcuXG4gICAgICAgIHRvdGFsU2tld1NpemUgPSBNYXRoLmFicyhsb2NhbFBvaW50LnkgKiAyKSAtIGRpbU5vU2tldy55LFxuICAgICAgICBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WSwgbmV3U2tldztcbiAgICBpZiAodG90YWxTa2V3U2l6ZSA8IDIpIHtcbiAgICAgIC8vIGxldCdzIG1ha2UgaXQgZWFzeSB0byBnbyBiYWNrIHRvIHBvc2l0aW9uIDAuXG4gICAgICBuZXdTa2V3ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdTa2V3ID0gcmFkaWFuc1RvRGVncmVlcyhcbiAgICAgICAgTWF0aC5hdGFuMigodG90YWxTa2V3U2l6ZSAvIHRhcmdldC5zY2FsZVkpLCAoZGltTm9Ta2V3LnggLyB0YXJnZXQuc2NhbGVYKSlcbiAgICAgICk7XG4gICAgICAvLyBub3cgd2UgaGF2ZSB0byBmaW5kIHRoZSBzaWduIG9mIHRoZSBza2V3LlxuICAgICAgLy8gaXQgbW9zdGx5IGRlcGVuZCBvbiB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBMRUZUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBCT1RUT00pIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBSSUdIVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gVE9QKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzU2tld2VkID0gY3VycmVudFNrZXcgIT09IG5ld1NrZXc7XG4gICAgaWYgKGhhc1NrZXdlZCkge1xuICAgICAgdmFyIGRpbUJlZm9yZVNrZXdpbmcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3WScsIG5ld1NrZXcpO1xuICAgICAgY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsICdza2V3WCcsICdzY2FsZVgnLCAneCcsIGRpbUJlZm9yZVNrZXdpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2tld2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZWQgQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpcywgdGFrZXMgY2FyZSBvZiB0aGVcbiAgICogc2tldyBkaXJlY3Rpb24gYW5kIGRldGVybWluZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGZvciB0aGUgYW5jaG9yIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0hhbmRsZXJYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gc3RlcDEgZmlndXJlIG91dCBhbmQgY2hhbmdlIHRyYW5zZm9ybSBvcmlnaW4uXG4gICAgLy8gaWYgc2tld1ggPiAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gcmlnaHRcbiAgICAvLyBpZiBza2V3WCA+IDAgYW5kIG9yaWdpblkgdG9wIHdlIGFuY2hvciBvbiBsZWZ0XG4gICAgLy8gaWYgc2tld1ggPCAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gbGVmdFxuICAgIC8vIGlmIHNrZXdYIDwgMCBhbmQgb3JpZ2luWSB0b3Agd2UgYW5jaG9yIG9uIHJpZ2h0XG4gICAgLy8gaWYgc2tld1ggaXMgMCwgd2UgbG9vayBmb3IgbW91c2UgcG9zaXRpb24gdG8gdW5kZXJzdGFuZCB3aGVyZSBhcmUgd2UgZ29pbmcuXG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBvcmlnaW5YLCBvcmlnaW5ZID0gdHJhbnNmb3JtLm9yaWdpblk7XG4gICAgaWYgKHRhcmdldC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTa2V3ID09PSAwKSB7XG4gICAgICB2YXIgbG9jYWxQb2ludEZyb21DZW50ZXIgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgQ0VOVEVSLCBDRU5URVIsIHgsIHkpO1xuICAgICAgaWYgKGxvY2FsUG9pbnRGcm9tQ2VudGVyLnggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHJpZ2h0LCBhbmNob3IgbGVmdDtcbiAgICAgICAgb3JpZ2luWCA9IExFRlQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgcmlnaHQsIGFuY2hvciByaWdodFxuICAgICAgICBvcmlnaW5YID0gUklHSFQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRTa2V3ID4gMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gTEVGVCA6IFJJR0hUO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTa2V3IDwgMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gUklHSFQgOiBMRUZUO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblggPT09IExFRlQgPyBSSUdIVCA6IExFRlQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBvcmlnaW4sIHdlIGZpbmQgdGhlIGFuY2hvciBwb2ludFxuICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gb3JpZ2luWDtcbiAgICB2YXIgZmluYWxIYW5kbGVyID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NrZXdpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RYKSk7XG4gICAgcmV0dXJuIGZpbmFsSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlZCBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzLCB0YWtlcyBjYXJlIG9mIHRoZVxuICAgKiBza2V3IGRpcmVjdGlvbiBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gZm9yIHRoZSBhbmNob3IgcG9pbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBza2V3SGFuZGxlclkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBzdGVwMSBmaWd1cmUgb3V0IGFuZCBjaGFuZ2UgdHJhbnNmb3JtIG9yaWdpbi5cbiAgICAvLyBpZiBza2V3WSA+IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gdG9wXG4gICAgLy8gaWYgc2tld1kgPiAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiBib3R0b21cbiAgICAvLyBpZiBza2V3WSA8IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gYm90dG9tXG4gICAgLy8gaWYgc2tld1kgPCAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiB0b3BcbiAgICAvLyBpZiBza2V3WSBpcyAwLCB3ZSBsb29rIGZvciBtb3VzZSBwb3NpdGlvbiB0byB1bmRlcnN0YW5kIHdoZXJlIGFyZSB3ZSBnb2luZy5cbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG9yaWdpblksIG9yaWdpblggPSB0cmFuc2Zvcm0ub3JpZ2luWDtcbiAgICBpZiAodGFyZ2V0LmxvY2tTa2V3aW5nWSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNrZXcgPT09IDApIHtcbiAgICAgIHZhciBsb2NhbFBvaW50RnJvbUNlbnRlciA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBDRU5URVIsIENFTlRFUiwgeCwgeSk7XG4gICAgICBpZiAobG9jYWxQb2ludEZyb21DZW50ZXIueSA+IDApIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgZG93biwgYW5jaG9yIHVwO1xuICAgICAgICBvcmlnaW5ZID0gVE9QO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHVwLCBhbmNob3IgZG93blxuICAgICAgICBvcmlnaW5ZID0gQk9UVE9NO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50U2tldyA+IDApIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblggPT09IExFRlQgPyBUT1AgOiBCT1RUT007XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFNrZXcgPCAwKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5YID09PSBMRUZUID8gQk9UVE9NIDogVE9QO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblkgPT09IFRPUCA/IEJPVFRPTSA6IFRPUDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmNlIHdlIGhhdmUgdGhlIG9yaWdpbiwgd2UgZmluZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcmlnaW5ZO1xuICAgIHZhciBmaW5hbEhhbmRsZXIgPSB3cmFwV2l0aEZpcmVFdmVudCgnc2tld2luZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2tld09iamVjdFkpKTtcbiAgICByZXR1cm4gZmluYWxIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igcm90YXRpb24gYW5kIHNuYXBwaW5nLCB3aXRob3V0IGFuY2hvciBwb2ludC5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvbldpdGhTbmFwcGluZyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0ID0gdHJhbnNmb3JtLFxuICAgICAgICB0YXJnZXQgPSB0LnRhcmdldCxcbiAgICAgICAgcGl2b3RQb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG5cbiAgICBpZiAodGFyZ2V0LmxvY2tSb3RhdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsYXN0QW5nbGUgPSBNYXRoLmF0YW4yKHQuZXkgLSBwaXZvdFBvaW50LnksIHQuZXggLSBwaXZvdFBvaW50LngpLFxuICAgICAgICBjdXJBbmdsZSA9IE1hdGguYXRhbjIoeSAtIHBpdm90UG9pbnQueSwgeCAtIHBpdm90UG9pbnQueCksXG4gICAgICAgIGFuZ2xlID0gcmFkaWFuc1RvRGVncmVlcyhjdXJBbmdsZSAtIGxhc3RBbmdsZSArIHQudGhldGEpLFxuICAgICAgICBoYXNSb3RhdGVkID0gdHJ1ZTtcblxuICAgIGlmICh0YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgdmFyIHNuYXBBbmdsZSAgPSB0YXJnZXQuc25hcEFuZ2xlLFxuICAgICAgICAgIHNuYXBUaHJlc2hvbGQgID0gdGFyZ2V0LnNuYXBUaHJlc2hvbGQgfHwgc25hcEFuZ2xlLFxuICAgICAgICAgIHJpZ2h0QW5nbGVMb2NrZWQgPSBNYXRoLmNlaWwoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlLFxuICAgICAgICAgIGxlZnRBbmdsZUxvY2tlZCA9IE1hdGguZmxvb3IoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoYW5nbGUgLSBsZWZ0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICBhbmdsZSA9IGxlZnRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGFuZ2xlIC0gcmlnaHRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIGFuZ2xlID0gcmlnaHRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IDM2MCArIGFuZ2xlO1xuICAgIH1cbiAgICBhbmdsZSAlPSAzNjA7XG5cbiAgICBoYXNSb3RhdGVkID0gdGFyZ2V0LmFuZ2xlICE9PSBhbmdsZTtcbiAgICB0YXJnZXQuYW5nbGUgPSBhbmdsZTtcbiAgICByZXR1cm4gaGFzUm90YXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNpYyBzY2FsaW5nIGxvZ2ljLCByZXVzZWQgd2l0aCBkaWZmZXJlbnQgY29uc3RyYWluIGZvciBzY2FsaW5nIFgsWSwgZnJlZWx5IG9yIGVxdWFsbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3Igc2NhbGluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieSAneCcsICd5JywgJ2VxdWFsbHknIG9yICcnIHRvIGluZGljYXRlIHR5cGUgb2Ygc2NhbGluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBsb2NrU2NhbGluZ1ggPSB0YXJnZXQubG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICBieSA9IG9wdGlvbnMuYnksIG5ld1BvaW50LCBzY2FsZVgsIHNjYWxlWSwgZGltLFxuICAgICAgICBzY2FsZVByb3BvcnRpb25hbGx5ID0gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIHRhcmdldCksXG4gICAgICAgIGZvcmJpZFNjYWxpbmcgPSBzY2FsaW5nSXNGb3JiaWRkZW4odGFyZ2V0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSksXG4gICAgICAgIHNpZ25YLCBzaWduWSwgZ2VzdHVyZVNjYWxlID0gdHJhbnNmb3JtLmdlc3R1cmVTY2FsZTtcblxuICAgIGlmIChmb3JiaWRTY2FsaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChnZXN0dXJlU2NhbGUpIHtcbiAgICAgIHNjYWxlWCA9IHRyYW5zZm9ybS5zY2FsZVggKiBnZXN0dXJlU2NhbGU7XG4gICAgICBzY2FsZVkgPSB0cmFuc2Zvcm0uc2NhbGVZICogZ2VzdHVyZVNjYWxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1BvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSk7XG4gICAgICAvLyB1c2Ugb2Ygc2lnbjogV2UgdXNlIHNpZ24gdG8gZGV0ZWN0IGNoYW5nZSBvZiBkaXJlY3Rpb24gb2YgYW4gYWN0aW9uLiBzaWduIHVzdWFsbHkgY2hhbmdlIHdoZW5cbiAgICAgIC8vIHdlIGNyb3NzIHRoZSBvcmlnaW4gcG9pbnQgd2l0aCB0aGUgbW91c2UuIFNvIGEgc2NhbGUgZmxpcCBmb3IgZXhhbXBsZS4gVGhlcmUgaXMgYW4gaXNzdWUgd2hlbiBzY2FsaW5nXG4gICAgICAvLyBieSBjZW50ZXIgYW5kIHNjYWxpbmcgdXNpbmcgb25lIG1pZGRsZSBjb250cm9sICggZGVmYXVsdDogbXIsIG10LCBtbCwgbWIpLCB0aGUgbW91c2UgbW92ZW1lbnQgY2FuIGVhc2lseVxuICAgICAgLy8gY3Jvc3MgbWFueSB0aW1lIHRoZSBvcmlnaW4gcG9pbnQgYW5kIGZsaXAgdGhlIG9iamVjdC4gc28gd2UgbmVlZCBhIHdheSB0byBmaWx0ZXIgb3V0IHRoZSBub2lzZS5cbiAgICAgIC8vIFRoaXMgdGVybmFyeSBoZXJlIHNob3VsZCBiZSBvayB0byBmaWx0ZXIgb3V0IFggc2NhbGluZyB3aGVuIHdlIHdhbnQgWSBvbmx5IGFuZCB2aWNlIHZlcnNhLlxuICAgICAgc2lnblggPSBieSAhPT0gJ3knID8gc2lnbihuZXdQb2ludC54KSA6IDE7XG4gICAgICBzaWduWSA9IGJ5ICE9PSAneCcgPyBzaWduKG5ld1BvaW50LnkpIDogMTtcbiAgICAgIGlmICghdHJhbnNmb3JtLnNpZ25YKSB7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWCA9IHNpZ25YO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2Zvcm0uc2lnblkpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQubG9ja1NjYWxpbmdGbGlwICYmXG4gICAgICAgICh0cmFuc2Zvcm0uc2lnblggIT09IHNpZ25YIHx8IHRyYW5zZm9ybS5zaWduWSAhPT0gc2lnblkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBkaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgLy8gbWlzc2luZyBkZXRlY3Rpb24gb2YgZmxpcCBhbmQgbG9naWMgdG8gc3dpdGNoIHRoZSBvcmlnaW5cbiAgICAgIGlmIChzY2FsZVByb3BvcnRpb25hbGx5ICYmICFieSkge1xuICAgICAgICAvLyB1bmlmb3JtIHNjYWxpbmdcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMobmV3UG9pbnQueCkgKyBNYXRoLmFicyhuZXdQb2ludC55KSxcbiAgICAgICAgICAgIG9yaWdpbmFsID0gdHJhbnNmb3JtLm9yaWdpbmFsLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXN0YW5jZSA9IE1hdGguYWJzKGRpbS54ICogb3JpZ2luYWwuc2NhbGVYIC8gdGFyZ2V0LnNjYWxlWCkgK1xuICAgICAgICAgICAgICBNYXRoLmFicyhkaW0ueSAqIG9yaWdpbmFsLnNjYWxlWSAvIHRhcmdldC5zY2FsZVkpLFxuICAgICAgICAgICAgc2NhbGUgPSBkaXN0YW5jZSAvIG9yaWdpbmFsRGlzdGFuY2U7XG4gICAgICAgIHNjYWxlWCA9IG9yaWdpbmFsLnNjYWxlWCAqIHNjYWxlO1xuICAgICAgICBzY2FsZVkgPSBvcmlnaW5hbC5zY2FsZVkgKiBzY2FsZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsZVggPSBNYXRoLmFicyhuZXdQb2ludC54ICogdGFyZ2V0LnNjYWxlWCAvIGRpbS54KTtcbiAgICAgICAgc2NhbGVZID0gTWF0aC5hYnMobmV3UG9pbnQueSAqIHRhcmdldC5zY2FsZVkgLyBkaW0ueSk7XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgc2NhbGluZyBieSBjZW50ZXIsIHdlIG5lZWQgdG8gZG91YmxlIHRoZSBzY2FsZVxuICAgICAgaWYgKGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSkge1xuICAgICAgICBzY2FsZVggKj0gMjtcbiAgICAgICAgc2NhbGVZICo9IDI7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLnNpZ25YICE9PSBzaWduWCAmJiBieSAhPT0gJ3knKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gb3Bwb3NpdGVbdHJhbnNmb3JtLm9yaWdpblhdO1xuICAgICAgICBzY2FsZVggKj0gLTE7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWCA9IHNpZ25YO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5zaWduWSAhPT0gc2lnblkgJiYgYnkgIT09ICd4Jykge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9IG9wcG9zaXRlW3RyYW5zZm9ybS5vcmlnaW5ZXTtcbiAgICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblkgPSBzaWduWTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbWluU2NhbGUgaXMgdGFrZW4gYXJlIGluIHRoZSBzZXR0ZXIuXG4gICAgdmFyIG9sZFNjYWxlWCA9IHRhcmdldC5zY2FsZVgsIG9sZFNjYWxlWSA9IHRhcmdldC5zY2FsZVk7XG4gICAgaWYgKCFieSkge1xuICAgICAgIWxvY2tTY2FsaW5nWCAmJiB0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpO1xuICAgICAgIWxvY2tTY2FsaW5nWSAmJiB0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGZvcmJpZGRlbiBjYXNlcyBhbHJlYWR5IGhhbmRsZWQgb24gdG9wIGhlcmUuXG4gICAgICBieSA9PT0gJ3gnICYmIHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCk7XG4gICAgICBieSA9PT0gJ3knICYmIHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSk7XG4gICAgfVxuICAgIHJldHVybiBvbGRTY2FsZVggIT09IHRhcmdldC5zY2FsZVggfHwgb2xkU2NhbGVZICE9PSB0YXJnZXQuc2NhbGVZO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgc2NhbGluZyBsb2dpYywgdG8gc2NhbGUgZnJvbSBjb3JuZXJzIGVpdGhlciBlcXVhbGx5IG9yIGZyZWVseS5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdEZyb21Db3JuZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBYIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3gnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBZIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3knIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBZIG9yIHNrZXcgWFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdZT3JTa2V3aW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZWQgYWN0aW9uIGhhbmRsZXIgdG8gZWl0aGVyIHNjYWxlIFggb3Igc2tldyBZXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ1hPclNrZXdpbmdZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gb2sgc29tZSBzYWZldHkgbmVlZGVkIGhlcmUuXG4gICAgaWYgKGV2ZW50RGF0YVt0cmFuc2Zvcm0udGFyZ2V0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0hhbmRsZXJZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxpbmdYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciB0byBjaGFuZ2UgdGV4dGJveCB3aWR0aFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNoYW5nZVdpZHRoKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHRhcmdldC5zdHJva2VXaWR0aCAvICh0YXJnZXQuc3Ryb2tlVW5pZm9ybSA/IHRhcmdldC5zY2FsZVggOiAxKSxcbiAgICAgICAgbXVsdGlwbGllciA9IGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSA/IDIgOiAxLFxuICAgICAgICBvbGRXaWR0aCA9IHRhcmdldC53aWR0aCxcbiAgICAgICAgbmV3V2lkdGggPSBNYXRoLmFicyhsb2NhbFBvaW50LnggKiBtdWx0aXBsaWVyIC8gdGFyZ2V0LnNjYWxlWCkgLSBzdHJva2VQYWRkaW5nO1xuICAgIHRhcmdldC5zZXQoJ3dpZHRoJywgTWF0aC5tYXgobmV3V2lkdGgsIDApKTtcbiAgICByZXR1cm4gb2xkV2lkdGggIT09IG5ld1dpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGRyYWdIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIG5ld0xlZnQgPSB4IC0gdHJhbnNmb3JtLm9mZnNldFgsXG4gICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgbW92ZVggPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WCcpICYmIHRhcmdldC5sZWZ0ICE9PSBuZXdMZWZ0LFxuICAgICAgICBtb3ZlWSA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRZJykgJiYgdGFyZ2V0LnRvcCAhPT0gbmV3VG9wO1xuICAgIG1vdmVYICYmIHRhcmdldC5zZXQoJ2xlZnQnLCBuZXdMZWZ0KTtcbiAgICBtb3ZlWSAmJiB0YXJnZXQuc2V0KCd0b3AnLCBuZXdUb3ApO1xuICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgZmlyZUV2ZW50KCdtb3ZpbmcnLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVYIHx8IG1vdmVZO1xuICB9XG5cbiAgY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMuc2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMucm90YXRpb25XaXRoU25hcHBpbmcgPSB3cmFwV2l0aEZpcmVFdmVudCgncm90YXRpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHJvdGF0aW9uV2l0aFNuYXBwaW5nKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdFcXVhbGx5ID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKCBzY2FsZU9iamVjdEZyb21Db3JuZXIpKTtcbiAgY29udHJvbHMuc2NhbGluZ1ggPSB3cmFwV2l0aEZpcmVFdmVudCgnc2NhbGluZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2NhbGVPYmplY3RYKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdZID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0WSkpO1xuICBjb250cm9scy5zY2FsaW5nWU9yU2tld2luZ1ggPSBzY2FsaW5nWU9yU2tld2luZ1g7XG4gIGNvbnRyb2xzLnNjYWxpbmdYT3JTa2V3aW5nWSA9IHNjYWxpbmdYT3JTa2V3aW5nWTtcbiAgY29udHJvbHMuY2hhbmdlV2lkdGggPSB3cmFwV2l0aEZpcmVFdmVudCgncmVzaXppbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKGNoYW5nZVdpZHRoKSk7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWCA9IHNrZXdIYW5kbGVyWDtcbiAgY29udHJvbHMuc2tld0hhbmRsZXJZID0gc2tld0hhbmRsZXJZO1xuICBjb250cm9scy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBzY2FsZU9yU2tld0FjdGlvbk5hbWU7XG4gIGNvbnRyb2xzLnJvdGF0aW9uU3R5bGVIYW5kbGVyID0gcm90YXRpb25TdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLmZpcmVFdmVudCA9IGZpcmVFdmVudDtcbiAgY29udHJvbHMud3JhcFdpdGhGaXhlZEFuY2hvciA9IHdyYXBXaXRoRml4ZWRBbmNob3I7XG4gIGNvbnRyb2xzLndyYXBXaXRoRmlyZUV2ZW50ID0gd3JhcFdpdGhGaXJlRXZlbnQ7XG4gIGNvbnRyb2xzLmdldExvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50O1xuICBmYWJyaWMuY29udHJvbHNVdGlscyA9IGNvbnRyb2xzO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIGNvbnRyb2xzID0gZmFicmljLmNvbnRyb2xzVXRpbHM7XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHJvdW5kIGNvbnRyb2wsIGFzIHBlciBmYWJyaWMgZmVhdHVyZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB0byByZXNwZWN0IG9iamVjdCBwcm9wZXJ0aWVzIGxpa2UgdHJhbnNwYXJlbnRDb3JuZXJzLCBjb3JuZXJTaXplXG4gICAqIGNvcm5lckNvbG9yLCBjb3JuZXJTdHJva2VDb2xvclxuICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb3ZlcnJpZGUgZm9yIGZhYnJpYy5PYmplY3QgY29udHJvbHMgc3R5bGVcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlckNpcmNsZUNvbnRyb2wgKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICB2YXIgeFNpemUgPSB0aGlzLnNpemVYIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgeVNpemUgPSB0aGlzLnNpemVZIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgOiBmYWJyaWNPYmplY3QudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICBtZXRob2ROYW1lID0gdHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCcsXG4gICAgICAgIHN0cm9rZSA9ICF0cmFuc3BhcmVudENvcm5lcnMgJiYgKHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yKSxcbiAgICAgICAgbXlMZWZ0ID0gbGVmdCxcbiAgICAgICAgbXlUb3AgPSB0b3AsIHNpemU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgLy8gYXMgc29vbiBhcyBmYWJyaWMgcmVhY3QgdjUsIHJlbW92ZSBpZTExLCB1c2UgcHJvcGVyIGVsbGlwc2UgY29kZS5cbiAgICBpZiAoeFNpemUgPiB5U2l6ZSkge1xuICAgICAgc2l6ZSA9IHhTaXplO1xuICAgICAgY3R4LnNjYWxlKDEuMCwgeVNpemUgLyB4U2l6ZSk7XG4gICAgICBteVRvcCA9IHRvcCAqIHhTaXplIC8geVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHlTaXplID4geFNpemUpIHtcbiAgICAgIHNpemUgPSB5U2l6ZTtcbiAgICAgIGN0eC5zY2FsZSh4U2l6ZSAvIHlTaXplLCAxLjApO1xuICAgICAgbXlMZWZ0ID0gbGVmdCAqIHlTaXplIC8geFNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2l6ZSA9IHhTaXplO1xuICAgIH1cbiAgICAvLyB0aGlzIGlzIHN0aWxsIHdyb25nXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMobXlMZWZ0LCBteVRvcCwgc2l6ZSAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY3R4W21ldGhvZE5hbWVdKCk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNxdWFyZSBjb250cm9sLCBhcyBwZXIgZmFicmljIGZlYXR1cmVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gdG8gcmVzcGVjdCBvYmplY3QgcHJvcGVydGllcyBsaWtlIHRyYW5zcGFyZW50Q29ybmVycywgY29ybmVyU2l6ZVxuICAgKiBjb3JuZXJDb2xvciwgY29ybmVyU3Ryb2tlQ29sb3JcbiAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG92ZXJyaWRlIGZvciBmYWJyaWMuT2JqZWN0IGNvbnRyb2xzIHN0eWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTcXVhcmVDb250cm9sKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICB2YXIgeFNpemUgPSB0aGlzLnNpemVYIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgeVNpemUgPSB0aGlzLnNpemVZIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgOiBmYWJyaWNPYmplY3QudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICBtZXRob2ROYW1lID0gdHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCcsXG4gICAgICAgIHN0cm9rZSA9ICF0cmFuc3BhcmVudENvcm5lcnMgJiYgKFxuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yXG4gICAgICAgICksIHhTaXplQnkyID0geFNpemUgLyAyLCB5U2l6ZUJ5MiA9IHlTaXplIC8gMjtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAvLyB0aGlzIGlzIHN0aWxsIHdyb25nXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnRyYW5zbGF0ZShsZWZ0LCB0b3ApO1xuICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyhmYWJyaWNPYmplY3QuYW5nbGUpKTtcbiAgICAvLyB0aGlzIGRvZXMgbm90IHdvcmssIGFuZCBmaXhlZCB3aXRoICggJiYgKSBkb2VzIG5vdCBtYWtlIHNlbnNlLlxuICAgIC8vIHRvIGhhdmUgcmVhbCB0cmFuc3BhcmVudCBjb3JuZXJzIHdlIG5lZWQgdGhlIGNvbnRyb2xzIG9uIHVwcGVyQ2FudmFzXG4gICAgLy8gdHJhbnNwYXJlbnRDb3JuZXJzIHx8IGN0eC5jbGVhclJlY3QoLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgY3R4W21ldGhvZE5hbWUgKyAnUmVjdCddKC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VSZWN0KC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgY29udHJvbHMucmVuZGVyQ2lyY2xlQ29udHJvbCA9IHJlbmRlckNpcmNsZUNvbnRyb2w7XG4gIGNvbnRyb2xzLnJlbmRlclNxdWFyZUNvbnRyb2wgPSByZW5kZXJTcXVhcmVDb250cm9sO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgZnVuY3Rpb24gQ29udHJvbChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMuQ29udHJvbCA9IENvbnRyb2w7XG5cbiAgZmFicmljLkNvbnRyb2wucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ29udHJvbC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICoga2VlcCB0cmFjayBvZiBjb250cm9sIHZpc2liaWxpdHkuXG4gICAgICogbWFpbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqIGlmIHlvdSBkbyBub3Qgd2FudCB0byBzZWUgYSBjb250cm9sLCB5b3UgY2FuIHJlbW92ZSBpdFxuICAgICAqIGZyb20gdGhlIGNvbnRyb2xzZXQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBhY3Rpb24gdGhhdCB0aGUgY29udHJvbCB3aWxsIGxpa2VseSBleGVjdXRlLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwuIEZhYnJpY0pTIHVzZXMgdG8gaWRlbnRpZnkgd2hhdCB0aGUgdXNlciBpcyBkb2luZyBmb3Igc29tZVxuICAgICAqIGV4dHJhIG9wdGltaXphdGlvbnMuIElmIHlvdSBhcmUgd3JpdGluZyBhIGN1c3RvbSBjb250cm9sIGFuZCB5b3Ugd2FudCB0byBrbm93XG4gICAgICogc29tZXdoZXJlIGVsc2UgaW4gdGhlIGNvZGUgd2hhdCBpcyBnb2luZyBvbiwgeW91IGNhbiB1c2UgdGhpcyBzdHJpbmcgaGVyZS5cbiAgICAgKiB5b3UgY2FuIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBnZXRBY3Rpb25OYW1lIGlmIHlvdXIgY29udHJvbCBydW4gbXVsdGlwbGUgYWN0aW9uc1xuICAgICAqIGRlcGVuZGluZyBvbiBzb21lIGV4dGVybmFsIHN0YXRlLlxuICAgICAqIGRlZmF1bHQgdG8gc2NhbGUgc2luY2UgaXMgdGhlIG1vc3QgY29tbW9uLCB1c2VkIG9uIDQgY29ybmVycyBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnc2NhbGUnXG4gICAgICovXG4gICAgYWN0aW9uTmFtZTogJ3NjYWxlJyxcblxuICAgIC8qKlxuICAgICAqIERyYXdpbmcgYW5nbGUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICogTk9UIHVzZWQgZm9yIG5vdywgYnV0IG5hbWUgbWFya2VkIGFzIG5lZWRlZCBmb3IgaW50ZXJuYWwgbG9naWNcbiAgICAgKiBleGFtcGxlOiB0byByZXVzZSB0aGUgc2FtZSBkcmF3aW5nIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgcm90YXRlZCBjb250cm9sc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuIFhcbiAgICAgKiAwLDAgaXMgdGhlIGNlbnRlciBvZiB0aGUgT2JqZWN0LCB3aGlsZSAtMC41IChsZWZ0KSBvciAwLjUgKHJpZ2h0KSBhcmUgdGhlIGV4dHJlbWl0aWVzXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB4OiAwLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuIFlcbiAgICAgKiAwLDAgaXMgdGhlIGNlbnRlciBvZiB0aGUgT2JqZWN0LCB3aGlsZSAtMC41ICh0b3ApIG9yIDAuNSAoYm90dG9tKSBhcmUgdGhlIGV4dHJlbWl0aWVzXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB5OiAwLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgb2YgdGhlIGNvbnRyb2wgZnJvbSB0aGUgZGVmaW5lZCBwb3NpdGlvbi4gSW4gcGl4ZWxzXG4gICAgICogUG9zaXRpdmUgb2Zmc2V0IG1vdmVzIHRoZSBjb250cm9sIHRvIHRoZSByaWdodCwgbmVnYXRpdmUgdG8gdGhlIGxlZnQuXG4gICAgICogSXQgdXNlZCB3aGVuIHlvdSB3YW50IHRvIGhhdmUgcG9zaXRpb24gb2YgY29udHJvbCB0aGF0IGRvZXMgbm90IHNjYWxlIHdpdGhcbiAgICAgKiB0aGUgYm91bmRpbmcgYm94LiBFeGFtcGxlOiByb3RhdGlvbiBjb250cm9sIGlzIHBsYWNlZCBhdCB4OjAsIHk6IDAuNSBvblxuICAgICAqIHRoZSBib3VuZGluZGJveCwgd2l0aCBhbiBvZmZzZXQgb2YgMzAgcGl4ZWxzIHZlcnRpY2FsbHkuIFRob3NlIDMwIHBpeGVscyB3aWxsXG4gICAgICogc3RheSAzMCBwaXhlbHMgbm8gbWF0dGVyIGhvdyB0aGUgb2JqZWN0IGlzIGJpZy4gQW5vdGhlciBleGFtcGxlIGlzIGhhdmluZyAyXG4gICAgICogY29udHJvbHMgaW4gdGhlIGNvcm5lciwgdGhhdCBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uIHdoZW4gdGhlIG9iamVjdCBzY2FsZS5cbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgb2YgdGhlIGNvbnRyb2wgZnJvbSB0aGUgZGVmaW5lZCBwb3NpdGlvbi4gSW4gcGl4ZWxzXG4gICAgICogUG9zaXRpdmUgb2Zmc2V0IG1vdmVzIHRoZSBjb250cm9sIHRvIHRoZSBib3R0b20sIG5lZ2F0aXZlIHRvIHRoZSB0b3AuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgY29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggc2l6ZVggYW5kIHNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgc2l6ZVg6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIGNvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHNpemVYIGFuZCBzaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHNpemVZOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaCBhcmVhIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyB0b3VjaENvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHRvdWNoU2l6ZVggYW5kIHRvdWNoU2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0b3VjaFNpemVYOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSB0b3VjaCBhcmVhIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyB0b3VjaENvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHRvdWNoU2l6ZVggYW5kIHRvdWNoU2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0b3VjaFNpemVZOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ3NzIGN1cnNvciBzdHlsZSB0byBkaXNwbGF5IHdoZW4gdGhlIGNvbnRyb2wgaXMgaG92ZXJlZC5cbiAgICAgKiBpZiB0aGUgbWV0aG9kIGBjdXJzb3JTdHlsZUhhbmRsZXJgIGlzIHByb3ZpZGVkLCB0aGlzIHByb3BlcnR5IGlzIGlnbm9yZWQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnY3Jvc3NoYWlyJ1xuICAgICAqL1xuICAgIGN1cnNvclN0eWxlOiAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIElmIGNvbnRyb2xzIGhhcyBhbiBvZmZzZXRZIG9yIG9mZnNldFgsIGRyYXcgYSBsaW5lIHRoYXQgY29ubmVjdHNcbiAgICAgKiB0aGUgY29udHJvbCB0byB0aGUgYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB3aXRoQ29ubmVjdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBhY3Rpb25IYW5kbGVyLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgYWN0aW9uICggY29udHJvbCBiZWluZyBtb3ZlZCApXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBoYW5kbGVyIGZvciBtb3VzZSBkb3duLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgbW91c2UgZG93biBvbiBjb250cm9sXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgbW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBtb3VzZVVwSGFuZGxlciwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIGFuIGVmZmVjdCBvbiBtb3VzZSB1cC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBtb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgYWN0aW9uSGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0QWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBtb3VzZURvd24gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0TW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBtb3VzZVVwIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldE1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VVcEhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBjdXJzb3JTdHlsZSBmb3IgY3NzIHVzaW5nIGN1cnNvclN0eWxlLiBJZiB5b3UgbmVlZCBhIG1vcmUgZWxhYm9yYXRlXG4gICAgICogZnVuY3Rpb24geW91IGNhbiBwYXNzIG9uZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKiB0aGUgY3Vyc29yU3R5bGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGN1cnJlbnQgY29udHJvbCAoIGxpa2VseSB0aGlzKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50RGF0YSwgY29udHJvbCAvKiBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24gbmFtZS4gVGhlIGJhc2ljIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJuIHRoZSBhY3Rpb25OYW1lIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY3VycmVudCBjb250cm9sICggbGlrZWx5IHRoaXMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEFjdGlvbk5hbWU6IGZ1bmN0aW9uKGV2ZW50RGF0YSwgY29udHJvbCAvKiBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHJldHVybiBjb250cm9sLmFjdGlvbk5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbHMgdmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IGtleSB3aGVyZSB0aGUgY29udHJvbCBpcyBtZW1vcml6ZWQgb24gdGhlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRWaXNpYmlsaXR5OiBmdW5jdGlvbihmYWJyaWNPYmplY3QsIGNvbnRyb2xLZXkpIHtcbiAgICAgIHZhciBvYmplY3RWaXNpYmlsaXR5ID0gZmFicmljT2JqZWN0Ll9jb250cm9sc1Zpc2liaWxpdHk7XG4gICAgICBpZiAob2JqZWN0VmlzaWJpbGl0eSAmJiB0eXBlb2Ygb2JqZWN0VmlzaWJpbGl0eVtjb250cm9sS2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFZpc2liaWxpdHlbY29udHJvbEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2liaWxpdHkgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uKHZpc2liaWxpdHkgLyogbmFtZSwgZmFicmljT2JqZWN0ICovKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmlsaXR5O1xuICAgIH0sXG5cblxuICAgIHBvc2l0aW9uSGFuZGxlcjogZnVuY3Rpb24oZGltLCBmaW5hbE1hdHJpeCAvKiwgZmFicmljT2JqZWN0LCBjdXJyZW50Q29udHJvbCAqLykge1xuICAgICAgdmFyIHBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoe1xuICAgICAgICB4OiB0aGlzLnggKiBkaW0ueCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogdGhpcy55ICogZGltLnkgKyB0aGlzLm9mZnNldFkgfSwgZmluYWxNYXRyaXgpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZHMgZm9yIHRoaXMgY29udHJvbCBiYXNlZCBvbiBvYmplY3QgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3RBbmdsZSBhbmdsZSBmcm9tIHRoZSBmYWJyaWMgb2JqZWN0IGhvbGRpbmcgdGhlIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2JqZWN0Q29ybmVyU2l6ZSBjb3JuZXJTaXplIGZyb20gdGhlIGZhYnJpYyBvYmplY3QgaG9sZGluZyB0aGUgY29udHJvbCAob3IgdG91Y2hDb3JuZXJTaXplIGlmXG4gICAgICogICBpc1RvdWNoIGlzIHRydWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlclggeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2VudGVyWSB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUb3VjaCB0cnVlIGlmIHRvdWNoIGNvcm5lciwgZmFsc2UgaWYgbm9ybWFsIGNvcm5lclxuICAgICAqL1xuICAgIGNhbGNDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKG9iamVjdEFuZ2xlLCBvYmplY3RDb3JuZXJTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBpc1RvdWNoKSB7XG4gICAgICB2YXIgY29zSGFsZk9mZnNldCxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICAgIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHhTaXplID0gKGlzVG91Y2gpID8gdGhpcy50b3VjaFNpemVYIDogdGhpcy5zaXplWCxcbiAgICAgICAgICB5U2l6ZSA9IChpc1RvdWNoKSA/IHRoaXMudG91Y2hTaXplWSA6IHRoaXMuc2l6ZVk7XG4gICAgICBpZiAoeFNpemUgJiYgeVNpemUgJiYgeFNpemUgIT09IHlTaXplKSB7XG4gICAgICAgIC8vIGhhbmRsZSByZWN0YW5ndWxhciBjb3JuZXJzXG4gICAgICAgIHZhciBjb250cm9sVHJpYW5nbGVBbmdsZSA9IE1hdGguYXRhbjIoeVNpemUsIHhTaXplKTtcbiAgICAgICAgdmFyIGNvcm5lckh5cG90ZW51c2UgPSBNYXRoLnNxcnQoeFNpemUgKiB4U2l6ZSArIHlTaXplICogeVNpemUpIC8gMjtcbiAgICAgICAgdmFyIG5ld1RoZXRhID0gY29udHJvbFRyaWFuZ2xlQW5nbGUgLSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9iamVjdEFuZ2xlKTtcbiAgICAgICAgdmFyIG5ld1RoZXRhQ29tcCA9IE1hdGguUEkgLyAyIC0gY29udHJvbFRyaWFuZ2xlQW5nbGUgLSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9iamVjdEFuZ2xlKTtcbiAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSk7XG4gICAgICAgIC8vIHVzZSBjb21wbGVtZW50YXJ5IGFuZ2xlIGZvciB0d28gY29ybmVyc1xuICAgICAgICBjb3NIYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGFDb21wKTtcbiAgICAgICAgc2luSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhQ29tcCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIHNxdWFyZSBjb3JuZXJzXG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG9iamVjdCBjb3JuZXIgc2l6ZSB1bmxlc3Mgc2l6ZSBpcyBkZWZpbmVkXG4gICAgICAgIHZhciBjb3JuZXJTaXplID0gKHhTaXplICYmIHlTaXplKSA/IHhTaXplIDogb2JqZWN0Q29ybmVyU2l6ZTtcbiAgICAgICAgLyogMC43MDcxMDY3ODEyIHN0YW5kcyBmb3Igc3FydCgyKS8yICovXG4gICAgICAgIGNvcm5lckh5cG90ZW51c2UgPSBjb3JuZXJTaXplICogMC43MDcxMDY3ODEyO1xuICAgICAgICAvLyBjb21wbGVtZW50YXJ5IGFuZ2xlcyBhcmUgZXF1YWwgc2luY2UgdGhleSdyZSBib3RoIDQ1IGRlZ3JlZXNcbiAgICAgICAgdmFyIG5ld1RoZXRhID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyg0NSAtIG9iamVjdEFuZ2xlKTtcbiAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvc0hhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YSk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXQgPSBzaW5IYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0bDoge1xuICAgICAgICAgIHg6IGNlbnRlclggLSBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB5OiBjZW50ZXJZIC0gY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgIH0sXG4gICAgICAgIHRyOiB7XG4gICAgICAgICAgeDogY2VudGVyWCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgeTogY2VudGVyWSAtIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICAgIGJsOiB7XG4gICAgICAgICAgeDogY2VudGVyWCAtIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgeTogY2VudGVyWSArIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICAgIGJyOiB7XG4gICAgICAgICAgeDogY2VudGVyWCArIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgY29udHJvbC5cbiAgICAqIFdoZW4gdGhpcyBmdW5jdGlvbiBydW5zIHRoZSBjb250ZXh0IGlzIHVuc2NhbGVkLiB1bnJvdGF0ZS4gSnVzdCByZXRpbmEgc2NhbGVkLlxuICAgICogYWxsIHRoZSBmdW5jdGlvbnMgd2lsbCBoYXZlIHRvIHRyYW5zbGF0ZSB0byB0aGUgcG9pbnQgbGVmdCx0b3AgYmVmb3JlIHN0YXJ0aW5nIERyYXdpbmdcbiAgICAqIGlmIHRoZXkgd2FudCB0byBkcmF3IGEgY29udHJvbCB3aGVyZSB0aGUgcG9zaXRpb24gaXMgZGV0ZWN0ZWQuXG4gICAgKiBsZWZ0IGFuZCB0b3AgYXJlIHRoZSByZXN1bHQgb2YgdGhlIHBvc2l0aW9uSGFuZGxlciBmdW5jdGlvblxuICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0aGUgY29udGV4dCB3aGVyZSB0aGUgY29udHJvbCB3aWxsIGJlIGRyYXduXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzIHdoZXJlIHdlIGFyZSBhYm91dCB0byByZW5kZXIgdGhlIGNvbnRyb2wuXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHBvc2l0aW9uIG9mIHRoZSBjYW52YXMgd2hlcmUgd2UgYXJlIGFib3V0IHRvIHJlbmRlciB0aGUgY29udHJvbC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlXG4gICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgb2JqZWN0IHdoZXJlIHRoZSBjb250cm9sIGlzIGFib3V0IHRvIGJlIHJlbmRlcmVkXG4gICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgc3dpdGNoIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0eWxlIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHlsZSkge1xuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgIGZhYnJpYy5jb250cm9sc1V0aWxzLnJlbmRlckNpcmNsZUNvbnRyb2wuY2FsbCh0aGlzLCBjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmYWJyaWMuY29udHJvbHNVdGlscy5yZW5kZXJTcXVhcmVDb250cm9sLmNhbGwodGhpcywgY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIGZ1bmN0aW9uIGdldENvbG9yU3RvcChlbCwgbXVsdGlwbGllcikge1xuICAgIHZhciBzdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSxcbiAgICAgICAgb2Zmc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKSB8fCAwLFxuICAgICAgICBjb2xvciwgY29sb3JBbHBoYSwgb3BhY2l0eSwgaTtcblxuICAgIC8vIGNvbnZlcnQgcGVyY2VudHMgdG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQpIC8gKC8lJC8udGVzdChvZmZzZXQpID8gMTAwIDogMSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQgPiAxID8gMSA6IG9mZnNldDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBrZXlWYWx1ZVBhaXJzID0gc3R5bGUuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICBpZiAoa2V5VmFsdWVQYWlyc1trZXlWYWx1ZVBhaXJzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBrZXlWYWx1ZVBhaXJzLmxlbmd0aDsgaS0tOyApIHtcblxuICAgICAgICB2YXIgc3BsaXQgPSBrZXlWYWx1ZVBhaXJzW2ldLnNwbGl0KC9cXHMqOlxccyovKSxcbiAgICAgICAgICAgIGtleSA9IHNwbGl0WzBdLnRyaW0oKSxcbiAgICAgICAgICAgIHZhbHVlID0gc3BsaXRbMV0udHJpbSgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdzdG9wLWNvbG9yJykge1xuICAgICAgICAgIGNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3RvcC1vcGFjaXR5Jykge1xuICAgICAgICAgIG9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJykgfHwgJ3JnYigwLDAsMCknO1xuICAgIH1cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIG9wYWNpdHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgIH1cblxuICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcik7XG4gICAgY29sb3JBbHBoYSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgb3BhY2l0eSA9IGlzTmFOKHBhcnNlRmxvYXQob3BhY2l0eSkpID8gMSA6IHBhcnNlRmxvYXQob3BhY2l0eSk7XG4gICAgb3BhY2l0eSAqPSBjb2xvckFscGhhICogbXVsdGlwbGllcjtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lYXJDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgneDInKSB8fCAnMTAwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCd5MicpIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFkaWFsQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z4JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgnZnknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMTogMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjI6IGVsLmdldEF0dHJpYnV0ZSgncicpIHx8ICc1MCUnXG4gICAgfTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICAvKipcbiAgICogR3JhZGllbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5HcmFkaWVudFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNncmFkaWVudHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5HcmFkaWVudCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyYWRpZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuR3JhZGllbnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmb3JtIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZ3JhZGllbnQgYmVmb3JlIHBhaW50aW5nLlxuICAgICAqIEltcG9ydGVkIGZyb20gc3ZnIGdyYWRpZW50cywgaXMgbm90IGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2Zvcm0gaW4gdGhlIGNlbnRlci5cbiAgICAgKiBCZWZvcmUgdGhpcyB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgdGhlIG9yaWdpbiBwb2ludCBpcyBhdCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBvYmplY3RcbiAgICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgICAqIEB0eXBlIE51bWJlcltdXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogY29vcmRpbmF0ZXMgdW5pdHMgZm9yIGNvb3Jkcy5cbiAgICAgKiBJZiBgcGl4ZWxzYCwgdGhlIG51bWJlciBvZiBjb29yZHMgYXJlIGluIHRoZSBzYW1lIHVuaXQgb2Ygd2lkdGggLyBoZWlnaHQuXG4gICAgICogSWYgc2V0IGFzIGBwZXJjZW50YWdlYCB0aGUgY29vcmRzIGFyZSBzdGlsbCBhIG51bWJlciwgYnV0IDEgbWVhbnMgMTAwJSBvZiB3aWR0aFxuICAgICAqIGZvciB0aGUgWCBhbmQgMTAwJSBvZiB0aGUgaGVpZ2h0IGZvciB0aGUgeS4gSXQgY2FuIGJlIGJpZ2dlciB0aGFuIDEgYW5kIG5lZ2F0aXZlLlxuICAgICAqIGFsbG93ZWQgdmFsdWVzIHBpeGVscyBvciBwZXJjZW50YWdlLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdwaXhlbHMnXG4gICAgICovXG4gICAgZ3JhZGllbnRVbml0czogJ3BpeGVscycsXG5cbiAgICAvKipcbiAgICAgKiBHcmFkaWVudCB0eXBlIGxpbmVhciBvciByYWRpYWxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAncGl4ZWxzJ1xuICAgICAqL1xuICAgIHR5cGU6ICdsaW5lYXInLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdCB3aXRoIHR5cGUsIGNvb3JkcywgZ3JhZGllbnRVbml0cyBhbmQgY29sb3JTdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50eXBlXSBncmFkaWVudCB0eXBlIGxpbmVhciBvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZ3JhZGllbnRVbml0c10gZ3JhZGllbnQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub2Zmc2V0WF0gU1ZHIGltcG9ydCBjb21wYXRpYmlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9mZnNldFldIFNWRyBpbXBvcnQgY29tcGF0aWJpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMuY29sb3JTdG9wcyBjb250YWlucyB0aGUgY29sb3JzdG9wcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5jb29yZHMgY29udGFpbnMgdGhlIGNvb3JkcyBvZiB0aGUgZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLngxXSBYIGNvb3JkaWFudGUgb2YgdGhlIGZpcnN0IHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGZvY2FsIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnkxXSBZIGNvb3JkaWFudGUgb2YgdGhlIGZpcnN0IHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGZvY2FsIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLngyXSBYIGNvb3JkaWFudGUgb2YgdGhlIHNlY29uZCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueTJdIFkgY29vcmRpYW50ZSBvZiB0aGUgc2Vjb25kIHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGNlbnRlciBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy5yMV0gb25seSBmb3IgcmFkaWFsIGdyYWRpZW50LCByYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMucjJdIG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudCwgcmFkaXVzIG9mIHRoZSBleHRlcm5hbCBjaXJjbGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIG9wdGlvbnMuY29vcmRzIHx8IChvcHRpb25zLmNvb3JkcyA9IHsgfSk7XG5cbiAgICAgIHZhciBjb29yZHMsIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gc2V0cyBldmVyeXRoaW5nLCB0aGVuIGNvb3JkcyBhbmQgY29sb3JzdG9wcyBnZXQgc2V0cyBhZ2FpblxuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgX3RoaXNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICB0aGlzLmlkICs9ICdfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgfVxuXG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLmNvb3Jkcy54MSB8fCAwLFxuICAgICAgICB5MTogb3B0aW9ucy5jb29yZHMueTEgfHwgMCxcbiAgICAgICAgeDI6IG9wdGlvbnMuY29vcmRzLngyIHx8IDAsXG4gICAgICAgIHkyOiBvcHRpb25zLmNvb3Jkcy55MiB8fCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMucjEgPSBvcHRpb25zLmNvb3Jkcy5yMSB8fCAwO1xuICAgICAgICBjb29yZHMucjIgPSBvcHRpb25zLmNvb3Jkcy5yMiB8fCAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcbiAgICAgIHRoaXMuY29sb3JTdG9wcyA9IG9wdGlvbnMuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgY29sb3JTdG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbG9yU3RvcCBPYmplY3Qgd2l0aCBvZmZzZXQgYW5kIGNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbihjb2xvclN0b3BzKSB7XG4gICAgICBmb3IgKHZhciBwb3NpdGlvbiBpbiBjb2xvclN0b3BzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3JTdG9wc1twb3NpdGlvbl0pO1xuICAgICAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBwYXJzZUZsb2F0KHBvc2l0aW9uKSxcbiAgICAgICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgICAgICBvcGFjaXR5OiBjb2xvci5nZXRBbHBoYSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgIGNvbG9yU3RvcHM6IHRoaXMuY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IHRoaXMuZ3JhZGllbnRVbml0cyxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb29yZHMgPSBjbG9uZSh0aGlzLmNvb3JkcywgdHJ1ZSksIGksIGxlbiwgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgbWFya3VwLCBjb21tb25BdHRyaWJ1dGVzLCBjb2xvclN0b3BzID0gY2xvbmUodGhpcy5jb2xvclN0b3BzLCB0cnVlKSxcbiAgICAgICAgICBuZWVkc1N3YXAgPSBjb29yZHMucjEgPiBjb29yZHMucjIsXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBvZmZzZXRYID0gLXRoaXMub2Zmc2V0WCwgb2Zmc2V0WSA9IC10aGlzLm9mZnNldFksXG4gICAgICAgICAgd2l0aFZpZXdwb3J0ID0gISFvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IHRoaXMuZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycgPyAndXNlclNwYWNlT25Vc2UnIDogJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgIC8vIGNvbG9yU3RvcHMgbXVzdCBiZSBzb3J0ZWQgYXNjZW5kaW5nXG4gICAgICBjb2xvclN0b3BzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94Jykge1xuICAgICAgICBvZmZzZXRYIC89IG9iamVjdC53aWR0aDtcbiAgICAgICAgb2Zmc2V0WSAvPSBvYmplY3QuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldFggKz0gb2JqZWN0LndpZHRoIC8gMjtcbiAgICAgICAgb2Zmc2V0WSArPSBvYmplY3QuaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ3BhdGgnICYmIHRoaXMuZ3JhZGllbnRVbml0cyAhPT0gJ3BlcmNlbnRhZ2UnKSB7XG4gICAgICAgIG9mZnNldFggLT0gb2JqZWN0LnBhdGhPZmZzZXQueDtcbiAgICAgICAgb2Zmc2V0WSAtPSBvYmplY3QucGF0aE9mZnNldC55O1xuICAgICAgfVxuXG5cbiAgICAgIHRyYW5zZm9ybVs0XSAtPSBvZmZzZXRYO1xuICAgICAgdHJhbnNmb3JtWzVdIC09IG9mZnNldFk7XG5cbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgPSAnaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICAnXCIgZ3JhZGllbnRVbml0cz1cIicgKyBncmFkaWVudFVuaXRzICsgJ1wiJztcbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgKz0gJyBncmFkaWVudFRyYW5zZm9ybT1cIicgKyAod2l0aFZpZXdwb3J0ID9cbiAgICAgICAgb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtICsgJyAnIDogJycpICsgZmFicmljLnV0aWwubWF0cml4VG9TVkcodHJhbnNmb3JtKSArICdcIiAnO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxsaW5lYXJHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyB4MT1cIicsIGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgeTE9XCInLCBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiIHgyPVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiB5Mj1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAvLyBzdmcgcmFkaWFsIGdyYWRpZW50IGhhcyBqdXN0IDEgcmFkaXVzLiB0aGUgYmlnZ2VzdC5cbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8cmFkaWFsR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgY3g9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDEgOiBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIGN5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkxIDogY29vcmRzLnkyLFxuICAgICAgICAgICdcIiByPVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnIxIDogY29vcmRzLnIyLFxuICAgICAgICAgICdcIiBmeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MiA6IGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgZnk9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTIgOiBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgaWYgKG5lZWRzU3dhcCkge1xuICAgICAgICAgIC8vIHN2ZyBnb2VzIGZyb20gaW50ZXJuYWwgdG8gZXh0ZXJuYWwgcmFkaXVzLiBpZiByYWRpdXMgYXJlIGludmVydGVkLCBzd2FwIGNvbG9yIHN0b3BzLlxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBjb2xvclN0b3BzLmNvbmNhdCgpO1xuICAgICAgICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ID0gMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUmFkaXVzID0gTWF0aC5taW4oY29vcmRzLnIxLCBjb29yZHMucjIpO1xuICAgICAgICBpZiAobWluUmFkaXVzID4gMCkge1xuICAgICAgICAgIC8vIGkgaGF2ZSB0byBzaGlmdCBhbGwgY29sb3JTdG9wcyBhbmQgYWRkIG5ldyBvbmUgaW4gMC5cbiAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5tYXgoY29vcmRzLnIxLCBjb29yZHMucjIpLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlU2hpZnQgPSBtaW5SYWRpdXMgLyBtYXhSYWRpdXM7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgKz0gcGVyY2VudGFnZVNoaWZ0ICogKDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yU3RvcCA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICdvZmZzZXQ9XCInLCAoY29sb3JTdG9wLm9mZnNldCAqIDEwMCkgKyAnJScsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwic3RvcC1jb2xvcjonLCBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgKHR5cGVvZiBjb2xvclN0b3Aub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyAnO3N0b3Atb3BhY2l0eTogJyArIGNvbG9yU3RvcC5vcGFjaXR5IDogJzsnKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicgPyAnPC9saW5lYXJHcmFkaWVudD5cXG4nIDogJzwvcmFkaWFsR3JhZGllbnQ+XFxuJykpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc0dyYWRpZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge0NhbnZhc0dyYWRpZW50fVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZ3JhZGllbnQsIGNvb3JkcyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmNvb3JkcyksIGksIGxlbjtcblxuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLngyLCBjb29yZHMueTIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLnIxLCBjb29yZHMueDIsIGNvb3Jkcy55MiwgY29vcmRzLnIyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGFjaXR5QXR0ciBBIGZpbGwtb3BhY2l0eSBvciBzdHJva2Utb3BhY2l0eSBhdHRyaWJ1dGUgdG8gbXVsdGlwbHkgdG8gZWFjaCBzdG9wJ3Mgb3BhY2l0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnT3B0aW9ucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aGUgU1ZHIGluIG9yZGVyIHRvIHBhcnNlIGNvcnJlY3RseSBncmFkaWVudHNcbiAgICAgKiB0aGF0IHVzZXMgZ3JhZGllbnRVbml0cyBhcyAndXNlclNwYWNlT25Vc2UnIGFuZCBwZXJjZW50YWdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHZpZXdCb3hXaWR0aCB3aWR0aCBwYXJ0IG9mIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvbiBzdmdcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHZpZXdCb3hIZWlnaHQgaGVpZ2h0IHBhcnQgb2YgdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9uIHN2Z1xuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gd2lkdGggd2lkdGggcGFydCBvZiB0aGUgc3ZnIHRhZyBpZiB2aWV3Qm94IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IGhlaWdodCBoZWlnaHQgcGFydCBvZiB0aGUgc3ZnIHRhZyBpZiB2aWV3Qm94IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IEdyYWRpZW50IGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNMaW5lYXJHcmFkaWVudEVsZW1lbnRcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI1JhZGlhbEdyYWRpZW50RWxlbWVudFxuICAgICAqL1xuICAgIGZyb21FbGVtZW50OiBmdW5jdGlvbihlbCwgaW5zdGFuY2UsIG9wYWNpdHlBdHRyLCBzdmdPcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqICBAZXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMjU1LDI1NSwyNTUpXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMCwwLDApXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIgc3RvcC1vcGFjaXR5PVwiMC41XCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAuNVwiIHN0b3AtY29sb3I9XCJyZ2IoMCwwLDApXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgdmFyIG11bHRpcGxpZXIgPSBwYXJzZUZsb2F0KG9wYWNpdHlBdHRyKSAvICgvJSQvLnRlc3Qob3BhY2l0eUF0dHIpID8gMTAwIDogMSk7XG4gICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciA8IDAgPyAwIDogbXVsdGlwbGllciA+IDEgPyAxIDogbXVsdGlwbGllcjtcbiAgICAgIGlmIChpc05hTihtdWx0aXBsaWVyKSkge1xuICAgICAgICBtdWx0aXBsaWVyID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yU3RvcEVscyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdG9wJyksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykgPT09ICd1c2VyU3BhY2VPblVzZScgP1xuICAgICAgICAgICAgJ3BpeGVscycgOiAncGVyY2VudGFnZScsXG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykgfHwgJycsXG4gICAgICAgICAgY29sb3JTdG9wcyA9IFtdLFxuICAgICAgICAgIGNvb3JkcywgaSwgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwLFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDtcbiAgICAgIGlmIChlbC5ub2RlTmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50JyB8fCBlbC5ub2RlTmFtZSA9PT0gJ0xJTkVBUkdSQURJRU5UJykge1xuICAgICAgICB0eXBlID0gJ2xpbmVhcic7XG4gICAgICAgIGNvb3JkcyA9IGdldExpbmVhckNvb3JkcyhlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdyYWRpYWwnO1xuICAgICAgICBjb29yZHMgPSBnZXRSYWRpYWxDb29yZHMoZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBjb2xvclN0b3BFbHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb2xvclN0b3BzLnB1c2goZ2V0Q29sb3JTdG9wKGNvbG9yU3RvcEVsc1tpXSwgbXVsdGlwbGllcikpO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1NYXRyaXggPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoZ3JhZGllbnRUcmFuc2Zvcm0pO1xuXG4gICAgICBfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhpbnN0YW5jZSwgY29vcmRzLCBzdmdPcHRpb25zLCBncmFkaWVudFVuaXRzKTtcblxuICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgIG9mZnNldFggPSAtaW5zdGFuY2UubGVmdDtcbiAgICAgICAgb2Zmc2V0WSA9IC1pbnN0YW5jZS50b3A7XG4gICAgICB9XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICBpZDogZWwuZ2V0QXR0cmlidXRlKCdpZCcpLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgZ3JhZGllbnRVbml0czogZ3JhZGllbnRVbml0cyxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRyYW5zZm9ybU1hdHJpeCxcbiAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICAgIC8qIF9GUk9NX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIG9wdGlvbnMsIHN2Z09wdGlvbnMsIGdyYWRpZW50VW5pdHMpIHtcbiAgICB2YXIgcHJvcFZhbHVlLCBmaW5hbFZhbHVlO1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcHJvcFZhbHVlID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wVmFsdWUgPT09ICctSW5maW5pdHknKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnNbcHJvcF0sIDEwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFxcZCtcXC5cXGQrKSV8KFxcZCspJSQvLnRlc3QocHJvcFZhbHVlKSkge1xuICAgICAgICAgIGZpbmFsVmFsdWUgKj0gMC4wMTtcbiAgICAgICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBmaXggdGhvc2UgcGVyY2VudGFnZXMgaGVyZSBpbiBzdmcgcGFyc2luZ1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJyB8fCBwcm9wID09PSAncjInKSB7XG4gICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gc3ZnT3B0aW9ucy52aWV3Qm94V2lkdGggfHwgc3ZnT3B0aW9ucy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICAgICAgZmluYWxWYWx1ZSAqPSBzdmdPcHRpb25zLnZpZXdCb3hIZWlnaHQgfHwgc3ZnT3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zW3Byb3BdID0gZmluYWxWYWx1ZTtcbiAgICB9KTtcbiAgfVxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICAvKipcbiAgICogUGF0dGVybiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdHRlcm5cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9wYXR0ZXJuc3xQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZHluYW1pYy1wYXR0ZXJuc3xEeW5hbWljUGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0dGVybiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cblxuXG4gIGZhYnJpYy5QYXR0ZXJuID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmVwZWF0IHByb3BlcnR5IG9mIGEgcGF0dGVybiAob25lIG9mIHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15IG9yIG5vLXJlcGVhdClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlcGVhdDogJ3JlcGVhdCcsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIGhvcml6b250YWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiB2ZXJ0aWNhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9zc09yaWdpbjogJycsXG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gbWF0cml4IHRvIGNoYW5nZSB0aGUgcGF0dGVybiwgaW1wb3J0ZWQgZnJvbSBzdmdzLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXR0ZXJuVHJhbnNmb3JtOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgY2FsbGJhY2sgaW5pdC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0dGVybn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy5zb3VyY2UgfHwgKG9wdGlvbnMuc291cmNlICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZSAhPT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1nIHNyYyBzdHJpbmdcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob3B0aW9ucy5zb3VyY2UsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICAgIF90aGlzLnNvdXJjZSA9IGltZztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhfdGhpcywgaXNFcnJvcik7XG4gICAgICAgIH0sIG51bGwsIHRoaXMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIHNvdXJjZSwgb2JqZWN0O1xuXG4gICAgICAvLyA8aW1nPiBlbGVtZW50XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgLy8gPGNhbnZhcz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyAmJiB0aGlzLnNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgcmVwZWF0OiB0aGlzLnJlcGVhdCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIG9mZnNldFg6IHRvRml4ZWQodGhpcy5vZmZzZXRYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgb2Zmc2V0WTogdG9GaXhlZCh0aGlzLm9mZnNldFksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0gPyB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0uY29uY2F0KCkgOiBudWxsXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHBhdHRlcm5Tb3VyY2UgPSB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0aGlzLnNvdXJjZSgpIDogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgcGF0dGVybldpZHRoID0gcGF0dGVyblNvdXJjZS53aWR0aCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gcGF0dGVyblNvdXJjZS5oZWlnaHQgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRYID0gdGhpcy5vZmZzZXRYIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRZID0gdGhpcy5vZmZzZXRZIC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuSW1nU3JjID0gJyc7XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSAxO1xuICAgICAgICBpZiAocGF0dGVybk9mZnNldFkpIHtcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ICs9IE1hdGguYWJzKHBhdHRlcm5PZmZzZXRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuV2lkdGggPSAxO1xuICAgICAgICBpZiAocGF0dGVybk9mZnNldFgpIHtcbiAgICAgICAgICBwYXR0ZXJuV2lkdGggKz0gTWF0aC5hYnMocGF0dGVybk9mZnNldFgpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuU291cmNlLnNyYykge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cGF0dGVybiBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHg9XCInICsgcGF0dGVybk9mZnNldFggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeT1cIicgKyBwYXR0ZXJuT2Zmc2V0WSArXG4gICAgICAgICAgICAgICAgICAgICdcIiB3aWR0aD1cIicgKyBwYXR0ZXJuV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5IZWlnaHQgKyAnXCI+XFxuJyArXG4gICAgICAgICAgICAgICAnPGltYWdlIHg9XCIwXCIgeT1cIjBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICcgd2lkdGg9XCInICsgcGF0dGVyblNvdXJjZS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuU291cmNlLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIHhsaW5rOmhyZWY9XCInICsgcGF0dGVybkltZ1NyYyArXG4gICAgICAgICAgICAgICAnXCI+PC9pbWFnZT5cXG4nICtcbiAgICAgICAgICAgICAnPC9wYXR0ZXJuPlxcbic7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNQYXR0ZXJuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNyZWF0ZSBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7Q2FudmFzUGF0dGVybn1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgLy8gaWYgdGhlIGltYWdlIGZhaWxlZCB0byBsb2FkLCByZXR1cm4sIGFuZCBhbGxvdyByZXN0IHRvIGNvbnRpbnVlIGxvYWRpbmdcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW4gaW1hZ2VcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuY29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5uYXR1cmFsV2lkdGggPT09IDAgfHwgc291cmNlLm5hdHVyYWxIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybihzb3VyY2UsIHRoaXMucmVwZWF0KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuU2hhZG93KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TaGFkb3cgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFkb3cgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TaGFkb3dcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zaGFkb3dzfFNoYWRvdyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU2hhZG93I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuU2hhZG93ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuU2hhZG93LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgY29sb3JcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgYmx1clxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgaG9yaXpvbnRhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgdmVydGljYWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc2hhZG93IHNob3VsZCBhZmZlY3Qgc3Ryb2tlIG9wZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhZmZlY3RTdHJva2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgdGhlIHNoYWRvdyB3aWxsIHNjYWxlIHdpdGggdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHNoYWRvdydzIG9mZnNldFgsIG9mZnNldFksIGFuZCBibHVyIHdpbGwgbm90IGJlIGFmZmVjdGVkIGJ5IHRoZSBvYmplY3QncyBzY2FsZS5cbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm9uU2NhbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggYW55IG9mIGNvbG9yLCBibHVyLCBvZmZzZXRYLCBvZmZzZXRZIHByb3BlcnRpZXMgb3Igc3RyaW5nIChlLmcuIFwicmdiYSgwLDAsMCwwLjIpIDJweCAycHggMTBweFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5TaGFkb3d9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlU2hhZG93KG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNoYWRvdyBTaGFkb3cgdmFsdWUgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFNoYWRvdyBvYmplY3Qgd2l0aCBjb2xvciwgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1clxuICAgICAqL1xuICAgIF9wYXJzZVNoYWRvdzogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICB2YXIgc2hhZG93U3RyID0gc2hhZG93LnRyaW0oKSxcbiAgICAgICAgICBvZmZzZXRzQW5kQmx1ciA9IGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ci5leGVjKHNoYWRvd1N0cikgfHwgW10sXG4gICAgICAgICAgY29sb3IgPSBzaGFkb3dTdHIucmVwbGFjZShmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIsICcnKSB8fCAncmdiKDAsMCwwKSc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBjb2xvci50cmltKCksXG4gICAgICAgIG9mZnNldFg6IHBhcnNlRmxvYXQob2Zmc2V0c0FuZEJsdXJbMV0sIDEwKSB8fCAwLFxuICAgICAgICBvZmZzZXRZOiBwYXJzZUZsb2F0KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VGbG9hdChvZmZzZXRzQW5kQmx1clszXSwgMTApIHx8IDBcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2Nzcy10ZXh0LWRlY29yLTMvI3RleHQtc2hhZG93XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIENTUzMgdGV4dC1zaGFkb3cgZGVjbGFyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIsIHRoaXMuY29sb3JdLmpvaW4oJ3B4ICcpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBmQm94WCA9IDQwLCBmQm94WSA9IDQwLCBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIG9mZnNldCA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihcbiAgICAgICAgICAgIHsgeDogdGhpcy5vZmZzZXRYLCB5OiB0aGlzLm9mZnNldFkgfSxcbiAgICAgICAgICAgIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoLW9iamVjdC5hbmdsZSkpLFxuICAgICAgICAgIEJMVVJfQk9YID0gMjAsIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKTtcblxuICAgICAgaWYgKG9iamVjdC53aWR0aCAmJiBvYmplY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNGaWx0ZXJFZmZlY3RzUmVnaW9uXG4gICAgICAgIC8vIHdlIGFkZCBzb21lIGV4dHJhIHNwYWNlIHRvIGZpbHRlciBib3ggdG8gY29udGFpbiB0aGUgYmx1ciAoIDIwIClcbiAgICAgICAgZkJveFggPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueCkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSAqIDEwMCArIEJMVVJfQk9YO1xuICAgICAgICBmQm94WSA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC55KSArIHRoaXMuYmx1cikgLyBvYmplY3QuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSAqIDEwMCArIEJMVVJfQk9YO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWCkge1xuICAgICAgICBvZmZzZXQueCAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFkpIHtcbiAgICAgICAgb2Zmc2V0LnkgKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICc8ZmlsdGVyIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgKyAnXCIgeT1cIi0nICsgZkJveFkgKyAnJVwiIGhlaWdodD1cIicgKyAoMTAwICsgMiAqIGZCb3hZKSArICclXCIgJyArXG4gICAgICAgICAgJ3g9XCItJyArIGZCb3hYICsgJyVcIiB3aWR0aD1cIicgKyAoMTAwICsgMiAqIGZCb3hYKSArICclXCIgJyArICc+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiJyArXG4gICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYmx1ciA/IHRoaXMuYmx1ciAvIDIgOiAwLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIj48L2ZlR2F1c3NpYW5CbHVyPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVPZmZzZXQgZHg9XCInICsgdG9GaXhlZChvZmZzZXQueCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICdcIiBkeT1cIicgKyB0b0ZpeGVkKG9mZnNldC55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiByZXN1bHQ9XCJvQmx1clwiID48L2ZlT2Zmc2V0PlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIicgKyBjb2xvci50b1JnYigpICsgJ1wiIGZsb29kLW9wYWNpdHk9XCInICsgY29sb3IuZ2V0QWxwaGEoKSArICdcIi8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUNvbXBvc2l0ZSBpbjI9XCJvQmx1clwiIG9wZXJhdG9yPVwiaW5cIiAvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVNZXJnZT5cXG4nICtcbiAgICAgICAgICAgICdcXHRcXHQ8ZmVNZXJnZU5vZGU+PC9mZU1lcmdlTm9kZT5cXG4nICtcbiAgICAgICAgICAgICdcXHRcXHQ8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCI+PC9mZU1lcmdlTm9kZT5cXG4nICtcbiAgICAgICAgICAnXFx0PC9mZU1lcmdlPlxcbicgK1xuICAgICAgICAnPC9maWx0ZXI+XFxuJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3cgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIGJsdXI6IHRoaXMuYmx1cixcbiAgICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICAgIGFmZmVjdFN0cm9rZTogdGhpcy5hZmZlY3RTdHJva2UsXG4gICAgICAgICAgbm9uU2NhbGluZzogdGhpcy5ub25TY2FsaW5nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0geyB9LCBwcm90byA9IGZhYnJpYy5TaGFkb3cucHJvdG90eXBlO1xuXG4gICAgICBbJ2NvbG9yJywgJ2JsdXInLCAnb2Zmc2V0WCcsICdvZmZzZXRZJywgJ2FmZmVjdFN0cm9rZScsICdub25TY2FsaW5nJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmICh0aGlzW3Byb3BdICE9PSBwcm90b1twcm9wXSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIHNoYWRvdyBvZmZzZXRYLCBvZmZzZXRZIGFuZCBibHVyIChleDogXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIsIFwicmdiKDAsMjU1LDApIDJweCAycHhcIilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5TaGFkb3dcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ciA9IC8oPzpcXHN8XikoLT9cXGQrKD86XFwuXFxkKik/KD86cHgpPyg/Olxccz98JCkpPygtP1xcZCsoPzpcXC5cXGQqKT8oPzpweCk/KD86XFxzP3wkKSk/KFxcZCsoPzpcXC5cXGQqKT8oPzpweCk/KT8oPzpcXHM/fCQpKD86JHxcXHMpLztcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TdGF0aWNDYW52YXMgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFsaWFzZXMgZm9yIGZhc3RlciByZXNvbHV0aW9uXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZ2V0RWxlbWVudE9mZnNldCA9IGZhYnJpYy51dGlsLmdldEVsZW1lbnRPZmZzZXQsXG4gICAgICByZW1vdmVGcm9tQXJyYXkgPSBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXksXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQsXG4gICAgICBpbnZlcnRUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0sXG4gICAgICBnZXROb2RlQ2FudmFzID0gZmFicmljLnV0aWwuZ2V0Tm9kZUNhbnZhcyxcbiAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50LFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kQ29sb3J9LlxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBiYWNrZ3JvdW5kLCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5Q29sb3J9XG4gICAgICogQHNpbmNlIDEuMy45XG4gICAgICogQHR5cGUgeyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheUNvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgaW1hZ2Ugb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIHNpbmNlIDIuNC4wIGltYWdlIGNhY2hpbmcgaXMgYWN0aXZlLCBwbGVhc2Ugd2hlbiBwdXR0aW5nIGFuIGltYWdlIGFzIG92ZXJsYXksIGFkZCB0byB0aGVcbiAgICAgKiBjYW52YXMgcHJvcGVydHkgYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBpdCBpcyBvbi4gT3RoZXJ3aXNlIHRoZSBpbWFnZSBjYW5ub3QgZGV0ZWN0IHRoZSB6b29tXG4gICAgICogdmFsZS4gQXMgYW4gYWx0ZXJuYXRpdmUgeW91IGNhbiBkaXNhYmxlIGltYWdlIG9iamVjdENhY2hpbmdcbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2UsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgb2JqZWN0IHZhbHVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cycgc3RhdGUgc2hvdWxkIGJlIHNhdmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RhdGVmdWw6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmFkZH0sIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5pbnNlcnRBdH0gYW5kIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5yZW1vdmV9LFxuICAgICAqIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLm1vdmVUb30sIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLmNsZWFyfSBhbmQgbWFueSBtb3JlLCBzaG91bGQgYWxzbyByZS1yZW5kZXIgY2FudmFzLlxuICAgICAqIERpc2FibGluZyB0aGlzIG9wdGlvbiB3aWxsIG5vdCBnaXZlIGEgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgYSBsb3Qgb2Ygb2JqZWN0cyB0by9mcm9tIGNhbnZhcyBhdCBvbmNlXG4gICAgICogc2luY2UgdGhlIHJlbmRlcnMgYXJlIHF1ZXF1ZWQgYW5kIGV4ZWN1dGVkIG9uZSBwZXIgZnJhbWUuXG4gICAgICogRGlzYWJsaW5nIGlzIHN1Z2dlc3RlZCBhbnl3YXkgYW5kIG1hbmFnaW5nIHRoZSByZW5kZXJzIG9mIHRoZSBhcHAgbWFudWFsbHkgaXMgbm90IGEgYmlnIGVmZm9ydCAoIGNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCkgKVxuICAgICAqIExlZnQgZGVmYXVsdCB0byB0cnVlIHRvIGRvIG5vdCBicmVhayBkb2N1bWVudGF0aW9uIGFuZCBvbGQgYXBwLCBmaWRkbGVzLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlbmRlck9uQWRkUmVtb3ZlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0IGNvbnRyb2xzIChib3JkZXJzL2NvbnRyb2xzKSBhcmUgcmVuZGVyZWQgYWJvdmUgb3ZlcmxheSBpbWFnZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbnRyb2xzQWJvdmVPdmVybGF5OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBicm93c2VyIGNhbiBiZSBzY3JvbGxlZCB3aGVuIHVzaW5nIGEgdG91Y2hzY3JlZW4gYW5kIGRyYWdnaW5nIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbGxvd1RvdWNoU2Nyb2xsaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FudmFzIHdpbGwgdXNlIGltYWdlIHNtb290aGluZywgdGhpcyBpcyBvbiBieSBkZWZhdWx0IGluIGJyb3dzZXJzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW1hZ2VTbW9vdGhpbmdFbmFibGVkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zZm9ybWF0aW9uIChhIENhbnZhcyAyRCBBUEkgdHJhbnNmb3JtIG1hdHJpeCkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRlZmF1bHQgdHJhbnNmb3JtPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TY2FsZSBieSA3MCUgYW5kIHRyYW5zbGF0ZSB0b3dhcmQgYm90dG9tLXJpZ2h0IGJ5IDUwLCB3aXRob3V0IHNrZXdpbmc8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtID0gWzAuNywgMCwgMCwgMC43LCA1MCwgNTBdO1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgY2FudmFzIGlzIHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvIGZvciBiZXR0ZXIgcmVuZGVyaW5nIG9uIHJldGluYSBzY3JlZW5zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZW5hYmxlUmV0aW5hU2NhbGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGNhbnZhcyBlbGVtZW50IGV4dGVuc2lvbiBvdmVyIGRlc2lnblxuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyLlxuICAgICAqIGlmIGNhbnZhcyBpcyBub3Qgem9vbWVkL3Bhbm5lZCB0aG9zZSBwb2ludHMgYXJlIHRoZSBmb3VyIGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBpZiBjYW52YXMgaXMgdmlld3BvcnRUcmFuc2Zvcm1lZCB5b3UgdGhvc2UgcG9pbnRzIGluZGljYXRlIHRoZSBleHRlbnNpb25cbiAgICAgKiBvZiBjYW52YXMgZWxlbWVudCBpbiBwbGFpbiB1bnRyYXNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICovXG4gICAgdnB0Q29vcmRzOiB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB2cHRDb29yZHMgYW5kIG9iamVjdC5hQ29vcmRzLCBza2lwIHJlbmRlcmluZyBvZiBvYmplY3RzIHRoYXRcbiAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICogTWF5IGdyZWF0bHkgaGVscCBpbiBhcHBsaWNhdGlvbnMgd2l0aCBjcm93ZGVkIGNhbnZhcyBhbmQgdXNlIG9mIHpvb20vcGFuXG4gICAgICogSWYgT25lIG9mIHRoZSBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb2JqZWN0IGlzIG9uIHRoZSBjYW52YXNcbiAgICAgKiB0aGUgb2JqZWN0cyBnZXQgcmVuZGVyZWQuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcE9mZnNjcmVlbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgY2FudmFzIGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGVcbiAgICAgKiB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBjbGlwUGF0aCB3aWxsIGNsaXAgYXdheSBjb250cm9scywgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgdG8gaGFwcGVuIHVzZSBjb250cm9sc0Fib3ZlT3ZlcmxheSA9IHRydWVcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0U3RhdGljOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNiID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQ7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLl9jcmVhdGVMb3dlckNhbnZhcyhlbCk7XG4gICAgICB0aGlzLl9pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIC8vIG9ubHkgaW5pdGlhbGl6ZSByZXRpbmEgc2NhbGluZyBvbmNlXG4gICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUltYWdlKG9wdGlvbnMub3ZlcmxheUltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kSW1hZ2Uob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUNvbG9yKG9wdGlvbnMub3ZlcmxheUNvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZmFicmljLmRldmljZVBpeGVsUmF0aW8gPiAxICYmIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSByZXRpbmFTY2FsaW5nIGlmIGFwcGxpZWQsIG90aGVyd2lzZSAxO1xuICAgICAqL1xuICAgIGdldFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmV0aW5hU2NhbGluZygpID8gTWF0aC5tYXgoMSwgZmFicmljLmRldmljZVBpeGVsUmF0aW8pIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2NhbGVSYXRpbyA9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMudXBwZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX19pbml0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oc2NhbGVSYXRpbywgY2FudmFzLCBjb250ZXh0KSB7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBzY2FsZVJhdGlvKTtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICogc2NhbGVSYXRpbyk7XG4gICAgICBjb250ZXh0LnNjYWxlKHNjYWxlUmF0aW8sIHNjYWxlUmF0aW8pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgLy8gVE9ETzogZml4IHN0cmV0Y2hlZCBleGFtcGxlc1xuICAgIHNldEJhY2tncm91bmRJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnYmFja2dyb3VuZEltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8Zm9yZWdyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gb3ZlcmxheUNvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGZvcmVncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBmb3JlZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wQjU1aC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUNvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUNvbG9yOiBmdW5jdGlvbihvdmVybGF5Q29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdvdmVybGF5Q29sb3InLCBvdmVybGF5Q29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gYmFja2dyb3VuZENvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGJhY2tncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBiYWNrZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9oWHp2ay98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZENvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdiYWNrZ3JvdW5kQ29sb3InLCBiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZEltYWdlfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5SW1hZ2V9KVxuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmd8bnVsbCl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSwgVVJMIG9mIGFuIGltYWdlIG9yIG51bGwgdG8gc2V0IGJhY2tncm91bmQgb3Igb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmQgb3Igb3ZlcmxheS4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBjcmVhdGVkIGltYWdlLCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZXJyb3Igb2NjdXJyZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGltYWdlfS5cbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoaW1hZ2UsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpbnN0YW5jZS5jYW52YXMgPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcsIGlzRXJyb3IpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgaW1hZ2UgJiYgKGltYWdlLmNhbnZhcyA9IHRoaXMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWFnZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KGNvbG9yLCBwcm9wZXJ0eSk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihjb2xvciwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGxvd2VyQ2FudmFzRWwgPSB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCB8fCBwYXJzZUludChsb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC5oZWlnaHQsIDEwKSB8fCAwO1xuXG4gICAgICBpZiAoIXRoaXMubG93ZXJDYW52YXNFbC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgbG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBib3R0b20gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY2FudmFzRWxdXG4gICAgICovXG4gICAgX2NyZWF0ZUxvd2VyQ2FudmFzOiBmdW5jdGlvbiAoY2FudmFzRWwpIHtcbiAgICAgIC8vIGNhbnZhc0VsID09PSAnSFRNTENhbnZhc0VsZW1lbnQnIGRvZXMgbm90IHdvcmsgb24ganNkb20vbm9kZVxuICAgICAgaWYgKGNhbnZhc0VsICYmIGNhbnZhc0VsLmdldENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gZmFicmljLnV0aWwuZ2V0QnlJZChjYW52YXNFbCkgfHwgdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmxvd2VyQ2FudmFzRWwsICdsb3dlci1jYW52YXMnKTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGUgPSB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGU7XG4gICAgICBpZiAodGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9hcHBseUNhbnZhc1N0eWxlKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IHRoaXMubG93ZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB3aWR0aCAoaW4gcHgpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgaGVpZ2h0IChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2lkdGggb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCB3aWR0aCB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaGVpZ2h0IG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBzZXQgaGVpZ2h0IHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyBoZWlnaHQ6IHZhbHVlIH0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGRpbWVuc2lvbnMgKHdpZHRoLCBoZWlnaHQpIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlLiB3aGVuIG9wdGlvbnMuY3NzT25seSBmbGFnIGFjdGl2ZSB5b3Ugc2hvdWxkIGFsc28gc3VwcGx5IHRoZSB1bml0IG9mIG1lYXN1cmUgKHB4LyUvZW0pXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBkaW1lbnNpb25zICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMud2lkdGhdICAgICAgICAgICAgV2lkdGggb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtkaW1lbnNpb25zLmhlaWdodF0gICAgICAgICAgIEhlaWdodCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3NzVmFsdWU7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgY3NzVmFsdWUgPSBkaW1lbnNpb25zW3Byb3BdO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5jc3NPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0QmFja3N0b3JlRGltZW5zaW9uKHByb3AsIGRpbWVuc2lvbnNbcHJvcF0pO1xuICAgICAgICAgIGNzc1ZhbHVlICs9ICdweCc7XG4gICAgICAgICAgdGhpcy5oYXNMb3N0Q29udGV4dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYmFja3N0b3JlT25seSkge1xuICAgICAgICAgIHRoaXMuX3NldENzc0RpbWVuc2lvbihwcm9wLCBjc3NWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoICYmIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5fc2V0QnJ1c2hTdHlsZXModGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRCYWNrc3RvcmVEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyBjc3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRDc3NEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgICB0aGlzLndyYXBwZXJFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2aWV3cG9ydCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZwdCBhIENhbnZhcyAyRCBBUEkgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgYmFja2dyb3VuZE9iamVjdCA9IHRoaXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgIG92ZXJsYXlPYmplY3QgPSB0aGlzLm92ZXJsYXlJbWFnZSxcbiAgICAgICAgICBvYmplY3QsIGksIGxlbjtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG9iamVjdC5ncm91cCB8fCBvYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCkge1xuICAgICAgICBhY3RpdmVPYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2dyb3VuZE9iamVjdCkge1xuICAgICAgICBiYWNrZ3JvdW5kT2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5T2JqZWN0KSB7XG4gICAgICAgIG92ZXJsYXlPYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgdGhlIHpvb20gY2VudGVyZWQgYXJvdW5kIHBvaW50XG4gICAgICogbWVhbmluZyB0aGF0IGZvbGxvd2luZyB6b29tIHRvIHBvaW50IHdpdGggdGhlIHNhbWUgcG9pbnQgd2lsbCBoYXZlIHRoZSB2aXN1YWxcbiAgICAgKiBlZmZlY3Qgb2YgdGhlIHpvb20gb3JpZ2luYXRpbmcgZnJvbSB0aGF0IHBvaW50LiBUaGUgcG9pbnQgd29uJ3QgbW92ZS5cbiAgICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIGNhbnZhcyBjZW50ZXIgb3IgdmlzdWFsIGNlbnRlciBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIHpvb20gd2l0aCByZXNwZWN0IHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHpvb21Ub1BvaW50OiBmdW5jdGlvbiAocG9pbnQsIHZhbHVlKSB7XG4gICAgICAvLyBUT0RPOiBqdXN0IGNoYW5nZSB0aGUgc2NhbGUsIHByZXNlcnZlIG90aGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgdmFyIGJlZm9yZSA9IHBvaW50LCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgcG9pbnQgPSB0cmFuc2Zvcm1Qb2ludChwb2ludCwgaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pKTtcbiAgICAgIHZwdFswXSA9IHZhbHVlO1xuICAgICAgdnB0WzNdID0gdmFsdWU7XG4gICAgICB2YXIgYWZ0ZXIgPSB0cmFuc2Zvcm1Qb2ludChwb2ludCwgdnB0KTtcbiAgICAgIHZwdFs0XSArPSBiZWZvcmUueCAtIGFmdGVyLng7XG4gICAgICB2cHRbNV0gKz0gYmVmb3JlLnkgLSBhZnRlci55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB6b29tIGxldmVsIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy56b29tVG9Qb2ludChuZXcgZmFicmljLlBvaW50KDAsIDApLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIHZpZXdwb3J0IHNvIGFzIHRvIHBsYWNlIHBvaW50IGF0IHRvcCBsZWZ0IGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgYWJzb2x1dGVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICB2cHRbNF0gPSAtcG9pbnQueDtcbiAgICAgIHZwdFs1XSA9IC1wb2ludC55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFucyB2aWV3cG9pbnQgcmVsYXRpdmVseVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCAocG9zaXRpb24gdmVjdG9yKSB0byBtb3ZlIGJ5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICByZWxhdGl2ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZVBhbihuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAtcG9pbnQueCAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNF0sXG4gICAgICAgIC1wb2ludC55IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs1XVxuICAgICAgKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyBhZGRlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgb2JqLnNldHVwU3RhdGUoKTtcbiAgICAgIG9iai5fc2V0KCdjYW52YXMnLCB0aGlzKTtcbiAgICAgIG9iai5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OmFkZGVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdhZGRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDpyZW1vdmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdyZW1vdmVkJyk7XG4gICAgICBkZWxldGUgb2JqLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHNwZWNpZmllZCBjb250ZXh0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNsZWFyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3RzIGFyZSBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZW1vdmUuYXBwbHkodGhpcywgdGhpcy5nZXRPYmplY3RzKCkpO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgIHRoaXMub3ZlcmxheUNvbG9yID0gJyc7XG4gICAgICBpZiAodGhpcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICB0aGlzLm9mZignbW91c2U6dXAnLCB0aGlzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgdGhpcy5maXJlKCdjYW52YXM6Y2xlYXJlZCcpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYW52YXNUb0RyYXdPbiA9IHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc1RvRHJhd09uLCB0aGlzLl9vYmplY3RzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjcmVhdGVkIHRvIGJlIGluc3RhbmNlIGJvdW5kIGF0IGluaXRpYWxpemF0aW9uXG4gICAgICogdXNlZCBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcmVuZGVyaW5nXG4gICAgICogTGV0IHRoZSBmYWJyaWNKUyBjYWxsIGl0LiBJZiB5b3UgY2FsbCBpdCBtYW51YWxseSB5b3UgY291bGQgaGF2ZSBtb3JlXG4gICAgICogYW5pbWF0aW9uRnJhbWUgc3RhY2tpbmcgb24gdG8gb2YgZWFjaCBvdGhlclxuICAgICAqIGZvciBhbiBpbXBlcmF0aXZlIHJlbmRlcmluZywgdXNlIGNhbnZhcy5yZW5kZXJBbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFuZFJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgcmVuZGVyQWxsIHJlcXVlc3QgdG8gbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICogdW5sZXNzIG9uZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzLCBpbiB0aGF0IGNhc2Ugbm90aGluZyBpcyBkb25lXG4gICAgICogYSBib29sZWFuIGZsYWcgd2lsbCBhdm9pZCBhcHBlbmRpbmcgbW9yZS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZXF1ZXN0UmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSA0IGNvcm5lciBvZiBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtLlxuICAgICAqIGhlbHBzIHRvIGRldGVybWluYXRlIHdoZW4gYW4gb2JqZWN0IGlzIGluIHRoZSBjdXJyZW50IHJlbmRlcmluZyB2aWV3cG9ydCB1c2luZ1xuICAgICAqIG9iamVjdCBhYnNvbHV0ZSBjb29yZGluYXRlcyAoIGFDb29yZHMgKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcG9pbnRzLnRsXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IHsgfSwgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBpVnB0ID0gaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcG9pbnRzLnRsID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAwLCB5OiAwIH0sIGlWcHQpO1xuICAgICAgcG9pbnRzLmJyID0gdHJhbnNmb3JtUG9pbnQoeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0sIGlWcHQpO1xuICAgICAgcG9pbnRzLnRyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHMuYnIueCwgcG9pbnRzLnRsLnkpO1xuICAgICAgcG9pbnRzLmJsID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHMudGwueCwgcG9pbnRzLmJyLnkpO1xuICAgICAgdGhpcy52cHRDb29yZHMgPSBwb2ludHM7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH0sXG5cbiAgICBjYW5jZWxSZXF1ZXN0ZWRSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBiYWNrZ3JvdW5kLCBvYmplY3RzLCBvdmVybGF5IGFuZCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIHRoaXMuY2FuY2VsUmVxdWVzdGVkUmVuZGVyKCk7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkKTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnJlbmRlcicsIHsgY3R4OiBjdHgsIH0pO1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy9hcHBseSB2aWV3cG9ydCB0cmFuc2Zvcm0gb25jZSBmb3IgYWxsIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGhpcy5fcmVuZGVyT2JqZWN0cyhjdHgsIG9iamVjdHMpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGlmICghdGhpcy5jb250cm9sc0Fib3ZlT3ZlcmxheSAmJiB0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLmNhbnZhcyA9IHRoaXM7XG4gICAgICAgIC8vIG5lZWRlZCB0byBzZXR1cCBhIGNvdXBsZSBvZiB2YXJpYWJsZXNcbiAgICAgICAgcGF0aC5zaG91bGRDYWNoZSgpO1xuICAgICAgICBwYXRoLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgICAgcGF0aC5yZW5kZXJDYWNoZSh7IGZvckNsaXBwaW5nOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FudmFzKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJPdmVybGF5KGN0eCk7XG4gICAgICBpZiAodGhpcy5jb250cm9sc0Fib3ZlT3ZlcmxheSAmJiB0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ2FmdGVyOnJlbmRlcicsIHsgY3R4OiBjdHgsIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNsaXBQYXRoIG9uIHRoZSBsb3dlckNhbnZhc0VsXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDbGlwUGF0aE9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgcGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNDtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgcGF0aC50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gcGF0aC56b29tWCwgMSAvIHBhdGguem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZShwYXRoLl9jYWNoZUNhbnZhcywgLXBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICovXG4gICAgX3JlbmRlck9iamVjdHM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIGksIGxlbjtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqZWN0c1tpXSAmJiBvYmplY3RzW2ldLnJlbmRlcihjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgJ2JhY2tncm91bmQnIG9yICdvdmVybGF5J1xuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5OiBmdW5jdGlvbihjdHgsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbCA9IHRoaXNbcHJvcGVydHkgKyAnQ29sb3InXSwgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddLFxuICAgICAgICAgIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBuZWVkc1ZwdCA9IHRoaXNbcHJvcGVydHkgKyAnVnB0J107XG4gICAgICBpZiAoIWZpbGwgJiYgIW9iamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy53aWR0aCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmVcbiAgICAgICAgICA/IGZpbGwudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgICA6IGZpbGw7XG4gICAgICAgIGlmIChuZWVkc1ZwdCkge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCBmaWxsLm9mZnNldFggfHwgMCwgZmlsbC5vZmZzZXRZIHx8IDApO1xuICAgICAgICB2YXIgbSA9IGZpbGwuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbC5wYXR0ZXJuVHJhbnNmb3JtO1xuICAgICAgICBtICYmIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmIChuZWVkc1ZwdCkge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnJlbmRlcihjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ2JhY2tncm91bmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdvdmVybGF5Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBjZW50ZXIgb2YgY2FudmFzLlxuICAgICAqIFJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRvcCBhbmQgbGVmdCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInRvcFwiIGFuZCBcImxlZnRcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQGRlcHJlY2F0ZWQgbWlncmF0ZSB0byBgZ2V0Q2VudGVyUG9pbnRgXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGVmdDogdGhpcy53aWR0aCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBjZW50ZXIgb2YgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gXG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHRoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS54LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgY2VudGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgdnBDZW50ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIHZpZXdwb3J0LCBvYmplY3QudG9wIGlzIHVuY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdEg6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuICAgICAgdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh2cENlbnRlci54LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgVmVydGljYWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHZwQ2VudGVyLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludCBpbiBjYW52YXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjZW50ZXIgb2YgYWN0dWFsIHZpZXdwb3J0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdnBDZW50ZXIsIHZpZXdwb3J0IGNlbnRlclxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBnZXRWcENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQoY2VudGVyLCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3MgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBqc29uIHN0cmluZ1xuICAgICAqL1xuICAgIHRvRGF0YWxlc3NKU09OOiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvRGF0YWxlc3NPYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RNZXRob2Q6IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG5cbiAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsIGRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICBvYmplY3RzOiB0aGlzLl90b09iamVjdHMobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSksXG4gICAgICB9O1xuICAgICAgaWYgKGNsaXBQYXRoICYmICFjbGlwUGF0aC5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmNsaXBQYXRoID0gdGhpcy5fdG9PYmplY3QodGhpcy5jbGlwUGF0aCwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBleHRlbmQoZGF0YSwgdGhpcy5fX3NlcmlhbGl6ZUJnT3ZlcmxheShtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG5cbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgZGF0YSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdHM6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFvYmplY3QuZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0KGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0ocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3NlcmlhbGl6ZUJnT3ZlcmxheTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGRhdGEgPSB7fSwgYmdJbWFnZSA9IHRoaXMuYmFja2dyb3VuZEltYWdlLCBvdmVybGF5SW1hZ2UgPSB0aGlzLm92ZXJsYXlJbWFnZSxcbiAgICAgICAgICBiZ0NvbG9yID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvciA9IHRoaXMub3ZlcmxheUNvbG9yO1xuXG4gICAgICBpZiAoYmdDb2xvciAmJiBiZ0NvbG9yLnRvT2JqZWN0KSB7XG4gICAgICAgIGlmICghYmdDb2xvci5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGRhdGEuYmFja2dyb3VuZCA9IGJnQ29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gYmdDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJsYXlDb2xvciAmJiBvdmVybGF5Q29sb3IudG9PYmplY3QpIHtcbiAgICAgICAgaWYgKCFvdmVybGF5Q29sb3IuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBkYXRhLm92ZXJsYXkgPSBvdmVybGF5Q29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG92ZXJsYXlDb2xvcikge1xuICAgICAgICBkYXRhLm92ZXJsYXkgPSBvdmVybGF5Q29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChiZ0ltYWdlICYmICFiZ0ltYWdlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZEltYWdlID0gdGhpcy5fdG9PYmplY3QoYmdJbWFnZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheUltYWdlICYmICFvdmVybGF5SW1hZ2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5SW1hZ2UgPSB0aGlzLl90b09iamVjdChvdmVybGF5SW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGdldFN2Z1RyYW5zZm9ybSgpIHdpbGwgYXBwbHkgdGhlIFN0YXRpY0NhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSB0byB0aGUgU1ZHIHRyYW5zZm9ybWF0aW9uLiBXaGVuIHRydWUsXG4gICAgICogYSB6b29tZWQgY2FudmFzIHdpbGwgdGhlbiBwcm9kdWNlIHpvb21lZCBTVkcgb3V0cHV0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IGZvciBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlPWZhbHNlXSBJZiB0cnVlIHhtbCB0YWcgaXMgbm90IGluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZpZXdCb3hdIFNWRyB2aWV3Ym94IG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnhdIHgtY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueV0geS1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC53aWR0aF0gV2lkdGggb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LmhlaWdodF0gSGVpZ2h0IG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9VVRGLThdIEVuY29kaW5nIG9mIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIGRlc2lyZWQgd2lkdGggb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIGRlc2lyZWQgaGVpZ2h0IG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNvbnZlcnRlZCBpbnRvIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBzdHJpbmdcbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvalEzWlovfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIFNWRyBvdXRwdXQ8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRygpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aG91dCBwcmVhbWJsZSAod2l0aG91dCAmbHQ7P3htbCAuLi8+KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtzdXBwcmVzc1ByZWFtYmxlOiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIHZpZXdCb3ggYXR0cmlidXRlPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe1xuICAgICAqICAgdmlld0JveDoge1xuICAgICAqICAgICB4OiAxMDAsXG4gICAgICogICAgIHk6IDEwMCxcbiAgICAgKiAgICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDBcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggZGlmZmVyZW50IGVuY29kaW5nIChkZWZhdWx0OiBVVEYtOCk8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7ZW5jb2Rpbmc6ICdJU08tODg1OS0xJ30pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1vZGlmeSBTVkcgb3V0cHV0IHdpdGggcmV2aXZlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKG51bGwsIGZ1bmN0aW9uKHN2Zykge1xuICAgICAqICAgcmV0dXJuIHN2Zy5yZXBsYWNlKCdzdHJva2UtZGFzaGFycmF5OiA7IHN0cm9rZS1saW5lY2FwOiBidXR0OyBzdHJva2UtbGluZWpvaW46IG1pdGVyOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7ICcsICcnKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob3B0aW9ucywgcmV2aXZlcikge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLnJldml2ZXIgPSByZXZpdmVyO1xuICAgICAgdmFyIG1hcmt1cCA9IFtdO1xuXG4gICAgICB0aGlzLl9zZXRTVkdQcmVhbWJsZShtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0U1ZHSGVhZGVyKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPGcgY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiA+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdiYWNrZ3JvdW5kJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdiYWNrZ3JvdW5kSW1hZ2UnLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3NldFNWR09iamVjdHMobWFya3VwLCByZXZpdmVyKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdvdmVybGF5Jyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdvdmVybGF5SW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgbWFya3VwLnB1c2goJzwvc3ZnPicpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdQcmVhbWJsZTogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiJywgKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ1VURi04JyksICdcIiBzdGFuZGFsb25lPVwibm9cIiA/PlxcbicsXG4gICAgICAgICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJyxcbiAgICAgICAgJ1wiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHSGVhZGVyOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICB2cHQsIHZpZXdCb3ggPSAndmlld0JveD1cIjAgMCAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0ICsgJ1wiICcsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgaWYgKG9wdGlvbnMudmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnkgKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC53aWR0aCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LmhlaWdodCArICdcIiAnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzRdIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNV0gLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxzdmcgJyxcbiAgICAgICAgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLFxuICAgICAgICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyxcbiAgICAgICAgJ3ZlcnNpb249XCIxLjFcIiAnLFxuICAgICAgICAnd2lkdGg9XCInLCB3aWR0aCwgJ1wiICcsXG4gICAgICAgICdoZWlnaHQ9XCInLCBoZWlnaHQsICdcIiAnLFxuICAgICAgICB2aWV3Qm94LFxuICAgICAgICAneG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4nLFxuICAgICAgICAnPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyAnLCBmYWJyaWMudmVyc2lvbiwgJzwvZGVzYz5cXG4nLFxuICAgICAgICAnPGRlZnM+XFxuJyxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdGb250RmFjZXNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwKG9wdGlvbnMpLFxuICAgICAgICAnPC9kZWZzPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgcmV0dXJuICAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhvcHRpb25zLnJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyByZWZlcmVuY2VkIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGdyYWRpZW50cyBldGMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgbWFya3VwID0gWydiYWNrZ3JvdW5kJywgJ292ZXJsYXknXS5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBfdGhpc1twcm9wICsgJ0NvbG9yJ107XG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgICAgICB2YXIgc2hvdWxkVHJhbnNmb3JtID0gX3RoaXNbcHJvcCArICdWcHQnXSwgdnB0ID0gX3RoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICBvYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy53aWR0aCAvIChzaG91bGRUcmFuc2Zvcm0gPyB2cHRbMF0gOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5oZWlnaHQgLyAoc2hvdWxkVHJhbnNmb3JtID8gdnB0WzNdIDogMSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBmaWxsLnRvU1ZHKFxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICB7IGFkZGl0aW9uYWxUcmFuc2Zvcm06IHNob3VsZFRyYW5zZm9ybSA/IGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHZwdCkgOiAnJyB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyBmb250IGZhY2VzLFxuICAgICAqIGZvbnQgVVJMcyBmb3IgZm9udCBmYWNlcyBtdXN0IGJlIGNvbGxlY3RlZCBieSBkZXZlbG9wZXJzXG4gICAgICogYW5kIGFyZSBub3QgZXh0cmFjdGVkIGZyb20gdGhlIERPTSBieSBmYWJyaWNqc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgQXJyYXkgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrdXAgPSAnJywgZm9udExpc3QgPSB7IH0sIG9iaiwgZm9udEZhbWlseSxcbiAgICAgICAgICBzdHlsZSwgcm93LCByb3dJbmRleCwgX2NoYXIsIGNoYXJJbmRleCwgaSwgbGVuLFxuICAgICAgICAgIGZvbnRQYXRocyA9IGZhYnJpYy5mb250UGF0aHMsIG9iamVjdHMgPSBbXTtcblxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuX29iamVjdHMpIHtcbiAgICAgICAgICBvYmplY3QuX29iamVjdHMuZm9yRWFjaChhZGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmogPSBvYmplY3RzW2ldO1xuICAgICAgICBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmIChvYmoudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xIHx8IGZvbnRMaXN0W2ZvbnRGYW1pbHldIHx8ICFmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgIGlmICghb2JqLnN0eWxlcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb2JqLnN0eWxlcztcbiAgICAgICAgZm9yIChyb3dJbmRleCBpbiBzdHlsZSkge1xuICAgICAgICAgIHJvdyA9IHN0eWxlW3Jvd0luZGV4XTtcbiAgICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiByb3cpIHtcbiAgICAgICAgICAgIF9jaGFyID0gcm93W2NoYXJJbmRleF07XG4gICAgICAgICAgICBmb250RmFtaWx5ID0gX2NoYXIuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGlmICghZm9udExpc3RbZm9udEZhbWlseV0gJiYgZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiBpbiBmb250TGlzdCkge1xuICAgICAgICBtYXJrdXAgKz0gW1xuICAgICAgICAgICdcXHRcXHRAZm9udC1mYWNlIHtcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRmb250LWZhbWlseTogXFwnJywgaiwgJ1xcJztcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRzcmM6IHVybChcXCcnLCBmb250UGF0aHNbal0sICdcXCcpO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdH1cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICdcXHQ8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAnPCFbQ0RBVEFbXFxuJyxcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgJ11dPicsXG4gICAgICAgICAgJzwvc3R5bGU+XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZSwgaSwgbGVuLCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmICF0aGlzW3Byb3BlcnR5XS5leGNsdWRlRnJvbUV4cG9ydCAmJiB0aGlzW3Byb3BlcnR5XS50b1NWRykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzW3Byb3BlcnR5XS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbGVyID0gdGhpc1twcm9wZXJ0eSArICdDb2xvciddLCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBmaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBmaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgaWYgKCFmaWxsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGZpbGxlci5yZXBlYXQsIGlWcHQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odnB0KSwgc2hvdWxkSW52ZXJ0ID0gdGhpc1twcm9wZXJ0eSArICdWcHQnXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBzaG91bGRJbnZlcnQgPyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyhpVnB0KSA6ICcnO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwiJyArIGFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnIHRyYW5zbGF0ZSgnLCBmaW5hbFdpZHRoIC8gMiwgJywnLCBmaW5hbEhlaWdodCAvIDIsICcpXCInLFxuICAgICAgICAgICcgeD1cIicsIGZpbGxlci5vZmZzZXRYIC0gZmluYWxXaWR0aCAvIDIsXG4gICAgICAgICAgJ1wiIHk9XCInLCBmaWxsZXIub2Zmc2V0WSAtIGZpbmFsSGVpZ2h0IC8gMiwgJ1wiICcsXG4gICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgOiBmaW5hbFdpZHRoICksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2UuaGVpZ2h0XG4gICAgICAgICAgICA6IGZpbmFsSGVpZ2h0KSxcbiAgICAgICAgICAnXCIgZmlsbD1cInVybCgjU1ZHSURfJyArIGZpbGxlci5pZCArICcpXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiAnLFxuICAgICAgICAgICdmaWxsPVwiJywgZmlsbGVyLCAnXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kIHRvIGJhY2tcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtZXRlciwgaW50ZXJzZWN0aW5nIGFsbG93cyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gYmVoaW5kXG4gICAgICogdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPiAwICsgb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRoZSBib3R0b20gb2Ygc3RhY2tcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3TG93ZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld0xvd2VySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIGRvd24gdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW1ldGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBmcm9udFxuICAgICAqIG9mIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nRm9yd2FyZDogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA8IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSAtIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRvcCBvZiBzdGFjayAobGFzdCBpdGVtIGluIGFuIGFycmF5KVxuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdVcHBlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3VXBwZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaSwgbGVuO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSB1cCB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggKyAxLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBQb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4KSB7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCBkaXNwb3NlIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbmNlbCBldmVudHVhbGx5IG9uZ29pbmcgcmVuZGVyc1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlICYmIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlICYmIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIC8vIHJlc3RvcmUgY2FudmFzIHN0eWxlXG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuY2xhc3NMaXN0LnJlbW92ZSgnbG93ZXItY2FudmFzJyk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGUpO1xuICAgICAgZGVsZXRlIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGU7XG4gICAgICAvLyByZXN0b3JlIGNhbnZhcyBzaXplIHRvIG9yaWdpbmFsIHNpemUgaW4gY2FzZSByZXRpbmEgc2NhbGluZyB3YXMgYXBwbGllZFxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLl9vYmplY3RzLmxlbmd0aCArICcgfT4nO1xuICAgIH1cbiAgfSk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkNvbGxlY3Rpb24pO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5EYXRhVVJMRXhwb3J0ZXIpO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgRU1QVFlfSlNPTjogJ3tcIm9iamVjdHNcIjogW10sIFwiYmFja2dyb3VuZFwiOiBcIndoaXRlXCJ9JyxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGNoZWNrIHN1cHBvcnQgb2Ygc29tZSBvZiB0aGUgY2FudmFzIG1ldGhvZHNcbiAgICAgKiAoZWl0aGVyIHRob3NlIG9mIEhUTUxDYW52YXNFbGVtZW50IGl0c2VsZiwgb3IgcmVuZGVyaW5nIGNvbnRleHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgdG8gY2hlY2sgc3VwcG9ydCBmb3I7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ291bGQgYmUgb25lIG9mIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqIHRoaXMgYWxpYXMgaXMgcHJvdmlkZWQgYmVjYXVzZSBpZiB5b3UgY2FsbCBKU09OLnN0cmluZ2lmeSBvbiBhbiBpbnN0YW5jZSxcbiAgICogdGhlIHRvSlNPTiBvYmplY3Qgd2lsbCBiZSBpbnZva2VkIGlmIGl0IGV4aXN0cy5cbiAgICogSGF2aW5nIGEgdG9KU09OIG1ldGhvZCBtZWFucyB5b3UgY2FuIGRvIEpTT04uc3RyaW5naWZ5KG15Q2FudmFzKVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gY29tcGF0aWJsZSBvYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wZWM4Ni98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkZWQ8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTihbJ2xvY2tNb3ZlbWVudFgnLCAnbG9ja01vdmVtZW50WScsICdsb2NrUm90YXRpb24nLCAnbG9ja1NjYWxpbmdYJywgJ2xvY2tTY2FsaW5nWSddKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGRlZmF1bHQgdmFsdWVzPC9jYXB0aW9uPlxuICAgKiBjYW52YXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b0pTT04gPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b09iamVjdDtcblxuICBpZiAoZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZVBOR1N0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltcGwgPSBnZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICAgIH07XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlSlBFR1N0cmVhbSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVKUEVHU3RyZWFtKG9wdHMpO1xuICAgIH07XG4gIH1cbn0pKCk7XG5cblxuLyoqXG4gKiBCYXNlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQmFzZUJydXNoXG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZyZWVkcmF3aW5nfEZyZWVkcmF3aW5nIGRlbW99XG4gKi9cbmZhYnJpYy5CYXNlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5CYXNlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQ29sb3Igb2YgYSBicnVzaFxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGNvbG9yOiAncmdiKDAsIDAsIDApJyxcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaCwgaGFzIHRvIGJlIGEgTnVtYmVyLCBubyBzdHJpbmcgbGl0ZXJhbHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMSxcblxuICAvKipcbiAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJzaGFkb3dDb2xvclwiIChTdHJpbmcpLCBcInNoYWRvd09mZnNldFhcIiAoTnVtYmVyKSxcbiAgICogXCJzaGFkb3dPZmZzZXRZXCIgKE51bWJlcikgYW5kIFwic2hhZG93Qmx1clwiIChOdW1iZXIpIHNpbmNlIHYxLjIuMTJcbiAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc2hhZG93OiBudWxsLFxuXG4gIC8qKlxuICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUNhcDogJ3JvdW5kJyxcblxuICAvKipcbiAgICogQ29ybmVyIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJldmVsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVKb2luOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGEgYnJ1c2gnc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIFN0cm9rZSBEYXNoIEFycmF5LlxuICAgKiBAdHlwZSBBcnJheVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlRGFzaEFycmF5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBXaGVuIGB0cnVlYCwgdGhlIGZyZWUgZHJhd2luZyBpcyBsaW1pdGVkIHRvIHRoZSB3aGl0ZWJvYXJkIHNpemUuIERlZmF1bHQgdG8gZmFsc2UuXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgKi9cblxuICBsaW1pdGVkVG9DYW52YXNTaXplOiBmYWxzZSxcblxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgY3R4LnNldExpbmVEYXNoKHRoaXMuc3Ryb2tlRGFzaEFycmF5IHx8IFtdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gb24gZ2l2ZW4gY29udGV4dFxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUFuZFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgIGN0eCA9IGNhbnZhcy5jb250ZXh0VG9wLFxuICAgICAgICB6b29tID0gY2FudmFzLmdldFpvb20oKTtcbiAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgIHpvb20gKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFggKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiB6b29tO1xuICB9LFxuXG4gIG5lZWRzRnVsbFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKTtcbiAgICByZXR1cm4gY29sb3IuZ2V0QWxwaGEoKSA8IDEgfHwgISF0aGlzLnNoYWRvdztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaXMgcG9pbnRlciBpcyBvdXRzaWRlIGNhbnZhcyBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqIEBwcml2YXRlXG4gICovXG4gIF9pc091dFNpZGVDYW52YXM6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICByZXR1cm4gcG9pbnRlci54IDwgMCB8fCBwb2ludGVyLnggPiB0aGlzLmNhbnZhcy5nZXRXaWR0aCgpIHx8IHBvaW50ZXIueSA8IDAgfHwgcG9pbnRlci55ID4gdGhpcy5jYW52YXMuZ2V0SGVpZ2h0KCk7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFBlbmNpbEJydXNoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGVuY2lsQnJ1c2hcbiAgICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICAgKi9cbiAgZmFicmljLlBlbmNpbEJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGVuY2lsQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIERpc2NhcmQgcG9pbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBgZGVjaW1hdGVgIHBpeGVsIGRpc3RhbnQgZnJvbSBlYWNoIG90aGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC40XG4gICAgICovXG4gICAgZGVjaW1hdGU6IDAuNCxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIGxhc3QgcmVjb3JkZWQgcG9pbnQgdG8gY3VycmVudCBwb2ludGVyXG4gICAgICogVXNlZCBmb3IgYHNoaWZ0YCBmdW5jdGlvbmFsaXR5XG4gICAgICpcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkcmF3U3RyYWlnaHRMaW5lOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBtb2RpZmllciBrZXkgdGhhdCBtYWtlcyB0aGUgYnJ1c2ggZHJhdyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5IHRoZSBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEB0eXBlIHsnYWx0S2V5JyB8ICdzaGlmdEtleScgfCAnY3RybEtleScgfCAnbm9uZScgfCB1bmRlZmluZWQgfCBudWxsfVxuICAgICAqL1xuICAgIHN0cmFpZ2h0TGluZUtleTogJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGVuY2lsQnJ1c2h9IEluc3RhbmNlIG9mIGEgcGVuY2lsIGJydXNoXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgIH0sXG5cbiAgICBuZWVkc0Z1bGxSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignbmVlZHNGdWxsUmVuZGVyJykgfHwgdGhpcy5faGFzU3RyYWlnaHRMaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfZHJhd1NlZ21lbnQ6IGZ1bmN0aW9uIChjdHgsIHAxLCBwMikge1xuICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAxLngsIHAxLnksIG1pZFBvaW50LngsIG1pZFBvaW50LnkpO1xuICAgICAgcmV0dXJuIG1pZFBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzLl9pc01haW5FdmVudChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IG9wdGlvbnMuZVt0aGlzLnN0cmFpZ2h0TGluZUtleV07XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yRHJhd2luZyhwb2ludGVyKTtcbiAgICAgIC8vIGNhcHR1cmUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHRvIGRyYXcgZG90cyAod2hlbiBtb3ZlbWVudCBuZXZlciBvY2N1cnMpXG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdTdHJhaWdodExpbmUgPSBvcHRpb25zLmVbdGhpcy5zdHJhaWdodExpbmVLZXldO1xuICAgICAgaWYgKHRoaXMubGltaXRlZFRvQ2FudmFzU2l6ZSA9PT0gdHJ1ZSAmJiB0aGlzLl9pc091dFNpZGVDYW52YXMocG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgICAgIC8vIHJlZHJhdyBjdXJ2ZVxuICAgICAgICAgIC8vIGNsZWFyIHRvcCBjYW52YXNcbiAgICAgICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cywgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCwgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgICAgICAvLyBkcmF3IHRoZSBjdXJ2ZSB1cGRhdGVcbiAgICAgICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgaWYgKHRoaXMub2xkRW5kKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMub2xkRW5kLngsIHRoaXMub2xkRW5kLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9sZEVuZCA9IHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcG9pbnRzW2xlbmd0aCAtIDJdLCBwb2ludHNbbGVuZ3RoIC0gMV0sIHRydWUpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICAgKi9cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdTdHJhaWdodExpbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMub2xkRW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZmluYWxpemVBbmRBZGRQYXRoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfcHJlcGFyZUZvckRyYXdpbmc6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcblxuICAgICAgdmFyIHAgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcblxuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuX2FkZFBvaW50KHApO1xuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEgJiYgcG9pbnQuZXEodGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZHJhd1N0cmFpZ2h0TGluZSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLl9oYXNTdHJhaWdodExpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wb2ludHMucG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wb2ludHMucHVzaChwb2ludCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcG9pbnRzIGFycmF5IGFuZCBzZXQgY29udGV4dFRvcCBjYW52YXMgc3R5bGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgICB0aGlzLl9zZXRCcnVzaFN0eWxlcyh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgICAgdGhpcy5faGFzU3RyYWlnaHRMaW5lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkUG9pbnQocG9pbnRlclBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNtb290aCBwYXRoIG9uIHRoZSB0b3BDYW52YXMgdXNpbmcgcXVhZHJhdGljQ3VydmVUb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgaSwgbGVuLFxuICAgICAgICAgIHAxID0gdGhpcy5fcG9pbnRzWzBdLFxuICAgICAgICAgIHAyID0gdGhpcy5fcG9pbnRzWzFdO1xuICAgICAgY3R4ID0gY3R4IHx8IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHAxLngsIHAxLnkpO1xuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocDIueCwgcDIueSk7XG4gICAgICAgIHAxLnggLT0gd2lkdGg7XG4gICAgICAgIHAyLnggKz0gd2lkdGg7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKGkgPSAxLCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgcG9pbnQgYmV0d2VlbiBwaSArIDEgJiBwaSArIDIgYXMgdGhlXG4gICAgICAgIC8vIGVuZCBwb2ludCBhbmQgcDEgYXMgb3VyIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgIHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcDEsIHAyKTtcbiAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIERyYXcgbGFzdCBsaW5lIGFzIGEgc3RyYWlnaHQgbGluZSB3aGlsZVxuICAgICAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgcG9pbnQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAgIC8vIHRoZSBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHBvaW50cyB0byBTVkcgcGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBTVkcgcGF0aCBjb21tYW5kc1xuICAgICAqL1xuICAgIGNvbnZlcnRQb2ludHNUb1NWR1BhdGg6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHZhciBjb3JyZWN0aW9uID0gdGhpcy53aWR0aCAvIDEwMDA7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMocG9pbnRzLCBjb3JyZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdW119IHBhdGhEYXRhIFNWRyBwYXRoIGNvbW1hbmRzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2lzRW1wdHlTVkdQYXRoOiBmdW5jdGlvbiAocGF0aERhdGEpIHtcbiAgICAgIHZhciBwYXRoU3RyaW5nID0gZmFicmljLnV0aWwuam9pblBhdGgocGF0aERhdGEpO1xuICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgPT09ICdNIDAgMCBRIDAgMCAwIDAgTCAwIDAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXVtdfSBwYXRoRGF0YSBQYXRoIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gUGF0aCB0byBhZGQgb24gY2FudmFzXG4gICAgICovXG4gICAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IGZhYnJpYy5QYXRoKHBhdGhEYXRhLCB7XG4gICAgICAgIGZpbGw6IG51bGwsXG4gICAgICAgIHN0cm9rZTogdGhpcy5jb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogdGhpcy5zdHJva2VNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaW1hdGUgcG9pbnRzIGFycmF5IHdpdGggdGhlIGRlY2ltYXRlIHZhbHVlXG4gICAgICovXG4gICAgZGVjaW1hdGVQb2ludHM6IGZ1bmN0aW9uKHBvaW50cywgZGlzdGFuY2UpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgIH1cbiAgICAgIHZhciB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLCBhZGp1c3RlZERpc3RhbmNlID0gTWF0aC5wb3coZGlzdGFuY2UgLyB6b29tLCAyKSxcbiAgICAgICAgICBpLCBsID0gcG9pbnRzLmxlbmd0aCAtIDEsIGxhc3RQb2ludCA9IHBvaW50c1swXSwgbmV3UG9pbnRzID0gW2xhc3RQb2ludF0sXG4gICAgICAgICAgY0Rpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGwgLSAxOyBpKyspIHtcbiAgICAgICAgY0Rpc3RhbmNlID0gTWF0aC5wb3cobGFzdFBvaW50LnggLSBwb2ludHNbaV0ueCwgMikgKyBNYXRoLnBvdyhsYXN0UG9pbnQueSAtIHBvaW50c1tpXS55LCAyKTtcbiAgICAgICAgaWYgKGNEaXN0YW5jZSA+PSBhZGp1c3RlZERpc3RhbmNlKSB7XG4gICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIG5ld1BvaW50cy5wdXNoKGxhc3RQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQWRkIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIG9yaWdpbmFsIGxpbmUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgKiBUaGlzIGVuc3VyZXMgZGVjaW1hdGUgZG9lc24ndCBkZWxldGUgdGhlIGxhc3QgcG9pbnQgb24gdGhlIGxpbmUsIGFuZCBlbnN1cmVzIHRoZSBsaW5lIGlzID4gMSBwb2ludC5cbiAgICAgICAqL1xuICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnRzW2xdKTtcbiAgICAgIHJldHVybiBuZXdQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgaWYgKHRoaXMuZGVjaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gdGhpcy5kZWNpbWF0ZVBvaW50cyh0aGlzLl9wb2ludHMsIHRoaXMuZGVjaW1hdGUpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5jb252ZXJ0UG9pbnRzVG9TVkdQYXRoKHRoaXMuX3BvaW50cyk7XG4gICAgICBpZiAodGhpcy5faXNFbXB0eVNWR1BhdGgocGF0aERhdGEpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgMCB3aWR0aC9oZWlnaHQgcGF0aHMsIGFzIHRoZXkgYXJlXG4gICAgICAgIC8vIHJlbmRlcmVkIGluY29uc2lzdGVudGx5IGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAvLyBGaXJlZm94IDQsIGZvciBleGFtcGxlLCByZW5kZXJzIGEgZG90LFxuICAgICAgICAvLyB3aGVyZWFzIENocm9tZSAxMCByZW5kZXJzIG5vdGhpbmdcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGVQYXRoKHBhdGhEYXRhKTtcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgICB0aGlzLmNhbnZhcy5hZGQocGF0aCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICBwYXRoLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcblxuXG4gICAgICAvLyBmaXJlIGV2ZW50ICdwYXRoJyBjcmVhdGVkXG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuLyoqXG4gKiBDaXJjbGVCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5DaXJjbGVCcnVzaFxuICovXG5mYWJyaWMuQ2lyY2xlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGVCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlQnJ1c2h9IEluc3RhbmNlIG9mIGEgY2lyY2xlIGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBkcmF3RG90OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5hZGRQb2ludChwb2ludGVyKSxcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgdGhpcy5kb3QoY3R4LCBwb2ludCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uKGN0eCwgcG9pbnQpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZnVsbCBzdGF0ZSBvZiB0aGUgYnJ1c2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuLFxuICAgICAgICBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRvdChjdHgsIHBvaW50c1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5saW1pdGVkVG9DYW52YXNTaXplID09PSB0cnVlICYmIHRoaXMuX2lzT3V0U2lkZUNhbnZhcyhwb2ludGVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5hZGRQb2ludChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSwgaSwgbGVuO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgY2lyY2xlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIChjaXJjbGUuc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcblxuICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgfVxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoY2lyY2xlcyk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IEp1c3QgYWRkZWQgcG9pbnRlciBwb2ludFxuICAgKi9cbiAgYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG5cbiAgICAgICAgY2lyY2xlUmFkaXVzID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgIC5zZXRBbHBoYShmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMClcbiAgICAgICAgICAudG9SZ2JhKCk7XG5cbiAgICBwb2ludGVyUG9pbnQucmFkaXVzID0gY2lyY2xlUmFkaXVzO1xuICAgIHBvaW50ZXJQb2ludC5maWxsID0gY2lyY2xlQ29sb3I7XG5cbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50ZXJQb2ludCk7XG5cbiAgICByZXR1cm4gcG9pbnRlclBvaW50O1xuICB9XG59KTtcblxuXG4vKipcbiAqIFNwcmF5QnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuU3ByYXlCcnVzaFxuICovXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKCBmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5TcHJheUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgc3ByYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogICAgICAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBEZW5zaXR5IG9mIGEgc3ByYXkgKG51bWJlciBvZiBkb3RzIHBlciBjaHVuaylcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkZW5zaXR5OiAgICAgICAgICAgIDIwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGg6ICAgICAgICAgICAxLFxuXG4gIC8qKlxuICAgKiBXaWR0aCB2YXJpYW5jZSBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGhWYXJpYW5jZTogICAxLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9wYWNpdHkgb2YgYSBkb3Qgc2hvdWxkIGJlIHJhbmRvbVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByYW5kb21PcGFjaXR5OiAgICAgICAgZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3ZlcmxhcHBpbmcgZG90cyAocmVjdGFuZ2xlcykgc2hvdWxkIGJlIHJlbW92ZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvcHRpbWl6ZU92ZXJsYXBwaW5nOiAgdHJ1ZSxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLlNwcmF5QnJ1c2h9IEluc3RhbmNlIG9mIGEgc3ByYXkgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc3ByYXlDaHVua3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG5cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmxpbWl0ZWRUb0NhbnZhc1NpemUgPT09IHRydWUgJiYgdGhpcy5faXNPdXRTaWRlQ2FudmFzKHBvaW50ZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFyIHNwcmF5Q2h1bmsgPSB0aGlzLnNwcmF5Q2h1bmtzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICAgIHdpZHRoOiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBsZWZ0OiBzcHJheUNodW5rW2pdLnggKyAxLFxuICAgICAgICAgIHRvcDogc3ByYXlDaHVua1tqXS55ICsgMSxcbiAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGltaXplT3ZlcmxhcHBpbmcpIHtcbiAgICAgIHJlY3RzID0gdGhpcy5fZ2V0T3B0aW1pemVkUmVjdHMocmVjdHMpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAocmVjdHMpO1xuICAgIHRoaXMuc2hhZG93ICYmIGdyb3VwLnNldCgnc2hhZG93JywgbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZWN0c1xuICAgKi9cbiAgX2dldE9wdGltaXplZFJlY3RzOiBmdW5jdGlvbihyZWN0cykge1xuXG4gICAgLy8gYXZvaWQgY3JlYXRpbmcgZHVwbGljYXRlIHJlY3RzIGF0IHRoZSBzYW1lIGNvb3JkaW5hdGVzXG4gICAgdmFyIHVuaXF1ZVJlY3RzID0geyB9LCBrZXksIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSByZWN0c1tpXS5sZWZ0ICsgJycgKyByZWN0c1tpXS50b3A7XG4gICAgICBpZiAoIXVuaXF1ZVJlY3RzW2tleV0pIHtcbiAgICAgICAgdW5pcXVlUmVjdHNba2V5XSA9IHJlY3RzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5pcXVlUmVjdHNBcnJheSA9IFtdO1xuICAgIGZvciAoa2V5IGluIHVuaXF1ZVJlY3RzKSB7XG4gICAgICB1bmlxdWVSZWN0c0FycmF5LnB1c2godW5pcXVlUmVjdHNba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXF1ZVJlY3RzQXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBuZXcgY2h1bmsgb2Ygc3ByYXkgYnJ1c2hcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24oc3ByYXlDaHVuaykge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBzcHJheUNodW5rW2ldO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwb2ludC5vcGFjaXR5O1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxSZWN0KHBvaW50LngsIHBvaW50LnksIHBvaW50LndpZHRoLCBwb2ludC53aWR0aCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgc3ByYXkgY2h1bmtzXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgaWxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rc1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBhZGRTcHJheUNodW5rOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rUG9pbnRzID0gW107XG5cbiAgICB2YXIgeCwgeSwgd2lkdGgsIHJhZGl1cyA9IHRoaXMud2lkdGggLyAyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIGdldFBhdHRlcm46IGZ1bmN0aW9uKGN0eCkge1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmMoKSwgJ3JlcGVhdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnLCBjdHgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0UGF0dGVybihjdHgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHBhdGhcbiAgICovXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLmNhbGxTdXBlcignY3JlYXRlUGF0aCcsIHBhdGhEYXRhKSxcbiAgICAgICAgdG9wTGVmdCA9IHBhdGguX2dldExlZnRUb3BDb29yZHMoKS5zY2FsYXJBZGQocGF0aC5zdHJva2VXaWR0aCAvIDIpO1xuXG4gICAgcGF0aC5zdHJva2UgPSBuZXcgZmFicmljLlBhdHRlcm4oe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmNGdW5jdGlvbigpLFxuICAgICAgb2Zmc2V0WDogLXRvcExlZnQueCxcbiAgICAgIG9mZnNldFk6IC10b3BMZWZ0LnlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZXRQb2ludGVyID0gZmFicmljLnV0aWwuZ2V0UG9pbnRlcixcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgaXNUb3VjaEV2ZW50ID0gZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50O1xuXG4gIC8qKlxuICAgKiBDYW52YXMgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DYW52YXNcbiAgICogQGV4dGVuZHMgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNjYW52YXN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DYW52YXMjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogQGZpcmVzIG9iamVjdDptb2RpZmllZCBhdCB0aGUgZW5kIG9mIGEgdHJhbnNmb3JtIG9yIGFueSBjaGFuZ2Ugd2hlbiBzdGF0ZWZ1bGwgaXMgdHJ1ZVxuICAgKiBAZmlyZXMgb2JqZWN0OnJvdGF0aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyByb3RhdGVkIGZyb20gdGhlIGNvbnRyb2xcbiAgICogQGZpcmVzIG9iamVjdDpzY2FsaW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBzY2FsZWQgYnkgY29udHJvbHNcbiAgICogQGZpcmVzIG9iamVjdDptb3Zpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGRyYWdnZWRcbiAgICogQGZpcmVzIG9iamVjdDpza2V3aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBza2V3ZWQgZnJvbSB0aGUgY29udHJvbHNcbiAgICpcbiAgICogQGZpcmVzIGJlZm9yZTp0cmFuc2Zvcm0gYmVmb3JlIGEgdHJhbnNmb3JtIGlzIGlzIHN0YXJ0ZWRcbiAgICogQGZpcmVzIGJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjp1cGRhdGVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkIGFmdGVyIGEgZHJhd2luZyBvcGVyYXRpb24gZW5kcyBhbmQgdGhlIHBhdGggaXMgYWRkZWRcbiAgICogQGZpcmVzIG1vdXNlOmRvd25cbiAgICogQGZpcmVzIG1vdXNlOm1vdmVcbiAgICogQGZpcmVzIG1vdXNlOnVwXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duOmJlZm9yZSAgb24gbW91c2UgZG93biwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6bW92ZTpiZWZvcmUgb24gbW91c2UgbW92ZSwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6dXA6YmVmb3JlIG9uIG1vdXNlIHVwLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTpvdmVyXG4gICAqIEBmaXJlcyBtb3VzZTpvdXRcbiAgICogQGZpcmVzIG1vdXNlOmRibGNsaWNrIHdoZW5ldmVyIGEgbmF0aXZlIGRibCBjbGljayBldmVudCBmaXJlcyBvbiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAZmlyZXMgZHJhZ292ZXJcbiAgICogQGZpcmVzIGRyYWdlbnRlclxuICAgKiBAZmlyZXMgZHJhZ2xlYXZlXG4gICAqIEBmaXJlcyBkcm9wOmJlZm9yZSBiZWZvcmUgZHJvcCBldmVudC4gc2FtZSBuYXRpdmUgZXZlbnQuIFRoaXMgaXMgYWRkZWQgdG8gaGFuZGxlIGVkZ2UgY2FzZXNcbiAgICogQGZpcmVzIGRyb3BcbiAgICogQGZpcmVzIGFmdGVyOnJlbmRlciBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXIgcHJvY2VzcywgcmVjZWl2ZXMgdGhlIGNvbnRleHQgaW4gdGhlIGNhbGxiYWNrXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyIGF0IHN0YXJ0IHRoZSByZW5kZXIgcHJvY2VzcywgcmVjZWl2ZXMgdGhlIGNvbnRleHQgaW4gdGhlIGNhbGxiYWNrXG4gICAqXG4gICAqL1xuICBmYWJyaWMuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQgPSB0aGlzLnJlbmRlckFuZFJlc2V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZCA9IHRoaXMucmVxdWVzdFJlbmRlckFsbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5faW5pdFN0YXRpYyhlbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0SW50ZXJhY3RpdmUoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyBjYW4gYmUgdHJhbnNmb3JtZWQgYnkgb25lIHNpZGUgKHVucHJvcG9ydGlvbmFsbHkpXG4gICAgICogd2hlbiBkcmFnZ2VkIG9uIHRoZSBjb3JuZXJzIHRoYXQgbm9ybWFsbHkgd291bGQgbm90IGRvIHRoYXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHNpbmNlIGZhYnJpYyA0LjAgLy8gY2hhbmdlZCBuYW1lIGFuZCBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgdW5pZm9ybVNjYWxpbmc6ICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgc3dpdGNoZXMgdW5pZm9ybSBzY2FsaW5nLlxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIHRvdGFsbHkgd3JvbmcgbmFtZWQuIHRoaXMgc291bmRzIGxpa2UgYHVuaWZvcm0gc2NhbGluZ2BcbiAgICAgKiBpZiBDYW52YXMudW5pZm9ybVNjYWxpbmcgaXMgdHJ1ZSwgcHJlc3NpbmcgdGhpcyB3aWxsIHNldCBpdCB0byBmYWxzZVxuICAgICAqIGFuZCB2aWNldmVyc2EuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmb3JtXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgb3Iga2V5cyBlbmFibGUgbXVsdGlwbGUgY2xpY2sgc2VsZWN0aW9uXG4gICAgICogUGFzcyB2YWx1ZSBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciBlbXB0eSBvciBjb250YWluaW5nIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ3xBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0aXZlIHNlbGVjdGlvblxuICAgICAqIGluIGNhc2Ugb2YgdGFyZ2V0IG92ZXJsYXBwaW5nIHdpdGggYWN0aXZlIG9iamVjdFxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBGb3IgYSBzZXJpZXMgb2YgcmVhc29uIHRoYXQgY29tZSBmcm9tIHRoZSBnZW5lcmFsIGV4cGVjdGF0aW9ucyBvbiBob3dcbiAgICAgKiB0aGluZ3Mgc2hvdWxkIHdvcmssIHRoaXMgZmVhdHVyZSB3b3JrcyBvbmx5IGZvciBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIHRydWUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgc2hhcGVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgZHJhZ2dlZCBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCBmb3IgdGhlIGVudGlyZSBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICAgICAgICAgICdkZWZhdWx0JyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGR1cmluZyBmcmVlIGRyYXdpbmdcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZyZWVEcmF3aW5nQ3Vyc29yOiAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIGRpc2FibGVkIGVsZW1lbnRzICggY29ybmVycyB3aXRoIGRpc2FibGVkIGFjdGlvbiApXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub3RBbGxvd2VkQ3Vyc29yOiAgICAgICAgICdub3QtYWxsb3dlZCcsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGVsZW1lbnQgY2xhc3MgdGhhdCdzIGdpdmVuIHRvIHdyYXBwZXIgKGRpdikgZWxlbWVudCBvZiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbnRhaW5lckNsYXNzOiAgICAgICAgICdjYW52YXMtY29udGFpbmVyJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0IGRldGVjdGlvbiBoYXBwZW5zIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBvbiBwZXItYm91bmRpbmctYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGFyb3VuZCB0YXJnZXQgcGl4ZWwgdG8gdG9sZXJhdGUgKGNvbnNpZGVyIGFjdGl2ZSkgZHVyaW5nIG9iamVjdCBkZXRlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRhcmdldEZpbmRUb2xlcmFuY2U6ICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRhcmdldCBkZXRlY3Rpb24gaXMgc2tpcHBlZC4gVGFyZ2V0IGRldGVjdGlvbiB3aWxsIHJldHVybiBhbHdheXMgdW5kZWZpbmVkLlxuICAgICAqIGNsaWNrIHNlbGVjdGlvbiB3b24ndCB3b3JrIGFueW1vcmUsIGV2ZW50cyB3aWxsIGZpcmUgd2l0aCBubyB0YXJnZXRzLlxuICAgICAqIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCBiZWZvcmUgc2V0dGluZyBpdCB0byB0cnVlLCBpdCB3aWxsIGJlIGRlc2VsZWN0ZWQgYXQgdGhlIGZpcnN0IGNsaWNrLlxuICAgICAqIGFyZWEgc2VsZWN0aW9uIHdpbGwgc3RpbGwgd29yay4gY2hlY2sgdGhlIGBzZWxlY3Rpb25gIHByb3BlcnR5IHRvby5cbiAgICAgKiBpZiB5b3UgZGVhY3RpdmF0ZSBib3RoLCB5b3Ugc2hvdWxkIGxvb2sgaW50byBzdGF0aWNDYW52YXMuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcFRhcmdldEZpbmQ6ICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG1vdXNlIGV2ZW50cyBvbiBjYW52YXMgKG1vdXNlZG93bi9tb3VzZW1vdmUvbW91c2V1cCkgcmVzdWx0IGluIGZyZWUgZHJhd2luZy5cbiAgICAgKiBBZnRlciBtb3VzZWRvd24sIG1vdXNlbW92ZSBjcmVhdGVzIGEgc2hhcGUsXG4gICAgICogYW5kIHRoZW4gbW91c2V1cCBmaW5hbGl6ZXMgaXQgYW5kIGFkZHMgYW4gaW5zdGFuY2Ugb2YgYGZhYnJpYy5QYXRoYCBvbnRvIGNhbnZhcy5cbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtNCNmcmVlX2RyYXdpbmd9XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNEcmF3aW5nTW9kZTogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzIHNob3VsZCByZW1haW4gaW4gY3VycmVudCBzdGFjayBwb3NpdGlvbiB3aGVuIHNlbGVjdGVkLlxuICAgICAqIFdoZW4gZmFsc2Ugb2JqZWN0cyBhcmUgYnJvdWdodCB0byB0b3AgYW5kIHJlbmRlcmVkIGFzIHBhcnQgb2YgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHByZXNlcnZlT2JqZWN0U3RhY2tpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBhbmdsZSB0aGF0IGFuIG9iamVjdCB3aWxsIGxvY2sgdG8gd2hpbGUgcm90YXRpbmcuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwQW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHNuYXBBbmdsZSB0aGUgcm90YXRpb24gd2lsbCBsb2NrIHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogV2hlbiBgbnVsbGAsIHRoZSBzbmFwVGhyZXNob2xkIHdpbGwgZGVmYXVsdCB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIEB0eXBlIG51bGx8TnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwVGhyZXNob2xkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSByaWdodCBjbGljayBvbiBjYW52YXMgY2FuIG91dHB1dCB0aGUgY29udGV4dCBtZW51IG9yIG5vdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0b3BDb250ZXh0TWVudTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSByaWdodCBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlUmlnaHRDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSBtaWRkbGUgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjcuOFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZU1pZGRsZUNsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIHN1YlRhcmdldHMgZm9yIE1vdXNlIEV2ZW50c1xuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqL1xuICAgIHRhcmdldHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQsIFBvaW50ZXJFdmVudCBpcyB1c2VkIGluc3RlYWQgb2YgTW91c2VFdmVudC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlbmFibGVQb2ludGVyRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIGhvdmVyZWQgdGFyZ2V0XG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hvdmVyZWRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBob2xkIHRoZSBsaXN0IG9mIG5lc3RlZCB0YXJnZXRzIGhvdmVyZWRcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0W11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ob3ZlcmVkVGFyZ2V0czogW10sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY3JlYXRlVXBwZXJDYW52YXMoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuXG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggPSBmYWJyaWMuUGVuY2lsQnJ1c2ggJiYgbmV3IGZhYnJpYy5QZW5jaWxCcnVzaCh0aGlzKTtcblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb2JqZWN0cyBpbiB0d28gZ3JvdXBzLCBvbmUgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICogYW5kIG9uZSB0byByZW5kZXIgYXMgYWN0aXZlR3JvdXAuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGFuZCBwdXNoZXMgdGhlIG90aGVyIGluIHRoZSBhY3RpdmVHcm91cC5cbiAgICAgKi9cbiAgICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgb2JqZWN0LCBvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cztcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCAmJiAhdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IFtdO1xuICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBvYmpzVG9SZW5kZXIucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuX29iamVjdHMgPSBhY3RpdmVHcm91cE9iamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2guYXBwbHkob2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMb3N0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRvcExheWVyKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuaGFzTG9zdENvbnRleHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNUb0RyYXdPbiA9IHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc1RvRHJhd09uLCB0aGlzLl9jaG9vc2VPYmplY3RzVG9SZW5kZXIoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyVG9wTGF5ZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyB3ZSByZW5kZXIgdGhlIHRvcCBjb250ZXh0IC0gbGFzdCBvYmplY3RcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb24oY3R4KTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHJlbmRlciBvbmx5IHRoZSB0b3AgY2FudmFzLlxuICAgICAqIEFsc28gdXNlZCB0byByZW5kZXIgdGhlIGdyb3VwIHNlbGVjdGlvbiBib3guXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJUb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5yZW5kZXJUb3BMYXllcihjdHgpO1xuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIHRhcmdldCBpcyB0aGUgYWN0aXZlT2JqZWN0LCB3ZSBjYW5ub3QgZXhlY3V0ZSB0aGlzIG9wdGltaXphdGlvblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGRyYXcgY29udHJvbHMgdG9vLlxuICAgICAgaWYgKHRhcmdldC5zaG91bGRDYWNoZSgpICYmIHRhcmdldC5fY2FjaGVDYW52YXMgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQb2ludGVyID0gdGhpcy5fbm9ybWFsaXplUG9pbnRlcih0YXJnZXQsIHt4OiB4LCB5OiB5fSksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVggPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblggKyAobm9ybWFsaXplZFBvaW50ZXIueCAqIHRhcmdldC56b29tWCksIDApLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gTWF0aC5tYXgodGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpLCAwKTtcblxuICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IGZhYnJpYy51dGlsLmlzVHJhbnNwYXJlbnQoXG4gICAgICAgICAgdGFyZ2V0Ll9jYWNoZUNvbnRleHQsIE1hdGgucm91bmQodGFyZ2V0UmVsYXRpdmVYKSwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVkpLCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0Q2FjaGUsXG4gICAgICAgICAgb3JpZ2luYWxDb2xvciA9IHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IsIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gJyc7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cbiAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgY3R4LCB4LCB5LCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYW4gZXZlbnQgYW5kIGRldGVybWluZXMgaWYgc2VsZWN0aW9uIGtleSBoYXMgYmVlbiBwcmVzc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9pc1NlbGVjdGlvbktleVByZXNzZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc2VsZWN0aW9uS2V5KSkge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gISF0aGlzLnNlbGVjdGlvbktleS5maW5kKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gZVtrZXldID09PSB0cnVlOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZVt0aGlzLnNlbGVjdGlvbktleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAhdGFyZ2V0XG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldCAmJlxuICAgICAgICAgICF0aGlzLl9pc1NlbGVjdGlvbktleVByZXNzZWQoZSkpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiYgIXRhcmdldC5ldmVudGVkKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgIXRhcmdldC5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXJlZFNjYWxpbmcgZnJvbSBvYmplY3QgY2FuJ3Qgb3ZlcnJpZGUgY2VudGVyZWRTY2FsaW5nIGZyb20gY2FudmFzLlxuICAgICAqIHRoaXMgc2hvdWxkIGJlIGZpeGVkLCBzaW5jZSBvYmplY3Qgc2V0dGluZyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgY2FudmFzLlxuICAgICAqIGFsc28gdGhpcyBzaG91bGQgYmUgc29tZXRoaW5nIHRoYXQgd2lsbCBiZSBtaWdyYXRlZCBpbiB0aGUgY29udHJvbCBwcm9wZXJ0aWVzLlxuICAgICAqIGFzIGFiaWxpdHkgdG8gZGVmaW5lIHRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgdGhlIGNvbnRyb2wgcHJvdmlkZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWx0S2V5XG4gICAgICovXG4gICAgX3Nob3VsZENlbnRlclRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCwgYWN0aW9uLCBhbHRLZXkpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbnRlclRyYW5zZm9ybTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ3NjYWxlJyB8fCBhY3Rpb24gPT09ICdzY2FsZVgnIHx8IGFjdGlvbiA9PT0gJ3NjYWxlWScgfHwgYWN0aW9uID09PSAncmVzaXppbmcnKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRTY2FsaW5nIHx8IHRhcmdldC5jZW50ZXJlZFNjYWxpbmc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRSb3RhdGlvbiB8fCB0YXJnZXQuY2VudGVyZWRSb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbnRlclRyYW5zZm9ybSA/ICFhbHRLZXkgOiBhbHRLZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNob3VsZCBkaXNhcHBlYXIgYmVmb3JlIHJlbGVhc2UgNC4wXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0T3JpZ2luRnJvbUNvcm5lcjogZnVuY3Rpb24odGFyZ2V0LCBjb3JuZXIpIHtcbiAgICAgIHZhciBvcmlnaW4gPSB7XG4gICAgICAgIHg6IHRhcmdldC5vcmlnaW5YLFxuICAgICAgICB5OiB0YXJnZXQub3JpZ2luWVxuICAgICAgfTtcblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ21sJyB8fCBjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnYmwnKSB7XG4gICAgICAgIG9yaWdpbi54ID0gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ21yJyB8fCBjb3JuZXIgPT09ICd0cicgfHwgY29ybmVyID09PSAnYnInKSB7XG4gICAgICAgIG9yaWdpbi54ID0gJ2xlZnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ210JyB8fCBjb3JuZXIgPT09ICd0cicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ2JsJyB8fCBjb3JuZXIgPT09ICdtYicgfHwgY29ybmVyID09PSAnYnInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ3RvcCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxyZWFkeVNlbGVjdGVkIHRydWUgaWYgdGFyZ2V0IGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29ybmVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29ybmVyIG1sLCBtciwgdGwgLi4uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFt0YXJnZXRdIGluc2VydGVkIGJhY2sgdG8gaGVscCBvdmVycmlkaW5nLiBVbnVzZWRcbiAgICAgKi9cbiAgICBfZ2V0QWN0aW9uRnJvbUNvcm5lcjogZnVuY3Rpb24oYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUsIHRhcmdldCkge1xuICAgICAgaWYgKCFjb3JuZXIgfHwgIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gJ2RyYWcnO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXTtcbiAgICAgIHJldHVybiBjb250cm9sLmdldEFjdGlvbk5hbWUoZSwgY29udHJvbCwgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3NldHVwQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24gKGUsIHRhcmdldCwgYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLCBjb3JuZXIgPSB0YXJnZXQuX19jb3JuZXIsXG4gICAgICAgICAgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgIGFjdGlvbkhhbmRsZXIgPSAoYWxyZWFkeVNlbGVjdGVkICYmIGNvcm5lcikgP1xuICAgICAgICAgICAgY29udHJvbC5nZXRBY3Rpb25IYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCkgOiBmYWJyaWMuY29udHJvbHNVdGlscy5kcmFnSGFuZGxlcixcbiAgICAgICAgICBhY3Rpb24gPSB0aGlzLl9nZXRBY3Rpb25Gcm9tQ29ybmVyKGFscmVhZHlTZWxlY3RlZCwgY29ybmVyLCBlLCB0YXJnZXQpLFxuICAgICAgICAgIG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIpLFxuICAgICAgICAgIGFsdEtleSA9IGVbdGhpcy5jZW50ZXJlZEtleV0sXG4gICAgICAgICAgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGFjdGlvbkhhbmRsZXI6IGFjdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgICAgIHNrZXdYOiB0YXJnZXQuc2tld1gsXG4gICAgICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICAgICAgLy8gdXNlZCBieSB0cmFuc2F0aW9uXG4gICAgICAgICAgICBvZmZzZXRYOiBwb2ludGVyLnggLSB0YXJnZXQubGVmdCxcbiAgICAgICAgICAgIG9mZnNldFk6IHBvaW50ZXIueSAtIHRhcmdldC50b3AsXG4gICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbi55LFxuICAgICAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgICAgIGV5OiBwb2ludGVyLnksXG4gICAgICAgICAgICBsYXN0WDogcG9pbnRlci54LFxuICAgICAgICAgICAgbGFzdFk6IHBvaW50ZXIueSxcbiAgICAgICAgICAgIC8vIHVuc3VyZSB0aGV5IGFyZSB1c2VmdWwgYW55bW9yZS5cbiAgICAgICAgICAgIC8vIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICAgICAgLy8gdG9wOiB0YXJnZXQudG9wLFxuICAgICAgICAgICAgdGhldGE6IGRlZ3JlZXNUb1JhZGlhbnModGFyZ2V0LmFuZ2xlKSxcbiAgICAgICAgICAgIC8vIGVuZCBvZiB1bnN1cmVcbiAgICAgICAgICAgIHdpZHRoOiB0YXJnZXQud2lkdGggKiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICAgICAgICBhbHRLZXk6IGFsdEtleSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiBmYWJyaWMudXRpbC5zYXZlT2JqZWN0VHJhbnNmb3JtKHRhcmdldCksXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0YXJnZXQsIGFjdGlvbiwgYWx0S2V5KSkge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLm9yaWdpbmFsLm9yaWdpblggPSBvcmlnaW4ueDtcbiAgICAgIHRyYW5zZm9ybS5vcmlnaW5hbC5vcmlnaW5ZID0gb3JpZ2luLnk7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBDdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXVpLyNjdXJzb3JcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlLmN1cnNvciA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdG8gZHJhdyB0aGUgc2VsZWN0aW9uIG9uXG4gICAgICovXG4gICAgX2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsXG4gICAgICAgICAgdmlld3BvcnRTdGFydCA9IG5ldyBmYWJyaWMuUG9pbnQoc2VsZWN0b3IuZXgsIHNlbGVjdG9yLmV5KSxcbiAgICAgICAgICBzdGFydCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZpZXdwb3J0U3RhcnQsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pLFxuICAgICAgICAgIHZpZXdwb3J0RXh0ZW50ID0gbmV3IGZhYnJpYy5Qb2ludChzZWxlY3Rvci5leCArIHNlbGVjdG9yLmxlZnQsIHNlbGVjdG9yLmV5ICsgc2VsZWN0b3IudG9wKSxcbiAgICAgICAgICBleHRlbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh2aWV3cG9ydEV4dGVudCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSksXG4gICAgICAgICAgbWluWCA9IE1hdGgubWluKHN0YXJ0LngsIGV4dGVudC54KSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oc3RhcnQueSwgZXh0ZW50LnkpLFxuICAgICAgICAgIG1heFggPSBNYXRoLm1heChzdGFydC54LCBleHRlbnQueCksXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KHN0YXJ0LnksIGV4dGVudC55KSxcbiAgICAgICAgICBzdHJva2VPZmZzZXQgPSB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCAvIDI7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCB8fCAhdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuXG4gICAgICBtaW5YICs9IHN0cm9rZU9mZnNldDtcbiAgICAgIG1pblkgKz0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgbWF4WCAtPSBzdHJva2VPZmZzZXQ7XG4gICAgICBtYXhZIC09IHN0cm9rZU9mZnNldDtcbiAgICAgIC8vIHNlbGVjdGlvbiBib3JkZXJcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLl9zZXRMaW5lRGFzaC5jYWxsKHRoaXMsIGN0eCwgdGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkpO1xuICAgICAgY3R4LnN0cm9rZVJlY3QobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IG9iamVjdCB3ZSBhcmUgY2xpY2tpbmcgb25cbiAgICAgKiB0aGUgc2tpcEdyb3VwIHBhcmFtZXRlciBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBuZWVkZWQgZm9yIHNoaWZ0K2NsaWNrIGFjdGlvblxuICAgICAqIDExLzA5LzIwMTggVE9ETzogd291bGQgYmUgY29vbCBpZiBmaW5kVGFyZ2V0IGNvdWxkIGRpc2Nlcm4gYmV0d2VlbiBiZWluZyBhIGZ1bGwgdGFyZ2V0XG4gICAgICogb3IgdGhlIG91dHNpZGUgcGFydCBvZiB0aGUgY29ybmVyLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBHcm91cCB3aGVuIHRydWUsIGFjdGl2ZUdyb3VwIGlzIHNraXBwZWQgYW5kIG9ubHkgb2JqZWN0cyBhcmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGUgdGFyZ2V0IGZvdW5kXG4gICAgICovXG4gICAgZmluZFRhcmdldDogZnVuY3Rpb24gKGUsIHNraXBHcm91cCkge1xuICAgICAgaWYgKHRoaXMuc2tpcFRhcmdldEZpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWdub3JlWm9vbSA9IHRydWUsXG4gICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCBpZ25vcmVab29tKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgYU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVUYXJnZXQsIGFjdGl2ZVRhcmdldFN1YnMsXG4gICAgICAgICAgaXNUb3VjaCA9IGlzVG91Y2hFdmVudChlKSxcbiAgICAgICAgICBzaG91bGRMb29rRm9yQWN0aXZlID0gKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCkgfHwgYU9iamVjdHMubGVuZ3RoID09PSAxO1xuXG4gICAgICAvLyBmaXJzdCBjaGVjayBjdXJyZW50IGdyb3VwIChpZiBvbmUgZXhpc3RzKVxuICAgICAgLy8gYWN0aXZlIGdyb3VwIGRvZXMgbm90IGNoZWNrIHN1YiB0YXJnZXRzIGxpa2Ugbm9ybWFsIGdyb3Vwcy5cbiAgICAgIC8vIGlmIGFjdGl2ZSBncm91cCBqdXN0IGV4aXRzLlxuICAgICAgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICAgIC8vIGlmIHdlIGhpdCB0aGUgY29ybmVyIG9mIGFuIGFjdGl2ZU9iamVjdCwgbGV0J3MgcmV0dXJuIHRoYXQuXG4gICAgICBpZiAoc2hvdWxkTG9va0ZvckFjdGl2ZSAmJiBhY3RpdmVPYmplY3QuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlciwgaXNUb3VjaCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPiAxICYmICFza2lwR3JvdXAgJiYgYWN0aXZlT2JqZWN0ID09PSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHMoW2FjdGl2ZU9iamVjdF0sIHBvaW50ZXIpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0ID0gYWN0aXZlT2JqZWN0O1xuICAgICAgICAgIGFjdGl2ZVRhcmdldFN1YnMgPSB0aGlzLnRhcmdldHM7XG4gICAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICBpZiAoZVt0aGlzLmFsdFNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIGFjdGl2ZVRhcmdldCAmJiB0YXJnZXQgIT09IGFjdGl2ZVRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhY3RpdmVUYXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGFjdGl2ZVRhcmdldFN1YnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsUG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMgdXNlZCB0byBzZWFyY2ggcGVyIHBpeGVsIHRhcmdldC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1RhcmdldDogZnVuY3Rpb24ocG9pbnRlciwgb2JqLCBnbG9iYWxQb2ludGVyKSB7XG4gICAgICBpZiAob2JqICYmXG4gICAgICAgICAgb2JqLnZpc2libGUgJiZcbiAgICAgICAgICBvYmouZXZlbnRlZCAmJlxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgICAgICAvLyBodHRwOi8vaWRhdi51Y2RhdmlzLmVkdS9+b2tyZXlsb3MvVEFzaGlwL1NwcmluZzIwMDAvUG9pbnRJblBvbHlnb24uaHRtbFxuICAgICAgICAgIG9iai5jb250YWluc1BvaW50KHBvaW50ZXIpXG4gICAgICApIHtcbiAgICAgICAgaWYgKCh0aGlzLnBlclBpeGVsVGFyZ2V0RmluZCB8fCBvYmoucGVyUGl4ZWxUYXJnZXRGaW5kKSAmJiAhb2JqLmlzRWRpdGluZykge1xuICAgICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KG9iaiwgZ2xvYmFsUG9pbnRlci54LCBnbG9iYWxQb2ludGVyLnkpO1xuICAgICAgICAgIGlmICghaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoIGluc2lkZSBvYmplY3RzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvaW50ZXIgaW4gYm91bmRpbmcgYm94IG9yIHRoYXQgY29udGFpbnMgcG9pbnRlck9uQ2FudmFzIHdoZW4gcGFpbnRlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvYmplY3RzXSBvYmplY3RzIGFycmF5IHRvIGxvb2sgaW50b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWFyY2hQb3NzaWJsZVRhcmdldHM6IGZ1bmN0aW9uKG9iamVjdHMsIHBvaW50ZXIpIHtcbiAgICAgIC8vIENhY2hlIGFsbCB0YXJnZXRzIHdoZXJlIHRoZWlyIGJvdW5kaW5nIGJveCBjb250YWlucyBwb2ludC5cbiAgICAgIHZhciB0YXJnZXQsIGkgPSBvYmplY3RzLmxlbmd0aCwgc3ViVGFyZ2V0O1xuICAgICAgLy8gRG8gbm90IGNoZWNrIGZvciBjdXJyZW50bHkgZ3JvdXBlZCBvYmplY3RzLCBzaW5jZSB3ZSBjaGVjayB0aGUgcGFyZW50IGdyb3VwIGl0c2VsZi5cbiAgICAgIC8vIHVudGlsIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiBzcGVjaWZpY2FsbHkgdG8gc2VhcmNoIGluc2lkZSB0aGUgYWN0aXZlR3JvdXBcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIG9ialRvQ2hlY2sgPSBvYmplY3RzW2ldO1xuICAgICAgICB2YXIgcG9pbnRlclRvVXNlID0gb2JqVG9DaGVjay5ncm91cCA/XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplUG9pbnRlcihvYmpUb0NoZWNrLmdyb3VwLCBwb2ludGVyKSA6IHBvaW50ZXI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1RhcmdldChwb2ludGVyVG9Vc2UsIG9ialRvQ2hlY2ssIHBvaW50ZXIpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrICYmIHRhcmdldCBpbnN0YW5jZW9mIGZhYnJpYy5Hcm91cCkge1xuICAgICAgICAgICAgc3ViVGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRhcmdldC5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICAgICAgICBzdWJUYXJnZXQgJiYgdGhpcy50YXJnZXRzLnB1c2goc3ViVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyB3aXRob3V0IHRoZSBlZmZlY3Qgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXN0b3JlUG9pbnRlclZwdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMuXG4gICAgICogQ2FuIHJldHVybiBjb29yZGluYXRlcyB3aXRoIG9yIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaWdub3JlWm9vbSBmYWxzZSBnaXZlcyBiYWNrIGNvb3JkaW5hdGVzIHRoYXQgcmVwcmVzZW50XG4gICAgICogdGhlIHBvaW50IGNsaWNrZWQgb24gY2FudmFzIGVsZW1lbnQuXG4gICAgICogaWdub3JlWm9vbSB0cnVlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgYWZ0ZXIgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogYnkgdGhlIHZpZXdwb3J0VHJhbnNmb3JtICggc29ydCBvZiBjb29yZGluYXRlcyBvZiB3aGF0IGlzIGRpc3BsYXllZFxuICAgICAqIG9uIHRoZSBjYW52YXMgd2hlcmUgeW91IGFyZSBjbGlja2luZy5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgPSBIVE1MRWxlbWVudCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0b3AsbGVmdFxuICAgICAqIGlnbm9yZVpvb20gZmFsc2UsIGRlZmF1bHQgPSBmYWJyaWMgc3BhY2UgY29vcmRpbmF0ZXMsIHRoZSBzYW1lIHVzZWQgZm9yIHNoYXBlIHBvc2l0aW9uXG4gICAgICogVG8gaW50ZXJhY3Qgd2l0aCB5b3VyIHNoYXBlcyB0b3AgYW5kIGxlZnQgeW91IHdhbnQgdG8gdXNlIGlnbm9yZVpvb20gdHJ1ZVxuICAgICAqIG1vc3Qgb2YgdGhlIHRpbWUsIHdoaWxlIGlnbm9yZVpvb20gZmFsc2Ugd2lsbCBnaXZlIHlvdSBjb29yZGluYXRlc1xuICAgICAqIGNvbXBhdGlibGUgd2l0aCB0aGUgb2JqZWN0Lm9Db29yZHMgc3lzdGVtLlxuICAgICAqIG9mIHRoZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVpvb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gKGUsIGlnbm9yZVpvb20pIHtcbiAgICAgIC8vIHJldHVybiBjYWNoZWQgdmFsdWVzIGlmIHdlIGFyZSBpbiB0aGUgZXZlbnQgcHJvY2Vzc2luZyBjaGFpblxuICAgICAgaWYgKHRoaXMuX2Fic29sdXRlUG9pbnRlciAmJiAhaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVQb2ludGVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXIgJiYgaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBnZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgYm91bmRzID0gdXBwZXJDYW52YXNFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCAwLFxuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IGJvdW5kcy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICBjc3NTY2FsZTtcblxuICAgICAgaWYgKCFib3VuZHNXaWR0aCB8fCAhYm91bmRzSGVpZ2h0ICkge1xuICAgICAgICBpZiAoJ3RvcCcgaW4gYm91bmRzICYmICdib3R0b20nIGluIGJvdW5kcykge1xuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IE1hdGguYWJzKCBib3VuZHMudG9wIC0gYm91bmRzLmJvdHRvbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncmlnaHQnIGluIGJvdW5kcyAmJiAnbGVmdCcgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzV2lkdGggPSBNYXRoLmFicyggYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICAgIHBvaW50ZXIueCA9IHBvaW50ZXIueCAtIHRoaXMuX29mZnNldC5sZWZ0O1xuICAgICAgcG9pbnRlci55ID0gcG9pbnRlci55IC0gdGhpcy5fb2Zmc2V0LnRvcDtcbiAgICAgIGlmICghaWdub3JlWm9vbSkge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdChwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldGluYVNjYWxpbmcgPSB0aGlzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgIGlmIChyZXRpbmFTY2FsaW5nICE9PSAxKSB7XG4gICAgICAgIHBvaW50ZXIueCAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgICBwb2ludGVyLnkgLz0gcmV0aW5hU2NhbGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kc1dpZHRoID09PSAwIHx8IGJvdW5kc0hlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgKGkuZS4gbm90IHZpc2libGUpLCBkbyBub3QgYXBwbHkgc2NhbGUuXG4gICAgICAgIGNzc1NjYWxlID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3NzU2NhbGUgPSB7XG4gICAgICAgICAgd2lkdGg6IHVwcGVyQ2FudmFzRWwud2lkdGggLyBib3VuZHNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHVwcGVyQ2FudmFzRWwuaGVpZ2h0IC8gYm91bmRzSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50ZXIueCAqIGNzc1NjYWxlLndpZHRoLFxuICAgICAgICB5OiBwb2ludGVyLnkgKiBjc3NTY2FsZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRocm93cyB7Q0FOVkFTX0lOSVRfRVJST1J9IElmIGNhbnZhcyBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgX2NyZWF0ZVVwcGVyQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG93ZXJDYW52YXNDbGFzcyA9IHRoaXMubG93ZXJDYW52YXNFbC5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmxvd2VyLWNhbnZhc1xccyovLCAnJyksXG4gICAgICAgICAgbG93ZXJDYW52YXNFbCA9IHRoaXMubG93ZXJDYW52YXNFbCwgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbDtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgdXBwZXJDYW52YXMgZWxlbWVudCBpZiB3ZSBoYXZlIGFscmVhZHkgb25lLlxuICAgICAgaWYgKHVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdXBwZXJDYW52YXNFbC5jbGFzc05hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB1cHBlckNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwgPSB1cHBlckNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModXBwZXJDYW52YXNFbCwgJ3VwcGVyLWNhbnZhcyAnICsgbG93ZXJDYW52YXNDbGFzcyk7XG5cbiAgICAgIHRoaXMud3JhcHBlckVsLmFwcGVuZENoaWxkKHVwcGVyQ2FudmFzRWwpO1xuXG4gICAgICB0aGlzLl9jb3B5Q2FudmFzU3R5bGUobG93ZXJDYW52YXNFbCwgdXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLl9hcHBseUNhbnZhc1N0eWxlKHVwcGVyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gdXBwZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgdG9wIGNhbnZhcyB3aGVyZSBpbnRlcmFjdGlvbnMgYXJlIGRyYXduXG4gICAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRUb3BDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cmFwcGVyRWwgPSBmYWJyaWMudXRpbC53cmFwRWxlbWVudCh0aGlzLmxvd2VyQ2FudmFzRWwsICdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6IHRoaXMuY29udGFpbmVyQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy53cmFwcGVyRWwsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUodGhpcy53cmFwcGVyRWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgc3R5bGVzIG9uXG4gICAgICovXG4gICAgX2FwcGx5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICAndG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZScsXG4gICAgICAgICctbXMtdG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgZW50aXJlIGlubGluZSBzdHlsZSBmcm9tIG9uZSBlbGVtZW50IChmcm9tRWwpIHRvIGFub3RoZXIgKHRvRWwpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21FbCBFbGVtZW50IHN0eWxlIGlzIGNvcGllZCBmcm9tXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0b0VsIEVsZW1lbnQgY29waWVkIHN0eWxlIGlzIGFwcGxpZWQgdG9cbiAgICAgKi9cbiAgICBfY29weUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0b0VsLnN0eWxlLmNzc1RleHQgPSBmcm9tRWwuc3R5bGUuY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IG9uIHdoaWNoIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25FbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cHBlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZS50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyAmJiBhY3RpdmUuX29iamVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbYWN0aXZlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyByZW1vdmluZyBhY3RpdmUgb2JqZWN0IHNob3VsZCBmaXJlIFwic2VsZWN0aW9uOmNsZWFyZWRcIiBldmVudHNcbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIG9iai5maXJlKCdkZXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAob2JqID09PSB0aGlzLl9ob3ZlcmVkVGFyZ2V0KXtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcignX29uT2JqZWN0UmVtb3ZlZCcsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ29tcGFyZXMgdGhlIG9sZCBhY3RpdmVPYmplY3Qgd2l0aCB0aGUgY3VycmVudCBvbmUgYW5kIGZpcmVzIGNvcnJlY3QgZXZlbnRzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogb2xkIGFjdGl2ZU9iamVjdFxuICAgICAqL1xuICAgIF9maXJlU2VsZWN0aW9uRXZlbnRzOiBmdW5jdGlvbihvbGRPYmplY3RzLCBlKSB7XG4gICAgICB2YXIgc29tZXRoaW5nQ2hhbmdlZCA9IGZhbHNlLCBvYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWRkZWQgPSBbXSwgcmVtb3ZlZCA9IFtdO1xuICAgICAgb2xkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9sZE9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0cy5pbmRleE9mKG9sZE9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2xkT2JqZWN0LmZpcmUoJ2Rlc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiBvbGRPYmplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkLnB1c2gob2xkT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvbGRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvYmplY3QuZmlyZSgnc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiBvYmplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhZGRlZC5wdXNoKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG9sZE9iamVjdHMubGVuZ3RoID4gMCAmJiBvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCAmJiB0aGlzLmZpcmUoJ3NlbGVjdGlvbjp1cGRhdGVkJywge1xuICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGFkZGVkLFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHJlbW92ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNyZWF0ZWQnLCB7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBzZWxlY3RlZDogYWRkZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNsZWFyZWQnLCB7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBkZXNlbGVjdGVkOiByZW1vdmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBnaXZlbiBvYmplY3QgYXMgdGhlIG9ubHkgYWN0aXZlIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2V0IGFzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChvYmplY3QsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIGZvciBub3cuXG4gICAgICogVGhpcyBpcyBzdXBwb3NlZCB0byBiZSBlcXVpdmFsZW50IHRvIHNldEFjdGl2ZU9iamVjdCBidXQgd2l0aG91dCBmaXJpbmdcbiAgICAgKiBhbnkgZXZlbnQuIFRoZXJlIGlzIGNvbW1pdG1lbnQgdG8gaGF2ZSB0aGlzIHN0YXkgdGhpcyB3YXkuXG4gICAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb25hbCBwYXJ0IG9mIHNldEFjdGl2ZU9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2V0IGFzIGFjdGl2ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OnNlbGVjdGVkXCIpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGhhcHBlbmVkXG4gICAgICovXG4gICAgX3NldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCBlKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlT2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KGUsIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5vblNlbGVjdCh7IGU6IGUgfSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gb2JqZWN0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBwcml2YXRlIG1ldGhvZCBmb3Igbm93LlxuICAgICAqIFRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgZXF1aXZhbGVudCB0byBkaXNjYXJkQWN0aXZlT2JqZWN0IGJ1dCB3aXRob3V0IGZpcmluZ1xuICAgICAqIGFueSBldmVudHMuIFRoZXJlIGlzIGNvbW1pdG1lbnQgdG8gaGF2ZSB0aGlzIHN0YXkgdGhpcyB3YXkuXG4gICAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb25hbCBwYXJ0IG9mIGRpc2NhcmRBY3RpdmVPYmplY3QuXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6ZGVzZWxlY3RlZFwiKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2V0IGFzIGFjdGl2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNlbGVjdGlvbiBoYXBwZW5lZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2NhcmRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKGUsIG9iamVjdCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgLy8gb25EZXNlbGVjdCByZXR1cm4gVFJVRSB0byBjYW5jZWwgc2VsZWN0aW9uO1xuICAgICAgICBpZiAob2JqLm9uRGVzZWxlY3QoeyBlOiBlLCBvYmplY3Q6IG9iamVjdCB9KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2NhcmRzIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0IGFuZCBmaXJlIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBmYWJyaWNcbiAgICAgKiBhcyBhIGNvbnNlcXVlbmNlIG9mIGEgbW91c2UgZXZlbnQsIHRoZSBldmVudCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgYW5kXG4gICAgICogc2VudCB0byB0aGUgZmlyZSBmdW5jdGlvbiBmb3IgdGhlIGN1c3RvbSBldmVudHMuIFdoZW4gdXNlZCBhcyBhIG1ldGhvZCB0aGVcbiAgICAgKiBlIHBhcmFtIGRvZXMgbm90IGhhdmUgYW55IGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc2NhcmRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKTtcbiAgICAgIGlmIChjdXJyZW50QWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5maXJlKCdiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogYWN0aXZlT2JqZWN0LCBlOiBlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdGhpcy53cmFwcGVyRWw7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gbnVsbDtcbiAgICAgIFsndXBwZXJDYW52YXNFbCcsICdjYWNoZUNhbnZhc0VsJ10uZm9yRWFjaCgoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXNbZWxlbWVudF0pO1xuICAgICAgICB0aGlzW2VsZW1lbnRdID0gdW5kZWZpbmVkO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLndyYXBwZXJFbCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy53cmFwcGVyRWw7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHRoaXMuZGlzY2FyZEFjdGl2ZUdyb3VwKCk7XG4gICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ2NsZWFyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIG9iamVjdHMnIGNvbnRyb2xzIChib3JkZXJzL2NvbnRyb2xzKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgY29udHJvbHMgb25cbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCkge1xuICAgICAgICBhY3RpdmVPYmplY3QuX3JlbmRlckNvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy9JZiB0aGUgb2JqZWN0IGlzIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGdyb3VwLCBpdCBzaG91bGRcbiAgICAgIC8vYmUgdHJhbnNmb3JtZWQgYXBwcm9wcmlhdGVseVxuICAgICAgLy9pLmUuIGl0IHNob3VsZCBiZSBzZXJpYWxpc2VkIGFzIGl0IHdvdWxkIGFwcGVhciBpZiB0aGUgc2VsZWN0aW9uIGdyb3VwXG4gICAgICAvL3dlcmUgdG8gYmUgZGVzdHJveWVkLlxuICAgICAgdmFyIG9yaWdpbmFsUHJvcGVydGllcyA9IHRoaXMuX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlKSxcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLmNhbGxTdXBlcignX3RvT2JqZWN0JywgaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgLy9VbmRvIHRoZSBkYW1hZ2Ugd2UgZGlkIGJ5IGNoYW5naW5nIGFsbCBvZiBpdHMgcHJvcGVydGllc1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWxpc2VzIGFuIG9iamVjdCdzIGdyb3VwIHRyYW5zZm9ybWF0aW9uIG9uIGl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB0cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcmV0dXJucyB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlIHdoaWNoIHdlcmUgY2hhbmdlZFxuICAgICAqL1xuICAgIF9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ncm91cCAmJiBpbnN0YW5jZS5ncm91cC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyAmJiB0aGlzLl9hY3RpdmVPYmplY3QgPT09IGluc3RhbmNlLmdyb3VwKSB7XG4gICAgICAgIHZhciBsYXlvdXRQcm9wcyA9IFsnYW5nbGUnLCAnZmxpcFgnLCAnZmxpcFknLCAnbGVmdCcsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NrZXdYJywgJ3NrZXdZJywgJ3RvcCddO1xuICAgICAgICAvL0NvcHkgYWxsIHRoZSBwb3NpdGlvbmFsbHkgcmVsZXZhbnQgcHJvcGVydGllcyBhY3Jvc3Mgbm93XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlcyA9IHt9O1xuICAgICAgICBsYXlvdXRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlc1twcm9wXSA9IGluc3RhbmNlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgZmFicmljLnV0aWwuYWRkVHJhbnNmb3JtVG9PYmplY3QoaW5zdGFuY2UsIHRoaXMuX2FjdGl2ZU9iamVjdC5jYWxjT3duTWF0cml4KCkpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMgb2YgaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHVuLXRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3JpZ2luYWxWYWx1ZXNdIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2UsIGFzIHJldHVybmVkIGJ5IF9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdFxuICAgICAqL1xuICAgIF91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgb3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgIGlmIChvcmlnaW5hbFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5zZXQob3JpZ2luYWxWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3Q6IGZ1bmN0aW9uKG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBpbiBhIHNlbGVjdGlvbiBncm91cCwgc2ltdWxhdGUgd2hhdCB3b3VsZCBoYXBwZW4gdG8gdGhhdFxuICAgICAgLy9vYmplY3Qgd2hlbiB0aGUgZ3JvdXAgaXMgZGVzZWxlY3RlZFxuICAgICAgdmFyIG9yaWdpbmFsUHJvcGVydGllcyA9IHRoaXMuX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0U1ZHT2JqZWN0JywgbWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBzZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24gKHZwdCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5pc0VkaXRpbmcpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0LmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuc2V0Vmlld3BvcnRUcmFuc2Zvcm0uY2FsbCh0aGlzLCB2cHQpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY29weWluZyBzdGF0aWMgcHJvcGVydGllcyBtYW51YWxseSB0byB3b3JrIGFyb3VuZCBPcGVyYSdzIGJ1ZyxcbiAgLy8gd2hlcmUgXCJwcm90b3R5cGVcIiBwcm9wZXJ0eSBpcyBlbnVtZXJhYmxlIGFuZCBvdmVycmlkZXMgZXhpc3RpbmcgcHJvdG90eXBlXG4gIGZvciAodmFyIHByb3AgaW4gZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGlmIChwcm9wICE9PSAncHJvdG90eXBlJykge1xuICAgICAgZmFicmljLkNhbnZhc1twcm9wXSA9IGZhYnJpYy5TdGF0aWNDYW52YXNbcHJvcF07XG4gICAgfVxuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgYWRkTGlzdGVuZXIgPSBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcixcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIsXG4gICAgICBSSUdIVF9DTElDSyA9IDMsIE1JRERMRV9DTElDSyA9IDIsIExFRlRfQ0xJQ0sgPSAxLFxuICAgICAgYWRkRXZlbnRPcHRpb25zID0geyBwYXNzaXZlOiBmYWxzZSB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZS5idXR0b24gJiYgKGUuYnV0dG9uID09PSB2YWx1ZSAtIDEpO1xuICB9XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyB0aGUgaWQgb2YgdGhlIHRvdWNoIGV2ZW50IHRoYXQgb3ducyB0aGUgZmFicmljIHRyYW5zZm9ybVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbWFpblRvdWNoSWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG1vdXNlIGxpc3RlbmVycyB0byBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGluIGNhc2Ugd2UgaW5pdGlhbGl6ZWQgdGhlIGNsYXNzIHR3aWNlLiBUaGlzIHNob3VsZCBub3QgaGFwcGVuIG5vcm1hbGx5XG4gICAgICAvLyBidXQgaW4gc29tZSBraW5kIG9mIGFwcGxpY2F0aW9ucyB3aGVyZSB0aGUgY2FudmFzIGVsZW1lbnQgbWF5IGJlIGNoYW5nZWRcbiAgICAgIC8vIHRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGhhdmluZyBkb3VibGUgbGlzdGVuZXJzLlxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmUoYWRkTGlzdGVuZXIsICdhZGQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGFuIGV2ZW50IHByZWZpeCBwb2ludGVyIG9yIG1vdXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEV2ZW50UHJlZml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXInIDogJ21vdXNlJztcbiAgICB9LFxuXG4gICAgYWRkT3JSZW1vdmU6IGZ1bmN0aW9uKGZ1bmN0b3IsIGV2ZW50anNGdW5jdG9yKSB7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgZnVuY3RvcihmYWJyaWMud2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ291dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnZW50ZXInLCB0aGlzLl9vbk1vdXNlRW50ZXIpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnd2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51KTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljayk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX29uRHJhZ092ZXIpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZHJhZ2VudGVyJywgdGhpcy5fb25EcmFnRW50ZXIpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZHJhZ2xlYXZlJywgdGhpcy5fb25EcmFnTGVhdmUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZHJvcCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cykge1xuICAgICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBldmVudGpzICE9PSAndW5kZWZpbmVkJyAmJiBldmVudGpzRnVuY3RvciBpbiBldmVudGpzKSB7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdnZXN0dXJlJywgdGhpcy5fb25HZXN0dXJlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnb3JpZW50YXRpb24nLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ3NoYWtlJywgdGhpcy5fb25TaGFrZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdsb25ncHJlc3MnLCB0aGlzLl9vbkxvbmdQcmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKHJlbW92ZUxpc3RlbmVyLCAncmVtb3ZlJyk7XG4gICAgICAvLyBpZiB5b3UgZGlzcG9zZSBvbiBhIG1vdXNlRG93biwgYmVmb3JlIG1vdXNlIHVwLCB5b3UgbmVlZCB0byBjbGVhbiBkb2N1bWVudCB0by4uLlxuICAgICAgdmFyIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICd1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ldmVudHNCb3VuZCkge1xuICAgICAgICAvLyBmb3IgYW55IHJlYXNvbiB3ZSBwYXNzIGhlcmUgdHdpY2Ugd2UgZG8gbm90IHdhbnQgdG8gYmluZCBldmVudHMgdHdpY2UuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uVG91Y2hTdGFydCA9IHRoaXMuX29uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25SZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25HZXN0dXJlID0gdGhpcy5fb25HZXN0dXJlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uU2hha2UgPSB0aGlzLl9vblNoYWtlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkxvbmdQcmVzcyA9IHRoaXMuX29uTG9uZ1ByZXNzLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlID0gdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZVdoZWVsID0gdGhpcy5fb25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlT3V0ID0gdGhpcy5fb25Nb3VzZU91dC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZUVudGVyID0gdGhpcy5fb25Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkNvbnRleHRNZW51ID0gdGhpcy5fb25Db250ZXh0TWVudS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Eb3VibGVDbGljayA9IHRoaXMuX29uRG91YmxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZ092ZXIgPSB0aGlzLl9vbkRyYWdPdmVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdFbnRlciA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnZW50ZXInKTtcbiAgICAgIHRoaXMuX29uRHJhZ0xlYXZlID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyLmJpbmQodGhpcywgJ2RyYWdsZWF2ZScpO1xuICAgICAgdGhpcy5fb25Ecm9wID0gdGhpcy5fb25Ecm9wLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMuZm9yRWFjaChmdW5jdGlvbihfdGFyZ2V0KXtcbiAgICAgICAgX3RoaXMuZmlyZSgnbW91c2U6b3V0JywgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgICAgX3RhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2VvdXQnLCB7IGU6IGUgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2VlbnRlclxuICAgICAqL1xuICAgIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIFRoaXMgZmluZCB0YXJnZXQgYW5kIGNvbnNlcXVlbnQgJ21vdXNlOm92ZXInIGlzIHVzZWQgdG9cbiAgICAgIC8vIGNsZWFyIG9sZCBpbnN0YW5jZXMgb24gaG92ZXJlZCB0YXJnZXQuXG4gICAgICAvLyBjYWxsaW5nIGZpbmRUYXJnZXQgaGFzIHRoZSBzaWRlIGVmZmVjdCBvZiBraWxsaW5nIHRhcmdldC5fX2Nvcm5lci5cbiAgICAgIC8vIGFzIGEgc2hvcnQgdGVybSBmaXggd2UgYXJlIG5vdCBmaXJpbmcgdGhpcyBpZiB3ZSBhcmUgY3VycmVudGx5IHRyYW5zZm9ybWluZy5cbiAgICAgIC8vIGFzIGEgbG9uZyB0ZXJtIGZpeCB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBhY3Rpb24gb2YgZmluZGluZyBhIHRhcmdldCB3aXRoIHRoZVxuICAgICAgLy8gc2lkZSBlZmZlY3RzIHdlIGFkZGVkIHRvIGl0LlxuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtICYmICF0aGlzLmZpbmRUYXJnZXQoZSkpIHtcbiAgICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdmVyJywgeyB0YXJnZXQ6IG51bGwsIGU6IGUgfSk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgb3JpZW50YXRpb24gY2hhbmdlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbk9yaWVudGF0aW9uQ2hhbmdlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZSAmJiB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vblNoYWtlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25TaGFrZSAmJiB0aGlzLl9fb25TaGFrZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkxvbmdQcmVzczogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uTG9uZ1ByZXNzICYmIHRoaXMuX19vbkxvbmdQcmVzcyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJldmVudCBkZWZhdWx0IHRvIGFsbG93IGRyb3AgZXZlbnQgdG8gYmUgZmlyZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKi9cbiAgICBfb25EcmFnT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlcignZHJhZ292ZXInLCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVFbnRlckxlYXZlRXZlbnRzKHRhcmdldCwgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBkcm9wOmJlZm9yZWAgaXMgYSBhbiBldmVudCB0aGF0IGFsbG93IHlvdSB0byBzY2hlZHVsZSBsb2dpY1xuICAgICAqIGJlZm9yZSB0aGUgYGRyb3BgIGV2ZW50LiBQcmVmZXIgYGRyb3BgIGV2ZW50IGFsd2F5cywgYnV0IGlmIHlvdSBuZWVkXG4gICAgICogdG8gcnVuIHNvbWUgZHJvcC1kaXNhYmxpbmcgbG9naWMgb24gYW4gZXZlbnQsIHNpbmNlIHRoZXJlIGlzIG5vIHdheVxuICAgICAqIHRvIGhhbmRsZSBldmVudCBoYW5kbGVycyBvcmRlcmluZywgdXNlIGBkcm9wOmJlZm9yZWBcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgX29uRHJvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlcignZHJvcDpiZWZvcmUnLCBlKTtcbiAgICAgIHJldHVybiB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2Ryb3AnLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLnN0b3BDb250ZXh0TWVudSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkYmxjbGljaycpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHRoZSBpZCBvZiBhbiBldmVudC5cbiAgICAgKiByZXR1cm5zIGVpdGhlciB0aGUgcG9pbnRlcklkIG9yIHRoZSBpZGVudGlmaWVyIG9yIDAgZm9yIHRoZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIGdldFBvaW50ZXJJZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmIChjaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlZFRvdWNoZXNbMF0gJiYgY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cykge1xuICAgICAgICByZXR1cm4gZXZ0LnBvaW50ZXJJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGhhcyB0aGUgaWQgb2YgdGhlIGV2ZW50IHRoYXQgaXMgY29uc2lkZXJlZCBtYWluXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2V2dH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzTWFpbkV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChldnQuaXNQcmltYXJ5ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5pc1ByaW1hcnkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBldnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHJldHVybiBldnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gdGhpcy5tYWluVG91Y2hJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLm1haW5Ub3VjaElkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubWFpblRvdWNoSWQgPSB0aGlzLmdldFBvaW50ZXJJZChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAvLyBVbmJpbmQgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoRW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgc3RvcCBoZXJlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5tYWluVG91Y2hJZCA9IG51bGw7XG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl93aWxsQWRkTW91c2VEb3duKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93aWxsQWRkTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dpbGxBZGRNb3VzZURvd24gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXYWl0IDQwMG1zIGJlZm9yZSByZWJpbmRpbmcgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzXG4gICAgICAgIC8vIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIF90aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICAgIF90aGlzLl93aWxsQWRkTW91c2VEb3duID0gMDtcbiAgICAgIH0sIDQwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBpZiAodGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGFkZExpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgIXRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX19vbk1vdXNlTW92ZShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHdoZXRoZXIgdGhlIGNhbnZhcyBzaG91bGQgYmUgcmVkcmF3biBpbiBtb3VzZXVwIGFuZCBtb3VzZWRvd24gZXZlbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRSZW5kZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgaWYgKFxuICAgICAgICAhIWFjdGl2ZU9iamVjdCAhPT0gISF0YXJnZXQgfHxcbiAgICAgICAgKGFjdGl2ZU9iamVjdCAmJiB0YXJnZXQgJiYgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KSlcbiAgICAgICkge1xuICAgICAgICAvLyB0aGlzIGNvdmVyczogc3dpdGNoIG9mIHRhcmdldCwgZnJvbSB0YXJnZXQgdG8gbm8gdGFyZ2V0LCBzZWxlY3Rpb24gb2YgdGFyZ2V0XG4gICAgICAgIC8vIG11bHRpU2VsZWN0aW9uIHdpdGgga2V5IGFuZCBtb3VzZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIC8vIGlmIHdlIG1vdXNlIHVwL2Rvd24gb3ZlciBhIGVkaXRpbmcgdGV4dGJveCBhIGN1cnNvciBjaGFuZ2UsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUgcmVuZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3Rvciwgc2hvdWxkUmVuZGVyID0gZmFsc2UsXG4gICAgICAgICAgaXNDbGljayA9ICghZ3JvdXBTZWxlY3RvciB8fCAoZ3JvdXBTZWxlY3Rvci5sZWZ0ID09PSAwICYmIGdyb3VwU2VsZWN0b3IudG9wID09PSAwKSk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cDpiZWZvcmUnKTtcbiAgICAgIC8vIGlmIHJpZ2h0L21pZGRsZSBjbGljayBqdXN0IGZpcmUgZXZlbnRzIGFuZCByZXR1cm5cbiAgICAgIC8vIHRhcmdldCB1bmRlZmluZWQgd2lsbCBtYWtlIHRoZSBfaGFuZGxlRXZlbnQgc2VhcmNoIHRoZSB0YXJnZXRcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIFJJR0hUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIE1JRERMRV9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZU1pZGRsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgTUlERExFX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VVcEluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNDbGljaykge1xuICAgICAgICB2YXIgdGFyZ2V0V2FzQWN0aXZlID0gdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHRoaXMuX21heWJlR3JvdXBPYmplY3RzKGUpO1xuICAgICAgICBpZiAoIXNob3VsZFJlbmRlcikge1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IChcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQpIHx8XG4gICAgICAgICAgICAoIXRhcmdldFdhc0FjdGl2ZSAmJiB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29ybmVyLCBwb2ludGVyO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGFyZ2V0LmFjdGl2ZU9uID09PSAndXAnKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyID0gY29udHJvbCAmJiBjb250cm9sLmdldE1vdXNlVXBIYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgICAgaWYgKG1vdXNlVXBIYW5kbGVyKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICAgICAgbW91c2VVcEhhbmRsZXIoZSwgdHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIGVuZGluZyB1cCBhIHRyYW5zZm9ybSBvbiBhIGRpZmZlcmVudCBjb250cm9sIG9yIGEgbmV3IG9iamVjdFxuICAgICAgLy8gZmlyZSB0aGUgb3JpZ2luYWwgbW91c2UgdXAgZnJvbSB0aGUgY29ybmVyIHRoYXQgc3RhcnRlZCB0aGUgdHJhbnNmb3JtXG4gICAgICBpZiAodHJhbnNmb3JtICYmICh0cmFuc2Zvcm0udGFyZ2V0ICE9PSB0YXJnZXQgfHwgdHJhbnNmb3JtLmNvcm5lciAhPT0gY29ybmVyKSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb250cm9sID0gdHJhbnNmb3JtLnRhcmdldCAmJiB0cmFuc2Zvcm0udGFyZ2V0LmNvbnRyb2xzW3RyYW5zZm9ybS5jb3JuZXJdLFxuICAgICAgICAgICAgb3JpZ2luYWxNb3VzZVVwSGFuZGxlciA9IG9yaWdpbmFsQ29udHJvbCAmJiBvcmlnaW5hbENvbnRyb2wuZ2V0TW91c2VVcEhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICBvcmlnaW5hbE1vdXNlVXBIYW5kbGVyICYmIG9yaWdpbmFsTW91c2VVcEhhbmRsZXIoZSwgdHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIExFRlRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIC8vIHJlc2V0IHRoZSB0YXJnZXQgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEByZXR1cm4ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCByZXR1cm4gdGhlIHRoZSB0YXJnZXQgZm91bmQsIGZvciBpbnRlcm5hbCByZWFzb25zLlxuICAgICAqL1xuICAgIF9zaW1wbGVFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldE9iaiByZWNlaXZpbmcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2J1dHRvbl0gYnV0dG9uIHVzZWQgaW4gdGhlIGV2ZW50IDEgPSBsZWZ0LCAyID0gbWlkZGxlLCAzID0gcmlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xpY2sgZm9yIGxlZnQgYnV0dG9uIG9ubHksIGluZGljYXRlcyB0aGF0IHRoZSBtb3VzZSB1cCBoYXBwZW5lZCB3aXRob3V0IG1vdmUuXG4gICAgICovXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbihlLCBldmVudFR5cGUsIGJ1dHRvbiwgaXNDbGljaykge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgICAgYnV0dG9uOiBidXR0b24gfHwgTEVGVF9DTElDSyxcbiAgICAgICAgICAgIGlzQ2xpY2s6IGlzQ2xpY2sgfHwgZmFsc2UsXG4gICAgICAgICAgICBwb2ludGVyOiB0aGlzLl9wb2ludGVyLFxuICAgICAgICAgICAgYWJzb2x1dGVQb2ludGVyOiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm1cbiAgICAgICAgICB9O1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3VwJykge1xuICAgICAgICBvcHRpb25zLmN1cnJlbnRUYXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSk7XG4gICAgICAgIG9wdGlvbnMuY3VycmVudFN1YlRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOicgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHNlbmQgdGhlIG1vdXNlIGV2ZW50IHRoYXQgZ2VuZXJhdGUgdGhlIGZpbmFsaXplIGRvd24sIHNvIGl0IGNhbiBiZSB1c2VkIGluIHRoZSBldmVudFxuICAgICAqL1xuICAgIF9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBhY3Rpb246IHRyYW5zZm9ybS5hY3Rpb24sXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCAodGhpcy5zdGF0ZWZ1bCAmJiB0YXJnZXQuaGFzU3RhdGVDaGFuZ2VkKCkpKSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoJ21vZGlmaWVkJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlRG93bihwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlVXAoeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBjbGlja2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIGluaXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMgYW5kIHJlbmRlcnMgYWxsIHRoZVxuICAgICAqIGNhbnZhcyBzbyB0aGUgY3VycmVudCBpbWFnZSBjYW4gYmUgcGxhY2VkIG9uIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgcmVzdFxuICAgICAqIGluIG9uIHRoZSBjb250YWluZXIgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX19vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd246YmVmb3JlJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgLy8gaWYgcmlnaHQgY2xpY2sganVzdCBmaXJlIGV2ZW50c1xuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBSSUdIVF9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgTUlERExFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZ25vcmUgaWYgc29tZSBvYmplY3QgaXMgYmVpbmcgdHJhbnNmb3JtZWQgYXQgdGhpcyBtb21lbnRcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyO1xuICAgICAgLy8gc2F2ZSBwb2ludGVyIGZvciBjaGVjayBpbiBfX29uTW91c2VVcCBldmVudFxuICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyID0gcG9pbnRlcjtcbiAgICAgIHZhciBzaG91bGRSZW5kZXIgPSB0aGlzLl9zaG91bGRSZW5kZXIodGFyZ2V0KSxcbiAgICAgICAgICBzaG91bGRHcm91cCA9IHRoaXMuX3Nob3VsZEdyb3VwKGUsIHRhcmdldCk7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJTZWxlY3Rpb24oZSwgdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaG91bGRHcm91cCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVHcm91cGluZyhlLCB0YXJnZXQpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiAoIXRhcmdldCB8fFxuICAgICAgICAoIXRhcmdldC5zZWxlY3RhYmxlICYmICF0YXJnZXQuaXNFZGl0aW5nICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0KSkpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IHtcbiAgICAgICAgICBleDogdGhpcy5fYWJzb2x1dGVQb2ludGVyLngsXG4gICAgICAgICAgZXk6IHRoaXMuX2Fic29sdXRlUG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgdGFyZ2V0LmFjdGl2ZU9uID09PSAnZG93bicpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdCh0YXJnZXQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICB0YXJnZXQuX19jb3JuZXIgPSBjb3JuZXI7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiAoY29ybmVyIHx8ICFzaG91bGRHcm91cCkpIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpO1xuICAgICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgPSBjb250cm9sICYmIGNvbnRyb2wuZ2V0TW91c2VEb3duSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICAgIGlmIChtb3VzZURvd25IYW5kbGVyKSB7XG4gICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyKGUsIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJyk7XG4gICAgICAvLyB3ZSBtdXN0IHJlbmRlckFsbCBzbyB0aGF0IHdlIHVwZGF0ZSB0aGUgdmlzdWFsc1xuICAgICAgKHNob3VsZFJlbmRlciB8fCBzaG91bGRHcm91cCkgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IGNhY2hlIGZvcm0gY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9wb2ludGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIGV2ZW50XG4gICAgICovXG4gICAgX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyByZXNldCBpbiBvcmRlciB0byBhdm9pZCBzdGFsZSBjYWNoaW5nXG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQodGhpcy5fcG9pbnRlcik7XG4gICAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID8gdGhpcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQgOiB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlVHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIHQudGFyZ2V0LnNhdmVTdGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6dHJhbnNmb3JtJywge1xuICAgICAgICBlOiBlLFxuICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGhvdmVyaW5nIHRoZSBjYW52YXMuXG4gICAgICogVGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVyIHdpbGwgZGVmaW5lIHdoZXRoZXIgdGhlIHVzZXIgaXMgcm90YXRpbmcvc2NhbGluZy90cmFuc2xhdGluZ1xuICAgICAqIGFuIGltYWdlIG9yIG5laXRoZXIgb2YgdGhlbSAob25seSBob3ZlcmluZykuIEEgZ3JvdXAgc2VsZWN0aW9uIGlzIGFsc28gcG9zc2libGUgYW5kIHdvdWxkIGNhbmNlbFxuICAgICAqIGFsbCBhbnkgb3RoZXIgdHlwZSBvZiBhY3Rpb24uXG4gICAgICogSW4gY2FzZSBvZiBhbiBpbWFnZSB0cmFuc2Zvcm1hdGlvbiBvbmx5IHRoZSB0b3AgY2FudmFzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmU6YmVmb3JlJyk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuX2Fic29sdXRlUG9pbnRlcjtcblxuICAgICAgICBncm91cFNlbGVjdG9yLmxlZnQgPSBwb2ludGVyLnggLSBncm91cFNlbGVjdG9yLmV4O1xuICAgICAgICBncm91cFNlbGVjdG9yLnRvcCA9IHBvaW50ZXIueSAtIGdyb3VwU2VsZWN0b3IuZXk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fZmlyZU92ZXJPdXRFdmVudHModGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PYmplY3QoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBtb3VzZW91dCwgbW91c2VvdmVyIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlT3Zlck91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgX2hvdmVyZWRUYXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXQsXG4gICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgY2FudmFzRXZ0T3V0OiAnbW91c2U6b3V0JyxcbiAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICBjYW52YXNFdnRJbjogJ21vdXNlOm92ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgICBldnRJbjogJ21vdXNlb3ZlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIGRyYWdFbnRlciwgZHJhZ0xlYXZlIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgb25EcmFnIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gb25kcmFnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUVudGVyTGVhdmVFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICBldnRJbjogJ2RyYWdlbnRlcicsXG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ2RyYWdsZWF2ZScsXG4gICAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIHN5bnRoZXRpYyBpbi9vdXQgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBzdXBwb3J0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiB0byB3b3JrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50YXJnZXROYW1lIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgd2hlcmUgdGhlIG9sZCB0YXJnZXQgaXMgc3RvcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0T3V0XSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ldnRPdXQgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0SW5dIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgYXQgY2FudmFzIGxldmVsIGZvciBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0SW4gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3IgaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNJbk91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlLCBjb25maWcpIHtcbiAgICAgIHZhciBpbk9wdCwgb3V0T3B0LCBvbGRUYXJnZXQgPSBjb25maWcub2xkVGFyZ2V0LCBvdXRGaXJlcywgaW5GaXJlcyxcbiAgICAgICAgICB0YXJnZXRDaGFuZ2VkID0gb2xkVGFyZ2V0ICE9PSB0YXJnZXQsIGNhbnZhc0V2dEluID0gY29uZmlnLmNhbnZhc0V2dEluLCBjYW52YXNFdnRPdXQgPSBjb25maWcuY2FudmFzRXZ0T3V0O1xuICAgICAgaWYgKHRhcmdldENoYW5nZWQpIHtcbiAgICAgICAgaW5PcHQgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBwcmV2aW91c1RhcmdldDogb2xkVGFyZ2V0IH07XG4gICAgICAgIG91dE9wdCA9IHsgZTogZSwgdGFyZ2V0OiBvbGRUYXJnZXQsIG5leHRUYXJnZXQ6IHRhcmdldCB9O1xuICAgICAgfVxuICAgICAgaW5GaXJlcyA9IHRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgb3V0RmlyZXMgPSBvbGRUYXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIGlmIChvdXRGaXJlcykge1xuICAgICAgICBjYW52YXNFdnRPdXQgJiYgdGhpcy5maXJlKGNhbnZhc0V2dE91dCwgb3V0T3B0KTtcbiAgICAgICAgb2xkVGFyZ2V0LmZpcmUoY29uZmlnLmV2dE91dCwgb3V0T3B0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbkZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dEluICYmIHRoaXMuZmlyZShjYW52YXNFdnRJbiwgaW5PcHQpO1xuICAgICAgICB0YXJnZXQuZmlyZShjb25maWcuZXZ0SW4sIGluT3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyBhY3Rpb25zIHdoZW4gYW4gRXZlbnQgTW91c2UgV2hlZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3doZWVsJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX3RyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0uc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgICAgdHJhbnNmb3JtLmFsdEtleSA9IGVbdGhpcy5jZW50ZXJlZEtleV07XG5cbiAgICAgIHRoaXMuX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKTtcbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb246IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcikge1xuICAgICAgdmFyIHggPSBwb2ludGVyLngsXG4gICAgICAgICAgeSA9IHBvaW50ZXIueSxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlLFxuICAgICAgICAgIGFjdGlvbkhhbmRsZXIgPSB0cmFuc2Zvcm0uYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAvLyB0aGlzIG9iamVjdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIGZ1bmN0aW9uIGluIHRoZSBjb250cm9sIGhhbmRsZXJzXG5cblxuICAgICAgaWYgKGFjdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2RyYWcnICYmIGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICB0cmFuc2Zvcm0udGFyZ2V0LmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodHJhbnNmb3JtLnRhcmdldC5tb3ZlQ3Vyc29yIHx8IHRoaXMubW92ZUN1cnNvcik7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmU6IGZhYnJpYy5jb250cm9sc1V0aWxzLmZpcmVFdmVudCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnNvciBkZXBlbmRpbmcgb24gd2hlcmUgdGhlIGNhbnZhcyBpcyBiZWluZyBob3ZlcmVkLlxuICAgICAqIE5vdGU6IHZlcnkgYnVnZ3kgaW4gT3BlcmFcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRoYXQgdGhlIG1vdXNlIGlzIGhvdmVyaW5nLCBpZiBzby5cbiAgICAgKi9cbiAgICBfc2V0Q3Vyc29yRnJvbUV2ZW50OiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaG92ZXJDdXJzb3IgPSB0YXJnZXQuaG92ZXJDdXJzb3IgfHwgdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgICBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nID9cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA6IG51bGwsXG4gICAgICAgICAgLy8gb25seSBzaG93IHByb3BlciBjb3JuZXIgd2hlbiBncm91cCBzZWxlY3Rpb24gaXMgbm90IGFjdGl2ZVxuICAgICAgICAgIGNvcm5lciA9ICghYWN0aXZlU2VsZWN0aW9uIHx8ICFhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSlcbiAgICAgICAgICAvLyBoZXJlIHdlIGNhbGwgZmluZFRhcmdldENvcm5lciBhbHdheXMgd2l0aCB1bmRlZmluZWQgZm9yIHRoZSB0b3VjaCBwYXJhbWV0ZXIuXG4gICAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgaWYgeW91IGFyZSB1c2luZyBhIGN1cnNvciB5b3UgZG8gbm90IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICAgICAgICAgIC8vIHRoZSBiaWdnZXIgdG91Y2ggYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgJiYgdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSk7XG5cbiAgICAgIGlmICghY29ybmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2spe1xuICAgICAgICAgIC8vIGhvdmVyQ3Vyc29yIHNob3VsZCBjb21lIGZyb20gdG9wLW1vc3Qgc3ViVGFyZ2V0LFxuICAgICAgICAgIC8vIHNvIHdlIHdhbGsgdGhlIGFycmF5IGJhY2t3YXJkc1xuICAgICAgICAgIHRoaXMudGFyZ2V0cy5jb25jYXQoKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKF90YXJnZXQpe1xuICAgICAgICAgICAgaG92ZXJDdXJzb3IgPSBfdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IGhvdmVyQ3Vyc29yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKGhvdmVyQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmdldENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldENvcm5lckN1cnNvcjogZnVuY3Rpb24oY29ybmVyLCB0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl07XG4gICAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZUhhbmRsZXIoZSwgY29udHJvbCwgdGFyZ2V0KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9zaG91bGRHcm91cDogZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdCAmJiB0aGlzLl9pc1NlbGVjdGlvbktleVByZXNzZWQoZSkgJiYgdGFyZ2V0ICYmIHRhcmdldC5zZWxlY3RhYmxlICYmIHRoaXMuc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAoYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQgfHwgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSAmJiAhdGFyZ2V0Lm9uU2VsZWN0KHsgZTogZSB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2hhbmRsZUdyb3VwaW5nOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgLy8gYXZvaWQgbXVsdGkgc2VsZWN0IHdoZW4gc2hpZnQgY2xpY2sgb24gYSBjb3JuZXJcbiAgICAgIGlmIChhY3RpdmVPYmplY3QuX19jb3JuZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldCA9PT0gYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBncm91cCwgZmluZCB0YXJnZXQgYWdhaW4sIHVzaW5nIGFjdGl2ZUdyb3VwIG9iamVjdHNcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUsIHRydWUpO1xuICAgICAgICAvLyBpZiBldmVuIG9iamVjdCBpcyBub3QgZm91bmQgb3Igd2UgYXJlIG9uIGFjdGl2ZU9iamVjdENvcm5lciwgYmFpbCBvdXRcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgY3VycmVudEFjdGl2ZU9iamVjdHMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLnJlbW92ZVdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICAgIGlmIChhY3RpdmVTZWxlY3Rpb24uc2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgLy8gYWN0aXZhdGUgbGFzdCByZW1haW5pbmcgb2JqZWN0XG4gICAgICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KGFjdGl2ZVNlbGVjdGlvbi5pdGVtKDApLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFjdGl2ZVNlbGVjdGlvbi5hZGRXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlT2JqZWN0cywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgZ3JvdXAgPSB0aGlzLl9jcmVhdGVHcm91cCh0YXJnZXQpO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGdyb3VwO1xuICAgICAgLy8gSVNTVUUgNDExNTogc2hvdWxkIHdlIGNvbnNpZGVyIHN1YlRhcmdldHMgaGVyZT9cbiAgICAgIC8vIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICAvLyB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChncm91cCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2NyZWF0ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICAgICAgICBpc0FjdGl2ZUxvd2VyID0gb2JqZWN0cy5pbmRleE9mKHRoaXMuX2FjdGl2ZU9iamVjdCkgPCBvYmplY3RzLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgICAgICBncm91cE9iamVjdHMgPSBpc0FjdGl2ZUxvd2VyXG4gICAgICAgICAgICA/IFt0aGlzLl9hY3RpdmVPYmplY3QsIHRhcmdldF1cbiAgICAgICAgICAgIDogW3RhcmdldCwgdGhpcy5fYWN0aXZlT2JqZWN0XTtcbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5pc0VkaXRpbmcgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmV4aXRFZGl0aW5nKCk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZ3JvdXBPYmplY3RzLCB7XG4gICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqL1xuICAgIF9ncm91cFNlbGVjdGVkT2JqZWN0czogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5fY29sbGVjdE9iamVjdHMoZSksXG4gICAgICAgICAgYUdyb3VwO1xuXG4gICAgICAvLyBkbyBub3QgY3JlYXRlIGdyb3VwIGZvciAxIGVsZW1lbnQgb25seVxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChncm91cFswXSwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFHcm91cCA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwLnJldmVyc2UoKSwge1xuICAgICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoYUdyb3VwLCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29sbGVjdE9iamVjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIGN1cnJlbnRPYmplY3QsXG4gICAgICAgICAgeDEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV4LFxuICAgICAgICAgIHkxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leSxcbiAgICAgICAgICB4MiA9IHgxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci5sZWZ0LFxuICAgICAgICAgIHkyID0geTEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBzZWxlY3Rpb25YMVkxID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oeDEsIHgyKSwgbWluKHkxLCB5MikpLFxuICAgICAgICAgIHNlbGVjdGlvblgyWTIgPSBuZXcgZmFicmljLlBvaW50KG1heCh4MSwgeDIpLCBtYXgoeTEsIHkyKSksXG4gICAgICAgICAgYWxsb3dJbnRlcnNlY3QgPSAhdGhpcy5zZWxlY3Rpb25GdWxseUNvbnRhaW5lZCxcbiAgICAgICAgICBpc0NsaWNrID0geDEgPT09IHgyICYmIHkxID09PSB5MjtcbiAgICAgIC8vIHdlIGl0ZXJhdGUgcmV2ZXJzZSBvcmRlciB0byBjb2xsZWN0IHRvcCBmaXJzdCBpbiBjYXNlIG9mIGNsaWNrLlxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjdXJyZW50T2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRPYmplY3QgfHwgIWN1cnJlbnRPYmplY3Quc2VsZWN0YWJsZSB8fCAhY3VycmVudE9iamVjdC52aXNpYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuaW50ZXJzZWN0c1dpdGhSZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIsIHRydWUpKSB8fFxuICAgICAgICAgICAgY3VycmVudE9iamVjdC5pc0NvbnRhaW5lZFdpdGhpblJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMiwgdHJ1ZSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDFZMSwgbnVsbCwgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgyWTIsIG51bGwsIHRydWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICBncm91cC5wdXNoKGN1cnJlbnRPYmplY3QpO1xuICAgICAgICAgIC8vIG9ubHkgYWRkIG9uZSBvYmplY3QgaWYgaXQncyBhIGNsaWNrXG4gICAgICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICBncm91cCA9IGdyb3VwLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gIW9iamVjdC5vblNlbGVjdCh7IGU6IGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21heWJlR3JvdXBPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGVkT2JqZWN0cyhlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAvLyBjbGVhciBzZWxlY3Rpb24gYW5kIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNhbnZhcyBlbGVtZW50IHRvIGEgZGF0YXVybCBpbWFnZS4gTm90ZSB0aGF0IHdoZW4gbXVsdGlwbGllciBpcyB1c2VkLCBjcm9wcGluZyBpcyBzY2FsZWQgYXBwcm9wcmlhdGVseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieSwgdG8gaGF2ZSBjb25zaXN0ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDIuMC4wXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9OZlpWYi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBqcGVnIGRhdGFVUkwgd2l0aCBsb3dlciBxdWFsaXR5PC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgKiAgIHF1YWxpdHk6IDAuOFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGNyb3BwZWQgcG5nIGRhdGFVUkwgKGNsaXBwaW5nIG9mIGNhbnZhcyk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBsZWZ0OiAxMDAsXG4gICAgICogICB0b3A6IDEwMCxcbiAgICAgKiAgIHdpZHRoOiAyMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGRvdWJsZSBzY2FsZWQgcG5nIGRhdGFVUkw8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBtdWx0aXBsaWVyOiAyXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCAncG5nJyxcbiAgICAgICAgICBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5IHx8IDEsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gdGhpcy5nZXRSZXRpbmFTY2FsaW5nKCkgOiAxKSxcbiAgICAgICAgICBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG11bHRpcGxpZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRGF0YVVSTChjYW52YXNFbCwgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEhUTUxDYW52YXMgZWxlbWVudCBwYWludGVkIHdpdGggdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRlbnQuXG4gICAgICogTm8gbmVlZCB0byByZXNpemUgdGhlIGFjdHVhbCBvbmUgb3IgcmVwYWludCBpdC5cbiAgICAgKiBXaWxsIHRyYW5zZmVyIG9iamVjdCBvd25lcnNoaXAgdG8gYSBuZXcgY2FudmFzLCBwYWludCBpdCwgYW5kIHNldCBldmVyeXRoaW5nIGJhY2suXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCB1c2VkIHRvIGdldCB0byBhIGRhdGFVcmwgYnV0IGFsc28gaXQgaXMgdXNlZnVsIHRvXG4gICAgICogY3JlYXRlIHF1aWNrIGltYWdlIGNvcGllcyBvZiBhIGNhbnZhcyB3aXRob3V0IHBhc3NpbmcgZm9yIHRoZSBkYXRhVXJsIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbXVsdGlwbGllcl0gYSB6b29tIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3BwaW5nXSBDcm9wcGluZyBpbmZvcm1hdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcud2lkdGhdIENyb3BwaW5nIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuXG4gICAgICovXG4gICAgdG9DYW52YXNFbGVtZW50OiBmdW5jdGlvbihtdWx0aXBsaWVyLCBjcm9wcGluZykge1xuICAgICAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgfHwgMTtcbiAgICAgIGNyb3BwaW5nID0gY3JvcHBpbmcgfHwgeyB9O1xuICAgICAgdmFyIHNjYWxlZFdpZHRoID0gKGNyb3BwaW5nLndpZHRoIHx8IHRoaXMud2lkdGgpICogbXVsdGlwbGllcixcbiAgICAgICAgICBzY2FsZWRIZWlnaHQgPSAoY3JvcHBpbmcuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgbmV3Wm9vbSA9IHpvb20gKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHZwID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSxcbiAgICAgICAgICB0cmFuc2xhdGVYID0gKHZwWzRdIC0gKGNyb3BwaW5nLmxlZnQgfHwgMCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICB0cmFuc2xhdGVZID0gKHZwWzVdIC0gKGNyb3BwaW5nLnRvcCB8fCAwKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgPSB0aGlzLmludGVyYWN0aXZlLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIG9yaWdpbmFsUmV0aW5hID0gdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIG9yaWdpbmFsQ29udGV4dFRvcCA9IHRoaXMuY29udGV4dFRvcDtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gbmV3VnA7XG4gICAgICB0aGlzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSwgdGhpcy5fb2JqZWN0cyk7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICB0aGlzLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBvcmlnaW5hbEludGVyYWN0aXZlO1xuICAgICAgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nID0gb3JpZ2luYWxSZXRpbmE7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBvcmlnaW5hbENvbnRleHRUb3A7XG4gICAgICByZXR1cm4gY2FudmFzRWw7XG4gICAgfSxcbiAgfSk7XG5cbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9KU09OfVxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gSlNPTiBzdHJpbmcgb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLCBpbnZva2VkIHdoZW4ganNvbiBpcyBwYXJzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGNvcnJlc3BvbmRpbmcgb2JqZWN0cyAoZS5nOiB7QGxpbmsgZmFicmljLkltYWdlfSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIGluaXRpYWxpemVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBKU09OIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZGVzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2ZtZ1h0L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT048L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT04gd2l0aCByZXZpdmVyPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCBmdW5jdGlvbihvLCBvYmplY3QpIHtcbiAgICogICAvLyBgb2AgPSBqc29uIG9iamVjdFxuICAgKiAgIC8vIGBvYmplY3RgID0gZmFicmljLk9iamVjdCBpbnN0YW5jZVxuICAgKiAgIC8vIC4uLiBkbyBzb21lIHN0dWZmIC4uLlxuICAgKiB9KTtcbiAgICovXG4gIGxvYWRGcm9tSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2VyaWFsaXplIGlmIGl0IHdhc24ndCBhbHJlYWR5XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxuICAgICAgPyBKU09OLnBhcnNlKGpzb24pXG4gICAgICA6IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShqc29uKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGNsaXBQYXRoID0gc2VyaWFsaXplZC5jbGlwUGF0aCxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlO1xuXG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuY2xpcFBhdGg7XG5cbiAgICB0aGlzLl9lbmxpdmVuT2JqZWN0cyhzZXJpYWxpemVkLm9iamVjdHMsIGZ1bmN0aW9uIChlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBfdGhpcy5jbGVhcigpO1xuICAgICAgX3RoaXMuX3NldEJnT3ZlcmxheShzZXJpYWxpemVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgIF90aGlzLl9lbmxpdmVuT2JqZWN0cyhbY2xpcFBhdGhdLCBmdW5jdGlvbiAoZW5saXZlbmVkQ2FudmFzQ2xpcCkge1xuICAgICAgICAgICAgX3RoaXMuY2xpcFBhdGggPSBlbmxpdmVuZWRDYW52YXNDbGlwWzBdO1xuICAgICAgICAgICAgX3RoaXMuX19zZXR1cENhbnZhcy5jYWxsKF90aGlzLCBzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9fc2V0dXBDYW52YXMuY2FsbChfdGhpcywgc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgcmV2aXZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdG9yZWQgY2FudmFzIG9iamVjdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FjaGVkIHJlbmRlck9uQWRkUmVtb3ZlIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgYWZ0ZXIgYWxsIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW1hZ2VzL3BhdHRlcm5zIGxvYWRlZFxuICAgKi9cbiAgX19zZXR1cENhbnZhczogZnVuY3Rpb24oc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBlbmxpdmVuZWRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpbmRleCkge1xuICAgICAgLy8gd2Ugc3BsaWNlIHRoZSBhcnJheSBqdXN0IGluIGNhc2Ugc29tZSBjdXN0b20gY2xhc3NlcyByZXN0b3JlZCBmcm9tIEpTT05cbiAgICAgIC8vIHdpbGwgYWRkIG1vcmUgb2JqZWN0IHRvIGNhbnZhcyBhdCBjYW52YXMgaW5pdC5cbiAgICAgIF90aGlzLmluc2VydEF0KG9iaiwgaW5kZXgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgPSByZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAvLyByZW1vdmUgcGFydHMgaSBjYW5ub3Qgc2V0IGFzIG9wdGlvbnNcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vYmplY3RzO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2U7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuYmFja2dyb3VuZDtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgIC8vIHRoaXMuX2luaXRPcHRpb25zIGRvZXMgdG9vIG1hbnkgdGhpbmdzIHRvIGp1c3RcbiAgICAvLyBjYWxsIGl0LiBOb3JtYWxseSBsb2FkaW5nIGFuIE9iamVjdCBmcm9tIEpTT05cbiAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgLy8gYWxyZWFkeSBhbiBpbnN0YW5jZSBhbmQgd2UgYXJlIGp1c3QgbG9hZGluZyB0aGluZ3Mgb3ZlciBpdFxuICAgIHRoaXMuX3NldE9wdGlvbnMoc2VyaWFsaXplZCk7XG4gICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgYWZ0ZXIgYWxsIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW1hZ2VzL3BhdHRlcm5zIGxvYWRlZFxuICAgKi9cbiAgX3NldEJnT3ZlcmxheTogZnVuY3Rpb24oc2VyaWFsaXplZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgbG9hZGVkID0ge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBmYWxzZSxcbiAgICAgIG92ZXJsYXlDb2xvcjogZmFsc2UsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGZhbHNlLFxuICAgICAgb3ZlcmxheUltYWdlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoIXNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlICYmICFzZXJpYWxpemVkLm92ZXJsYXlJbWFnZSAmJiAhc2VyaWFsaXplZC5iYWNrZ3JvdW5kICYmICFzZXJpYWxpemVkLm92ZXJsYXkpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNiSWZMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobG9hZGVkLmJhY2tncm91bmRJbWFnZSAmJiBsb2FkZWQub3ZlcmxheUltYWdlICYmIGxvYWRlZC5iYWNrZ3JvdW5kQ29sb3IgJiYgbG9hZGVkLm92ZXJsYXlDb2xvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kSW1hZ2UnLCBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5SW1hZ2UnLCBzZXJpYWxpemVkLm92ZXJsYXlJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kQ29sb3InLCBzZXJpYWxpemVkLmJhY2tncm91bmQsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUNvbG9yJywgc2VyaWFsaXplZC5vdmVybGF5LCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0IChiYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXlJbWFnZSwgYmFja2dyb3VuZENvbG9yLCBvdmVybGF5Q29sb3IpXG4gICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmcpfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvYWRlZCBTZXQgbG9hZGVkIHByb3BlcnR5IHRvIHRydWUgaWYgcHJvcGVydHkgaXMgc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgcHJvcGVydHkgaXMgc2V0XG4gICAqL1xuICBfX3NldEJnT3ZlcmxheTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlLCBsb2FkZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHkgPT09ICdiYWNrZ3JvdW5kSW1hZ2UnIHx8IHByb3BlcnR5ID09PSAnb3ZlcmxheUltYWdlJykge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW3ZhbHVlXSwgZnVuY3Rpb24oZW5saXZlZE9iamVjdCl7XG4gICAgICAgIF90aGlzW3Byb3BlcnR5XSA9IGVubGl2ZWRPYmplY3RbMF07XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1snc2V0JyArIGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKHByb3BlcnR5LCB0cnVlKV0odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl1cbiAgICovXG4gIF9lbmxpdmVuT2JqZWN0czogZnVuY3Rpb24gKG9iamVjdHMsIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgaWYgKCFvYmplY3RzIHx8IG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgfSwgbnVsbCwgcmV2aXZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF90b0RhdGFVUkw6IGZ1bmN0aW9uIChmb3JtYXQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTChmb3JtYXQpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbXVsdGlwbGllclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyOiBmdW5jdGlvbiAoZm9ybWF0LCBtdWx0aXBsaWVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2xvbmUoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICBjYWxsYmFjayhjbG9uZS50b0RhdGFVUkxXaXRoTXVsdGlwbGllcihmb3JtYXQsIG11bHRpcGxpZXIpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIGNhbnZhcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc10gQXJyYXkgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIGluIHRoZSBjbG9uZWQgY2FudmFzIGFuZCBjaGlsZHJlblxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJvcGVydGllcykge1xuICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04ocHJvcGVydGllcykpO1xuICAgIHRoaXMuY2xvbmVXaXRob3V0RGF0YShmdW5jdGlvbihjbG9uZSkge1xuICAgICAgY2xvbmUubG9hZEZyb21KU09OKGRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIGNhbnZhcyBpbnN0YW5jZSB3aXRob3V0IGNsb25pbmcgZXhpc3RpbmcgZGF0YS5cbiAgICogVGhpcyBlc3NlbnRpYWxseSBjb3BpZXMgY2FudmFzIGRpbWVuc2lvbnMsIGNsaXBwaW5nIHByb3BlcnRpZXMsIGV0Yy5cbiAgICogYnV0IGxlYXZlcyBkYXRhIGVtcHR5IChzbyB0aGF0IHlvdSBjYW4gcG9wdWxhdGUgaXQgd2l0aCB5b3VyIG93bilcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gUmVjZWl2ZXMgY2xvbmVkIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGNsb25lV2l0aG91dERhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgZWwud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGVsLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdmFyIGNsb25lID0gbmV3IGZhYnJpYy5DYW52YXMoZWwpO1xuICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgY2xvbmUuc2V0QmFja2dyb3VuZEltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlLnNyYywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsb25lLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZU9wYWNpdHkgPSB0aGlzLmJhY2tncm91bmRJbWFnZU9wYWNpdHk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBjYXBpdGFsaXplID0gZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9iamVjdENhY2hpbmcgPSAhZmFicmljLmlzTGlrZWx5Tm9kZSxcbiAgICAgIEFMSUFTSU5HX0xJTUlUID0gMjtcblxuICBpZiAoZmFicmljLk9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb290IG9iamVjdCBjbGFzcyBmcm9tIHdoaWNoIGFsbCAyZCBzaGFwZSBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICAgKiBAY2xhc3MgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNvYmplY3RzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBhZGRlZFxuICAgKiBAZmlyZXMgcmVtb3ZlZFxuICAgKlxuICAgKiBAZmlyZXMgc2VsZWN0ZWRcbiAgICogQGZpcmVzIGRlc2VsZWN0ZWRcbiAgICogQGZpcmVzIG1vZGlmaWVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW92ZWRcbiAgICogQGZpcmVzIHNjYWxlZFxuICAgKiBAZmlyZXMgcm90YXRlZFxuICAgKiBAZmlyZXMgc2tld2VkXG4gICAqXG4gICAqIEBmaXJlcyByb3RhdGluZ1xuICAgKiBAZmlyZXMgc2NhbGluZ1xuICAgKiBAZmlyZXMgbW92aW5nXG4gICAqIEBmaXJlcyBza2V3aW5nXG4gICAqXG4gICAqIEBmaXJlcyBtb3VzZWRvd25cbiAgICogQGZpcmVzIG1vdXNldXBcbiAgICogQGZpcmVzIG1vdXNlb3ZlclxuICAgKiBAZmlyZXMgbW91c2VvdXRcbiAgICogQGZpcmVzIG1vdXNld2hlZWxcbiAgICogQGZpcmVzIG1vdXNlZGJsY2xpY2tcbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcFxuICAgKi9cbiAgZmFicmljLk9iamVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0IChyZWN0LCBjaXJjbGUsIHBhdGgsIGV0Yy4pLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIG1lYW50IHRvIGJlIHJlYWQtb25seSBhbmQgbm90IG1lYW50IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIElmIHlvdSBtb2RpZnksIGNlcnRhaW4gcGFydHMgb2YgRmFicmljIChzdWNoIGFzIEpTT04gbG9hZGluZykgd29uJ3Qgd29yayBjb3JyZWN0bHkuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzI0NC8gb24gaG93IG9yaWdpblgvb3JpZ2luWSBhZmZlY3Qgb2JqZWN0cyBpbiBncm91cHNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9yaWdpblk6ICAgICAgICAgICAgICAgICAgJ3RvcCcsXG5cbiAgICAvKipcbiAgICAgKiBUb3AgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCB0b3AuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5ZPXt0b3AvY2VudGVyL2JvdHRvbX1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIExlZnQgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCBsZWZ0LiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWD17bGVmdC9jZW50ZXIvcmlnaHR9XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKGhvcml6b250YWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yICh2ZXJ0aWNhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgaG9yaXpvbnRhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgdmVydGljYWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygcm90YXRpb24gb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB4IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB5IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTaXplOiAgICAgICAgICAgICAgIDEzLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIHdoZW4gdG91Y2ggaW50ZXJhY3Rpb24gaXMgZGV0ZWN0ZWRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvdWNoQ29ybmVyU2l6ZTogICAgICAgICAgICAgICAyNCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2IoMTc4LDIwNCwyNTUpJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlIGFuZCB0cmFuc3BhcmVudENvcm5lcnMgZmFsc2UpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTdHJva2VDb2xvcjogICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0eWxlIG9mIGNvbnRyb2wsICdyZWN0JyBvciAnY2lyY2xlJ1xuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGNvcm5lclN0eWxlOiAgICAgICAgICAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBjb250cm9sIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29ybmVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgc2NhbGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgcm90YXRlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygb2JqZWN0J3MgZmlsbFxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHJ1bGUgdXNlZCB0byBmaWxsIGFuIG9iamVjdFxuICAgICAqIGFjY2VwdGVkIHZhbHVlcyBhcmUgbm9uemVybywgZXZlbm9kZFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIHVzZWQgZm9yIHNldHRpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHVudGlsIHYxLjQuMTIgKHVzZSBgZmFicmljLk9iamVjdCNnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25gIGluc3RlYWQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgICdub256ZXJvJyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSBydWxlIHVzZWQgZm9yIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogJ3NvdXJjZS1vdmVyJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LlxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvbiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC4gY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCB3aGVuIGl0IGlzIGFjdGl2ZS5cbiAgICAgKiBkb2VzIG5vdCBtaXggZ29vZCB3aXRoIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBtZXRob2RzLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvclxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UgdXNlZCB0byByZW5kZXIgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAoc3Ryb2tlIG11c3QgYmUgZGVmaW5lZClcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgb2Zmc2V0IG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICAnYnV0dCcsXG5cbiAgICAvKipcbiAgICAgKiBDb3JuZXIgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgJ21pdGVyJyxcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDQsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyB3aGVuIG9iamVjdCBpcyBhY3RpdmUgYW5kIG1vdmluZ1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6ICAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3Igb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVyc1xuICAgICAqIGJpZ2dlciBudW1iZXIgd2lsbCBtYWtlIGEgdGhpY2tlciBib3JkZXJcbiAgICAgKiBib3JkZXIgaXMgMSwgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBib3JkZXIgdGhpY2tuZXNzXG4gICAgICogc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIGNoYW5nZSB0aGUgYm9yZGVyIGl0c2VsZi5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlclNjYWxlRmFjdG9yOiAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblNjYWxlTGltaXQ6ICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIHNlbGVjdGVkIGZvciBtb2RpZmljYXRpb24gKHVzaW5nIGVpdGhlciBwb2ludC1jbGljay1iYXNlZCBvciBncm91cC1iYXNlZCBzZWxlY3Rpb24pLlxuICAgICAqIEJ1dCBldmVudHMgc3RpbGwgZmlyZSBvbiBpdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBhIHRhcmdldCBvZiBldmVudHMuIEFsbCBldmVudHMgcHJvcGFnYXRlIHRocm91Z2ggaXQuIEludHJvZHVjZWQgaW4gdjEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXZlbnRlZDogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGlzIG5vdCByZW5kZXJlZCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9scyBhcmUgbm90IGRpc3BsYXllZCBhbmQgY2FuIG5vdCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgb2JqZWN0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQ29udHJvbHM6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyBhcmUgbm90IHJlbmRlcmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQm9yZGVyczogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3RzIGFyZSBcImZvdW5kXCIgb24gY2FudmFzIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBhY2NvcmRpbmcgdG8gYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgZGVmYXVsdCBvYmplY3QncyB2YWx1ZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiBpdHMgc2VyaWFsaXphdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRYOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRZOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCByb3RhdGlvbiBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrUm90YXRpb246ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXhjbHVkZUZyb21FeHBvcnQ6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgY2FjaGVkIG9uIGFuIGFkZGl0aW9uYWwgY2FudmFzLlxuICAgICAqIFdoZW4gYGZhbHNlYCwgb2JqZWN0IGlzIG5vdCBjYWNoZWQgdW5sZXNzIG5lY2Vzc2FyeSAoIGNsaXBQYXRoIClcbiAgICAgKiBkZWZhdWx0IHRvIHRydWVcbiAgICAgKiBAc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzdG9rZSB3aWR0aCB3aWxsIHNjYWxlIHdpdGggdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHN0cm9rZSB3aWxsIGFsd2F5cyBtYXRjaCB0aGUgZXhhY3QgcGl4ZWwgc2l6ZSBlbnRlcmVkIGZvciBzdHJva2Ugd2lkdGguXG4gICAgICogdGhpcyBQcm9wZXJ0eSBkb2VzIG5vdCB3b3JrIG9uIFRleHQgY2xhc3NlcyBvciBkcmF3aW5nIGNhbGwgdGhhdCB1c2VzIHN0cm9rZVRleHQsZmlsbFRleHQgbWV0aG9kc1xuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdHJva2VVbmlmb3JtOiAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvcm5lciBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgKiAwIGlzIG5vIGNvcm5lciwgb3IgJ210JywgJ21sJywgJ210cicgZXRjLi5cbiAgICAgKiBJdCBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IHRoZXJlIGlzIG5vIGhhcm0gaW4gdXNpbmcgaXQgYXNcbiAgICAgKiBhIHJlYWQtb25seSBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSBudW1iZXJ8c3RyaW5nfGFueVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX2Nvcm5lcjogMCxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZpbGwgb3IgdGhlIHN0cm9rZSBpcyBkcmF3biBmaXJzdCAob25lIG9mIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWludEZpcnN0OiAgICAgICAgICAgJ2ZpbGwnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiAnZG93bicsIG9iamVjdCBpcyBzZXQgdG8gYWN0aXZlIG9uIG1vdXNlZG93bi90b3VjaHN0YXJ0XG4gICAgICogV2hlbiAndXAnLCBvYmplY3QgaXMgc2V0IHRvIGFjdGl2ZSBvbiBtb3VzZXVwL3RvdWNoZW5kXG4gICAgICogRXhwZXJpbWVudGFsLiBMZXQncyBzZWUgaWYgdGhpcyBicmVha3MgYW55dGhpbmcgYmVmb3JlIHN1cHBvcnRpbmcgb2ZmaWNpYWxseVxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2luY2UgNC40LjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnZG93bidcbiAgICAgKi9cbiAgICBhY3RpdmVPbjogICAgICAgICAgICdkb3duJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlXG4gICAgICogb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkKVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogKFxuICAgICAgJ3RvcCBsZWZ0IHdpZHRoIGhlaWdodCBzY2FsZVggc2NhbGVZIGZsaXBYIGZsaXBZIG9yaWdpblggb3JpZ2luWSB0cmFuc2Zvcm1NYXRyaXggJyArXG4gICAgICAnc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSBzdHJva2VMaW5lQ2FwIHN0cm9rZURhc2hPZmZzZXQgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCAnICtcbiAgICAgICdhbmdsZSBvcGFjaXR5IGZpbGwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHNoYWRvdyB2aXNpYmxlIGJhY2tncm91bmRDb2xvciAnICtcbiAgICAgICdza2V3WCBza2V3WSBmaWxsUnVsZSBwYWludEZpcnN0IGNsaXBQYXRoIHN0cm9rZVVuaWZvcm0nXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIFRob3NlIHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgYnkgc3RhdGVmdWxsQ2FjaGUgT04gKCBvciBsYXp5IG1vZGUgaWYgd2Ugd2FudCApIG9yIGZyb20gc2luZ2xlXG4gICAgICogY2FsbHMgdG8gT2JqZWN0LnNldChrZXksIHZhbHVlKS4gSWYgdGhlIGtleSBpcyBpbiB0aGlzIGxpc3QsIHRoZSBvYmplY3QgaXMgbWFya2VkIGFzIGRpcnR5XG4gICAgICogYW5kIHJlZnJlc2hlZCBhdCB0aGUgbmV4dCByZW5kZXJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogKFxuICAgICAgJ2ZpbGwgc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSB3aWR0aCBoZWlnaHQgcGFpbnRGaXJzdCBzdHJva2VVbmlmb3JtJyArXG4gICAgICAnIHN0cm9rZUxpbmVDYXAgc3Ryb2tlRGFzaE9mZnNldCBzdHJva2VMaW5lSm9pbiBzdHJva2VNaXRlckxpbWl0IGJhY2tncm91bmRDb2xvciBjbGlwUGF0aCdcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgZm9yIGFuaW1hdGluZyBjb2xvcnMuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb2xvclByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBiYWNrZ3JvdW5kQ29sb3InXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogYSBmYWJyaWNPYmplY3QgdGhhdCwgd2l0aG91dCBzdHJva2UgZGVmaW5lIGEgY2xpcHBpbmcgYXJlYSB3aXRoIHRoZWlyIHNoYXBlLiBmaWxsZWQgaW4gYmxhY2tcbiAgICAgKiB0aGUgY2xpcFBhdGggb2JqZWN0IGdldHMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaGFzIHJlbmRlcmVkLCBhbmQgdGhlIGNvbnRleHQgaXMgcGxhY2VkIGluIHRoZSBjZW50ZXJcbiAgICAgKiBvZiB0aGUgb2JqZWN0IGNhY2hlQ2FudmFzLlxuICAgICAqIElmIHlvdSB3YW50IDAsMCBvZiBhIGNsaXBQYXRoIHRvIGFsaWduIHdpdGggYW4gb2JqZWN0IGNlbnRlciwgdXNlIGNsaXBQYXRoLm9yaWdpblgvWSB0byAnY2VudGVyJ1xuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICBjbGlwUGF0aDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhbmluZ2Z1bCBPTkxZIHdoZW4gdGhlIG9iamVjdCBpcyB1c2VkIGFzIGNsaXBQYXRoLlxuICAgICAqIGlmIHRydWUsIHRoZSBjbGlwUGF0aCB3aWxsIG1ha2UgdGhlIG9iamVjdCBjbGlwIHRvIHRoZSBvdXRzaWRlIG9mIHRoZSBjbGlwUGF0aFxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaW52ZXJ0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTWVhbmluZ2Z1bCBPTkxZIHdoZW4gdGhlIG9iamVjdCBpcyB1c2VkIGFzIGNsaXBQYXRoLlxuICAgICAqIGlmIHRydWUsIHRoZSBjbGlwUGF0aCB3aWxsIGhhdmUgaXRzIHRvcCBhbmQgbGVmdCByZWxhdGl2ZSB0byBjYW52YXMsIGFuZCB3aWxsXG4gICAgICogbm90IGJlIGluZmx1ZW5jZWQgYnkgdGhlIG9iamVjdCB0cmFuc2Zvcm0uIFRoaXMgd2lsbCBtYWtlIHRoZSBjbGlwUGF0aCByZWxhdGl2ZVxuICAgICAqIHRvIHRoZSBjYW52YXMsIGJ1dCBjbGlwcGluZyBqdXN0IGEgcGFydGljdWxhciBvYmplY3QuXG4gICAgICogV0FSTklORyB0aGlzIGlzIGJldGEsIHRoaXMgZmVhdHVyZSBtYXkgY2hhbmdlIG9yIGJlIHJlbmFtZWQuXG4gICAgICogc2luY2UgMi40LjBcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBvc2l0aW9uZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aGUgY2FudmFzIHVzZWQgdG8ga2VlcCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlUHJvcGVydGllcyA9IHt9O1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIC8vIGlmIGNhbnZhcyBnZXRzIGNyZWF0ZWQsIGlzIGVtcHR5LCBzbyBkaXJ0eS5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgY2FjaGUgZGltZW5zaW9ucyBzbyB0aGF0IFggKiBZIGRvIG5vdCBjcm9zcyBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsXG4gICAgICogYW5kIGVhY2ggc2lkZSBkbyBub3QgY3Jvc3MgZmFicmljLmNhY2hlU2lkZUxpbWl0XG4gICAgICogdGhvc2UgbnVtYmVycyBhcmUgY29uZmlndXJhYmxlIHNvIHRoYXQgeW91IGNhbiBnZXQgYXMgbXVjaCBkZXRhaWwgYXMgeW91IHdhbnRcbiAgICAgKiBtYWtpbmcgYmFyZ2FpbiB3aXRoIHBlcmZvcm1hbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2xpbWl0Q2FjaGVTaXplOiBmdW5jdGlvbihkaW1zKSB7XG4gICAgICB2YXIgcGVyZkxpbWl0U2l6ZVRvdGFsID0gZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LFxuICAgICAgICAgIG1heCA9IGZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCwgbWluID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0O1xuICAgICAgaWYgKHdpZHRoIDw9IG1heCAmJiBoZWlnaHQgPD0gbWF4ICYmIHdpZHRoICogaGVpZ2h0IDw9IHBlcmZMaW1pdFNpemVUb3RhbCkge1xuICAgICAgICBpZiAod2lkdGggPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLndpZHRoID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLmhlaWdodCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIHZhciBhciA9IHdpZHRoIC8gaGVpZ2h0LCBsaW1pdGVkRGltcyA9IGZhYnJpYy51dGlsLmxpbWl0RGltc0J5QXJlYShhciwgcGVyZkxpbWl0U2l6ZVRvdGFsKSxcbiAgICAgICAgICBjYXBWYWx1ZSA9IGZhYnJpYy51dGlsLmNhcFZhbHVlLFxuICAgICAgICAgIHggPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLngsIG1heCksXG4gICAgICAgICAgeSA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueSwgbWF4KTtcbiAgICAgIGlmICh3aWR0aCA+IHgpIHtcbiAgICAgICAgZGltcy56b29tWCAvPSB3aWR0aCAvIHg7XG4gICAgICAgIGRpbXMud2lkdGggPSB4O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4geSkge1xuICAgICAgICBkaW1zLnpvb21ZIC89IGhlaWdodCAvIHk7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0geTtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICAvLyBjYWN1bGF0ZSBkaW1lbnNpb25zIHdpdGhvdXQgc2tld2luZ1xuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygwLCAwKSxcbiAgICAgICAgICBuZWVkZWRYID0gZGltLnggKiBvYmplY3RTY2FsZS5zY2FsZVggLyB0aGlzLnNjYWxlWCxcbiAgICAgICAgICBuZWVkZWRZID0gZGltLnkgKiBvYmplY3RTY2FsZS5zY2FsZVkgLyB0aGlzLnNjYWxlWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGZvciBzdXJlIHRoaXMgQUxJQVNJTkdfTElNSVQgaXMgc2xpZ2h0bHkgY3JlYXRpbmcgcHJvYmxlbVxuICAgICAgICAvLyBpbiBzaXR1YXRpb24gaW4gd2hpY2ggdGhlIGNhY2hlIGNhbnZhcyBnZXRzIGFuIHVwcGVyIGxpbWl0XG4gICAgICAgIC8vIGFsc28gb2JqZWN0U2NhbGUgY29udGFpbnMgYWxyZWFkeSBzY2FsZVggYW5kIHNjYWxlWVxuICAgICAgICB3aWR0aDogbmVlZGVkWCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICBoZWlnaHQ6IG5lZWRlZFkgKyBBTElBU0lOR19MSU1JVCxcbiAgICAgICAgem9vbVg6IG9iamVjdFNjYWxlLnNjYWxlWCxcbiAgICAgICAgem9vbVk6IG9iamVjdFNjYWxlLnNjYWxlWSxcbiAgICAgICAgeDogbmVlZGVkWCxcbiAgICAgICAgeTogbmVlZGVkWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNhbnZhcyBmb3IgY2FjaGVcbiAgICAgKiByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgY2FudmFzIG5lZWRlZCByZXNpemUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgaGFzIGJlZW4gcmVzaXplZFxuICAgICAqL1xuICAgIF91cGRhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBpZiAodGhpcy5ub1NjYWxlQ2FjaGUgJiYgdGFyZ2V0Q2FudmFzICYmIHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbiA9IHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybS5hY3Rpb247XG4gICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgYWN0aW9uLnNsaWNlICYmIGFjdGlvbi5zbGljZSgwLCA1KSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhY2hlQ2FudmFzLFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9saW1pdENhY2hlU2l6ZSh0aGlzLl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMoKSksXG4gICAgICAgICAgbWluQ2FjaGVTaXplID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0LFxuICAgICAgICAgIHdpZHRoID0gZGltcy53aWR0aCwgaGVpZ2h0ID0gZGltcy5oZWlnaHQsIGRyYXdpbmdXaWR0aCwgZHJhd2luZ0hlaWdodCxcbiAgICAgICAgICB6b29tWCA9IGRpbXMuem9vbVgsIHpvb21ZID0gZGltcy56b29tWSxcbiAgICAgICAgICBkaW1lbnNpb25zQ2hhbmdlZCA9IHdpZHRoICE9PSB0aGlzLmNhY2hlV2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmNhY2hlSGVpZ2h0LFxuICAgICAgICAgIHpvb21DaGFuZ2VkID0gdGhpcy56b29tWCAhPT0gem9vbVggfHwgdGhpcy56b29tWSAhPT0gem9vbVksXG4gICAgICAgICAgc2hvdWxkUmVkcmF3ID0gZGltZW5zaW9uc0NoYW5nZWQgfHwgem9vbUNoYW5nZWQsXG4gICAgICAgICAgYWRkaXRpb25hbFdpZHRoID0gMCwgYWRkaXRpb25hbEhlaWdodCA9IDAsIHNob3VsZFJlc2l6ZUNhbnZhcyA9IGZhbHNlO1xuICAgICAgaWYgKGRpbWVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBjYW52YXNXaWR0aCA9IHRoaXMuX2NhY2hlQ2FudmFzLndpZHRoLFxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gdGhpcy5fY2FjaGVDYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgc2l6ZUdyb3dpbmcgPSB3aWR0aCA+IGNhbnZhc1dpZHRoIHx8IGhlaWdodCA+IGNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgIHNpemVTaHJpbmtpbmcgPSAod2lkdGggPCBjYW52YXNXaWR0aCAqIDAuOSB8fCBoZWlnaHQgPCBjYW52YXNIZWlnaHQgKiAwLjkpICYmXG4gICAgICAgICAgICAgIGNhbnZhc1dpZHRoID4gbWluQ2FjaGVTaXplICYmIGNhbnZhc0hlaWdodCA+IG1pbkNhY2hlU2l6ZTtcbiAgICAgICAgc2hvdWxkUmVzaXplQ2FudmFzID0gc2l6ZUdyb3dpbmcgfHwgc2l6ZVNocmlua2luZztcbiAgICAgICAgaWYgKHNpemVHcm93aW5nICYmICFkaW1zLmNhcHBlZCAmJiAod2lkdGggPiBtaW5DYWNoZVNpemUgfHwgaGVpZ2h0ID4gbWluQ2FjaGVTaXplKSkge1xuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IHdpZHRoICogMC4xO1xuICAgICAgICAgIGFkZGl0aW9uYWxIZWlnaHQgPSBoZWlnaHQgKiAwLjE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgZmFicmljLlRleHQgJiYgdGhpcy5wYXRoKSB7XG4gICAgICAgIHNob3VsZFJlZHJhdyA9IHRydWU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHRydWU7XG4gICAgICAgIGFkZGl0aW9uYWxXaWR0aCArPSB0aGlzLmdldEhlaWdodE9mTGluZSgwKSAqIHRoaXMuem9vbVg7XG4gICAgICAgIGFkZGl0aW9uYWxIZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoMCkgKiB0aGlzLnpvb21ZO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZHJhdykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzaXplQ2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICsgYWRkaXRpb25hbFdpZHRoKTtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCArIGFkZGl0aW9uYWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdpbmdXaWR0aCA9IGRpbXMueCAvIDI7XG4gICAgICAgIGRyYXdpbmdIZWlnaHQgPSBkaW1zLnkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBuZWVkRnVsbFRyYW5zZm9ybSA9ICh0aGlzLmdyb3VwICYmICF0aGlzLmdyb3VwLl90cmFuc2Zvcm1Eb25lKSB8fFxuICAgICAgICAgKHRoaXMuZ3JvdXAgJiYgdGhpcy5jYW52YXMgJiYgY3R4ID09PSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHZhciBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCFuZWVkRnVsbFRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdmVyc2lvbjogICAgICAgICAgICAgICAgICBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgICAgIG9yaWdpblg6ICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5YLFxuICAgICAgICAgICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblksXG4gICAgICAgICAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5sZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAodGhpcy5maWxsICYmIHRoaXMuZmlsbC50b09iamVjdCkgPyB0aGlzLmZpbGwudG9PYmplY3QoKSA6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlLnRvT2JqZWN0KSA/IHRoaXMuc3Ryb2tlLnRvT2JqZWN0KCkgOiB0aGlzLnN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZVdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5jb25jYXQoKSA6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0OiAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaE9mZnNldCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZVVuaWZvcm06ICAgICAgICAgICAgdGhpcy5zdHJva2VVbmlmb3JtLFxuICAgICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmFuZ2xlLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgcGFpbnRGaXJzdDogICAgICAgICAgICAgICB0aGlzLnBhaW50Rmlyc3QsXG4gICAgICAgICAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1gsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1ksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmICF0aGlzLmNsaXBQYXRoLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5pbnZlcnRlZCA9IHRoaXMuY2xpcFBhdGguaW52ZXJ0ZWQ7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQgPSB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZDtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX3JlbW92ZURlZmF1bHRWYWx1ZXMob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAoZGF0YWxlc3MpIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgc3ViY2xhc3Nlc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICAgIF9yZW1vdmVEZWZhdWx0VmFsdWVzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBmYWJyaWMudXRpbC5nZXRLbGFzcyhvYmplY3QudHlwZSkucHJvdG90eXBlLFxuICAgICAgICAgIHN0YXRlUHJvcGVydGllcyA9IHByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXM7XG4gICAgICBzdGF0ZVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnbGVmdCcgfHwgcHJvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXSA9PT0gcHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiYXNpY2FsbHkgYSBjaGVjayBmb3IgW10gPT09IFtdXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFtwcm9wXSkgJiYgQXJyYXkuaXNBcnJheShwcm90b3R5cGVbcHJvcF0pXG4gICAgICAgICAgJiYgb2JqZWN0W3Byb3BdLmxlbmd0aCA9PT0gMCAmJiBwcm90b3R5cGVbcHJvcF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy4nICsgY2FwaXRhbGl6ZSh0aGlzLnR5cGUpICsgJz4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggc2NhbGVYIGFuZCBzY2FsZVkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9iamVjdFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBhIHRvcCBsZXZlbCBvbmUsIG9uIHRoZSBjYW52YXMsIHdlIGdvIGZvciBzaW1wbGUgYXJpdG1ldGljXG4gICAgICAvLyBvdGhlcndpc2UgdGhlIGNvbXBsZXggbWV0aG9kIHdpdGggYW5nbGVzIHdpbGwgcmV0dXJuIGFwcHJveGltYXRpb25zIGFuZCBkZWNpbWFsc1xuICAgICAgLy8gYW5kIHdpbGwgbGlrZWx5IGtpbGwgdGhlIGNhY2hlIHdoZW4gbm90IG5lZWRlZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhYnJpY2pzL2ZhYnJpYy5qcy9pc3N1ZXMvNzE1N1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIGluc2lkZSBhIGdyb3VwIHRvdGFsIHpvb20gY2FsY3VsYXRpb24gaXMgY29tcGxleCwgd2UgZGVmZXIgdG8gZ2VuZXJpYyBtYXRyaWNlc1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICByZXR1cm4geyBzY2FsZVg6IE1hdGguYWJzKG9wdGlvbnMuc2NhbGVYKSwgc2NhbGVZOiBNYXRoLmFicyhvcHRpb25zLnNjYWxlWSkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgc2NhbGUgZmFjdG9yIGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHNjYWxpbmcsIHpvb20gYW5kIHJldGluYVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggc2NhbGVYIGFuZCBzY2FsZVkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldFRvdGFsT2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKSwgc2NhbGVYID0gc2NhbGUuc2NhbGVYLCBzY2FsZVkgPSBzY2FsZS5zY2FsZVk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcy5nZXRab29tKCk7XG4gICAgICAgIHZhciByZXRpbmEgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICAgIHNjYWxlWCAqPSB6b29tICogcmV0aW5hO1xuICAgICAgICBzY2FsZVkgKj0gem9vbSAqIHJldGluYTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHNjYWxlWDogc2NhbGVYLCBzY2FsZVk6IHNjYWxlWSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBvcGFjaXR5IGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldE9iamVjdE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICBvcGFjaXR5ICo9IHRoaXMuZ3JvdXAuZ2V0T2JqZWN0T3BhY2l0eSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wYWNpdHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHNob3VsZENvbnN0cmFpblZhbHVlID0gKGtleSA9PT0gJ3NjYWxlWCcgfHwga2V5ID09PSAnc2NhbGVZJyksXG4gICAgICAgICAgaXNDaGFuZ2VkID0gdGhpc1trZXldICE9PSB2YWx1ZSwgZ3JvdXBOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQ29uc3RyYWluVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jb25zdHJhaW5TY2FsZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2NhbGVYJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWCA9ICF0aGlzLmZsaXBYO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlWScgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFkgPSAhdGhpcy5mbGlwWTtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzaGFkb3cnICYmIHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBmYWJyaWMuU2hhZG93KSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBmYWJyaWMuU2hhZG93KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2RpcnR5JyAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG5cbiAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSA9IHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5pc09uQUNhY2hlKCk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlUHJvcGVydGllcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgIGdyb3VwTmVlZHNVcGRhdGUgJiYgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLnN0YXRlUHJvcGVydGllcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIHBhcmVudCBncm91cCBvZiBhbiBvYmplY3QgZXZlcnlcbiAgICAgKiB0aW1lIGEgbm9uLWRlbGVnYXRlZCBwcm9wZXJ0eSBjaGFuZ2VzIG9uIHRoZSBncm91cC4gSXQgaXMgcGFzc2VkIHRoZSBrZXlcbiAgICAgKiBhbmQgdmFsdWUgYXMgcGFyYW1ldGVycy4gTm90IGFkZGluZyBpbiB0aGlzIGZ1bmN0aW9uJ3Mgc2lnbmF0dXJlIHRvIGF2b2lkXG4gICAgICogVHJhdmlzIGJ1aWxkIGVycm9yIGFib3V0IHVudXNlZCB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgc2V0T25Hcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdmlld3BvcnRUcmFuc2Zvcm0gZnJvbSBPYmplY3QncyBjYW52YXMgaWYgcG9zc2libGVcbiAgICAgKiBAbWV0aG9kIGdldFZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJldHVybiBpZiB0aGUgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaW4gcmVuZGVyaW5nXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05vdFZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3BhY2l0eSA9PT0gMCB8fFxuICAgICAgICAoIXRoaXMud2lkdGggJiYgIXRoaXMuaGVpZ2h0ICYmIHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHx8XG4gICAgICAgICF0aGlzLnZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgd2lkdGgvaGVpZ2h0IGFyZSB6ZXJvcyBvciBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5za2lwT2Zmc2NyZWVuICYmICF0aGlzLmdyb3VwICYmICF0aGlzLmlzT25TY3JlZW4oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0dXBDb21wb3NpdGVPcGVyYXRpb24oY3R4KTtcbiAgICAgIHRoaXMuZHJhd1NlbGVjdGlvbkJhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9zZXRPcGFjaXR5KGN0eCk7XG4gICAgICB0aGlzLl9zZXRTaGFkb3coY3R4LCB0aGlzKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZENhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDYWNoZSgpO1xuICAgICAgICB0aGlzLmRyYXdDYWNoZU9uQ2FudmFzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2FjaGVDYW52YXMoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QoY3R4KTtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0Q2FjaGluZyAmJiB0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIHJlbmRlckNhY2hlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghdGhpcy5fY2FjaGVDYW52YXMgfHwgIXRoaXMuX2NhY2hlQ29udGV4dCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNDYWNoZURpcnR5KCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgdGhpcy5kcmF3T2JqZWN0KHRoaXMuX2NhY2hlQ29udGV4dCwgb3B0aW9ucy5mb3JDbGlwcGluZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhY2hlQ2FudmFzIGFuZCBpdHMgZGltZW5zaW9ucyBmcm9tIHRoZSBvYmplY3RzXG4gICAgICovXG4gICAgX3JlbW92ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmNhY2hlV2lkdGggPSAwO1xuICAgICAgdGhpcy5jYWNoZUhlaWdodCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3Qgd2lsbCBkcmF3IGEgc3Ryb2tlXG4gICAgICogRG9lcyBub3QgY29uc2lkZXIgdGV4dCBzdHlsZXMuIFRoaXMgaXMganVzdCBhIHNob3J0Y3V0IHVzZWQgYXQgcmVuZGVyaW5nIHRpbWVcbiAgICAgKiBXZSB3YW50IGl0IHRvIGJlIGFuIGFwcHJveGltYXRpb24gYW5kIGJlIGZhc3QuXG4gICAgICogd3JvdGUgdG8gYXZvaWQgZXh0cmEgY2FjaGluZywgaXQgaGFzIHRvIHJldHVybiB0cnVlIHdoZW4gc3Ryb2tlIGhhcHBlbnMsXG4gICAgICogY2FuIGd1ZXNzIHdoZW4gaXQgd2lsbCBub3QgaGFwcGVuIGF0IDEwMCUgY2hhbmNlLCBkb2VzIG5vdCBtYXR0ZXIgaWYgaXQgbWlzc2VzXG4gICAgICogc29tZSB1c2UgY2FzZSB3aGVyZSB0aGUgc3Ryb2tlIGlzIGludmlzaWJsZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZSAhPT0gJ3RyYW5zcGFyZW50JyAmJiB0aGlzLnN0cm9rZVdpZHRoICE9PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHdpbGwgZHJhdyBhIGZpbGxcbiAgICAgKiBEb2VzIG5vdCBjb25zaWRlciB0ZXh0IHN0eWxlcy4gVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgdXNlZCBhdCByZW5kZXJpbmcgdGltZVxuICAgICAqIFdlIHdhbnQgaXQgdG8gYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgYmUgZmFzdC5cbiAgICAgKiB3cm90ZSB0byBhdm9pZCBleHRyYSBjYWNoaW5nLCBpdCBoYXMgdG8gcmV0dXJuIHRydWUgd2hlbiBmaWxsIGhhcHBlbnMsXG4gICAgICogY2FuIGd1ZXNzIHdoZW4gaXQgd2lsbCBub3QgaGFwcGVuIGF0IDEwMCUgY2hhbmNlLCBkb2VzIG5vdCBtYXR0ZXIgaWYgaXQgbWlzc2VzXG4gICAgICogc29tZSB1c2UgY2FzZSB3aGVyZSB0aGUgZmlsbCBpcyBpbnZpc2libGUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwgIT09ICd0cmFuc3BhcmVudCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgZm9yY2UgdGhlIG9iamVjdCB0byBoYXZlIGl0cyBvd24gY2FjaGUsIGV2ZW4gaWYgaXQgaXMgaW5zaWRlIGEgZ3JvdXBcbiAgICAgKiBpdCBtYXkgYmUgbmVlZGVkIHdoZW4geW91ciBvYmplY3QgYmVoYXZlIGluIGEgcGFydGljdWxhciB3YXkgb24gdGhlIGNhY2hlIGFuZCBhbHdheXMgbmVlZHNcbiAgICAgKiBpdHMgb3duIGlzb2xhdGVkIGNhbnZhcyB0byByZW5kZXIgY29ycmVjdGx5LlxuICAgICAqIENyZWF0ZWQgdG8gYmUgb3ZlcnJpZGRlblxuICAgICAqIHNpbmNlIDEuNy4xMlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBuZWVkc0l0c093bkNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnICYmXG4gICAgICAgIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdHlwZW9mIHRoaXMuc2hhZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogUmVhZCBhczogY2FjaGUgaWYgaXMgbmVlZGVkLCBvciBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkIGJ1dCB3ZSBhcmUgbm90IGFscmVhZHkgY2FjaGluZy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMub3duQ2FjaGluZyA9IHRoaXMubmVlZHNJdHNPd25DYWNoZSgpIHx8IChcbiAgICAgICAgdGhpcy5vYmplY3RDYWNoaW5nICYmXG4gICAgICAgICghdGhpcy5ncm91cCB8fCAhdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogdXNlZCBieSBHcm91cC5zaG91bGRDYWNoZSB0byBrbm93IGlmIGNoaWxkIGhhcyBhIHNoYWRvdyByZWN1cnNpdmVseVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2lsbERyYXdTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5zaGFkb3cgJiYgKHRoaXMuc2hhZG93Lm9mZnNldFggIT09IDAgfHwgdGhpcy5zaGFkb3cub2Zmc2V0WSAhPT0gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3QgY2xpcFBhdGhcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjbGlwUGF0aFxuICAgICAqL1xuICAgIGRyYXdDbGlwUGF0aE9uQ2FjaGU6IGZ1bmN0aW9uKGN0eCwgY2xpcFBhdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjRcbiAgICAgIGlmIChjbGlwUGF0aC5pbnZlcnRlZCkge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICB9XG4gICAgICAvL2N0eC5zY2FsZSgxIC8gMiwgMSAvIDIpO1xuICAgICAgaWYgKGNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCkge1xuICAgICAgICB2YXIgbSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gY2xpcFBhdGguem9vbVgsIDEgLyBjbGlwUGF0aC56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKGNsaXBQYXRoLl9jYWNoZUNhbnZhcywgLWNsaXBQYXRoLmNhY2hlVHJhbnNsYXRpb25YLCAtY2xpcFBhdGguY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdPYmplY3Q6IGZ1bmN0aW9uKGN0eCwgZm9yQ2xpcHBpbmcpIHtcbiAgICAgIHZhciBvcmlnaW5hbEZpbGwgPSB0aGlzLmZpbGwsIG9yaWdpbmFsU3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICBpZiAoZm9yQ2xpcHBpbmcpIHtcbiAgICAgICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5zdHJva2UgPSAnJztcbiAgICAgICAgdGhpcy5fc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyKGN0eCk7XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4LCB0aGlzLmNsaXBQYXRoKTtcbiAgICAgIHRoaXMuZmlsbCA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIHRoaXMuc3Ryb2tlID0gb3JpZ2luYWxTdHJva2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgY2xpcFBhdGggc3RhdGUgYW5kIGNhY2hlIGFuZCBkcmF3IGl0IG9uIGluc3RhbmNlJ3MgY2FjaGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjbGlwUGF0aFxuICAgICAqL1xuICAgIF9kcmF3Q2xpcFBhdGg6IGZ1bmN0aW9uIChjdHgsIGNsaXBQYXRoKSB7XG4gICAgICBpZiAoIWNsaXBQYXRoKSB7IHJldHVybjsgfVxuICAgICAgLy8gbmVlZGVkIHRvIHNldHVwIGEgY291cGxlIG9mIHZhcmlhYmxlc1xuICAgICAgLy8gcGF0aCBjYW52YXMgZ2V0cyBvdmVycmlkZGVuIHdpdGggdGhpcyBvbmUuXG4gICAgICAvLyBUT0RPIGZpbmQgYSBiZXR0ZXIgc29sdXRpb24/XG4gICAgICBjbGlwUGF0aC5jYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNsaXBQYXRoLnNob3VsZENhY2hlKCk7XG4gICAgICBjbGlwUGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICBjbGlwUGF0aC5yZW5kZXJDYWNoZSh7IGZvckNsaXBwaW5nOiB0cnVlIH0pO1xuICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhY2hlKGN0eCwgY2xpcFBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdCBvbiB0aGUgdGFyZ2V0IGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDYWNoZU9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy56b29tWCwgMSAvIHRoaXMuem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9jYWNoZUNhbnZhcywgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBDYW52YXMgc2tpcCBjYW52YXMgY2hlY2tzIGJlY2F1c2UgdGhpcyBvYmplY3QgaXMgcGFpbnRlZFxuICAgICAqIG9uIHBhcmVudCBjYW52YXMuXG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgdGhpcy5fY2FjaGVDb250ZXh0ICYmICFza2lwQ2FudmFzICYmIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCkpIHtcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSBjb250ZXh0IGlzIGFscmVhZHkgY2xlYXJlZC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHxcbiAgICAgICAgICAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCkgfHxcbiAgICAgICAgICAodGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnY2FjaGVQcm9wZXJ0aWVzJykpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiB0aGlzLl9jYWNoZUNvbnRleHQgJiYgIXNraXBDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FjaGVXaWR0aCAvIHRoaXMuem9vbVg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBiYWNrZ3JvdW5kIGZvciB0aGUgb2JqZWN0IGJpZyBhcyBpdHMgdW50cmFuc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgc3Ryb2tlID0gZGVjbC5zdHJva2U7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBkZWNsLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHgubGluZUNhcCA9IGRlY2wuc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGVjbC5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgICBjdHgubGluZUpvaW4gPSBkZWNsLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGRlY2wuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgaWYgKHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgICBpZiAoc3Ryb2tlLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJyB8fCBzdHJva2UuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgc3Ryb2tlLnBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIGdyYWRpZW50IGluIGEgcGF0dGVybi5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IHVzaW5nIGNhY2hpbmcsIHlvdSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIGl0IG9uLlxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIGNhbnZhcyBhcyBiaWcgYXMgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hpbmcgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudChjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBzdHJva2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIGNvbG9yXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGVjbC5zdHJva2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgdmFyIGZpbGwgPSBkZWNsLmZpbGw7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBpZiAoZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmUoY3R4LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIGRlY2wuZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldENsaXBwaW5nUHJvcGVydGllczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU2V0cyBsaW5lIGRhc2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gc2V0IHRoZSBkYXNoIGxpbmUgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoQXJyYXkgYXJyYXkgcmVwcmVzZW50aW5nIGRhc2hlc1xuICAgICAqL1xuICAgIF9zZXRMaW5lRGFzaDogZnVuY3Rpb24oY3R4LCBkYXNoQXJyYXkpIHtcbiAgICAgIGlmICghZGFzaEFycmF5IHx8IGRhc2hBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGNvbnRyb2xzIGFuZCBib3JkZXJzIGZvciB0aGUgb2JqZWN0XG4gICAgICogdGhlIGNvbnRleHQgaGVyZSBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zLCBkcmF3Qm9yZGVycywgZHJhd0NvbnRyb2xzO1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgZHJhd0JvcmRlcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyA6IHRoaXMuaGFzQm9yZGVycztcbiAgICAgIGRyYXdDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgICBvcHRpb25zLmFuZ2xlIC09IDE4MDtcbiAgICAgIH1cbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmdyb3VwID8gb3B0aW9ucy5hbmdsZSA6IHRoaXMuYW5nbGUpKTtcbiAgICAgIGlmIChzdHlsZU92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbiB8fCB0aGlzLmdyb3VwKSB7XG4gICAgICAgIGRyYXdCb3JkZXJzICYmIHRoaXMuZHJhd0JvcmRlcnNJbkdyb3VwKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVycyhjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgZHJhd0NvbnRyb2xzICYmIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0U2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hhZG93ID0gdGhpcy5zaGFkb3csIGNhbnZhcyA9IHRoaXMuY2FudmFzLCBzY2FsaW5nLFxuICAgICAgICAgIG11bHRYID0gKGNhbnZhcyAmJiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bMF0pIHx8IDEsXG4gICAgICAgICAgbXVsdFkgPSAoY2FudmFzICYmIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVszXSkgfHwgMTtcbiAgICAgIGlmIChzaGFkb3cubm9uU2NhbGluZykge1xuICAgICAgICBzY2FsaW5nID0geyBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICBtdWx0WCAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgbXVsdFkgKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyICogZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgKlxuICAgICAgICAobXVsdFggKyBtdWx0WSkgKiAoc2NhbGluZy5zY2FsZVggKyBzY2FsaW5nLnNjYWxlWSkgLyA0O1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WCAqIG11bHRYICogc2NhbGluZy5zY2FsZVg7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZICogbXVsdFkgKiBzY2FsaW5nLnNjYWxlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbW92ZVNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsbGVyIGZhYnJpYy5QYXR0ZXJuIG9yIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2Zmc2V0Lm9mZnNldFggb2Zmc2V0IGZvciB0ZXh0IHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2Zmc2V0Lm9mZnNldFkgb2Zmc2V0IGZvciB0ZXh0IHJlbmRlcmluZ1xuICAgICAqL1xuICAgIF9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4LCBmaWxsZXIpIHtcbiAgICAgIGlmICghZmlsbGVyIHx8ICFmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gZmlsbGVyLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtO1xuICAgICAgdmFyIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDIgKyBmaWxsZXIub2Zmc2V0WCB8fCAwLFxuICAgICAgICAgIG9mZnNldFkgPSAtdGhpcy5oZWlnaHQgLyAyICsgZmlsbGVyLm9mZnNldFkgfHwgMDtcblxuICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0aGlzLndpZHRoLCAwLCAwLCB0aGlzLmhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGlmICh0KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odFswXSwgdFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYWludEluT3JkZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGZ1bmN0aW9uIHRoYXQgYWN0dWFsbHkgcmVuZGVyIHNvbWV0aGluZyBvbiB0aGUgY29udGV4dC5cbiAgICAgKiBlbXB0eSBoZXJlIHRvIGFsbG93IE9iZWN0cyB0byB3b3JrIG9uIHRlc3RzIHRvIGJlbmNobWFyayBmYWJyaWMgZnVuY3Rpb25hbGl0ZXNcbiAgICAgKiBub3QgcmVsYXRlZCB0byByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oLyogY3R4ICovKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuZmlsbFJ1bGUgPT09ICdldmVub2RkJykge1xuICAgICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHZhciBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGluZy5zY2FsZVgsIDEgLyBzY2FsaW5nLnNjYWxlWSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0pIHtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnNjYWxlWCwgMSAvIHRoaXMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyd2FiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyYWRpZW50fSBmaWxsZXIgYSBmYWJyaWMgZ3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudDogZnVuY3Rpb24oY3R4LCBmaWxsZXIpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIHBDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksIHBDdHgsIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgd2lkdGggPSBkaW1zLnggLyB0aGlzLnNjYWxlWCAvIHJldGluYVNjYWxpbmcsIGhlaWdodCA9IGRpbXMueSAvIHRoaXMuc2NhbGVZIC8gcmV0aW5hU2NhbGluZztcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LnNjYWxlKFxuICAgICAgICBkaW1zLnpvb21YIC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICBkaW1zLnpvb21ZIC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nXG4gICAgICApO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbFN0eWxlID0gZmlsbGVyLnRvTGl2ZShjdHgpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVggLyBkaW1zLnpvb21YLFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVkgLyBkaW1zLnpvb21ZXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMubGVmdCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgZGVjb21wb3NlIHRoZSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBhbmQgYXNzaWduIHByb3BlcnRpZXMgdG8gb2JqZWN0LlxuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICAgIHRoaXMuc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgICB0aGlzLnNrZXdZID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJlbW92ZXMgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBhbmQgc2V0IHRvIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgZmFicmljanMgY2FuIGhhbmRsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zXG4gICAgICogQHJldHVybiB7dGhpc0FyZ31cbiAgICAgKi9cbiAgICBfcmVtb3ZlVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzKCk7XG4gICAgICAgIGNlbnRlciA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KGNlbnRlciwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NhbGVYICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVZO1xuICAgICAgICB0aGlzLmNyb3BYID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFg7XG4gICAgICAgIHRoaXMuY3JvcFkgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWTtcbiAgICAgICAgY2VudGVyLnggKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0TGVmdDtcbiAgICAgICAgY2VudGVyLnkgKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGFuIGluc3RhbmNlLCB1c2luZyBhIGNhbGxiYWNrIG1ldGhvZCB3aWxsIHdvcmsgZm9yIGV2ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpcyBpbnZva2VkIHdpdGggYSBjbG9uZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihjYWxsYmFjaywgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdEZvcm0gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3Qob2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ09iamVjdCcsIG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2Ugb3V0IG9mIGFuIG9iamVjdFxuICAgICAqIG1ha2VzIHVzZSBvZiB0b0NhbnZhc0VsZW1lbnQuXG4gICAgICogT25jZSB0aGlzIG1ldGhvZCB3YXMgYmFzZWQgb24gdG9EYXRhVXJsIGFuZCBsb2FkSW1hZ2UsIHNvIGl0IGFsc28gaGFkIGEgcXVhbGl0eVxuICAgICAqIGFuZCBmb3JtYXQgb3B0aW9uLiB0b0NhbnZhc0VsZW1lbnQgaXMgZmFzdGVyIGFuZCBwcm9kdWNlIG5vIGxvc3Mgb2YgcXVhbGl0eS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byBnZXQgYSByZWFsIEpwZWcgb3IgUG5nIGZyb20gYW4gb2JqZWN0LCB1c2luZyB0b0RhdGFVUkwgaXMgdGhlIHJpZ2h0IHdheSB0byBkbyBpdC5cbiAgICAgKiB0b0NhbnZhc0VsZW1lbnQgYW5kIHRoZW4gdG9CbG9iIGZyb20gdGhlIG9idGFpbmVkIGNhbnZhcyBpcyBhbHNvIGEgZ29vZCBvcHRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgc3luYyBub3csIGJ1dCBzdGlsbCBzdXBwb3J0IHRoZSBjYWxsYmFjayBiZWNhdXNlIHdlIGRpZCBub3Qgd2FudCB0byBicmVhay5cbiAgICAgKiBXaGVuIGZhYnJpY0pTIDUuMCB3aWxsIGJlIHBsYW5uZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBjaGFuZ2VkIHRvIG5vdCBoYXZlIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNsb25lQXNJbWFnZTogZnVuY3Rpb24oY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoY2FudmFzRWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEhUTUxDYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIERPTSBlbGVtZW50IDxjYW52YXM+IHdpdGggdGhlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgdXRpbHMgPSBmYWJyaWMudXRpbCwgb3JpZ1BhcmFtcyA9IHV0aWxzLnNhdmVPYmplY3RUcmFuc2Zvcm0odGhpcyksXG4gICAgICAgICAgb3JpZ2luYWxHcm91cCA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgb3JpZ2luYWxTaGFkb3cgPSB0aGlzLnNoYWRvdywgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gZmFicmljLmRldmljZVBpeGVsUmF0aW8gOiAxKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3VwO1xuICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICB1dGlscy5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRTaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgLy8gc2tpcCBjYW52YXMgem9vbSBhbmQgY2FsY3VsYXRlIHdpdGggc2V0Q29vcmRzIG5vdy5cbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0cnVlLCB0cnVlKSxcbiAgICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdywgc2NhbGluZyxcbiAgICAgICAgICBzaGFkb3dPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfSwgc2hhZG93Qmx1cixcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIHNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc2lkZXIgbm9uIHNjYWxpbmcgc2hhZG93LlxuICAgICAgICBzaGFkb3dPZmZzZXQueCA9IDIgKiBNYXRoLnJvdW5kKGFicyhzaGFkb3cub2Zmc2V0WCkgKyBzaGFkb3dCbHVyKSAqIChhYnMoc2NhbGluZy5zY2FsZVgpKTtcbiAgICAgICAgc2hhZG93T2Zmc2V0LnkgPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFkpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVZKSk7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCArIHNoYWRvd09mZnNldC54O1xuICAgICAgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCArIHNoYWRvd09mZnNldC55O1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgd2lkdGgvaGVpZ2h0IGlzIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgaXQgc28uXG4gICAgICBlbC53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgICBlbC5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgZmFicmljLlN0YXRpY0NhbnZhcyhlbCwge1xuICAgICAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBlZycpIHtcbiAgICAgICAgY2FudmFzLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihuZXcgZmFicmljLlBvaW50KGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKSwgJ2NlbnRlcicsICdjZW50ZXInKTtcblxuICAgICAgdmFyIG9yaWdpbmFsQ2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKHRoaXMpO1xuICAgICAgdmFyIGNhbnZhc0VsID0gY2FudmFzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyIHx8IDEsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zaGFkb3cgPSBvcmlnaW5hbFNoYWRvdztcbiAgICAgIHRoaXMuc2V0KCdjYW52YXMnLCBvcmlnaW5hbENhbnZhcyk7XG4gICAgICBpZiAob3JpZ2luYWxHcm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwID0gb3JpZ2luYWxHcm91cDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgLy8gY2FudmFzLmRpc3Bvc2Ugd2lsbCBjYWxsIGltYWdlLmRpc3Bvc2UgdGhhdCB3aWxsIG51bGxpZnkgdGhlIGVsZW1lbnRzXG4gICAgICAvLyBzaW5jZSB0aGlzIGNhbnZhcyBpcyBhIHNpbXBsZSBlbGVtZW50IGZvciB0aGUgcHJvY2Vzcywgd2UgcmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRvIG9iamVjdHMgaW4gdGhpcyB3YXkgaW4gb3JkZXIgdG8gYXZvaWQgb2JqZWN0IHRyYXNoaW5nLlxuICAgICAgY2FudmFzLl9vYmplY3RzID0gW107XG4gICAgICBjYW52YXMuZGlzcG9zZSgpO1xuICAgICAgY2FudmFzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpLCBvcHRpb25zLmZvcm1hdCB8fCAncG5nJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IEFycmF5LmZyb20oYXJndW1lbnRzKS5pbmNsdWRlcyh0aGlzLnR5cGUpIDogdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZSAoaXMgMSB1bmxlc3Mgc3ViY2xhc3NlZClcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiYW5nbGVcIiBvZiBhbiBpbnN0YW5jZSB3aXRoIGNlbnRlcmVkIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIHZhbHVlIChpbiBkZWdyZWVzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgdmFyIHNob3VsZENlbnRlck9yaWdpbiA9ICh0aGlzLm9yaWdpblggIT09ICdjZW50ZXInIHx8IHRoaXMub3JpZ2luWSAhPT0gJ2NlbnRlcicpICYmIHRoaXMuY2VudGVyZWRSb3RhdGlvbjtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9zZXRPcmlnaW5Ub0NlbnRlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCgnYW5nbGUnLCBhbmdsZSk7XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fcmVzZXRPcmlnaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGlzIHdhcyBhZGRlZCBsYXN0XG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgcmVsYXRpdmUgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBvcGVyYXRlIHVwb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIFBvaW50ZXIgdG8gb3BlcmF0ZSB1cG9uIChpbnN0ZWFkIG9mIGV2ZW50KVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyICh4LCB5KVxuICAgICAqL1xuICAgIGdldExvY2FsUG9pbnRlcjogZnVuY3Rpb24oZSwgcG9pbnRlcikge1xuICAgICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgdGhpcy5jYW52YXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHZhciBwQ2xpY2tlZCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuICAgICAgICAgIG9iamVjdExlZnRUb3AgPSB0aGlzLl9nZXRMZWZ0VG9wQ29vcmRzKCk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwQ2xpY2tlZCA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KFxuICAgICAgICAgIHBDbGlja2VkLCBvYmplY3RMZWZ0VG9wLCBkZWdyZWVzVG9SYWRpYW5zKC10aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwQ2xpY2tlZC54IC0gb2JqZWN0TGVmdFRvcC54LFxuICAgICAgICB5OiBwQ2xpY2tlZC55IC0gb2JqZWN0TGVmdFRvcC55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gZm9yIHNwZWNpZmljIG9iamVjdFxuICAgICAqIGN1c3RvbSBjb21wb3NpdGlvbiBvcGVyYXRpb24gZm9yIHRoZSBwYXJ0aWN1bGFyIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgaW5zdGFuY2UncyBydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgKiBvdmVycmlkZSBpZiBuZWNlc3NhcnkgdG8gZGlzcG9zZSBhcnRpZmFjdHMgc3VjaCBhcyBgY2xpcFBhdGhgXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucykge1xuICAgICAgICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuY2FuY2VsQnlUYXJnZXQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5PYmplY3QpO1xuXG4gIGV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIHVzZSB3aGVuIHNlcmlhbGl6aW5nIG9iamVjdCB2YWx1ZXMuXG4gICAqIFlvdSBjYW4gdXNlIGl0IHRvIGluY3JlYXNlL2RlY3JlYXNlIHByZWNpc2lvbiBvZiBzdWNoIHZhbHVlcyBsaWtlIGxlZnQsIHRvcCwgc2NhbGVYLCBzY2FsZVksIGV0Yy5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMgPSAyO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIGVubGl2ZW5lZCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIHRvIHtAbGluayBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0fVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSBzdHJpbmdbXVxuICAgKi9cbiAgZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTID0gWydjbGlwUGF0aCddO1xuXG4gIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihjbGFzc05hbWUsIG9iamVjdCwgY2FsbGJhY2ssIGV4dHJhUGFyYW0pIHtcbiAgICB2YXIga2xhc3MgPSBmYWJyaWNbY2xhc3NOYW1lXTtcbiAgICBvYmplY3QgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5QYXR0ZXJucyhbb2JqZWN0LmZpbGwsIG9iamVjdC5zdHJva2VdLCBmdW5jdGlvbihwYXR0ZXJucykge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LmZpbGwgPSBwYXR0ZXJuc1swXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zdHJva2UgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGV4dHJhUGFyYW0gPyBuZXcga2xhc3Mob2JqZWN0W2V4dHJhUGFyYW1dLCBvYmplY3QpIDogbmV3IGtsYXNzKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgaWQgdXNlZCBpbnRlcm5hbGx5IHdoZW4gY3JlYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Ll9fdWlkID0gMDtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgb3JpZ2luWE9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICByaWdodDogMC41XG4gICAgICB9LFxuICAgICAgb3JpZ2luWU9mZnNldCA9IHtcbiAgICAgICAgdG9wOiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIGJvdHRvbTogMC41XG4gICAgICB9O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBhIHNldCBvZiBvcmlnaW4gdG8gYW5vdGhlciAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9HaXZlbk9yaWdpbjogZnVuY3Rpb24ocG9pbnQsIGZyb21PcmlnaW5YLCBmcm9tT3JpZ2luWSwgdG9PcmlnaW5YLCB0b09yaWdpblkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZLCBkaW07XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5YID0gb3JpZ2luWE9mZnNldFtmcm9tT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5YID0gb3JpZ2luWE9mZnNldFt0b09yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFggPSB0b09yaWdpblggLSBmcm9tT3JpZ2luWDtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W2Zyb21PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W3RvT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WSA9IHRvT3JpZ2luWSAtIGZyb21PcmlnaW5ZO1xuXG4gICAgICBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICB4ID0gcG9pbnQueCArIG9mZnNldFggKiBkaW0ueDtcbiAgICAgICAgeSA9IHBvaW50LnkgKyBvZmZzZXRZICogZGltLnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIG9yaWdpbiB0byBjZW50ZXIgY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBwb2ludCwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgdG8gb3JpZ2luIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byBjZW50ZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb09yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBjZW50ZXIsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgY2VudGVyIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlZnRUb3AgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChsZWZ0VG9wLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gZ2V0T3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgIC8vICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBhcyBpZiBpdCBoYXMgYSBkaWZmZXJlbnQgb3JpZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldFBvaW50QnlPcmlnaW46IGZ1bmN0aW9uKG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRvTG9jYWxQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgcCwgcDI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luWCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9yaWdpblkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cblxuICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcDIgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwMiwgY2VudGVyLCAtZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDIuc3VidHJhY3RFcXVhbHMocCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIHRvR2xvYmFsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgLy8gICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocG9pbnQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSkuYWRkRXF1YWxzKG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIG9iamVjdCdzIG9yaWdpblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb3MgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkJ5T3JpZ2luOiBmdW5jdGlvbihwb3MsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAgIHRoaXMuc2V0KCdsZWZ0JywgcG9zaXRpb24ueCk7XG4gICAgICB0aGlzLnNldCgndG9wJywgcG9zaXRpb24ueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0byBPbmUgb2YgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAqL1xuICAgIGFkanVzdFBvc2l0aW9uOiBmdW5jdGlvbih0bykge1xuICAgICAgdmFyIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICBoeXBvdEZ1bGwgPSB0aGlzLmdldFNjYWxlZFdpZHRoKCksXG4gICAgICAgICAgeEZ1bGwgPSBmYWJyaWMudXRpbC5jb3MoYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIHlGdWxsID0gZmFicmljLnV0aWwuc2luKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICBvZmZzZXRGcm9tLCBvZmZzZXRUbztcblxuICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIG1peGVkIHNpdHVhdGlvbiBsaWtlIHRvcCwgY2VudGVyLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldEZyb20gPSBvcmlnaW5YT2Zmc2V0W3RoaXMub3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IHRoaXMub3JpZ2luWCAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldFRvID0gb3JpZ2luWE9mZnNldFt0b107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0VG8gPSB0byAtIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVmdCArPSB4RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy50b3AgKz0geUZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLm9yaWdpblggPSB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBjZW50ZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldE9yaWdpblRvQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IHRoaXMub3JpZ2luWDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLm9yaWdpblkgPSAnY2VudGVyJztcblxuICAgICAgdGhpcy5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0aGlzLnRvcCA9IGNlbnRlci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3Mgb3JpZ2luYWwgb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZXNldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSB0aGlzLl9vcmlnaW5hbE9yaWdpblg7XG4gICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLl9vcmlnaW5hbE9yaWdpblk7XG5cbiAgICAgIHRoaXMubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0aGlzLnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9wQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCAnbGVmdCcsICd0b3AnKTtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYXJyYXlGcm9tQ29vcmRzKGNvb3Jkcykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50bC54LCBjb29yZHMudGwueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50ci54LCBjb29yZHMudHIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ici54LCBjb29yZHMuYnIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ibC54LCBjb29yZHMuYmwueSlcbiAgICBdO1xuICB9XG5cbiAgdmFyIHV0aWwgPSBmYWJyaWMudXRpbCxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSB1dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gdXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuICAgICAgdHJhbnNmb3JtUG9pbnQgPSB1dGlsLnRyYW5zZm9ybVBvaW50O1xuXG4gIHV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogcHJvcGVydGllcyBhcmUgZGVwZW5kaW5nIG9uIGNvbnRyb2wga2V5cyBhbmQgcGFkZGluZyB0aGUgbWFpbiBjb250cm9scy5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHkgYW5kIGNvcm5lci5cbiAgICAgKiBUaGUgYGNvcm5lcmAgcHJvcGVydHkgY29udGFpbnMgaW4gYSBzaW1pbGFyIG1hbm5lciB0aGUgNCBwb2ludHMgb2YgdGhlXG4gICAgICogaW50ZXJhY3RpdmUgYXJlYSBvZiB0aGUgY29ybmVyLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhlIGNvbnRyb2xzIHBvc2l0aW9uSGFuZGxlciBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBkcmF3IGFuZCBsb2NhdGUgY29udHJvbHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxiciBhbmQgZGVzY3JpYmUgdGhlIGZvdXIgbWFpbiBjb3JuZXIuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5LCBpbnN0YW5jZSBvZiBGYWJyaWMuUG9pbnQuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGlzIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHQsIHNjYWxlWCwgc2NhbGVZXG4gICAgICogc2tld1gsIHNrZXdZLCBhbmdsZSwgc3Ryb2tlV2lkdGgsIHRvcCwgbGVmdC5cbiAgICAgKiBUaG9zZSBjb29yZGluYXRlcyBhcmUgdXNlZnVsIHRvIHVuZGVyc3RhbmQgd2hlcmUgYW4gb2JqZWN0IGlzLiBUaGV5IGdldCB1cGRhdGVkXG4gICAgICogd2l0aCBvQ29vcmRzIGJ1dCB0aGV5IGRvIG5vdCBuZWVkIHRvIGJlIHVwZGF0ZWQgd2hlbiB6b29tIG9yIHBhbm5pbmcgY2hhbmdlLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2Qgc2V0Q29vcmRzLlxuICAgICAqIFlvdSBjYW4gY2FsY3VsYXRlIHRoZW0gd2l0aG91dCB1cGRhdGluZyB3aXRoIEBtZXRob2QgY2FsY0FDb29yZHMoKTtcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIGluY2x1ZGVzIHBhZGRpbmcuIFVzZWQgb2Ygb2JqZWN0IGRldGVjdGlvbi5cbiAgICAgKiBzZXQgYW5kIHJlZnJlc2hlZCB3aXRoIHNldENvb3Jkcy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsaW5lQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBvd25NYXRyaXhDYWNoZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCBmdWxsIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBtYXRyaXhDYWNoZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGN1c3RvbSBjb250cm9scyBpbnRlcmZhY2VcbiAgICAgKiBjb250cm9scyBhcmUgYWRkZWQgYnkgZGVmYXVsdF9jb250cm9scy5qc1xuICAgICAqL1xuICAgIGNvbnRyb2xzOiB7IH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqIHRoaXMgd2lsbCByZXR1cm4gZWl0aGVyIGFDb29yZHMgb3IgbGluZUNvb3Jkcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIHdpbGwgcmV0dXJuIGFDb29yZHMgaWYgdHJ1ZSBvciBsaW5lQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7dGwsIHRyLCBiciwgYmx9IHBvaW50c1xuICAgICAqL1xuICAgIF9nZXRDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIGlmIChjYWxjdWxhdGUpIHtcbiAgICAgICAgcmV0dXJuIChhYnNvbHV0ZSA/IHRoaXMuY2FsY0FDb29yZHMoKSA6IHRoaXMuY2FsY0xpbmVDb29yZHMoKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYUNvb3JkcyB8fCAhdGhpcy5saW5lQ29vcmRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChhYnNvbHV0ZSA/IHRoaXMuYUNvb3JkcyA6IHRoaXMubGluZUNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBjb3JyZWN0IHNldCBvZiBjb29yZGluYXRlcyBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICogdGhpcyB3aWxsIHJldHVybiBlaXRoZXIgYUNvb3JkcyBvciBsaW5lQ29vcmRzLlxuICAgICAqIFRoZSBjb29yZHMgYXJlIHJldHVybmVkIGluIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBbdGwsIHRyLCBiciwgYmxdIG9mIHBvaW50c1xuICAgICAqL1xuICAgIGdldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgcmV0dXJuIGFycmF5RnJvbUNvb3Jkcyh0aGlzLl9nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZShcbiAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgIHBvaW50VEwsXG4gICAgICAgICAgICBwb2ludEJSXG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aE9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKFxuICAgICAgICB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgb3RoZXIuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbidcbiAgICAgICAgfHwgb3RoZXIuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICAgfHwgdGhpcy5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5PYmplY3Q6IGZ1bmN0aW9uKG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgb3RoZXJDb29yZHMgPSBhYnNvbHV0ZSA/IG90aGVyLmFDb29yZHMgOiBvdGhlci5saW5lQ29vcmRzLFxuICAgICAgICAgIGkgPSAwLCBsaW5lcyA9IG90aGVyLl9nZXRJbWFnZUxpbmVzKG90aGVyQ29vcmRzKTtcbiAgICAgIGZvciAoOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGlmICghb3RoZXIuY29udGFpbnNQb2ludChwb2ludHNbaV0sIGxpbmVzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpblJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgPj0gcG9pbnRUTC54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoIDw9IHBvaW50QlIueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QudG9wID49IHBvaW50VEwueSAmJlxuICAgICAgICBib3VuZGluZ1JlY3QudG9wICsgYm91bmRpbmdSZWN0LmhlaWdodCA8PSBwb2ludEJSLnlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtsaW5lc10gb2JqZWN0IHJldHVybmVkIGZyb20gQG1ldGhvZCBfZ2V0SW1hZ2VMaW5lc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCwgbGluZXMsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgbGluZXMgPSBsaW5lcyB8fCB0aGlzLl9nZXRJbWFnZUxpbmVzKGNvb3JkcyksXG4gICAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyhwb2ludCwgbGluZXMpO1xuICAgICAgLy8gaWYgeFBvaW50cyBpcyBvZGQgdGhlbiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAgcmV0dXJuICh4UG9pbnRzICE9PSAwICYmIHhQb2ludHMgJSAyID09PSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogdGhlIGNoZWNrIGlzIGRvbmUgc3RvcHBpbmcgYXQgZmlyc3QgcG9pbnQgdGhhdCBhcHBlYXJzIG9uIHNjcmVlblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAuYUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IG9yIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIGNhbnZhc1xuICAgICAqL1xuICAgIGlzT25TY3JlZW46IGZ1bmN0aW9uKGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRUTCA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy50bCwgcG9pbnRCUiA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy5icjtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3Jkcyh0cnVlLCBjYWxjdWxhdGUpO1xuICAgICAgLy8gaWYgc29tZSBwb2ludCBpcyBvbiBzY3JlZW4sIHRoZSBvYmplY3QgaXMgb24gc2NyZWVuLlxuICAgICAgaWYgKHBvaW50cy5zb21lKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludC54IDw9IHBvaW50QlIueCAmJiBwb2ludC54ID49IHBvaW50VEwueCAmJlxuICAgICAgICBwb2ludC55IDw9IHBvaW50QlIueSAmJiBwb2ludC55ID49IHBvaW50VEwueTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gbm8gcG9pbnRzIG9uIHNjcmVlbiwgY2hlY2sgaW50ZXJzZWN0aW9uIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNXaXRoUmVjdChwb2ludFRMLCBwb2ludEJSLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIG1pZHBvaW50IGJldHdlZW4gY2FudmFzIGV4dHJlbWl0aWVzXG4gICAgICogRG9lcyBub3QgbWFrZSBzZW5zZSBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGlzT25TY3JlZW4gYW5kIGlzUGFydGlhbGx5T25TY3JlZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludFRMIFRvcCBMZWZ0IHBvaW50XG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50QlIgVG9wIFJpZ2h0IHBvaW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYWxjdWxhdGUgdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfY29udGFpbnNDZW50ZXJPZkNhbnZhczogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKSB7XG4gICAgICAvLyB3b3JzdCBjYXNlIHNjZW5hcmlvIHRoZSBvYmplY3QgaXMgc28gYmlnIHRoYXQgY29udGFpbnMgdGhlIHNjcmVlblxuICAgICAgdmFyIGNlbnRlclBvaW50ID0geyB4OiAocG9pbnRUTC54ICsgcG9pbnRCUi54KSAvIDIsIHk6IChwb2ludFRMLnkgKyBwb2ludEJSLnkpIC8gMiB9O1xuICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChjZW50ZXJQb2ludCwgbnVsbCwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIGNhbnZhc1xuICAgICAqL1xuICAgIGlzUGFydGlhbGx5T25TY3JlZW46IGZ1bmN0aW9uKGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRUTCA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy50bCwgcG9pbnRCUiA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy5icjtcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNXaXRoUmVjdChwb2ludFRMLCBwb2ludEJSLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGFsbFBvaW50c0FyZU91dHNpZGUgPSB0aGlzLmdldENvb3Jkcyh0cnVlLCBjYWxjdWxhdGUpLmV2ZXJ5KGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAocG9pbnQueCA+PSBwb2ludEJSLnggfHwgcG9pbnQueCA8PSBwb2ludFRMLngpICYmXG4gICAgICAgIChwb2ludC55ID49IHBvaW50QlIueSB8fCBwb2ludC55IDw9IHBvaW50VEwueSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxQb2ludHNBcmVPdXRzaWRlICYmIHRoaXMuX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0IGVkZ2VzIGluIGl0LCBnaXZlbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQ29vcmRzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgY29ybmVyc1xuICAgICAqL1xuICAgIF9nZXRJbWFnZUxpbmVzOiBmdW5jdGlvbihvQ29vcmRzKSB7XG5cbiAgICAgIHZhciBsaW5lcyA9IHtcbiAgICAgICAgdG9wbGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudGwsXG4gICAgICAgICAgZDogb0Nvb3Jkcy50clxuICAgICAgICB9LFxuICAgICAgICByaWdodGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYnJcbiAgICAgICAgfSxcbiAgICAgICAgYm90dG9tbGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMuYnIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5ibFxuICAgICAgICB9LFxuICAgICAgICBsZWZ0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMuYmwsXG4gICAgICAgICAgZDogb0Nvb3Jkcy50bFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyAvLyBkZWJ1Z2dpbmdcbiAgICAgIC8vIGlmICh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLmQueCwgbGluZXMudG9wbGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IGNyb3NzIHBvaW50cyBhcmUgYmV0d2VlbiB0aGUgNCBvYmplY3QgZWRnZXNcbiAgICAgKiBhbmQgdGhlIGhvcml6b250YWwgbGluZSBkZXRlcm1pbmVkIGJ5IGEgcG9pbnQgb24gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGluZXMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiZWluZyBldmFsdWF0ZWRcbiAgICAgKi9cbiAgICAvLyByZW1vdmUgeWksIG5vdCB1c2VkIGJ1dCBsZWZ0IGNvZGUgaGVyZSBqdXN0IGluIGNhc2UuXG4gICAgX2ZpbmRDcm9zc1BvaW50czogZnVuY3Rpb24ocG9pbnQsIGxpbmVzKSB7XG4gICAgICB2YXIgYjEsIGIyLCBhMSwgYTIsIHhpLCAvLyB5aSxcbiAgICAgICAgICB4Y291bnQgPSAwLFxuICAgICAgICAgIGlMaW5lO1xuXG4gICAgICBmb3IgKHZhciBsaW5lS2V5IGluIGxpbmVzKSB7XG4gICAgICAgIGlMaW5lID0gbGluZXNbbGluZUtleV07XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAxOiBsaW5lIGJlbG93IHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA8IHBvaW50LnkpICYmIChpTGluZS5kLnkgPCBwb2ludC55KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAyOiBsaW5lIGFib3ZlIHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA+PSBwb2ludC55KSAmJiAoaUxpbmUuZC55ID49IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDM6IHZlcnRpY2FsIGxpbmUgY2FzZVxuICAgICAgICBpZiAoKGlMaW5lLm8ueCA9PT0gaUxpbmUuZC54KSAmJiAoaUxpbmUuby54ID49IHBvaW50LngpKSB7XG4gICAgICAgICAgeGkgPSBpTGluZS5vLng7XG4gICAgICAgICAgLy8geWkgPSBwb2ludC55O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGIxID0gMDtcbiAgICAgICAgICBiMiA9IChpTGluZS5kLnkgLSBpTGluZS5vLnkpIC8gKGlMaW5lLmQueCAtIGlMaW5lLm8ueCk7XG4gICAgICAgICAgYTEgPSBwb2ludC55IC0gYjEgKiBwb2ludC54O1xuICAgICAgICAgIGEyID0gaUxpbmUuby55IC0gYjIgKiBpTGluZS5vLng7XG5cbiAgICAgICAgICB4aSA9IC0oYTEgLSBhMikgLyAoYjEgLSBiMik7XG4gICAgICAgICAgLy8geWkgPSBhMSArIGIxICogeGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBjb3VudCB4aSA8IHBvaW50LnggY2FzZXNcbiAgICAgICAgaWYgKHhpID49IHBvaW50LngpIHtcbiAgICAgICAgICB4Y291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gNDogc3BlY2lmaWMgZm9yIHNxdWFyZSBpbWFnZXNcbiAgICAgICAgaWYgKHhjb3VudCA9PT0gMikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIHRoZSBib3ggaXMgaW50ZW5kZWQgYXMgYWxpZ25lZCB0byBheGlzIG9mIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHMgLyAuYUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICAgIHJldHVybiB1dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggY291bnRpbmcgdHJhbnNmb3JtYXRpb25zXG4gICAgICogYmVmb3JlIDIuMCBpdCB3YXMgbmFtZWQgZ2V0V2lkdGgoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIGFuIG9iamVjdCBib3VuZGluZyBib3ggY291bnRpbmcgdHJhbnNmb3JtYXRpb25zXG4gICAgICogYmVmb3JlIDIuMCBpdCB3YXMgbmFtZWQgZ2V0SGVpZ2h0KCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhlIHNjYWxlIGlzIHZhbGlkIGFuZCBtb2RpZmllcyBpdCBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBfY29uc3RyYWluU2NhbGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgdGhpcy5taW5TY2FsZUxpbWl0KSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLXRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IChlcXVhbGx5IGJ5IHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFNjYWxlIGZhY3RvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWCcsIHZhbHVlKTtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVZJywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiB3aWR0aCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IHdpZHRoIHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9XaWR0aDogZnVuY3Rpb24odmFsdWUsIGFic29sdXRlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlKS53aWR0aCAvIHRoaXMuZ2V0U2NhbGVkV2lkdGgoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy53aWR0aCAvIGJvdW5kaW5nUmVjdEZhY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiBoZWlnaHQsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyBoZWlnaHQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb0hlaWdodDogZnVuY3Rpb24odmFsdWUsIGFic29sdXRlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlKS5oZWlnaHQgLyB0aGlzLmdldFNjYWxlZEhlaWdodCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLmhlaWdodCAvIGJvdW5kaW5nUmVjdEZhY3Rvcik7XG4gICAgfSxcblxuICAgIGNhbGNMaW5lQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZywgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IHV0aWwuY29zKGFuZ2xlKSwgc2luID0gdXRpbC5zaW4oYW5nbGUpLFxuICAgICAgICAgIGNvc1AgPSBjb3MgKiBwYWRkaW5nLCBzaW5QID0gc2luICogcGFkZGluZywgY29zUFNpblAgPSBjb3NQICsgc2luUCxcbiAgICAgICAgICBjb3NQTWludXNTaW5QID0gY29zUCAtIHNpblAsIGFDb29yZHMgPSB0aGlzLmNhbGNBQ29vcmRzKCk7XG5cbiAgICAgIHZhciBsaW5lQ29vcmRzID0ge1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50bCwgdnB0KSxcbiAgICAgICAgdHI6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMudHIsIHZwdCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJsLCB2cHQpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy5iciwgdnB0KSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIGxpbmVDb29yZHMudGwueCAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRsLnkgLT0gY29zUFNpblA7XG4gICAgICAgIGxpbmVDb29yZHMudHIueCArPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci55IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYmwueCAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC55ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueCArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJyLnkgKz0gY29zUFNpblA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lQ29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjT0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgc3RhcnRNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHZwdCwgdHJhbnNsYXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoc3RhcnRNYXRyaXgsIHJvdGF0ZU1hdHJpeCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKGZpbmFsTWF0cml4LCBbMSAvIHZwdFswXSwgMCwgMCwgMSAvIHZwdFszXSwgMCwgMF0pLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgY29vcmRzID0ge307XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIGNvb3Jkc1trZXldID0gY29udHJvbC5wb3NpdGlvbkhhbmRsZXIoZGltLCBmaW5hbE1hdHJpeCwgZmFicmljT2JqZWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWJ1ZyBjb2RlXG4gICAgICAvLyB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5jbGVhclJlY3QoMCwgMCwgNzAwLCA3MDApO1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5maWxsU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gICBPYmplY3Qua2V5cyhjb29yZHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyAgICAgdmFyIGNvbnRyb2wgPSBjb29yZHNba2V5XTtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChjb250cm9sLngsIGNvbnRyb2wueSwgMywgMyk7XG4gICAgICAvLyAgIH0pO1xuICAgICAgLy8gfSwgNTApO1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgY2FsY0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRyYW5zbGF0ZU1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3ID0gZGltLnggLyAyLCBoID0gZGltLnkgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiBoIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYnI6IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogaCB9LCBmaW5hbE1hdHJpeClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIGFuZCBjb250cm9scyBwb3NpdGlvbiBjb29yZGluYXRlcyBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0LCBsZWZ0IGFuZCB0b3AuXG4gICAgICogb0Nvb3JkcyBhcmUgdXNlZCB0byBmaW5kIHRoZSBjb3JuZXJzXG4gICAgICogYUNvb3JkcyBhcmUgdXNlZCB0byBxdWlja2x5IGZpbmQgYW4gb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBsaW5lQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBvYmplY3QgZHVyaW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ZhYnJpY2pzL2ZhYnJpYy5qcy93aWtpL1doZW4tdG8tY2FsbC1zZXRDb29yZHN9IGFuZCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtZ290Y2hhc31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb3JuZXJzXSBza2lwIGNhbGN1bGF0aW9uIG9mIG9Db29yZHMuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb29yZHM6IGZ1bmN0aW9uKHNraXBDb3JuZXJzKSB7XG4gICAgICB0aGlzLmFDb29yZHMgPSB0aGlzLmNhbGNBQ29vcmRzKCk7XG4gICAgICAvLyBpbiBjYXNlIHdlIGFyZSBpbiBhIGdyb3VwLCBmb3IgaG93IHRoZSBpbm5lciBncm91cCB0YXJnZXQgY2hlY2sgd29ya3MsXG4gICAgICAvLyBsaW5lQ29vcmRzIGFyZSBleGFjdGx5IGFDb29yZHMuIFNpbmNlIHRoZSB2cHQgZ2V0cyBhYnNvcmJlZCBieSB0aGUgbm9ybWFsaXplZCBwb2ludGVyLlxuICAgICAgdGhpcy5saW5lQ29vcmRzID0gdGhpcy5ncm91cCA/IHRoaXMuYUNvb3JkcyA6IHRoaXMuY2FsY0xpbmVDb29yZHMoKTtcbiAgICAgIGlmIChza2lwQ29ybmVycykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgdGhpcy5vQ29vcmRzID0gdGhpcy5jYWxjT0Nvb3JkcygpO1xuICAgICAgdGhpcy5fc2V0Q29ybmVyQ29vcmRzICYmIHRoaXMuX3NldENvcm5lckNvb3JkcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlsLmNhbGNSb3RhdGVNYXRyaXgodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb24gbWF0cml4IGZvciBhbiBvYmplY3QgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjVHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIGNlbnRlci54LCBjZW50ZXIueV07XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hdHJpeEtleTogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgc2VwID0gJ18nLCBwcmVmaXggPSAnJztcbiAgICAgIGlmICghc2tpcEdyb3VwICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSArIHNlcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy50b3AgKyBzZXAgKyB0aGlzLmxlZnQgKyBzZXAgKyB0aGlzLnNjYWxlWCArIHNlcCArIHRoaXMuc2NhbGVZICtcbiAgICAgICAgc2VwICsgdGhpcy5za2V3WCArIHNlcCArIHRoaXMuc2tld1kgKyBzZXAgKyB0aGlzLmFuZ2xlICsgc2VwICsgdGhpcy5vcmlnaW5YICsgc2VwICsgdGhpcy5vcmlnaW5ZICtcbiAgICAgICAgc2VwICsgdGhpcy53aWR0aCArIHNlcCArIHRoaXMuaGVpZ2h0ICsgc2VwICsgdGhpcy5zdHJva2VXaWR0aCArIHRoaXMuZmxpcFggKyB0aGlzLmZsaXBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25zIGZyb20gdGhlXG4gICAgICogb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwR3JvdXBdIHJldHVybiB0cmFuc2Zvcm0gbWF0cml4IGZvciBvYmplY3Qgbm90IGNvdW50aW5nIHBhcmVudCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBUaGVyZSBhcmUgc29tZSBzaXR1YXRpb24gaW4gd2hpY2ggdGhpcyBpcyB1c2VmdWwgdG8gYXZvaWQgdGhlIGZha2Ugcm90YXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihza2lwR3JvdXApIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIGlmIChza2lwR3JvdXAgfHwgIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0aGlzLnRyYW5zZm9ybU1hdHJpeEtleShza2lwR3JvdXApLCBjYWNoZSA9IHRoaXMubWF0cml4Q2FjaGUgfHwgKHRoaXMubWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyh0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoZmFsc2UpLCBtYXRyaXgpO1xuICAgICAgfVxuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgY2FjaGUudmFsdWUgPSBtYXRyaXg7XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25zIGZyb20gdGhlXG4gICAgICogb2JqZWN0J3MgcHJvcGVydGllcywgdGhpcyBtYXRyaXggZG9lcyBub3QgaW5jbHVkZSB0aGUgZ3JvdXAgdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNPd25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHRydWUpLCBjYWNoZSA9IHRoaXMub3duTWF0cml4Q2FjaGUgfHwgKHRoaXMub3duTWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHRNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogdE1hdHJpeFs0XSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHRNYXRyaXhbNV0sXG4gICAgICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgICAgIHNrZXdYOiB0aGlzLnNrZXdYLFxuICAgICAgICAgICAgc2tld1k6IHRoaXMuc2tld1ksXG4gICAgICAgICAgICBmbGlwWDogdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiB0aGlzLmZsaXBZLFxuICAgICAgICAgIH07XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IHV0aWwuY29tcG9zZU1hdHJpeChvcHRpb25zKTtcbiAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYLCBhIHZhbHVlIHRvIG92ZXJyaWRlIGN1cnJlbnQgc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1ksIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbihza2V3WCwgc2tld1kpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2tld1ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2tld1kgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdZID0gdGhpcy5za2V3WTtcbiAgICAgIH1cbiAgICAgIHZhciBkaW1lbnNpb25zLCBkaW1YLCBkaW1ZLFxuICAgICAgICAgIG5vU2tldyA9IHNrZXdYID09PSAwICYmIHNrZXdZID09PSAwO1xuXG4gICAgICBpZiAodGhpcy5zdHJva2VVbmlmb3JtKSB7XG4gICAgICAgIGRpbVggPSB0aGlzLndpZHRoO1xuICAgICAgICBkaW1ZID0gdGhpcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBkaW1YID0gZGltZW5zaW9ucy54O1xuICAgICAgICBkaW1ZID0gZGltZW5zaW9ucy55O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2tldykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGRpbVggKiB0aGlzLnNjYWxlWCwgZGltWSAqIHRoaXMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYm94ID0gdXRpbC5zaXplQWZ0ZXJUcmFuc2Zvcm0oZGltWCwgZGltWSwge1xuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1gsXG4gICAgICAgIHNrZXdZOiBza2V3WSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRGltZW5zaW9ucyhiYm94LngsIGJib3gueSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBib3VuZGluZyBib3ggZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzIHNjYWxlLCBza2V3LlxuICAgICAqIEBwYXJhbSBOdW1iZXIgd2lkdGggd2lkdGggb2YgdGhlIGJib3hcbiAgICAgKiBAcGFyYW0gTnVtYmVyIGhlaWdodCBoZWlnaHQgb2YgdGhlIGJib3hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggZmluYWxpemVkIHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgZmluYWxpemVkIGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZmluYWxpemVEaW1lbnNpb25zOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJva2VVbmlmb3JtID9cbiAgICAgICAgeyB4OiB3aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIHk6IGhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGggfVxuICAgICAgICA6XG4gICAgICAgIHsgeDogd2lkdGgsIHk6IGhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmb3IgY29udHJvbHMgYm94LCBpbmNsdWRpbmcgcGFkZGluZyBhbmQgY2FudmFzIHpvb20uXG4gICAgICogYW5kIGFjdGl2ZSBzZWxlY3Rpb25cbiAgICAgKiBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zOiBmdW5jdGlvbigpICB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHAgPSB0cmFuc2Zvcm1Qb2ludChkaW0sIHZwdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kVG9CYWNrKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nVG9Gcm9udCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCBkb3duIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZW5kQmFja3dhcmRzOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuc2VuZEJhY2t3YXJkcy5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nRm9yd2FyZCh0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBOZXcgcG9zaXRpb24gb2Ygb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSAhPT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLm1vdmVUby5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLm1vdmVUbyh0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBnZXRTdmdDb2xvclN0cmluZyhwcm9wLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogbm9uZTsgJztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUudG9MaXZlKSB7XG4gICAgICByZXR1cm4gcHJvcCArICc6IHVybCgjU1ZHSURfJyArIHZhbHVlLmlkICsgJyk7ICc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSksXG4gICAgICAgICAgc3RyID0gcHJvcCArICc6ICcgKyBjb2xvci50b1JnYigpICsgJzsgJyxcbiAgICAgICAgICBvcGFjaXR5ID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIC8vY2hhbmdlIHRoZSBjb2xvciBpbiByZ2IgKyBvcGFjaXR5XG4gICAgICAgIHN0ciArPSBwcm9wICsgJy1vcGFjaXR5OiAnICsgb3BhY2l0eS50b1N0cmluZygpICsgJzsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcblxuICAgICAgdmFyIGZpbGxSdWxlID0gdGhpcy5maWxsUnVsZSA/IHRoaXMuZmlsbFJ1bGUgOiAnbm9uemVybycsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoID8gdGhpcy5zdHJva2VXaWR0aCA6ICcwJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmpvaW4oJyAnKSA6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0ID8gdGhpcy5zdHJva2VEYXNoT2Zmc2V0IDogJzAnLFxuICAgICAgICAgIHN0cm9rZUxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXAgPyB0aGlzLnN0cm9rZUxpbmVDYXAgOiAnYnV0dCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luID8gdGhpcy5zdHJva2VMaW5lSm9pbiA6ICdtaXRlcicsXG4gICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA/IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA6ICc0JyxcbiAgICAgICAgICBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wYWNpdHkgOiAnMScsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JyxcbiAgICAgICAgICBmaWx0ZXIgPSBza2lwU2hhZG93ID8gJycgOiB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICAgIGZpbGwgPSBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHRoaXMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoOiAnLCBzdHJva2VXaWR0aCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXk6ICcsIHN0cm9rZURhc2hBcnJheSwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwOiAnLCBzdHJva2VMaW5lQ2FwLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQ6ICcsIHN0cm9rZURhc2hPZmZzZXQsICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW46ICcsIHN0cm9rZUxpbmVKb2luLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQ6ICcsIHN0cm9rZU1pdGVyTGltaXQsICc7ICcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgICdmaWxsLXJ1bGU6ICcsIGZpbGxSdWxlLCAnOyAnLFxuICAgICAgICAnb3BhY2l0eTogJywgb3BhY2l0eSwgJzsnLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlV2hpdGVTcGFjZSBhIGJvb2xlYW4gdG8gaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBpbiB0aGUgc3R5bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1NwYW5TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlLCB1c2VXaGl0ZVNwYWNlKSB7XG4gICAgICB2YXIgdGVybSA9ICc7ICc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgP1xuICAgICAgICAnZm9udC1mYW1pbHk6ICcgKyAoKChzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1xcJycpID09PSAtMSAmJiBzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1wiJykgPT09IC0xKSA/XG4gICAgICAgICAgJ1xcJycgKyBzdHlsZS5mb250RmFtaWx5ICArICdcXCcnIDogc3R5bGUuZm9udEZhbWlseSkpICsgdGVybSA6ICcnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGggPyAnc3Ryb2tlLXdpZHRoOiAnICsgc3R5bGUuc3Ryb2tlV2lkdGggKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSA/ICdmb250LXNpemU6ICcgKyBzdHlsZS5mb250U2l6ZSArICdweCcgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU6ICcgKyBzdHlsZS5mb250U3R5bGUgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ6ICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZpbGwgPSBzdHlsZS5maWxsID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCBzdHlsZS5maWxsKSA6ICcnLFxuICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLnN0cm9rZSA/IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpIDogJycsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHN0eWxlKSxcbiAgICAgICAgICBkZWx0YVkgPSBzdHlsZS5kZWx0YVkgPyAnYmFzZWxpbmUtc2hpZnQ6ICcgKyAoLXN0eWxlLmRlbHRhWSkgKyAnOyAnIDogJyc7XG4gICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgdGV4dERlY29yYXRpb24gPSAndGV4dC1kZWNvcmF0aW9uOiAnICsgdGV4dERlY29yYXRpb24gKyB0ZXJtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZGVsdGFZLFxuICAgICAgICB1c2VXaGl0ZVNwYWNlID8gJ3doaXRlLXNwYWNlOiBwcmU7ICcgOiAnJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0LWRlY29yYXRpb24gcHJvcGVydHkgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICByZXR1cm4gWydvdmVybGluZScsICd1bmRlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10uZmlsdGVyKGZ1bmN0aW9uKGRlY29yYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlW2RlY29yYXRpb24ucmVwbGFjZSgnLScsICcnKV07XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlsdGVyIGZvciBzdmcgc2hhZG93XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkb3cgPyAnZmlsdGVyOiB1cmwoI1NWR0lEXycgKyB0aGlzLnNoYWRvdy5pZCArICcpOycgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZCBhdHRyaWJ1dGUgZm9yIHN2ZyBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnQ29tbW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmlkID8gJ2lkPVwiJyArIHRoaXMuaWQgKyAnXCIgJyA6ICcnLFxuICAgICAgICB0aGlzLmNsaXBQYXRoID8gJ2NsaXAtcGF0aD1cInVybCgjJyArIHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCArICcpXCIgJyA6ICcnLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2UgdGhlIGZ1bGwgdHJhbnNmb3JtIG9yIHRoZSBzaW5nbGUgb2JqZWN0IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVHJhbnNmb3JtOiBmdW5jdGlvbihmdWxsLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZnVsbCA/IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpIDogdGhpcy5jYWxjT3duTWF0cml4KCksXG4gICAgICAgICAgc3ZnVHJhbnNmb3JtID0gJ3RyYW5zZm9ybT1cIicgKyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHN2Z1RyYW5zZm9ybSArXG4gICAgICAgIChhZGRpdGlvbmFsVHJhbnNmb3JtIHx8ICcnKSArICdcIiAnO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzKSB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5iYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy53aWR0aCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuICdcXHQnICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKHJldml2ZXIpLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycsXG4gICAgICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0odHJ1ZSwgYWRkaXRpb25hbFRyYW5zZm9ybSksXG4gICAgICAgICAgICB0aGlzLmdldFN2Z0NvbW1vbnMoKSxcbiAgICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICAgIC8vIGluc2VydCBjb21tb25zIGluIHRoZSBtYXJrdXAsIHN0eWxlIGFuZCBzdmdDb21tb25zXG4gICAgICAgICAgaW5kZXggPSBvYmplY3RNYXJrdXAuaW5kZXhPZignQ09NTU9OX1BBUlRTJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG9iamVjdE1hcmt1cC5qb2luKCcnKSkgOiBvYmplY3RNYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VTVkdNYXJrdXA6IGZ1bmN0aW9uKG9iamVjdE1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgbm9TdHlsZSA9IG9wdGlvbnMubm9TdHlsZSxcbiAgICAgICAgICByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIHN0eWxlSW5mbyA9IG5vU3R5bGUgPyAnJyA6ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z1N0eWxlcygpICsgJ1wiICcsXG4gICAgICAgICAgc2hhZG93SW5mbyA9IG9wdGlvbnMud2l0aFNoYWRvdyA/ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z0ZpbHRlcigpICsgJ1wiICcgOiAnJyxcbiAgICAgICAgICBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsXG4gICAgICAgICAgdmVjdG9yRWZmZWN0ID0gdGhpcy5zdHJva2VVbmlmb3JtID8gJ3ZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiAnIDogJycsXG4gICAgICAgICAgYWJzb2x1dGVDbGlwUGF0aCA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCxcbiAgICAgICAgICBzdHJva2UgPSB0aGlzLnN0cm9rZSwgZmlsbCA9IHRoaXMuZmlsbCwgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgICAgY29tbW9uUGllY2VzLCBtYXJrdXAgPSBbXSwgY2xpcFBhdGhNYXJrdXAsXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKSxcbiAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgY2xpcFBhdGhNYXJrdXAgPSAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIGNsaXBQYXRoLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikgK1xuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoYWJzb2x1dGVDbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPGcgJywgc2hhZG93SW5mbywgdGhpcy5nZXRTdmdDb21tb25zKCksICcgPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgJyxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oZmFsc2UpLFxuICAgICAgICAhYWJzb2x1dGVDbGlwUGF0aCA/IHNoYWRvd0luZm8gKyB0aGlzLmdldFN2Z0NvbW1vbnMoKSA6ICcnLFxuICAgICAgICAnID5cXG4nXG4gICAgICApO1xuICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICBzdHlsZUluZm8sXG4gICAgICAgIHZlY3RvckVmZmVjdCxcbiAgICAgICAgbm9TdHlsZSA/ICcnIDogdGhpcy5hZGRQYWludE9yZGVyKCksICcgJyxcbiAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA/ICd0cmFuc2Zvcm09XCInICsgYWRkaXRpb25hbFRyYW5zZm9ybSArICdcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgICAgb2JqZWN0TWFya3VwW2luZGV4XSA9IGNvbW1vblBpZWNlcztcbiAgICAgIGlmIChmaWxsICYmIGZpbGwudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKGZpbGwudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2UudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHN0cm9rZS50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goY2xpcFBhdGhNYXJrdXApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2gob2JqZWN0TWFya3VwLmpvaW4oJycpKTtcbiAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICBhYnNvbHV0ZUNsaXBQYXRoICYmIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgYWRkUGFpbnRPcmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcgPyAnIHBhaW50LW9yZGVyPVwiJyArIHRoaXMucGFpbnRGaXJzdCArICdcIiAnIDogJyc7XG4gICAgfVxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBvcmlnaW5hbFNldCA9ICdzdGF0ZVByb3BlcnRpZXMnO1xuXG4gIC8qXG4gICAgRGVwZW5kcyBvbiBgc3RhdGVQcm9wZXJ0aWVzYFxuICAqL1xuICBmdW5jdGlvbiBzYXZlUHJvcHMob3JpZ2luLCBkZXN0aW5hdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgdG1wT2JqID0geyB9LCBkZWVwID0gdHJ1ZTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHRtcE9ialtwcm9wXSA9IG9yaWdpbltwcm9wXTtcbiAgICB9KTtcblxuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBzaW5jZSBjbGlwUGF0aCBpcyBpbiB0aGUgc3RhdGVmdWxsIGNhY2hlIGxpc3QgYW5kIHRoZSBjbGlwUGF0aCBvYmplY3RzXG4gICAgICAgIC8vIHdvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIG9iamVjdCwgdGhpcyB3b3VsZCBsZWFkIHRvIHBvc3NpYmxlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBjb21wYXJlIHRob3NlLlxuICAgICAgICBpZiAoa2V5ID09PSAnY2FudmFzJyB8fCBrZXkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eVNldF0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHNldCBvZiBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNhdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGluc3RhbmNlJyBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2F2ZVN0YXRlfWAgd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc1N0YXRlQ2hhbmdlZDogZnVuY3Rpb24ocHJvcGVydHlTZXQpIHtcbiAgICAgIHByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICB2YXIgZGFzaGVkUHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSkubGVuZ3RoIDwgdGhpc1twcm9wZXJ0eVNldF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoIXRoaXNbZGVzdGluYXRpb25dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwU3RhdGUob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIHRoaXNbcHJvcGVydHlTZXRdKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXR1cFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgb3B0aW9ucy5wcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0O1xuICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eVNldF0gPSB7IH07XG4gICAgICB0aGlzLnNhdmVTdGF0ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGljaCBjb3JuZXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgVGhlIHBvaW50ZXIgaW5kaWNhdGluZyB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn0gY29ybmVyIGNvZGUgKHRsLCB0ciwgYmwsIGJyLCBldGMuKSwgb3IgZmFsc2UgaWYgbm90aGluZyBpcyBmb3VuZFxuICAgICAqL1xuICAgIF9maW5kVGFyZ2V0Q29ybmVyOiBmdW5jdGlvbihwb2ludGVyLCBmb3JUb3VjaCkge1xuICAgICAgLy8gb2JqZWN0cyBpbiBncm91cCwgYW55a2luZCwgYXJlIG5vdCBzZWxmIG1vZGlmaWNhYmxlLFxuICAgICAgLy8gbXVzdCBub3QgcmV0dXJuIGFuIGhvdmVyZWQgY29ybmVyLlxuICAgICAgaWYgKCF0aGlzLmhhc0NvbnRyb2xzIHx8IHRoaXMuZ3JvdXAgfHwgKCF0aGlzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBleCA9IHBvaW50ZXIueCxcbiAgICAgICAgICBleSA9IHBvaW50ZXIueSxcbiAgICAgICAgICB4UG9pbnRzLFxuICAgICAgICAgIGxpbmVzLCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vQ29vcmRzKSxcbiAgICAgICAgICBqID0ga2V5cy5sZW5ndGggLSAxLCBpO1xuICAgICAgdGhpcy5fX2Nvcm5lciA9IDA7XG5cbiAgICAgIC8vIGN5Y2xlIGluIHJldmVyc2Ugb3JkZXIgc28gd2UgcGljayBmaXJzdCB0aGUgb25lIG9uIHRvcFxuICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSB0aGlzLl9nZXRJbWFnZUxpbmVzKGZvclRvdWNoID8gdGhpcy5vQ29vcmRzW2ldLnRvdWNoQ29ybmVyIDogdGhpcy5vQ29vcmRzW2ldLmNvcm5lcik7XG4gICAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuZC54LCBsaW5lcy5ib3R0b21saW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuZC54LCBsaW5lcy5yaWdodGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHsgeDogZXgsIHk6IGV5IH0sIGxpbmVzKTtcbiAgICAgICAgaWYgKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fY29ybmVyID0gaTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGNvbnRyb2wuIFRoZSBmdW5jdGlvbiBnZXRzIGNhbGxlZCxcbiAgICAgKiB3aXRoIHRoZSBjb250cm9sLCB0aGUgb2JqZWN0IHRoYXQgaXMgY2FsbGluZyB0aGUgaXRlcmF0b3IgYW5kIHRoZSBjb250cm9sJ3Mga2V5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjb250cm9scyBvdmVyXG4gICAgICovXG4gICAgZm9yRWFjaENvbnRyb2w6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuY29udHJvbHMpIHtcbiAgICAgICAgZm4odGhpcy5jb250cm9sc1tpXSwgaSwgdGhpcyk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIG9mXG4gICAgICogdGhlIGltYWdlIHVzZWQgdG8gc2NhbGUvcm90YXRlIGl0LlxuICAgICAqIG5vdGU6IGlmIHdlIHdvdWxkIHN3aXRjaCB0byBST1VORCBjb3JuZXIgYXJlYSwgYWxsIG9mIHRoaXMgd291bGQgZGlzYXBwZWFyLlxuICAgICAqIGV2ZXJ5dGhpbmcgd291bGQgcmVzb2x2ZSB0byBhIHNpbmdsZSBwb2ludCBhbmQgYSBweXRoYWdvcmVhbiB0aGVvcmVtIGZvciB0aGUgZGlzdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMub0Nvb3JkcztcblxuICAgICAgZm9yICh2YXIgY29udHJvbCBpbiBjb29yZHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xPYmplY3QgPSB0aGlzLmNvbnRyb2xzW2NvbnRyb2xdO1xuICAgICAgICBjb29yZHNbY29udHJvbF0uY29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMuY29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCBmYWxzZSk7XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS50b3VjaENvcm5lciA9IGNvbnRyb2xPYmplY3QuY2FsY0Nvcm5lckNvb3JkcyhcbiAgICAgICAgICB0aGlzLmFuZ2xlLCB0aGlzLnRvdWNoQ29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0LCBpbnNpZGUgaXRzIHNlbGVjdGlvbiBib3JkZXJzLlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBjb250ZXh0IGlzIHRyYW5zZm9ybWVkXG4gICAgICogaGFzIGNoZWNrcyB0byBiZSBza2lwcGVkIHdoZW4gdGhlIG9iamVjdCBpcyBvbiBhIHN0YXRpY0NhbnZhc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3U2VsZWN0aW9uQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiAhdGhpcy5jYW52YXMuaW50ZXJhY3RpdmUpIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdnB0WzBdLCAxIC8gdnB0WzNdKTtcbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoLXdoLnggLyAyLCAtd2gueSAvIDIsIHdoLngsIHdoLnkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhhc0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IGZhbHNlO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSk7XG5cbiAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAtaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICAgIC8vIGluIHRoaXMgbW9tZW50LCB0aGUgY3R4IGlzIGNlbnRlcmVkIG9uIHRoZSBvYmplY3QuXG4gICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYWJvdmUgZnVuY3Rpb24gYXJlIHRoZSBzaXplIG9mIHRoZSBiYm94LlxuICAgICAgICAgIGlmIChjb250cm9sLndpdGhDb25uZWN0aW9uICYmIGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IG1vdmVtZW50IGZvciBlYWNoIGNvbnRyb2xcbiAgICAgICAgICAgIHNob3VsZFN0cm9rZSA9IHRydWU7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNvbnRyb2wueCAqIHdpZHRoLCBjb250cm9sLnkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbC54ICogd2lkdGggKyBjb250cm9sLm9mZnNldFgsXG4gICAgICAgICAgICAgIGNvbnRyb2wueSAqIGhlaWdodCArIGNvbnRyb2wub2Zmc2V0WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkU3Ryb2tlKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyc0luR3JvdXA6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgYmJveCA9IGZhYnJpYy51dGlsLnNpemVBZnRlclRyYW5zZm9ybSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgb3B0aW9ucyksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZVVuaWZvcm0gPSB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgYm9yZGVyU2NhbGVGYWN0b3IgPSB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID1cbiAgICAgICAgICAgIGJib3gueCArIHN0cm9rZVdpZHRoICogKHN0cm9rZVVuaWZvcm0gPyB0aGlzLmNhbnZhcy5nZXRab29tKCkgOiBvcHRpb25zLnNjYWxlWCkgKyBib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICBoZWlnaHQgPVxuICAgICAgICAgICAgYmJveC55ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVZKSArIGJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGNvcm5lcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IGNvcm5lclNpemUsIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksIG1hdHJpeCwgcDtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0ocmV0aW5hU2NhbGluZywgMCwgMCwgcmV0aW5hU2NhbGluZywgMCwgMCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCB0aGlzLmNvcm5lckNvbG9yO1xuICAgICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50Q29ybmVycykge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuY29ybmVyRGFzaEFycmF5IHx8IHRoaXMuY29ybmVyRGFzaEFycmF5KTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICAvLyBmYWJyaWNKUyBkb2VzIG5vdCByZWFsbHkgc3VwcG9ydCBkcmF3aW5nIGNvbnRyb2xzIGluc2lkZSBncm91cHMsXG4gICAgICAgIC8vIHRoaXMgcGllY2Ugb2YgY29kZSBoZXJlIGhlbHBzIGhhdmluZyBhdCBsZWFzdCB0aGUgY29udHJvbCBpbiBwbGFjZXMuXG4gICAgICAgIC8vIElmIGFuIGFwcGxpY2F0aW9uIG5lZWRzIHRvIHNob3cgc29tZSBvYmplY3RzIGFzIHNlbGVjdGVkIGJlY2F1c2Ugb2Ygc29tZSBVSSBzdGF0ZVxuICAgICAgICAvLyBjYW4gc3RpbGwgY2FsbCBPYmplY3QuX3JlbmRlckNvbnRyb2xzKCkgb24gYW55IG9iamVjdCB0aGV5IGRlc2lyZSwgaW5kZXBlbmRlbnRseSBvZiBncm91cHMuXG4gICAgICAgIC8vIHVzaW5nIG5vIHBhZGRpbmcsIGNpcmN1bGFyIGNvbnRyb2xzIGFuZCBoaWRpbmcgdGhlIHJvdGF0aW5nIGN1cnNvciBpcyBoaWdseSBzdWdnZXN0ZWQsXG4gICAgICAgIG1hdHJpeCA9IHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICBwID0gZmFicmljT2JqZWN0Lm9Db29yZHNba2V5XTtcbiAgICAgICAgaWYgKGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbC5yZW5kZXIoY3R4LCBwLngsIHAueSwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkgVGhlIGtleSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHNbY29udHJvbEtleV0gJiYgdGhpcy5jb250cm9sc1tjb250cm9sS2V5XS5nZXRWaXNpYmlsaXR5KHRoaXMsIGNvbnRyb2xLZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzcGVjaWZpZWQgY29udHJvbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBUaGUga2V5IG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSB0cnVlIHRvIHNldCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbEtleSwgdmlzaWJsZSkge1xuICAgICAgaWYgKCF0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5ID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHlbY29udHJvbEtleV0gPSB2aXNpYmxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2Ygb2JqZWN0IGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJsXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnJdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtYm90dG9tIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1sXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRsXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcC1yb3RhdGUgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbHNWaXNpYmlsaXR5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udHJvbFZpc2libGUocCwgb3B0aW9uc1twXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gZGVzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvblNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gZHVyYXRpb24gKGluIG1zKSBmb3IgZngqIG1ldGhvZHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBGWF9EVVJBVElPTjogNTAwLFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQW5pbWF0aW9uQ29udGV4dH0gY29udGV4dFxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5sZWZ0LFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS54LFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnbGVmdCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeENlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LnRvcCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlclBvaW50KCkueSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ3RvcCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHR9IGNvbnRleHRcbiAgICovXG4gIGZ4UmVtb3ZlOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBBbmltYXRlcyBvYmplY3QncyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZSAoaWYgc3RyaW5nKSBvciBwcm9wZXJ0aWVzIHRvIGFuaW1hdGUgKGlmIG9iamVjdClcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBhbmltYXRlIHByb3BlcnR5IHRvIChpZiBzdHJpbmcgd2FzIGdpdmVuIGZpcnN0KSBvciBvcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2FuaW1hdGlvbn1cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHQgfCBmYWJyaWMuQW5pbWF0aW9uQ29udGV4dFtdfSBhbmltYXRpb24gY29udGV4dCAob3IgYW4gYXJyYXkgaWYgcGFzc2VkIG11bHRpcGxlIHByb3BlcnRpZXMpXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByb3BzVG9BbmltYXRlID0gW10sIHByb3AsIHNraXBDYWxsYmFja3MsIG91dCA9IFtdO1xuICAgICAgZm9yIChwcm9wIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICBwcm9wc1RvQW5pbWF0ZS5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BzVG9BbmltYXRlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1RvQW5pbWF0ZVtpXTtcbiAgICAgICAgc2tpcENhbGxiYWNrcyA9IGkgIT09IGxlbiAtIDE7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuX2FuaW1hdGUocHJvcCwgYXJndW1lbnRzWzBdW3Byb3BdLCBhcmd1bWVudHNbMV0sIHNraXBDYWxsYmFja3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0byBWYWx1ZSB0byBhbmltYXRlIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENhbGxiYWNrc10gV2hlbiB0cnVlLCBjYWxsYmFja3MgbGlrZSBvbmNoYW5nZSBhbmQgb25jb21wbGV0ZSBhcmUgbm90IGludm9rZWRcbiAgICovXG4gIF9hbmltYXRlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdG8sIG9wdGlvbnMsIHNraXBDYWxsYmFja3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBwcm9wUGFpcjtcblxuICAgIHRvID0gdG8udG9TdHJpbmcoKTtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZignLicpKSB7XG4gICAgICBwcm9wUGFpciA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BJc0NvbG9yID1cbiAgICAgIF90aGlzLmNvbG9yUHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSA+IC0xIHx8XG4gICAgICAocHJvcFBhaXIgJiYgX3RoaXMuY29sb3JQcm9wZXJ0aWVzLmluZGV4T2YocHJvcFBhaXJbMV0pID4gLTEpO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHByb3BQYWlyXG4gICAgICA/IHRoaXMuZ2V0KHByb3BQYWlyWzBdKVtwcm9wUGFpclsxXV1cbiAgICAgIDogdGhpcy5nZXQocHJvcGVydHkpO1xuXG4gICAgaWYgKCEoJ2Zyb20nIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZyb20gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wSXNDb2xvcikge1xuICAgICAgaWYgKH50by5pbmRleE9mKCc9JykpIHtcbiAgICAgICAgdG8gPSBjdXJyZW50VmFsdWUgKyBwYXJzZUZsb2F0KHRvLnJlcGxhY2UoJz0nLCAnJykpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb3B0aW9ucy5mcm9tLFxuICAgICAgZW5kVmFsdWU6IHRvLFxuICAgICAgYnlWYWx1ZTogb3B0aW9ucy5ieSxcbiAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGFib3J0OiBvcHRpb25zLmFib3J0ICYmIGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcywgdmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChwcm9wUGFpcikge1xuICAgICAgICAgIF90aGlzW3Byb3BQYWlyWzBdXVtwcm9wUGFpclsxXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXQocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm9uQ2hhbmdlICYmIG9wdGlvbnMub25DaGFuZ2UodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHByb3BJc0NvbG9yKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yKF9vcHRpb25zLnN0YXJ0VmFsdWUsIF9vcHRpb25zLmVuZFZhbHVlLCBfb3B0aW9ucy5kdXJhdGlvbiwgX29wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKF9vcHRpb25zKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfTtcblxuICBpZiAoZmFicmljLkxpbmUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5MaW5lXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5MaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuTGluZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MTogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MTogMCxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDI6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkyOiAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCd4MScsICd4MicsICd5MScsICd5MicpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcG9pbnRzXSBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHBvaW50cyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5zZXQoJ3gxJywgcG9pbnRzWzBdKTtcbiAgICAgIHRoaXMuc2V0KCd5MScsIHBvaW50c1sxXSk7XG4gICAgICB0aGlzLnNldCgneDInLCBwb2ludHNbMl0pO1xuICAgICAgdGhpcy5zZXQoJ3kyJywgcG9pbnRzWzNdKTtcblxuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy53aWR0aCA9IE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuXG4gICAgICB0aGlzLmxlZnQgPSAnbGVmdCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMubGVmdFxuICAgICAgICA6IHRoaXMuX2dldExlZnRUb09yaWdpblgoKTtcblxuICAgICAgdGhpcy50b3AgPSAndG9wJyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy50b3BcbiAgICAgICAgOiB0aGlzLl9nZXRUb3BUb09yaWdpblkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIGNvb3JkUHJvcHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbGVmdFRvT3JpZ2luWCBEaXN0YW5jZSBmcm9tIGxlZnQgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWCBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9PcmlnaW5YOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5YJyxcbiAgICAgICAgYXhpczE6ICd4MScsXG4gICAgICAgIGF4aXMyOiAneDInLFxuICAgICAgICBkaW1lbnNpb246ICd3aWR0aCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ2xlZnQnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ3JpZ2h0J1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdG9wVG9PcmlnaW5ZIERpc3RhbmNlIGZyb20gdG9wIGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblkgb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0VG9wVG9PcmlnaW5ZOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5ZJyxcbiAgICAgICAgYXhpczE6ICd5MScsXG4gICAgICAgIGF4aXMyOiAneTInLFxuICAgICAgICBkaW1lbnNpb246ICdoZWlnaHQnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICd0b3AnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ2JvdHRvbSdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblxuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICBjdHgubW92ZVRvKHAueDEsIHAueTEpO1xuICAgICAgY3R4LmxpbmVUbyhwLngyLCBwLnkyKTtcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpc1xuICAgICAgLy8gbWFrZSBzdXJlIHNldHRpbmcgXCJmaWxsXCIgY2hhbmdlcyBjb2xvciBvZiBhIGxpbmVcbiAgICAgIC8vIChieSBjb3B5aW5nIGZpbGxTdHlsZSB0byBzdHJva2VTdHlsZSwgc2luY2UgbGluZSBpcyBzdHJva2VkLCBub3QgZmlsbGVkKVxuICAgICAgdmFyIG9yaWdTdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlIHx8IGN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdTdHJva2VTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh0aGlzLngxICsgdGhpcy54MikgLyAyLFxuICAgICAgICB5OiAodGhpcy55MSArIHRoaXMueTIpIC8gMixcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB0aGlzLmNhbGNMaW5lUG9pbnRzKCkpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmNhbGxTdXBlcignX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucycpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlTGluZUNhcCA9PT0gJ2J1dHQnKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgZGltLnkgLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBkaW0ueCAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgbGluZSBwb2ludHMgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY0xpbmVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHhNdWx0ID0gdGhpcy54MSA8PSB0aGlzLngyID8gLTEgOiAxLFxuICAgICAgICAgIHlNdWx0ID0gdGhpcy55MSA8PSB0aGlzLnkyID8gLTEgOiAxLFxuICAgICAgICAgIHgxID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgICAgeTEgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIDAuNSksXG4gICAgICAgICAgeDIgPSAoeE11bHQgKiB0aGlzLndpZHRoICogLTAuNSksXG4gICAgICAgICAgeTIgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIC0wLjUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPGxpbmUgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICd4MT1cIicsIHAueDEsXG4gICAgICAgICdcIiB5MT1cIicsIHAueTEsXG4gICAgICAgICdcIiB4Mj1cIicsIHAueDIsXG4gICAgICAgICdcIiB5Mj1cIicsIHAueTIsXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgaWYgKGZhYnJpYy5DaXJjbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNpcmNsZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogZGVncmVlcyBvZiBzdGFydCBvZiB0aGUgY2lyY2xlLlxuICAgICAqIHByb2JhYmx5IHdpbGwgY2hhbmdlIHRvIGRlZ3JlZXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICogQHR5cGUgTnVtYmVyIDAgLSAzNTlcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEVuZCBhbmdsZSBvZiB0aGUgY2lyY2xlXG4gICAgICogcHJvYmFibHkgd2lsbCBjaGFuZ2UgdG8gZGVncmVlcyBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgKiBAdHlwZSBOdW1iZXIgMSAtIDM2MFxuICAgICAqIEBkZWZhdWx0IDM2MFxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiAzNjAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcsIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlIDM2MDtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPGNpcmNsZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgICAnY3g9XCInICsgeCArICdcIiBjeT1cIicgKyB5ICsgJ1wiICcsXG4gICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnXCIgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgZW5kID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmVuZEFuZ2xlKSxcbiAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHN0YXJ0KSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbihzdGFydCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IDE4MCA/ICcxJyA6ICcwJztcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgcmFkaXVzICsgJyAnICsgcmFkaXVzLFxuICAgICAgICAgICcgMCAnLCArbGFyZ2VGbGFnICsgJyAxJywgJyAnICsgZW5kWCArICcgJyArIGVuZFksXG4gICAgICAgICAgJ1wiICcsICdDT01NT05fUEFSVFMnLCAnIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZW5kQW5nbGUpLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNYOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNZOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmFkaXVzIG9mIGFuIG9iamVjdCAoYW5kIHVwZGF0ZXMgd2lkdGggYWNjb3JkaW5nbHkpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKS5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjQ2lyY2xlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBpZiAoIWlzVmFsaWRSYWRpdXMocGFyc2VkQXR0cmlidXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBhbmQgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IChwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucmFkaXVzO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuQ2lyY2xlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRSYWRpdXMoYXR0cmlidXRlcykge1xuICAgIHJldHVybiAoKCdyYWRpdXMnIGluIGF0dHJpYnV0ZXMpICYmIChhdHRyaWJ1dGVzLnJhZGl1cyA+PSAwKSk7XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIC13aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MixcbiAgICAgICAgICAgICcwICcgKyAtaGVpZ2h0QnkyLFxuICAgICAgICAgICAgd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTJcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cG9seWdvbiAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cyxcbiAgICAgICAgJ1wiIC8+J1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlRyaWFuZ2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVHJpYW5nbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVHJpYW5nbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGlCeTIgICA9IE1hdGguUEkgKiAyO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXQoJ3J4Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ4IHx8IDApO1xuICAgICAgdGhpcy5zZXQoJ3J5Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ5IHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICBjYXNlICdyeCc6XG4gICAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncnknOlxuICAgICAgICAgIHRoaXMucnkgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncngnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBWZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncnknKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8ZWxsaXBzZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2N4PVwiMFwiIGN5PVwiMFwiICcsXG4gICAgICAgICdyeD1cIicsIHRoaXMucngsXG4gICAgICAgICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgdGhpcy5yeSAvIHRoaXMucngsIDAsIDApO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yeCxcbiAgICAgICAgMCxcbiAgICAgICAgcGlCeTIsXG4gICAgICAgIGZhbHNlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjRWxsaXBzZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHJ4IHJ5Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucng7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJ5O1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuRWxsaXBzZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnRWxsaXBzZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuUmVjdCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUmVjdCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVjdGFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUmVjdFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5SZWN0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5SZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUmVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlJlY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRSeFJ5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJ4L3J5IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0UnhSeTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yeCAmJiAhdGhpcy5yeSkge1xuICAgICAgICB0aGlzLnJ5ID0gdGhpcy5yeDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucnkgJiYgIXRoaXMucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IHRoaXMucnk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAvLyAxeDEgY2FzZSAodXNlZCBpbiBzcHJheSBicnVzaCkgb3B0aW1pemF0aW9uIHdhcyByZW1vdmVkIGJlY2F1c2VcbiAgICAgIC8vIHdpdGggY2FjaGluZyBhbmQgaGlnaGVyIHpvb20gbGV2ZWwgdGhpcyBtYWtlcyBtb3JlIGRhbWFnZSB0aGFuIGhlbHBcblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cmVjdCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMucngsICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgID0gcGFyc2VkQXR0cmlidXRlcy50b3AgIHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgID0gcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLndpZHRoICA9IHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBwcm9qZWN0U3Ryb2tlT25Qb2ludHMgPSBmYWJyaWMudXRpbC5wcm9qZWN0U3Ryb2tlT25Qb2ludHM7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBGZWF0dXJlIGluIHByb2dyZXNzXG4gICAgICogQ2FsY3VsYXRlIHRoZSBleGFjdCBib3VuZGluZyBib3ggdGFraW5nIGluIGFjY291bnQgc3Ryb2tlV2lkdGggb24gYWN1dGUgYW5nbGVzXG4gICAgICogdGhpcyB3aWxsIGJlIHR1cm5lZCB0byB0cnVlIGJ5IGRlZmF1bHQgb24gZmFicmljIDYuMFxuICAgICAqIG1heWJlIHdpbGwgYmUgbGVmdCBpbiBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgY2FsY3VsYXRpb25zIG1heSBiZSBzbG93XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBleGFjdEJvdW5kaW5nQm94OiBmYWxzZSxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncG9pbnRzJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfc2V0UG9zaXRpb25EaW1lbnNpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsY0RpbSA9IHRoaXMuX2NhbGNEaW1lbnNpb25zKG9wdGlvbnMpLCBjb3JyZWN0TGVmdFRvcCxcbiAgICAgICAgICBjb3JyZWN0U2l6ZSA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAwO1xuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGggLSBjb3JyZWN0U2l6ZTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQgLSBjb3JyZWN0U2l6ZTtcbiAgICAgIGlmICghb3B0aW9ucy5mcm9tU1ZHKSB7XG4gICAgICAgIGNvcnJlY3RMZWZ0VG9wID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbG9va3MgYmFkLCBidXQgaXMgb25lIHdheSB0byBrZWVwIGl0IG9wdGlvbmFsIGZvciBub3cuXG4gICAgICAgICAgICB4OiBjYWxjRGltLmxlZnQgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgICAgIHk6IGNhbGNEaW0udG9wIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgICAgICB9LFxuICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAndG9wJyxcbiAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgdGhpcy5vcmlnaW5ZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS5sZWZ0IDogY29ycmVjdExlZnRUb3AueDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudG9wID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS50b3AgOiBjb3JyZWN0TGVmdFRvcC55O1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9seWdvbiBtaW4gYW5kIG1heCBwb2ludCBmcm9tIHBvaW50cyBhcnJheSxcbiAgICAgKiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgICogcG9seWdvbiBzaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QubGVmdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC50b3AgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCBkaXN0YW5jZSBiZXR3ZWVuIFggY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmhlaWdodCBkaXN0YW5jZSBiZXR3ZWVuIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuX3Byb2plY3RTdHJva2VPblBvaW50cygpIDogdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYIC0gbWluWCksXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW10sIGRpZmZYID0gdGhpcy5wYXRoT2Zmc2V0LngsIGRpZmZZID0gdGhpcy5wYXRoT2Zmc2V0LnksXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueCAtIGRpZmZYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJywnLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueSAtIGRpZmZZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJyAnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPCcgKyB0aGlzLnR5cGUgKyAnICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLmpvaW4oJycpLFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGNvbW1vblJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcG9pbnQsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICB4ID0gdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgeSA9IHRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBpZiAoIWxlbiB8fCBpc05hTih0aGlzLnBvaW50c1tsZW4gLSAxXS55KSkge1xuICAgICAgICAvLyBkbyBub3QgZHJhdyBpZiBubyBwb2ludHMgb3Igb2RkIHBvaW50c1xuICAgICAgICAvLyBOYU4gY29tZXMgZnJvbSBwYXJzZUZsb2F0IG9mIGEgZW1wdHkgc3RyaW5nIGluIHBhcnNlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLnggLSB4LCB0aGlzLnBvaW50c1swXS55IC0geSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCAtIHgsIHBvaW50LnkgLSB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihfY2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpY1tfY2xhc3NdLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpY1tfY2xhc3NdKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IoJ1BvbHlsaW5lJyk7XG5cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHt9KSxcbiAgICAgIHByb2plY3RTdHJva2VPblBvaW50cyA9IGZhYnJpYy51dGlsLnByb2plY3RTdHJva2VPblBvaW50cztcblxuICBpZiAoZmFicmljLlBvbHlnb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvbHlnb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlnb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWdvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUG9seWxpbmUsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlnb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5Z29uJyk7XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlnb24gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlnb24nLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuUGF0aCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUGF0aCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUGF0aCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdGhcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNwYXRoX2FuZF9wYXRoZ3JvdXB9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXRoI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUGF0aCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBhdGgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncGF0aCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwYXRoIHBvaW50c1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoOiBudWxsLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJywgJ2ZpbGxSdWxlJyksXG5cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBjbG9uZShvcHRpb25zIHx8IHt9KTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnBhdGg7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UGF0aChwYXRoIHx8IFtdLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgKi9cbiAgICBfc2V0UGF0aDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucGF0aCA9IGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlcihcbiAgICAgICAgQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBmYWJyaWMudXRpbC5wYXJzZVBhdGgocGF0aClcbiAgICAgICk7XG5cbiAgICAgIGZhYnJpYy5Qb2x5bGluZS5wcm90b3R5cGUuX3NldFBvc2l0aW9uRGltZW5zaW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMgfHwge30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoQ29tbWFuZHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFszXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0gKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhdGhDb21tYW5kcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlBhdGggKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidG9wXCI6ICcgKyB0aGlzLnRvcCArICcsIFwibGVmdFwiOiAnICsgdGhpcy5sZWZ0ICsgJyB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnNsaWNlKCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IGZhYnJpYy51dGlsLmpvaW5QYXRoKHRoaXMucGF0aCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHBhdGggJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0T2Zmc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWdpdHMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICByZXR1cm4gJyB0cmFuc2xhdGUoJyArIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC54LCBkaWdpdHMpICsgJywgJyArXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LnksIGRpZ2l0cykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoXG4gICAgICAgIHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSAgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IDAsXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IDAsXG4gICAgICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgICAgICBib3VuZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgYVgucHVzaChwb2ludC54KTtcbiAgICAgICAgICBhWS5wdXNoKHBvaW50LnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYVgucHVzaCh4KTtcbiAgICAgICAgYVkucHVzaCh5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pblggPSBtaW4oYVgpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihhWSkgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KGFYKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgoYVkpIHx8IDAsXG4gICAgICAgICAgZGVsdGFYID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgZGVsdGFZID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgaGVpZ2h0OiBkZWx0YVlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuY2xpcFBhdGgpIHtcbiAgICAgICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbb2JqZWN0LmNsaXBQYXRoXSwgZnVuY3Rpb24oZWxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBwYXRoLmNsaXBQYXRoID0gZWxpdmVuZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socGF0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBvYmplY3QsIGNhbGxiYWNrLCAncGF0aCcpO1xuICAgIH1cbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5QYXRoLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChbJ2QnXSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBTVkcgPHBhdGg+IGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5QYXRoLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5mcm9tU1ZHID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4O1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Hcm91cFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Hcm91cCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyb3VwID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgZmFicmljLkNvbGxlY3Rpb24sIC8qKiBAbGVuZHMgZmFicmljLkdyb3VwLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2dyb3VwJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY2xpY2ssIG1vdXNlb3ZlciwgbW91c2VvdXQgZXZlbnRzICYgaG92ZXJDdXJzb3Igc2hvdWxkIGFsc28gY2hlY2sgZm9yIHN1YnRhcmdldHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJUYXJnZXRDaGVjazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYXJlIGNvbnRhaW5lciwgZG8gbm90IHJlbmRlciBhbnl0aGluZyBvbiB0aGV5ciBvd24sIGVuY2Ugbm8gY2FjaGUgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogc2V0T25Hcm91cCBpcyBhIG1ldGhvZCB1c2VkIGZvciBUZXh0Qm94IHRoYXQgaXMgbm8gbW9yZSB1c2VkIHNpbmNlIDIuMC4wIFRoZSBiZWhhdmlvciBpcyBzdGlsbFxuICAgICAqIGF2YWlsYWJsZSBzZXR0aW5nIHRoaXMgYm9vbGVhbiB0byB0cnVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVzZVNldE9uR3JvdXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBHcm91cCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQWxyZWFkeUdyb3VwZWRdIGlmIHRydWUsIG9iamVjdHMgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zLCBpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIC8vIGlmIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LFxuICAgICAgLy8gd2UgY2Fubm90IGNoYW5nZSBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuXG4gICAgICAvLyBUaHVzIHdlIG5lZWQgdG8gc2V0IG9wdGlvbnMgdG8gZ3JvdXAgd2l0aG91dCBvYmplY3RzLFxuICAgICAgaXNBbHJlYWR5R3JvdXBlZCAmJiB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBzZXQgb3JpZ2lucyBiZWZvcmUgY2FsY3VsYXRpbmcgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdG9wbGVmdCBjYW4gYmUgc2V0IHdpdGggdGhhdCBpbiBtaW5kLlxuICAgICAgICAvLyBpZiBzcGVjaWZpYyB0b3AgYW5kIGxlZnQgYXJlIHBhc3NlZCwgYXJlIG92ZXJ3cml0dGVuIGxhdGVyXG4gICAgICAgIC8vIHdpdGggdGhlIGNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpXG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpblggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY29taW5nIGZyb20gc3ZnIGkgZG8gbm90IHdhbnQgdG8gY2FsYyBib3VuZHMuXG4gICAgICAgIC8vIGkgYXNzdW1lIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHBhc3NlZCBhbG9uZyBvcHRpb25zXG4gICAgICAgIGNlbnRlciB8fCB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoY2VudGVyKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0FDb29yZHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNraXBDb250cm9scyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ29vcmRzQ2hhbmdlXSBpZiB0cnVlLCBjb29yZGluYXRlcyBvZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgZG8gbm90IGNoYW5nZVxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RzQ29vcmRzOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBjZW50ZXIgfHwgdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdENvb3Jkcyh0aGlzLl9vYmplY3RzW2ldLCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyLCBjdXJyZW50IGNlbnRlciBvZiBncm91cC5cbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0Q29vcmRzOiBmdW5jdGlvbihvYmplY3QsIGNlbnRlcikge1xuICAgICAgdmFyIG9iamVjdExlZnQgPSBvYmplY3QubGVmdCxcbiAgICAgICAgICBvYmplY3RUb3AgPSBvYmplY3QudG9wLFxuICAgICAgICAgIHNraXBDb250cm9scyA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBsZWZ0OiBvYmplY3RMZWZ0IC0gY2VudGVyLngsXG4gICAgICAgIHRvcDogb2JqZWN0VG9wIC0gY2VudGVyLnlcbiAgICAgIH0pO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBuZXN0ZWQgPSAhIXRoaXMuZ3JvdXA7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgZ3JvdXAgaXMgaW5zaWRlIGFub3RoZXIgZ3JvdXAsIHdlIG5lZWQgdG8gcHJlIHRyYW5zZm9ybSB0aGUgb2JqZWN0XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlVHJhbnNmb3JtRnJvbU9iamVjdChvYmplY3QsIHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICB0aGlzLmdyb3VwLmFkZFdpdGhVcGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVtb3ZlV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcblxuICAgICAgdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgX2luY2x1ZGVEZWZhdWx0VmFsdWVzID0gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgIHZhciBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiAhb2JqLmV4Y2x1ZGVGcm9tRXhwb3J0O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gb3JpZ2luYWxEZWZhdWx0cztcbiAgICAgICAgICByZXR1cm4gX29iajtcbiAgICAgICAgfSk7XG4gICAgICB2YXIgb2JqID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UsIGluIGRhdGFsZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCwgc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIGlmIChzb3VyY2VQYXRoKSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuX29iamVjdHMubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICB2YXIgX29iaiA9IG9iai50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvRGF0YWxlc3NPYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZSBvbiBhIGdpdmVuIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIGlzIGFscmVhZHkgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG93bkNhY2hlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2hvdWxkQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChvd25DYWNoZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICAgIHRoaXMub3duQ2FjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG93bkNhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS53aWxsRHJhd1NoYWRvdy5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4LCB0aGlzLmNsaXBQYXRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5Jywgc2tpcENhbnZhcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgc3RhdGUgb2YgZWFjaCBvZiBncm91cCBvYmplY3RzIChvcmlnaW5hbCBzdGF0ZSBpcyB0aGF0IHdoaWNoIHdhcyBiZWZvcmUgZ3JvdXAgd2FzIGNyZWF0ZWQpLlxuICAgICAqIGlmIHRoZSBuZXN0ZWQgYm9vbGVhbiBpcyB0cnVlLCB0aGUgb3JpZ2luYWwgc3RhdGUgd2lsbCBiZSByZXN0b3JlZCBqdXN0IGZvciB0aGVcbiAgICAgKiBmaXJzdCBncm91cCBhbmQgbm90IGZvciBhbGwgdGhlIGdyb3VwIGNoYWluXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lc3RlZCB0ZWxsIHRoZSBmdW5jdGlvbiB0byByZXN0b3JlIG9iamVjdCBzdGF0ZSB1cCB0byB0aGUgcGFyZW50IGdyb3VwIGFuZCBub3QgbW9yZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdHNTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ3JvdXBNYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZhYnJpYy51dGlsLmFkZFRyYW5zZm9ybVRvT2JqZWN0KG9iamVjdCwgZ3JvdXBNYXRyaXgpO1xuICAgICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gd2hlbiBncm91cCBpcyBkZXN0cm95ZWQgb2JqZWN0cyBuZWVkcyB0byBnZXQgYSByZXBhaW50IHRvIGJlIGV2ZW50dWFsbHlcbiAgICAgIC8vIGRpc3BsYXllZCBvbiBjYW52YXMuXG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBncm91cCBhbiBhY3RpdmUgc2VsZWN0aW9uLCByZW1vdmUgdGhlIGdyb3VwIGZyb20gY2FudmFzXG4gICAgICogdGhlIGdyb3VwIGhhcyB0byBiZSBvbiBjYW52YXMgZm9yIHRoaXMgdG8gd29yay5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQWN0aXZlU2VsZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHRvQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihbXSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uc2V0KG9wdGlvbnMpO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnR5cGUgPSAnYWN0aXZlU2VsZWN0aW9uJztcbiAgICAgIGNhbnZhcy5yZW1vdmUodGhpcyk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgb2JqZWN0LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgY2FudmFzLmFkZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uY2FudmFzID0gY2FudmFzO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIGFjdGl2ZVNlbGVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB1bmdyb3VwT25DYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb29yZGluYXRlcyBvZiBhbGwgb2JqZWN0cyBpbnNpZGUgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0T2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2tpcENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0JvdW5kczogZnVuY3Rpb24ob25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICB2YXIgYVggPSBbXSxcbiAgICAgICAgICBhWSA9IFtdLFxuICAgICAgICAgIG8sIHByb3AsIGNvb3JkcyxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgY29vcmRzID0gby5jYWxjQUNvb3JkcygpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIGFYLnB1c2goY29vcmRzW3Byb3BdLngpO1xuICAgICAgICAgIGFZLnB1c2goY29vcmRzW3Byb3BdLnkpO1xuICAgICAgICB9XG4gICAgICAgIG8uYUNvb3JkcyA9IGNvb3JkcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ2V0Qm91bmRzKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihhWCwgYVksIG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIG1pblhZID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oYVgpLCBtaW4oYVkpKSxcbiAgICAgICAgICBtYXhYWSA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KGFYKSwgbWF4KGFZKSksXG4gICAgICAgICAgdG9wID0gbWluWFkueSB8fCAwLCBsZWZ0ID0gbWluWFkueCB8fCAwLFxuICAgICAgICAgIHdpZHRoID0gKG1heFhZLnggLSBtaW5YWS54KSB8fCAwLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhYWS55IC0gbWluWFkueSkgfHwgMDtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBhbHdheXMgZmluZHMgdGhlIHRvcGxlZnQgbW9zdCBjb3JuZXIuXG4gICAgICAgIC8vIHdoYXRldmVyIGlzIHRoZSBncm91cCBvcmlnaW4sIHdlIHNldCB1cCBoZXJlIHRoZSBsZWZ0L3RvcCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKHsgeDogbGVmdCwgeTogdG9wIH0sICdsZWZ0JywgJ3RvcCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IFsnPGcgJywgJ0NPTU1PTl9QQVJUUycsICcgPlxcbiddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdmdTdHJpbmcucHVzaCgnXFx0XFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgICBzdmdTdHJpbmcucHVzaCgnPC9nPlxcbicpO1xuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0LCBzcGVjaWZpYyB2ZXJzaW9uIGZvciBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wYWNpdHkgIT09IDEgP1xuICAgICAgICAgICAgJ29wYWNpdHk6ICcgKyB0aGlzLm9wYWNpdHkgKyAnOycgOiAnJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdmdTdHJpbmcucHVzaCgnXFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b0NsaXBQYXRoU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cChzdmdTdHJpbmcsIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyb3VwfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGdyb3VwIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Hcm91cC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3RzID0gb2JqZWN0Lm9iamVjdHMsXG4gICAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGl0IGhhcyB0byBiZSBhbiB1cmwgb3Igc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwob2JqZWN0cywgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBncm91cCA9IGZhYnJpYy51dGlsLmdyb3VwU1ZHRWxlbWVudHMoZWxlbWVudHMsIG9iamVjdCwgb2JqZWN0cyk7XG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG9wdGlvbnMuY2xpcFBhdGg7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNsaXBQYXRoO1xuICAgICAgICBncm91cC5zZXQob3B0aW9ucyk7XG4gICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtjbGlwUGF0aF0sIGZ1bmN0aW9uKGVsaXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgICAgZ3JvdXAuY2xpcFBhdGggPSBlbGl2ZW5lZE9iamVjdHNbMF07XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhncm91cCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24gKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9wdGlvbnMsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Hcm91cFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuR3JvdXAsIC8qKiBAbGVuZHMgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdhY3RpdmVTZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBBY3RpdmVTZWxlY3Rpb24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0ZSBhY3RpdmVTZWxlY3Rpb24gdG8gYSBub3JtYWwgZ3JvdXAsXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkcyBpdCB0byBjYW52YXMgYXNcbiAgICAgKiBhY3RpdmUgb2JqZWN0LiBubyBldmVudHMgZmlyZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIHRvR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBuZXdHcm91cDtcbiAgICAgIH0pO1xuICAgICAgbmV3R3JvdXAuX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKG5ld0dyb3VwKTtcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gbmV3R3JvdXA7XG4gICAgICBuZXdHcm91cC5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgcmV0dXJucyB0cnVlLCBkZXNlbGVjdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2NhbmNlbF1cbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQWN0aXZlU2VsZWN0aW9uOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUgPSBjaGlsZHJlbk92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW5PdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fcmVuZGVyQ29udHJvbHMoY3R4LCBjaGlsZHJlbk92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNhbGxpbmcge0BsaW5rIGZhYnJpYy5JbWFnZS5nZXRTcmN9LCByZXR1cm4gdmFsdWUgZnJvbSBlbGVtZW50IHNyYyB3aXRoIGBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJylgLlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciByZWxhdGl2ZSB1cmxzIGFzIGltYWdlIHNyYy5cbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzcmNGcm9tQXR0cmlidXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWCB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVkgdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1g6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsaW5nIGFwcGxpZWQgYnkgdGhlIGFwcGx5IGZpbHRlciBjaGFpblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9maWx0ZXJTY2FsaW5nWTogMSxcblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0gc2NhbGUgZmFjdG9yIHVuZGVyIHdoaWNoIGFueSByZXNpemVGaWx0ZXIgaXMgdHJpZ2dlcmVkIHRvIHJlc2l6ZSB0aGUgaW1hZ2VcbiAgICAgKiAwIHdpbGwgZGlzYWJsZSB0aGUgYXV0b21hdGljIHJlc2l6ZS4gMSB3aWxsIHRyaWdnZXIgYXV0b21hdGljYWxseSBhbHdheXMuXG4gICAgICogbnVtYmVyIGJpZ2dlciB0aGFuIDEgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgbWluaW11bVNjYWxlVHJpZ2dlcjogMC41LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWZcbiAgICAgKiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ2Nyb3BYJywgJ2Nyb3BZJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogVGhvc2UgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBieSBzdGF0ZWZ1bGxDYWNoZSBPTiAoIG9yIGxhenkgbW9kZSBpZiB3ZSB3YW50ICkgb3IgZnJvbSBzaW5nbGVcbiAgICAgKiBjYWxscyB0byBPYmplY3Quc2V0KGtleSwgdmFsdWUpLiBJZiB0aGUga2V5IGlzIGluIHRoaXMgbGlzdCwgdGhlIG9iamVjdCBpcyBtYXJrZWQgYXMgZGlydHlcbiAgICAgKiBhbmQgcmVmcmVzaGVkIGF0IHRoZSBuZXh0IHJlbmRlclxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICoga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRleHR1cmUgcmVwcmVzZW50aW5nIHRoaXMgaW1hZ2VcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BYOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcgd2hlbiBwYWludGluZyB0aGlzIGltYWdlLlxuICAgICAqIEFsc28gaW5mbHVlbmNlIGlmIHRoZSBjYWNoZUNhbnZhcyBmb3IgdGhpcyBpbWFnZSB1c2VzIGltYWdlU21vb3RoaW5nXG4gICAgICogQHNpbmNlIDQuMC4wLWJldGEuMTFcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogSW1hZ2UgY2FuIGJlIGluaXRpYWxpemVkIHdpdGggYW55IGNhbnZhcyBkcmF3YWJsZSBvciBhIHN0cmluZy5cbiAgICAgKiBUaGUgc3RyaW5nIHNob3VsZCBiZSBhIHVybCBhbmQgd2lsbCBiZSBsb2FkZWQgYXMgYW4gaW1hZ2UuXG4gICAgICogQ2FudmFzIGFuZCBJbWFnZSBlbGVtZW50IHdvcmsgb3V0IG9mIHRoZSBib3gsIHdoaWxlIHZpZGVvcyByZXF1aXJlIGV4dHJhIGNvZGUgdG8gd29yay5cbiAgICAgKiBQbGVhc2UgY2hlY2sgdmlkZW8gZWxlbWVudCBldmVudHMgZm9yIHNlZWtpbmcuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBlbGVtZW50IEltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGV2ZW50dWFsIGZpbHRlcnMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jYWNoZUtleSA9ICd0ZXh0dXJlJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbWFnZSBlbGVtZW50IHdoaWNoIHRoaXMgaW5zdGFuY2UgaWYgYmFzZWQgb25cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudCB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbWFnZSBlbGVtZW50IGZvciB0aGlzIGluc3RhbmNlIHRvIGEgc3BlY2lmaWVkIG9uZS5cbiAgICAgKiBJZiBmaWx0ZXJzIGRlZmluZWQgdGhleSBhcmUgYXBwbGllZCB0byBuZXcgaW1hZ2UuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgY2FudmFzLnJlbmRlckFsbGAgYW5kIGBvYmplY3Quc2V0Q29vcmRzYCBhZnRlciByZXBsYWNpbmcsIHRvIHJlbmRlciBuZXcgaW1hZ2UgYW5kIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2l6ZUZpbHRlcnMgd29yayBvbiB0aGUgYWxyZWFkeSBmaWx0ZXJlZCBjb3B5LlxuICAgICAgLy8gd2UgbmVlZCB0byBhcHBseSByZXNpemVGaWx0ZXJzIEFGVEVSIG5vcm1hbCBmaWx0ZXJzLlxuICAgICAgLy8gYXBwbHlSZXNpemVGaWx0ZXJzIGlzIHJ1biBtb3JlIG9mdGVuIHRoYW4gbm9ybWFsIGZpbHRlcnNcbiAgICAgIC8vIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgcmF0aGVyIHRoYW4gZGV2IGNvZGVcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpbmdsZSB0ZXh0dXJlIGlmIGluIHdlYmdsIG1vZGVcbiAgICAgKi9cbiAgICByZW1vdmVUZXh0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBiYWNrZW5kID0gZmFicmljLmZpbHRlckJhY2tlbmQ7XG4gICAgICBpZiAoYmFja2VuZCAmJiBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KSB7XG4gICAgICAgIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRleHR1cmVzLCByZWZlcmVuY2UgdG8gZWxlbWVudHMgYW5kIGV2ZW50dWFsbHkgSlNET00gY2xlYW51cFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIFsnX29yaWdpbmFsRWxlbWVudCcsICdfZWxlbWVudCcsICdfZmlsdGVyZWRFbCcsICdfY2FjaGVDYW52YXMnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcm9zc09yaWdpbiB2YWx1ZSAob2YgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZWxlbWVudClcbiAgICAgKi9cbiAgICBnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxFbGVtZW50ICYmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQuY3Jvc3NPcmlnaW4gfHwgbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb3JpZ2luYWwgc2l6ZSBvZiBhbiBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBlbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoIC8gMiwgaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgLWgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZChcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoXG4gICAgICAgICAgJ3RvT2JqZWN0JyxcbiAgICAgICAgICBbJ2Nyb3BYJywgJ2Nyb3BZJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuZ2V0Q3Jvc3NPcmlnaW4oKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoZWlnaHQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3BYIHx8IHRoaXMuY3JvcFkgfHwgdGhpcy53aWR0aCA8IHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5oZWlnaHQgPCB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW10sIGltYWdlTWFya3VwID0gW10sIHN0cm9rZVN2ZywgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDIsIGNsaXBQYXRoID0gJycsIGltYWdlUmVuZGVyaW5nID0gJyc7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzQ3JvcCgpKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBzdmdTdHJpbmcucHVzaChcbiAgICAgICAgICAnPGNsaXBQYXRoIGlkPVwiaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJ1wiPlxcbicsXG4gICAgICAgICAgJ1xcdDxyZWN0IHg9XCInICsgeCArICdcIiB5PVwiJyArIHkgKyAnXCIgd2lkdGg9XCInICsgdGhpcy53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgdGhpcy5oZWlnaHQgKyAnXCIgLz5cXG4nLFxuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgY2xpcFBhdGggPSAnIGNsaXAtcGF0aD1cInVybCgjaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJylcIiAnO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmltYWdlU21vb3RoaW5nKSB7XG4gICAgICAgIGltYWdlUmVuZGVyaW5nID0gJ1wiIGltYWdlLXJlbmRlcmluZz1cIm9wdGltaXplU3BlZWQnO1xuICAgICAgfVxuICAgICAgaW1hZ2VNYXJrdXAucHVzaCgnXFx0PGltYWdlICcsICdDT01NT05fUEFSVFMnLCAneGxpbms6aHJlZj1cIicsIHRoaXMuZ2V0U3ZnU3JjKHRydWUpLFxuICAgICAgICAnXCIgeD1cIicsIHggLSB0aGlzLmNyb3BYLCAnXCIgeT1cIicsIHkgLSB0aGlzLmNyb3BZLFxuICAgICAgICAvLyB3ZSdyZSBlc3NlbnRpYWxseSBtb3Zpbmcgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIGZyb20gdG9wL2xlZnQgY29ybmVyIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlXG4gICAgICAgIC8vIGJ5IHdyYXBwaW5nIGl0IGluIGNvbnRhaW5lciA8Zz4gZWxlbWVudCB3aXRoIGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBvZmZzZXR0aW5nIG9iamVjdCB0byB0aGUgdG9wL2xlZnRcbiAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgZWxlbWVudC53aWR0aCB8fCBlbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsIGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBpbWFnZVJlbmRlcmluZyxcbiAgICAgICAgJ1wiJywgY2xpcFBhdGgsXG4gICAgICAgICc+PC9pbWFnZT5cXG4nKTtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5KSB7XG4gICAgICAgIHZhciBvcmlnRmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5maWxsID0gbnVsbDtcbiAgICAgICAgc3Ryb2tlU3ZnID0gW1xuICAgICAgICAgICdcXHQ8cmVjdCAnLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJykge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KHN0cm9rZVN2ZywgaW1hZ2VNYXJrdXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoaW1hZ2VNYXJrdXAsIHN0cm9rZVN2Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVyZWQgaW5kaWNhdGVzIGlmIHRoZSBzcmMgaXMgbmVlZGVkIGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqL1xuICAgIGdldFNyYzogZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmlsdGVyZWQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudG9EYXRhVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zcmNGcm9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zcmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcywgaXNFcnJvcik7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgbWluaW11bVNjYWxlID0gdGhpcy5taW5pbXVtU2NhbGVUcmlnZ2VyLFxuICAgICAgICAgIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsZVggPSBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICAgIGVsZW1lbnRUb0ZpbHRlciA9IHRoaXMuX2ZpbHRlcmVkRWwgfHwgdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbHRlciB8fCAoc2NhbGVYID4gbWluaW11bVNjYWxlICYmIHNjYWxlWSA+IG1pbmltdW1TY2FsZSkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRUb0ZpbHRlcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBjYWNoZUtleSA9IHRoaXMuX2ZpbHRlcmVkRWwgPyAodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKSA6IHRoaXMuY2FjaGVLZXksXG4gICAgICAgICAgc291cmNlV2lkdGggPSBlbGVtZW50VG9GaWx0ZXIud2lkdGgsIHNvdXJjZUhlaWdodCA9IGVsZW1lbnRUb0ZpbHRlci5oZWlnaHQ7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc291cmNlSGVpZ2h0O1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVZID0gZmlsdGVyLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgW2ZpbHRlcl0sIGVsZW1lbnRUb0ZpbHRlciwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgY2FjaGVLZXkpO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSBjYW52YXNFbC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gY2FudmFzRWwuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXJzIGFzc2lnbmVkIHRvIHRoaXMgaW1hZ2UgKGZyb20gXCJmaWx0ZXJzXCIgYXJyYXkpIG9yIGZyb20gZmlsdGVyIHBhcmFtXG4gICAgICogQG1ldGhvZCBhcHBseUZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGFwcGxpZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclJlc2l6aW5nIHNwZWNpZnkgaWYgdGhlIGZpbHRlciBvcGVyYXRpb24gaXMgYSByZXNpemUgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiB7dGhpc0FyZ30gcmV0dXJuIHRoZSBmYWJyaWMuSW1hZ2Ugb2JqZWN0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgICBmaWx0ZXJzID0gZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIgJiYgIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuXG4gICAgICAvLyBuZWVkcyB0byBjbGVhciBvdXQgb3IgV0VCR0wgd2lsbCBub3QgcmVzaXplIGNvcnJlY3RseVxuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgLy8gYWxzbyBkZXJlZmVyZW5jZSB0aGUgZXZlbnR1YWwgcmVzaXplZCBfZWxlbWVudFxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fZmlsdGVyZWRFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlc2l6ZSBhZ2FpbiBhdCBuZXh0IHJlbmRlckFsbCwgc28gcmVtb3ZlIHNhdmVkIF9sYXN0U2NhbGVYL1lcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBmaWx0ZXJzLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuY2FjaGVLZXkpO1xuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aCAhPT0gdGhpcy5fZWxlbWVudC53aWR0aCB8fFxuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0ICE9PSB0aGlzLl9lbGVtZW50LmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IHRoaXMuX2VsZW1lbnQud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGg7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gdGhpcy5fZWxlbWVudC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nKTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nICE9PSB0cnVlICYmIHRoaXMucmVzaXplRmlsdGVyICYmIHRoaXMuX25lZWRzUmVzaXplKCkpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0cm9rZShjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBpdCB3aWxsIHNldCB0aGUgaW1hZ2VTbW9vdGhpbmcgZm9yIHRoZSBkcmF3IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuZHJhd0NhY2hlT25DYW52YXMuY2FsbCh0aGlzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBUaGlzIGlzIHRoZSBzcGVjaWFsIGltYWdlIHZlcnNpb24gd2hlcmUgd2Ugd291bGQgbGlrZSB0byBhdm9pZCBjYWNoaW5nIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqIEVzc2VudGlhbGx5IGltYWdlcyBkbyBub3QgYmVuZWZpdCBmcm9tIGNhY2hpbmcuIFRoZXkgbWF5IHJlcXVpcmUgY2FjaGluZywgYW5kIGluIHRoYXRcbiAgICAgKiBjYXNlIHdlIGRvIGl0LiBBbHNvIGNhY2hpbmcgYW4gaW1hZ2UgdXN1YWxseSBlbmRzIGluIGEgbG9zcyBvZiBkZXRhaWxzLlxuICAgICAqIEEgZnVsbCBwZXJmb3JtYW5jZSBhdWRpdCBzaG91bGQgYmUgZG9uZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50VG9EcmF3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9maWx0ZXJTY2FsaW5nWCwgc2NhbGVZID0gdGhpcy5fZmlsdGVyU2NhbGluZ1ksXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCwgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICAgIC8vIGNyb3AgdmFsdWVzIGNhbm5vdCBiZSBsZXNzZXIgdGhhbiAwLlxuICAgICAgICAgIGNyb3BYID0gbWF4KHRoaXMuY3JvcFgsIDApLCBjcm9wWSA9IG1heCh0aGlzLmNyb3BZLCAwKSxcbiAgICAgICAgICBlbFdpZHRoID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsV2lkdGggfHwgZWxlbWVudFRvRHJhdy53aWR0aCxcbiAgICAgICAgICBlbEhlaWdodCA9IGVsZW1lbnRUb0RyYXcubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50VG9EcmF3LmhlaWdodCxcbiAgICAgICAgICBzWCA9IGNyb3BYICogc2NhbGVYLFxuICAgICAgICAgIHNZID0gY3JvcFkgKiBzY2FsZVksXG4gICAgICAgICAgLy8gdGhlIHdpZHRoIGhlaWdodCBjYW5ub3QgZXhjZWVkIGVsZW1lbnQgd2lkdGgvaGVpZ2h0LCBzdGFydGluZyBmcm9tIHRoZSBjcm9wIG9mZnNldC5cbiAgICAgICAgICBzVyA9IG1pbih3ICogc2NhbGVYLCBlbFdpZHRoIC0gc1gpLFxuICAgICAgICAgIHNIID0gbWluKGggKiBzY2FsZVksIGVsSGVpZ2h0IC0gc1kpLFxuICAgICAgICAgIHggPSAtdyAvIDIsIHkgPSAtaCAvIDIsXG4gICAgICAgICAgbWF4RGVzdFcgPSBtaW4odywgZWxXaWR0aCAvIHNjYWxlWCAtIGNyb3BYKSxcbiAgICAgICAgICBtYXhEZXN0SCA9IG1pbihoLCBlbEhlaWdodCAvIHNjYWxlWSAtIGNyb3BZKTtcblxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsIHNYLCBzWSwgc1csIHNILCB4LCB5LCBtYXhEZXN0VywgbWF4RGVzdEgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgaW1hZ2UgbmVlZHMgcmVzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIHJldHVybiAoc2NhbGUuc2NhbGVYICE9PSB0aGlzLl9sYXN0U2NhbGVYIHx8IHNjYWxlLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5nZXRPcmlnaW5hbFNpemUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBJbWFnZSBjbGFzcydzIGluaXRpYWxpemF0aW9uIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8U3RyaW5nfSBlbGVtZW50IFRoZSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgb3B0aW9ucyk7XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgZmFicmljLkltYWdlLkNTU19DQU5WQVMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdENvbmZpZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIGZhYnJpYy5JbWFnZS5maWx0ZXJzIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICAgICAqL1xuICAgIF9pbml0RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGZpbHRlcnMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfSwgJ2ZhYnJpYy5JbWFnZS5maWx0ZXJzJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvYmplY3QsIHVzaW5nIHRoZSBlbGVtZW50IG9yIHRoZVxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC53aWR0aCB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLmhlaWdodCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb2JqZWN0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgbnVsbCwgb2JqZWN0LmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UgZnJvbSBhbiBVUkwgc3RyaW5nXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY3JlYXRlIGFuIGltYWdlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBjcmVhdGVkIChuZXdseSBjcmVhdGVkIGltYWdlIGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KS4gU2Vjb25kIGFyZ3VtZW50IGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbWdPcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBpbWdPcHRpb25zKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKHVybCwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZywgaW1nT3B0aW9ucyksIGlzRXJyb3IpO1xuICAgIH0sIG51bGwsIGltZ09wdGlvbnMgJiYgaW1nT3B0aW9ucy5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNJbWFnZUVsZW1lbnR9XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTID1cbiAgICBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICAgJ3ggeSB3aWR0aCBoZWlnaHQgcHJlc2VydmVBc3BlY3RSYXRpbyB4bGluazpocmVmIGNyb3NzT3JpZ2luIGltYWdlLXJlbmRlcmluZycuc3BsaXQoJyAnKVxuICAgICk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5JbWFnZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGZhYnJpYy5JbWFnZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgZmFicmljLkltYWdlLmZyb21VUkwocGFyc2VkQXR0cmlidXRlc1sneGxpbms6aHJlZiddLCBjYWxsYmFjayxcbiAgICAgIGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlIHZhbHVlXG4gICAqL1xuICBfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGUgJSAzNjA7XG4gICAgaWYgKGFuZ2xlID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlIC0gMSkgLyA5MCkgKiA5MDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYW5nbGUgLyA5MCkgKiA5MDtcbiAgfSxcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgYW4gb2JqZWN0IChyb3RhdGluZyBpdCBmcm9tIGN1cnJlbnQgYW5nbGUgdG8gb25lIG9mIDAsIDkwLCAxODAsIDI3MCwgZXRjLiBkZXBlbmRpbmcgb24gd2hpY2ggaXMgY2xvc2VyKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKi9cbiAgZnhTdHJhaWdodGVuOiBmdW5jdGlvbihjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IHRoaXMuZ2V0KCdhbmdsZScpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGhpcy5yb3RhdGUodmFsdWUpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICovXG4gIGZ4U3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuZnhTdHJhaWdodGVuKHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZFxuICAgIH0pO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB3ZWJnbCBzdXBwb3J0cyBjZXJ0YWluIHByZWNpc2lvblxuICAgKiBAcGFyYW0ge1dlYkdMfSBDYW52YXMgV2ViR0wgY29udGV4dCB0byB0ZXN0IG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBQcmVjaXNpb24gdG8gdGVzdCBjYW4gYmUgYW55IG9mIGZvbGxvd2luZzogJ2xvd3AnLCAnbWVkaXVtcCcsICdoaWdocCdcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIFdlYkdMIHN1cHBvcnRzIGdpdmVuIHByZWNpc2lvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbil7XG4gICAgdmFyIGZyYWdtZW50U291cmNlID0gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG52b2lkIG1haW4oKXt9JztcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmaWx0ZXJpbmcgYmFja2VuZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIncyBicm93c2VyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemUgY2hlY2sgaWYgdGhlIHRpbGVTaXplIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydHMgV2ViR0wuXG4gICAqL1xuICBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCA9IGZ1bmN0aW9uKHRpbGVTaXplKSB7XG4gICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZS50aWxlU2l6ZTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChnbCkge1xuICAgICAgZmFicmljLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgaXNTdXBwb3J0ZWQgPSBmYWJyaWMubWF4VGV4dHVyZVNpemUgPj0gdGlsZVNpemU7XG4gICAgICB2YXIgcHJlY2lzaW9ucyA9IFsnaGlnaHAnLCAnbWVkaXVtcCcsICdsb3dwJ107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKyl7XG4gICAgICAgIGlmICh0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb25zW2ldKSl7XG4gICAgICAgICAgZmFicmljLndlYkdsUHJlY2lzaW9uID0gcHJlY2lzaW9uc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfTtcblxuICBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kID0gV2ViZ2xGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBXZWJHTCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIFdlYmdsRmlsdGVyQmFja2VuZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aWxlU2l6ZSkge1xuICAgICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBHTENvbnRleHQodGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgdGhpcy5jYXB0dXJlR1BVSW5mbygpO1xuICB9O1xuXG4gIFdlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcblxuICAgIHRpbGVTaXplOiAyMDQ4LFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwIGEgV2ViR0wgY29udGV4dCBzdWl0YWJsZSBmb3IgZmlsdGVyaW5nLCBhbmQgYmluZCBhbnkgbmVlZGVkIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIHNldHVwR0xDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuY3JlYXRlV2ViR0xDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHRoaXMuYVBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pO1xuICAgICAgdGhpcy5jaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBhIG1ldGhvZCB0byBjb3B5IGRhdGEgZnJvbSBHTCBjb250ZXh0IHRvIDJkIGNhbnZhcy4gIEluIHNvbWUgYnJvd3NlcnMgdXNpbmdcbiAgICAgKiBwdXRJbWFnZURhdGEgaXMgZmFzdGVyIHRoYW4gZHJhd0ltYWdlIGZvciB0aGF0IHNwZWNpZmljIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbk1lYXN1cmVQZXJmID0gdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcsIGNhblVzZUltYWdlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBJbWFnZURhdGEoMSwgMSk7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZVVpbnQ4Q2xhbXBlZCA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIGlmICghKGNhbk1lYXN1cmVQZXJmICYmIGNhblVzZUltYWdlRGF0YSAmJiBjYW5Vc2VBcnJheUJ1ZmZlciAmJiBjYW5Vc2VVaW50OENsYW1wZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGltYWdlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBpZiAoZmFicmljLmZvcmNlR0xQdXRJbWFnZURhdGEpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGVzdENvbnRleHQgPSB7XG4gICAgICAgIGltYWdlQnVmZmVyOiBpbWFnZUJ1ZmZlcixcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHN0YXJ0VGltZSwgZHJhd0ltYWdlVGltZSwgcHV0SW1hZ2VEYXRhVGltZTtcbiAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRERyYXdJbWFnZS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBkcmF3SW1hZ2VUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIHB1dEltYWdlRGF0YVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGlmIChkcmF3SW1hZ2VUaW1lID4gcHV0SW1hZ2VEYXRhVGltZSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRERyYXdJbWFnZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnQgYW5kIGFzc29jaWF0ZWQgV2ViR0wgY29udGV4dCBhbmQgYXR0YWNoZXMgdGhlbSBhc1xuICAgICAqIGNsYXNzIHByb3BlcnRpZXMgdG8gdGhlIEdMRmlsdGVyQmFja2VuZCBjbGFzcy5cbiAgICAgKi9cbiAgICBjcmVhdGVXZWJHTENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciBnbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgIC8vIHRoaXMgY2FudmFzIGNhbiBmaXJlIHdlYmdsY29udGV4dGxvc3QgYW5kIHdlYmdsY29udGV4dHJlc3RvcmVkXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gYXBwbHkgdGhlIHJlcXVlc3RlZCBmaWx0ZXJzIHRvIHRoZSBzb3VyY2UgcHJvdmlkZWQsIGRyYXdpbmcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB0YXJnZXQgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBBIGtleSB1c2VkIHRvIGNhY2hlIHJlc291cmNlcyByZWxhdGVkIHRvIHRoZSBzb3VyY2UuIElmXG4gICAgICogb21pdHRlZCwgY2FjaGluZyB3aWxsIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQsIHRhcmdldENhbnZhcywgY2FjaGVLZXkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgY2FjaGVkVGV4dHVyZTtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRUZXh0dXJlID0gdGhpcy5nZXRDYWNoZWRUZXh0dXJlKGNhY2hlS2V5LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIG9yaWdpbmFsV2lkdGg6IHNvdXJjZS53aWR0aCB8fCBzb3VyY2Uub3JpZ2luYWxXaWR0aCxcbiAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IHNvdXJjZS5oZWlnaHQgfHwgc291cmNlLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICBzb3VyY2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogaGVpZ2h0LFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgY29udGV4dDogZ2wsXG4gICAgICAgIHNvdXJjZVRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgdGFyZ2V0VGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgb3JpZ2luYWxUZXh0dXJlOiBjYWNoZWRUZXh0dXJlIHx8XG4gICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICBwYXNzZXM6IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICB3ZWJnbDogdHJ1ZSxcbiAgICAgICAgYVBvc2l0aW9uOiB0aGlzLmFQb3NpdGlvbixcbiAgICAgICAgcHJvZ3JhbUNhY2hlOiB0aGlzLnByb2dyYW1DYWNoZSxcbiAgICAgICAgcGFzczogMCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgdGVtcEZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBGYm8pO1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIgJiYgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSk7XG4gICAgICB0aGlzLmNvcHlHTFRvMkQoZ2wsIHBpcGVsaW5lU3RhdGUpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUuc291cmNlVGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUudGFyZ2V0VGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0ZW1wRmJvKTtcbiAgICAgIHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlclR5cGUgZ2wuTkVBUkVTVCBvciBnbC5MSU5FQVIgdXN1YWxseSwgd2ViZ2wgbnVtZXJpIGNvbnN0YW50c1xuICAgICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9XG4gICAgICovXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVJbWFnZVNvdXJjZSwgZmlsdGVyVHlwZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJUeXBlIHx8IGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclR5cGUgfHwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgaWYgKHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmVJbWFnZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgb3B0aW9uYWxseSB1c2VkIHRvIGdldCBhIHRleHR1cmUgZnJvbSB0aGUgY2FjaGUgYXJyYXlcbiAgICAgKlxuICAgICAqIElmIGFuIGV4aXN0aW5nIHRleHR1cmUgaXMgbm90IGZvdW5kLCBhIG5ldyB0ZXh0dXJlIGlzIGNyZWF0ZWQgYW5kIGNhY2hlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bmlxdWVJZCBBIGNhY2hlIGtleSB0byB1c2UgdG8gZmluZCBhbiBleGlzdGluZyB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gdGV4dHVyZUltYWdlU291cmNlIEEgc291cmNlIHRvIHVzZSB0byBjcmVhdGUgdGhlXG4gICAgICogdGV4dHVyZSBjYWNoZSBlbnRyeSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRDYWNoZWRUZXh0dXJlOiBmdW5jdGlvbih1bmlxdWVJZCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoXG4gICAgICAgICAgdGhpcy5nbCwgdGV4dHVyZUltYWdlU291cmNlLndpZHRoLCB0ZXh0dXJlSW1hZ2VTb3VyY2UuaGVpZ2h0LCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF0gPSB0ZXh0dXJlO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgb3V0IGNhY2hlZCByZXNvdXJjZXMgcmVsYXRlZCB0byBhIHNvdXJjZSBpbWFnZSB0aGF0IGhhcyBiZWVuXG4gICAgICogZmlsdGVyZWQgcHJldmlvdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWNoZUtleSBUaGUgY2FjaGUga2V5IHByb3ZpZGVkIHdoZW4gdGhlIHNvdXJjZSBpbWFnZSB3YXMgZmlsdGVyZWQuXG4gICAgICovXG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IGZ1bmN0aW9uKGNhY2hlS2V5KSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pO1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5R0xUbzJEOiBjb3B5R0xUbzJERHJhd0ltYWdlLFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBleHRyYWN0IEdQVSBpbmZvcm1hdGlvbiBzdHJpbmdzIGZyb20gYSBXZWJHTCBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlZnVsIGluZm9ybWF0aW9uIHdoZW4gZGVidWdnaW5nIG9yIGJsYWNrbGlzdGluZyBzcGVjaWZpYyBHUFVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBHUFUgaW5mbyBvYmplY3Qgd2l0aCByZW5kZXJlciBhbmQgdmVuZG9yIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2FwdHVyZUdQVUluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZ3B1SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGdsID0gdGhpcy5nbCwgZ3B1SW5mbyA9IHsgcmVuZGVyZXI6ICcnLCB2ZW5kb3I6ICcnIH07XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybiBncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbycpO1xuICAgICAgaWYgKGV4dCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKTtcbiAgICAgICAgdmFyIHZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfVkVORE9SX1dFQkdMKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgICAgZ3B1SW5mby5yZW5kZXJlciA9IHJlbmRlcmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlbmRvcikge1xuICAgICAgICAgIGdwdUluZm8udmVuZG9yID0gdmVuZG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZ3B1SW5mbyA9IGdwdUluZm87XG4gICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICB9LFxuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICB3aWR0aCA9IHRhcmdldENhbnZhcy53aWR0aCwgaGVpZ2h0ID0gdGFyZ2V0Q2FudmFzLmhlaWdodCxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0O1xuXG4gIGlmICh3aWR0aCAhPT0gZFdpZHRoIHx8IGhlaWdodCAhPT0gZEhlaWdodCkge1xuICAgIHRhcmdldENhbnZhcy53aWR0aCA9IGRXaWR0aDtcbiAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gZEhlaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMuXG4gKlxuICogVGhlIFdlYkdMIGNhbnZhcyBpcyBhc3N1bWVkIHRvIGJlIHVwc2lkZSBkb3duLCB3aXRoIHRoZSB0b3AtbGVmdCBwaXhlbCBvZiB0aGVcbiAqIGRlc2lyZWQgb3V0cHV0IGltYWdlIGFwcGVhcmluZyBpbiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSBXZWJHTCBjYW52YXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJERHJhd0ltYWdlKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciBnbENhbnZhcyA9IGdsLmNhbnZhcywgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnRyYW5zbGF0ZSgwLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTsgLy8gbW92ZSBpdCBkb3duIGFnYWluXG4gIGN0eC5zY2FsZSgxLCAtMSk7IC8vIHZlcnRpY2FsIGZsaXBcbiAgLy8gd2hlcmUgaXMgbXkgaW1hZ2Ugb24gdGhlIGJpZyBnbGNhbnZhcz9cbiAgdmFyIHNvdXJjZVkgPSBnbENhbnZhcy5oZWlnaHQgLSB0YXJnZXRDYW52YXMuaGVpZ2h0O1xuICBjdHguZHJhd0ltYWdlKGdsQ2FudmFzLCAwLCBzb3VyY2VZLCB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQsIDAsIDAsXG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzIHVzaW5nIDJkIGNhbnZhcycgcHV0SW1hZ2VEYXRhXG4gKiBBUEkuIE1lYXN1cmFibHkgZmFzdGVyIHRoYW4gdXNpbmcgY3R4LmRyYXdJbWFnZSBpbiBGaXJlZm94ICh2ZXJzaW9uIDU0IG9uIE9TWCBTaWVycmEpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRFB1dEltYWdlRGF0YShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQsXG4gICAgICBudW1CeXRlcyA9IGRXaWR0aCAqIGRIZWlnaHQgKiA0O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdTggPSBuZXcgVWludDhBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdThDbGFtcGVkID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcblxuICBnbC5yZWFkUGl4ZWxzKDAsIDAsIGRXaWR0aCwgZEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdTgpO1xuICB2YXIgaW1nRGF0YSA9IG5ldyBJbWFnZURhdGEodThDbGFtcGVkLCBkV2lkdGgsIGRIZWlnaHQpO1xuICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQgPSBDYW52YXMyZEZpbHRlckJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIENhbnZhcyAyRCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhczJkRmlsdGVyQmFja2VuZCgpIHt9O1xuXG4gIENhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcbiAgICBldmljdENhY2hlc0ZvcktleTogbm9vcCxcbiAgICBkaXNwb3NlOiBub29wLFxuICAgIGNsZWFyV2ViR0xDYWNoZXM6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwuIFRoaXMgb2JqZWN0IGlzIGEgc29ydCBvZiByZXBvc2l0b3J5IG9mIGhlbHAgbGF5ZXJzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBvZiByZWNyZWF0aW5nIHRoZW0gZHVyaW5nIGZyZXF1ZW50IGZpbHRlcmluZy4gSWYgeW91IGFyZSBwcmV2aWV3aW5nIGEgZmlsdGVyIHdpdGhcbiAgICAgKiBhIHNsaWRlciB5b3UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzZXQgb2YgZmlsdGVycyBhZ2FpbnN0IGEgc291cmNlIGltYWdlIGFuZCBkcmF3IHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgZGVzdGluYXRpb24gY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZEZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVyIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlRWxlbWVudCBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2VFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRDYW52YXMpIHtcbiAgICAgIHZhciBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc291cmNlRWxlbWVudCwgMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBvcmlnaW5hbEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgcGlwZWxpbmVTdGF0ZSA9IHtcbiAgICAgICAgc291cmNlV2lkdGg6IHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IHNvdXJjZUhlaWdodCxcbiAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZURhdGEsXG4gICAgICAgIG9yaWdpbmFsRWw6IHNvdXJjZUVsZW1lbnQsXG4gICAgICAgIG9yaWdpbmFsSW1hZ2VEYXRhOiBvcmlnaW5hbEltYWdlRGF0YSxcbiAgICAgICAgY2FudmFzRWw6IHRhcmdldENhbnZhcyxcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICB9O1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIuYXBwbHlUbyhwaXBlbGluZVN0YXRlKTsgfSk7XG4gICAgICBpZiAocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGggIT09IHNvdXJjZVdpZHRoIHx8IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodCAhPT0gc291cmNlSGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShwaXBlbGluZVN0YXRlLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZVxuICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjaW1hZ2VfZmlsdGVyc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAqL1xuZmFicmljLkltYWdlID0gZmFicmljLkltYWdlIHx8IHsgfTtcbmZhYnJpYy5JbWFnZS5maWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMgfHwgeyB9O1xuXG4vKipcbiAqIFJvb3QgZmlsdGVyIGNsYXNzIGZyb20gd2hpY2ggYWxsIGZpbHRlciBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB0eXBlOiAnQmFzZUZpbHRlcicsXG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gc2VuZCB3aXRoIGJ1ZmZlcnMuIGRvIG5vdCBtb2RpZnlcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAnfScsXG5cbiAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICd9JyxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGZpbHRlcidzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlciBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHRvIHVzZSBmb3Igc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJhZ21lbnRTb3VyY2UgZnJhZ21lbnRTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmVydGV4U291cmNlIHZlcnRleFNoYWRlciBzb3VyY2UgZm9yIGNvbXBpbGF0aW9uXG4gICAqL1xuICBjcmVhdGVQcm9ncmFtOiBmdW5jdGlvbihnbCwgZnJhZ21lbnRTb3VyY2UsIHZlcnRleFNvdXJjZSkge1xuICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2UgfHwgdGhpcy5mcmFnbWVudFNvdXJjZTtcbiAgICB2ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhTb3VyY2UgfHwgdGhpcy52ZXJ0ZXhTb3VyY2U7XG4gICAgaWYgKGZhYnJpYy53ZWJHbFByZWNpc2lvbiAhPT0gJ2hpZ2hwJyl7XG4gICAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlLnJlcGxhY2UoXG4gICAgICAgIC9wcmVjaXNpb24gaGlnaHAgZmxvYXQvZyxcbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgZmFicmljLndlYkdsUHJlY2lzaW9uICsgJyBmbG9hdCdcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnVmVydGV4IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ0ZyYWdtZW50IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdTaGFkZXIgbGluayBlcnJvciBmb3IgXCIke3RoaXMudHlwZX1cIiAnICtcbiAgICAgICAgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHRoaXMuZ2V0QXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSkgfHwgeyB9O1xuICAgIHVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwSCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBIJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnNcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgYXR0cmlidXRlIG5hbWVzIHRvIFdlYkdMQXR0cmlidXRlTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGUgc2hhZGVyIHByb2dyYW0gZnJvbSB3aGljaCB0byB0YWtlIGF0dHJpYnV0ZSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHJldHVybiB7XG4gICAgICBhUG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9zaXRpb24nKSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uICgvKiBnbCwgcHJvZ3JhbSAqLykge1xuICAgIC8vIGluIGNhc2UgaSBkbyBub3QgbmVlZCBhbnkgc3BlY2lhbCB1bmlmb3JtIGkgbmVlZCB0byByZXR1cm4gYW4gZW1wdHkgb2JqZWN0XG4gICAgcmV0dXJuIHsgfTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCBhdHRyaWJ1dGUgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVMb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIGF0dHJpYnV0ZSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kQXR0cmlidXRlRGF0YTogZnVuY3Rpb24oZ2wsIGF0dHJpYnV0ZUxvY2F0aW9ucywgYVBvc2l0aW9uRGF0YSkge1xuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbiA9IGF0dHJpYnV0ZUxvY2F0aW9ucy5hUG9zaXRpb247XG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhUG9zaXRpb25EYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gIH0sXG5cbiAgX3NldHVwRnJhbWVCdWZmZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMucGFzc2VzID4gMSkge1xuICAgICAgd2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGggIT09IHdpZHRoIHx8IG9wdGlvbnMuc291cmNlSGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShvcHRpb25zLnRhcmdldFRleHR1cmUpO1xuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZHJhdyBsYXN0IGZpbHRlciBvbiBjYW52YXMgYW5kIG5vdCB0byBmcmFtZWJ1ZmZlci5cbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5maW5pc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgX3N3YXBUZXh0dXJlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMucGFzc2VzLS07XG4gICAgb3B0aW9ucy5wYXNzKys7XG4gICAgdmFyIHRlbXAgPSBvcHRpb25zLnRhcmdldFRleHR1cmU7XG4gICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlO1xuICAgIG9wdGlvbnMuc291cmNlVGV4dHVyZSA9IHRlbXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgaXNOZXV0cmFsIGltcGxlbWVudGF0aW9uIGZvciBvbmUgcGFyYW1ldGVyIGJhc2VkIGZpbHRlcnMuXG4gICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICogb24gdGhlIGltYWdlXG4gICAqIE90aGVyIGZpbHRlcnMgbWF5IG5lZWQgdGhlaXIgb3duIHZlcnNpb24gKCBDb2xvck1hdHJpeCwgSHVlUm90YXRpb24sIGdhbW1hLCBDb21wb3NlZEZpbHRlciApXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqKi9cbiAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKC8qIG9wdGlvbnMgKi8pIHtcbiAgICB2YXIgbWFpbiA9IHRoaXMubWFpblBhcmFtZXRlcixcbiAgICAgICAgX2NsYXNzID0gZmFicmljLkltYWdlLmZpbHRlcnNbdGhpcy50eXBlXS5wcm90b3R5cGU7XG4gICAgaWYgKG1haW4pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc1ttYWluXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IF9jbGFzc1ttYWluXS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAodGhpc1ttYWluXVtpXSAhPT0gX2NsYXNzW21haW5dW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY2xhc3NbbWFpbl0gPT09IHRoaXNbbWFpbl07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGZpbHRlciB1c2luZyB3ZWJnbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUgVGhlIHRleHR1cmUgb2YgdGhlIG9yaWdpbmFsIGlucHV0IGltYWdlLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLnJldHJpZXZlU2hhZGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnBhc3MgPT09IDAgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLnNvdXJjZVRleHR1cmUpO1xuICAgIH1cbiAgICBnbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNlbmRBdHRyaWJ1dGVEYXRhKGdsLCBzaGFkZXIuYXR0cmlidXRlTG9jYXRpb25zLCBvcHRpb25zLmFQb3NpdGlvbik7XG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXLCAxIC8gb3B0aW9ucy5zb3VyY2VXaWR0aCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwSCwgMSAvIG9wdGlvbnMuc291cmNlSGVpZ2h0KTtcblxuICAgIHRoaXMuc2VuZFVuaWZvcm1EYXRhKGdsLCBzaGFkZXIudW5pZm9ybUxvY2F0aW9ucyk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoLCBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgfSxcblxuICBiaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIC8vIHJlc2V0IGFjdGl2ZSB0ZXh0dXJlIHRvIDAgYXMgdXN1YWxcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICB1bmJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgZ2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXTtcbiAgfSxcblxuICBzZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIHVuaWZvcm0gZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbigvKiBnbCwgdW5pZm9ybUxvY2F0aW9ucyAqLykge1xuICAgIC8vIEludGVudGlvbmFsbHkgbGVmdCBibGFuay4gIE92ZXJyaWRlIG1lIGluIHN1YmNsYXNzZXMuXG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRlZCBieSBhIDJkIGZpbHRlciwgdGhpcyBmdW5jdGlvbnMgY2FuIGNyZWF0ZSBhbiBoZWxwZXIgY2FudmFzIHRvIGJlIHVzZWRcbiAgICogcmVtZW1iZXIgdGhhdCBvcHRpb25zLnRhcmdldENhbnZhcyBpcyBhdmFpbGFibGUgZm9yIHVzZSB0aWxsIGVuZCBvZiBjaGFpbi5cbiAgICovXG4gIGNyZWF0ZUhlbHBMYXllcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5oZWxwTGF5ZXIpIHtcbiAgICAgIHZhciBoZWxwTGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGhlbHBMYXllci53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICBoZWxwTGF5ZXIuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICBvcHRpb25zLmhlbHBMYXllciA9IGhlbHBMYXllcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqL1xuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdCA9IHsgdHlwZTogdGhpcy50eXBlIH0sIG1haW5QID0gdGhpcy5tYWluUGFyYW1ldGVyO1xuICAgIGlmIChtYWluUCkge1xuICAgICAgb2JqZWN0W21haW5QXSA9IHRoaXNbbWFpblBdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KCk7XG4gIH1cbn0pO1xuXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGZpbHRlcik7XG4gIHJldHVybiBmaWx0ZXI7XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIE1hdHJpeCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3d3dy53ZWJ3YXNwLmNvLnVrL3R1dG9yaWFscy8yMTkvQ29sb3JfTWF0cml4X0ZpbHRlci5waHB9XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly9waG9ib3NsYWIub3JnL2xvZy8yMDEzLzExL2Zhc3QtaW1hZ2UtZmlsdGVycy13aXRoLXdlYmdsfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Lb2RhY2hyb21lIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCh7XG4gICAqICBtYXRyaXg6IFtcbiAgICAgICAxLjEyODU1ODIzOTY1OTM1MjUsIC0wLjM5NjczODIyODM2MDEzNDgsIC0wLjAzOTkyNTU5MTcyOTIxNzkzLCAwLCA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNiwgMS4wODM1MjUxNTY2MjkxMzA0LCAtMC4wNTQ5ODgwNTExNTYzMzEzMiwgMCwgMjQuNzMyNDA3ODk2NzA2MjAzLFxuICAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db2xvck1hdHJpeCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbG9yTWF0cml4JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUNvbnN0YW50cztcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IgKj0gdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgICAnY29sb3IgKz0gdUNvbnN0YW50cztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3JtYXRyaXggZm9yIHBpeGVscy5cbiAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0cml4IGFycmF5IG9mIDIwIG51bWJlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYXRyaXg6IFtcbiAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ21hdHJpeCcsXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGEsIG1haW5seSBmb3Igbm9uIHdlYmdsIHNjZW5hcmlvXG4gICAgICogdG8gc2F2ZSBzb21lIGNhbGN1bGF0aW9uXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBjb2xvcnNPbmx5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4LnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQ29sb3JNYXRyaXggb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGksIGNvbG9yc09ubHkgPSB0aGlzLmNvbG9yc09ubHk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBpZiAoY29sb3JzT25seSkge1xuICAgICAgICAgIGRhdGFbaV0gPSByICogbVswXSArIGcgKiBtWzFdICsgYiAqIG1bMl0gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIG1bMTRdICogMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgYSAqIG1bM10gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgYSAqIG1bOF0gKyBtWzldICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDJdID0gciAqIG1bMTBdICsgZyAqIG1bMTFdICsgYiAqIG1bMTJdICsgYSAqIG1bMTNdICsgbVsxNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSByICogbVsxNV0gKyBnICogbVsxNl0gKyBiICogbVsxN10gKyBhICogbVsxOF0gKyBtWzE5XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbG9yTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb2xvck1hdHJpeCcpLFxuICAgICAgICB1Q29uc3RhbnRzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb25zdGFudHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgbWF0cml4ID0gW1xuICAgICAgICAgICAgbVswXSwgbVsxXSwgbVsyXSwgbVszXSxcbiAgICAgICAgICAgIG1bNV0sIG1bNl0sIG1bN10sIG1bOF0sXG4gICAgICAgICAgICBtWzEwXSwgbVsxMV0sIG1bMTJdLCBtWzEzXSxcbiAgICAgICAgICAgIG1bMTVdLCBtWzE2XSwgbVsxN10sIG1bMThdXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjb25zdGFudHMgPSBbbVs0XSwgbVs5XSwgbVsxNF0sIG1bMTldXTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3JNYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVDb25zdGFudHMsIGNvbnN0YW50cyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXguZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCcmlnaHRuZXNzIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzKHtcbiAgICogICBicmlnaHRuZXNzOiAwLjA1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQnJpZ2h0bmVzcyA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCcmlnaHRuZXNzO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQnJpZ2h0bmVzcyB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRyYW5zbGF0ZWQgdG8gLTI1NSB0byAyNTUgZm9yIDJkXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3NcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJyaWdodG5lc3M6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnYnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5icmlnaHRuZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGJyaWdodG5lc3MgPSBNYXRoLnJvdW5kKHRoaXMuYnJpZ2h0bmVzcyAqIDI1NSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gKyBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMl0gPSBkYXRhW2kgKyAyXSArIGJyaWdodG5lc3M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1QnJpZ2h0bmVzczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QnJpZ2h0bmVzcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJyaWdodG5lc3MsIHRoaXMuYnJpZ2h0bmVzcyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1wiPmh0bWw1cm9ja3MgYXJ0aWNsZTwvYT5cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TaGFycGVuIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAwLCAtMSwgIDAsXG4gICAqICAgICAgICAgICAgLTEsICA1LCAtMSxcbiAgICogICAgICAgICAgICAgMCwgLTEsICAwIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkJsdXIgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzkgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXIgd2l0aCBvcGFxdWVuZXNzPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgb3BhcXVlOiB0cnVlLFxuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnZvbHV0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb252b2x1dGUnLFxuXG4gICAgLypcbiAgICAgKiBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICovXG4gICAgb3BhcXVlOiBmYWxzZSxcblxuICAgIC8qXG4gICAgICogbWF0cml4IGZvciB0aGUgZmlsdGVyLCBtYXggOXg5XG4gICAgICovXG4gICAgbWF0cml4OiBbMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMF0sXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgQ29udm9sdXRlXzNfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxKSwgdVN0ZXBIICogKGggLSAxKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzNfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxLjApLCB1U3RlcEggKiAoaCAtIDEuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA1LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfNV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDUuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA3LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfN18wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDcuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA5LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfOV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDkuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3BhcXVlPWZhbHNlXSBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWF0cml4XSBGaWx0ZXIgbWF0cml4XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLnNxcnQodGhpcy5tYXRyaXgubGVuZ3RoKTtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHNpemUgKyAnXycgKyAodGhpcy5vcGFxdWUgPyAxIDogMCk7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVtjYWNoZUtleV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHdlaWdodHMgPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKSxcbiAgICAgICAgICBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpLFxuICAgICAgICAgIHN3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIHNoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoc3csIHNoKSxcbiAgICAgICAgICBkc3QgPSBvdXRwdXQuZGF0YSxcbiAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcbiAgICAgICAgICBhbHBoYUZhYyA9IHRoaXMub3BhcXVlID8gMSA6IDAsXG4gICAgICAgICAgciwgZywgYiwgYSwgZHN0T2ZmLFxuICAgICAgICAgIHNjeCwgc2N5LCBzcmNPZmYsIHd0LFxuICAgICAgICAgIHgsIHksIGN4LCBjeTtcblxuICAgICAgZm9yICh5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICBkc3RPZmYgPSAoeSAqIHN3ICsgeCkgKiA0O1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgd2VpZ2hlZCBzdW0gb2YgdGhlIHNvdXJjZSBpbWFnZSBwaXhlbHMgdGhhdFxuICAgICAgICAgIC8vIGZhbGwgdW5kZXIgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxuICAgICAgICAgIHIgPSAwOyBnID0gMDsgYiA9IDA7IGEgPSAwO1xuXG4gICAgICAgICAgZm9yIChjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgZm9yIChjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgICBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoc2N5IDwgMCB8fCBzY3kgPj0gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPj0gc3cpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNyY09mZiA9IChzY3kgKiBzdyArIHNjeCkgKiA0O1xuICAgICAgICAgICAgICB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIHIgKz0gZGF0YVtzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgIGcgKz0gZGF0YVtzcmNPZmYgKyAxXSAqIHd0O1xuICAgICAgICAgICAgICBiICs9IGRhdGFbc3JjT2ZmICsgMl0gKiB3dDtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICAgICAgYSArPSBkYXRhW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcbiAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGRhdGFbZHN0T2ZmICsgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IG91dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1hdHJpeCcpLFxuICAgICAgICB1T3BhcXVlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VPcGFxdWUnKSxcbiAgICAgICAgdUhhbGZTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIYWxmU2l6ZScpLFxuICAgICAgICB1U2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2l6ZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVNYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgb3BhcXVlOiB0aGlzLm9wYXF1ZSxcbiAgICAgICAgbWF0cml4OiB0aGlzLm1hdHJpeFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdyYXlzY2FsZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HcmF5c2NhbGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR3JheXNjYWxlJyxcblxuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBhdmVyYWdlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5iICsgY29sb3IuZykgLyAzLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGxpZ2h0bmVzczogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBpbnQgdU1vZGU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IChtYXgobWF4KGNvbC5yLCBjb2wuZyksY29sLmIpICsgbWluKG1pbihjb2wuciwgY29sLmcpLGNvbC5iKSkgLyAyLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBsdW1pbm9zaXR5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gMC4yMSAqIGNvbC5yICsgMC43MiAqIGNvbC5nICsgMC4wNyAqIGNvbC5iO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBtb2RlLCBiZXR3ZWVuICdhdmVyYWdlJywgJ2xpZ2h0bmVzcycsICdsdW1pbm9zaXR5J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb2RlOiAnYXZlcmFnZScsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbW9kZScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR3JheXNjYWxlIG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsIHZhbHVlLFxuICAgICAgICAgIG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdhdmVyYWdlJykge1xuICAgICAgICAgIHZhbHVlID0gKGRhdGFbaV0gKyBkYXRhW2kgKyAxXSArIGRhdGFbaSArIDJdKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2xpZ2h0bmVzcycpIHtcbiAgICAgICAgICB2YWx1ZSA9IChNYXRoLm1pbihkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pICtcbiAgICAgICAgICAgIE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbHVtaW5vc2l0eScpIHtcbiAgICAgICAgICB2YWx1ZSA9IDAuMjEgKiBkYXRhW2ldICsgMC43MiAqIGRhdGFbaSArIDFdICsgMC4wNyAqIGRhdGFbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1vZGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1vZGUnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIC8vIGRlZmF1bHQgYXZlcmFnZSBtb2RlLlxuICAgICAgdmFyIG1vZGUgPSAxO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudU1vZGUsIG1vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmF5c2NhbGUgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVGhlIGZpbHRlciBpcyBuZXZlciBuZXV0cmFsXG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEludmVydCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0KCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkludmVydCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdJbnZlcnQnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBpbnQgdUludmVydDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZiAodUludmVydCA9PSAxKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wIC0gY29sb3IuciwxLjAgLWNvbG9yLmcsMS4wIC1jb2xvci5iLGNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgaW52ZXJ0LiBpZiBmYWxzZSwgZG9lcyBub3RoaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbnZlcnRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludmVydDogdHJ1ZSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdpbnZlcnQnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEludmVydCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pbnZlcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1SW52ZXJ0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbnZlcnQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbnZlcnQsIHRoaXMuaW52ZXJ0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIE5vaXNlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlKHtcbiAgICogICBub2lzZTogNzAwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Ob2lzZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ05vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIG5vaXNlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTZWVkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZCh2ZWMyIGNvLCBmbG9hdCBzZWVkLCBmbG9hdCB2U2NhbGUpIHtcXG4nICtcbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICogdlNjYWxlICx2ZWMyKDEyLjk4OTggLCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzICogKHNlZWQgKyAwLjAxKSAvIDIuMCk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gKDAuNSAtIHJhbmQodlRleENvb3JkLCB1U2VlZCwgMC4xIC8gdVN0ZXBIKSkgKiB1Tm9pc2U7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdub2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBOb2lzZSB2YWx1ZSwgZnJvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBub2lzZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm9pc2U6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm5vaXNlID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG5vaXNlID0gdGhpcy5ub2lzZSwgcmFuZDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHJhbmQgPSAoMC41IC0gTWF0aC5yYW5kb20oKSkgKiBub2lzZTtcblxuICAgICAgICBkYXRhW2ldICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IHJhbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Tm9pc2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU5vaXNlJyksXG4gICAgICAgIHVTZWVkOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTZWVkJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Tm9pc2UsIHRoaXMubm9pc2UgLyAyNTUpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNlZWQsIE1hdGgucmFuZG9tKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBub2lzZTogdGhpcy5ub2lzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFBpeGVsYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlKHtcbiAgICogICBibG9ja3NpemU6IDhcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5QaXhlbGF0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1BpeGVsYXRlJyxcblxuICAgIGJsb2Nrc2l6ZTogNCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdibG9ja3NpemUnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgUGl4ZWxhdGUgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUJsb2Nrc2l6ZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrVyA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja0ggPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnaW50IHBvc1ggPSBpbnQodlRleENvb3JkLnggLyBibG9ja1cpO1xcbicgK1xuICAgICAgICAnaW50IHBvc1kgPSBpbnQodlRleENvb3JkLnkgLyBibG9ja0gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1ggPSBmbG9hdChwb3NYKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NZID0gZmxvYXQocG9zWSk7XFxuJyArXG4gICAgICAgICd2ZWMyIHNxdWFyZUNvb3JkcyA9IHZlYzIoZnBvc1ggKiBibG9ja1csIGZwb3NZICogYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHNxdWFyZUNvb3Jkcyk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBQaXhlbGF0ZSBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgakxlbiA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBpbmRleCwgaSwgaiwgciwgZywgYiwgYSxcbiAgICAgICAgICBfaSwgX2osIF9pTGVuLCBfakxlbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gdGhpcy5ibG9ja3NpemUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gdGhpcy5ibG9ja3NpemUpIHtcblxuICAgICAgICAgIGluZGV4ID0gKGkgKiA0KSAqIGpMZW4gKyAoaiAqIDQpO1xuXG4gICAgICAgICAgciA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgIGcgPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgYiA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICBhID0gZGF0YVtpbmRleCArIDNdO1xuXG4gICAgICAgICAgX2lMZW4gPSBNYXRoLm1pbihpICsgdGhpcy5ibG9ja3NpemUsIGlMZW4pO1xuICAgICAgICAgIF9qTGVuID0gTWF0aC5taW4oaiArIHRoaXMuYmxvY2tzaXplLCBqTGVuKTtcbiAgICAgICAgICBmb3IgKF9pID0gaTsgX2kgPCBfaUxlbjsgX2krKykge1xuICAgICAgICAgICAgZm9yIChfaiA9IGo7IF9qIDwgX2pMZW47IF9qKyspIHtcbiAgICAgICAgICAgICAgaW5kZXggPSAoX2kgKiA0KSAqIGpMZW4gKyAoX2ogKiA0KTtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBnO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMl0gPSBiO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgM10gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB3aGVuIHRoZSBmaWx0ZXIgaXMgbm90IGdvbm5hIGFwcGx5IGNoYW5nZXMgdG8gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2Nrc2l6ZSA9PT0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVCbG9ja3NpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJsb2Nrc2l6ZScpLFxuICAgICAgICB1U3RlcFc6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyksXG4gICAgICAgIHVTdGVwSDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcEgnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCbG9ja3NpemUsIHRoaXMuYmxvY2tzaXplKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2hpdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvclxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3Ioe1xuICAgKiAgIHRocmVzaG9sZDogMC4yLFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuUmVtb3ZlQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZW1vdmVDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byByZW1vdmUsIGluIGFueSBmb3JtYXQgdW5kZXJzdG9vZCBieSBmYWJyaWMuQ29sb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAnI0ZGRkZGRicsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUxvdztcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUhpZ2g7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZihhbGwoZ3JlYXRlclRoYW4oZ2xfRnJhZ0NvbG9yLnJnYix1TG93LnJnYikpICYmIGFsbChncmVhdGVyVGhhbih1SGlnaC5yZ2IsZ2xfRnJhZ0NvbG9yLnJnYikpKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gMC4wO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogZGlzdGFuY2UgdG8gYWN0dWFsIGNvbG9yLCBhcyB2YWx1ZSB1cCBvciBkb3duIGZyb20gZWFjaCByLGcsYlxuICAgICAqIGJldHdlZW4gMCBhbmQgMVxuICAgICAqKi9cbiAgICBkaXN0YW5jZTogMC4wMixcblxuICAgIC8qKlxuICAgICAqIEZvciBjb2xvciB0byByZW1vdmUgaW5zaWRlIGRpc3RhbmNlLCB1c2UgYWxwaGEgY2hhbm5lbCBmb3IgYSBzbW9vdGhlciBkZWxldGlvblxuICAgICAqIE5PVCBJTVBMRU1FTlRFRCBZRVRcbiAgICAgKiovXG4gICAgdXNlQWxwaGE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2xvcj0jUlJHR0JCXSBUaHJlc2hvbGQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGFuY2U9MTBdIERpc3RhbmNlIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlICogMjU1LFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBsb3dDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAtIGRpc3RhbmNlLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgaGlnaEMgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdICsgZGlzdGFuY2UsXG4gICAgICAgICAgXTtcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiBsb3dDWzBdICYmXG4gICAgICAgICAgICBnID4gbG93Q1sxXSAmJlxuICAgICAgICAgICAgYiA+IGxvd0NbMl0gJiZcbiAgICAgICAgICAgIHIgPCBoaWdoQ1swXSAmJlxuICAgICAgICAgICAgZyA8IGhpZ2hDWzFdICYmXG4gICAgICAgICAgICBiIDwgaGlnaENbMl0pIHtcbiAgICAgICAgICBkYXRhW2kgKyAzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVMb3c6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUxvdycpLFxuICAgICAgICB1SGlnaDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SGlnaCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgICAgZGlzdGFuY2UgPSBwYXJzZUZsb2F0KHRoaXMuZGlzdGFuY2UpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICAwICsgc291cmNlWzBdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzFdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzJdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVMb3csIGxvd0MpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVIaWdoLCBoaWdoQyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBkaXN0YW5jZTogdGhpcy5kaXN0YW5jZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgdmFyIG1hdHJpY2VzID0ge1xuICAgIEJyb3duaWU6IFtcbiAgICAgIDAuNTk5NzAsMC4zNDU1MywtMC4yNzA4MiwwLDAuMTg2LFxuICAgICAgLTAuMDM3NzAsMC44NjA5NSwwLjE1MDU5LDAsLTAuMTQ0OSxcbiAgICAgIDAuMjQxMTMsLTAuMDc0NDEsMC40NDk3MiwwLC0wLjAyOTY1LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBWaW50YWdlOiBbXG4gICAgICAwLjYyNzkzLDAuMzIwMjEsLTAuMDM5NjUsMCwwLjAzNzg0LFxuICAgICAgMC4wMjU3OCwwLjY0NDExLDAuMDMyNTksMCwwLjAyOTI2LFxuICAgICAgMC4wNDY2MCwtMC4wODUxMiwwLjUyNDE2LDAsMC4wMjAyMyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgS29kYWNocm9tZTogW1xuICAgICAgMS4xMjg1NSwtMC4zOTY3MywtMC4wMzk5MiwwLDAuMjQ5OTEsXG4gICAgICAtMC4xNjQwNCwxLjA4MzUyLC0wLjA1NDk4LDAsMC4wOTY5OCxcbiAgICAgIC0wLjE2Nzg2LC0wLjU2MDM0LDEuNjAxNDgsMCwwLjEzOTcyLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBUZWNobmljb2xvcjogW1xuICAgICAgMS45MTI1MiwtMC44NTQ1MywtMC4wOTE1NSwwLDAuMDQ2MjQsXG4gICAgICAtMC4zMDg3OCwxLjc2NTg5LC0wLjEwNjAxLDAsLTAuMjc1ODksXG4gICAgICAtMC4yMzExMCwtMC43NTAxOCwxLjg0NzU5LDAsMC4xMjEzNyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgUG9sYXJvaWQ6IFtcbiAgICAgIDEuNDM4LC0wLjA2MiwtMC4wNjIsMCwwLFxuICAgICAgLTAuMTIyLDEuMzc4LC0wLjEyMiwwLDAsXG4gICAgICAtMC4wMTYsLTAuMDE2LDEuNDgzLDAsMCxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgU2VwaWE6IFtcbiAgICAgIDAuMzkzLCAwLjc2OSwgMC4xODksIDAsIDAsXG4gICAgICAwLjM0OSwgMC42ODYsIDAuMTY4LCAwLCAwLFxuICAgICAgMC4yNzIsIDAuNTM0LCAwLjEzMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuICAgIEJsYWNrV2hpdGU6IFtcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgXVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBtYXRyaWNlcykge1xuICAgIGZpbHRlcnNba2V5XSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlICovIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIHR5cGU6IGtleSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xvcm1hdHJpeCBmb3IgdGhlIGVmZmVjdFxuICAgICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIG1hdHJpeDogbWF0cmljZXNba2V5XSxcblxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBtYXRyaXggZXhwb3J0IGZvciB0aGlzIGtpbmQgb2Ygc3RhdGljLCBwYXJhbWV0ZXIgbGVzcyBmaWx0ZXJzLlxuICAgICAgICovXG4gICAgICBtYWluUGFyYW1ldGVyOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhXG4gICAgICAgKi9cbiAgICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICB9KTtcbiAgICBmYWJyaWMuSW1hZ2UuZmlsdGVyc1trZXldLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG4gIH1cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZENvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmQucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgbW9kZTogJ211bHRpcGx5JyxcblxuICAgIC8qKlxuICAgICAqIGFscGhhIHZhbHVlLiByZXByZXNlbnQgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibGVuZCBjb2xvciBvcGVyYXRpb24uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBzY3JlZW46ICdnbF9GcmFnQ29sb3IucmdiID0gMS4wIC0gKDEuMCAtIGdsX0ZyYWdDb2xvci5yZ2IpICogKDEuMCAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBhZGQ6ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGRpZmY6ICdnbF9GcmFnQ29sb3IucmdiID0gYWJzKGdsX0ZyYWdDb2xvci5yZ2IgLSB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgc3VidHJhY3Q6ICdnbF9GcmFnQ29sb3IucmdiIC09IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGxpZ2h0ZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWF4KGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBkYXJrZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWluKGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBleGNsdXNpb246ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2IgLSAyLjAgKiAodUNvbG9yLnJnYiAqIGdsX0ZyYWdDb2xvci5yZ2IpO1xcbicsXG4gICAgICBvdmVybGF5OiAnaWYgKHVDb2xvci5yIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5yICo9IDIuMCAqIHVDb2xvci5yO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnIpICogKDEuMCAtIHVDb2xvci5yKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuZyA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuZyAqPSAyLjAgKiB1Q29sb3IuZztcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5nKSAqICgxLjAgLSB1Q29sb3IuZyk7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdpZiAodUNvbG9yLmIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmIgKj0gMi4wICogdUNvbG9yLmI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IuYikgKiAoMS4wIC0gdUNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnfVxcbicsXG4gICAgICB0aW50OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSAoMS4wIC0gdUNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiO1xcbicsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJ1aWxkIHRoZSBmcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBmaWx0ZXJzLCBqb2luaW5nIHRoZSBjb21tb24gcGFydCB3aXRoXG4gICAgICogdGhlIHNwZWNpZmljIG9uZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgbW9kZSBvZiB0aGUgZmlsdGVyLCBhIGtleSBvZiB0aGlzLmZyYWdtZW50U291cmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFNvdXJjZTogZnVuY3Rpb24obW9kZSkge1xuICAgICAgcmV0dXJuICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4nICtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTb3VyY2VbbW9kZV0gK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICd9JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZSwgc2hhZGVyU291cmNlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgc2hhZGVyU291cmNlID0gdGhpcy5idWlsZFNvdXJjZSh0aGlzLm1vZGUpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHRyLCB0ZywgdGIsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UsIGFscGhhMSA9IDEgLSB0aGlzLmFscGhhO1xuXG4gICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgdHIgPSBzb3VyY2VbMF0gKiB0aGlzLmFscGhhO1xuICAgICAgdGcgPSBzb3VyY2VbMV0gKiB0aGlzLmFscGhhO1xuICAgICAgdGIgPSBzb3VyY2VbMl0gKiB0aGlzLmFscGhhO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSAyNTUgLSAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSAoMjU1IC0gZykgKiAoMjU1IC0gdGcpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICsgdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKyB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiArIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgY2FzZSAnZGlmZmVyZW5jZSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5hYnMociAtIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5hYnMoZyAtIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5hYnMoYiAtIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByIC0gdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgLSB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAtIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGFya2VuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1pbihyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWluKGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGlnaHRlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5tYXgociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heChnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyIDwgMTI4ID8gKDIgKiByICogdHIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgPCAxMjggPyAoMiAqIGcgKiB0ZyAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiA8IDEyOCA/ICgyICogYiAqIHRiIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGIpICogKDI1NSAtIHRiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdleGNsdXNpb24nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAtICgoMiAqIHRyICogcikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyArIGcgLSAoKDIgKiB0ZyAqIGcpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiIC0gKCgyICogdGIgKiBiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0aW50JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciArIHIgKiBhbHBoYTE7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiICogYWxwaGExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbG9yJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVswXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMF0gLyAyNTU7XG4gICAgICBzb3VyY2VbMV0gPSB0aGlzLmFscGhhICogc291cmNlWzFdIC8gMjU1O1xuICAgICAgc291cmNlWzJdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVsyXSAvIDI1NTtcbiAgICAgIHNvdXJjZVszXSA9IHRoaXMuYWxwaGE7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yLCBzb3VyY2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvclxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRJbWFnZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3Ioe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZSh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZEltYWdlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRJbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiovXG4gICAgaW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCbGVuZCBtb2RlIGZvciB0aGUgZmlsdGVyIChvbmUgb2YgXCJtdWx0aXBseVwiLCBcIm1hc2tcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGltYWdlIG9wZXJhdGlvbi5cbiAgICAgKiBub3QgaW1wbGVtZW50ZWQuXG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm1NYXRyaXg7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgICAndlRleENvb3JkMiA9ICh1VHJhbnNmb3JtTWF0cml4ICogdmVjMyhhUG9zaXRpb24sIDEuMCkpLnh5O1xcbicgK1xuICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IucmdiYSAqPSBjb2xvcjIucmdiYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIG1hc2s6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLmEgPSBjb2xvcjIuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBsb2FkIHRleHR1cmUgdG8gYmxlbmQuXG4gICAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShvcHRpb25zLmZpbHRlckJhY2tlbmQsIHRoaXMuaW1hZ2UpO1xuICAgICAgdGhpcy5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIHRleHR1cmUsIGdsLlRFWFRVUkUxKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdhcHBseVRvV2ViR0wnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudW5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIGdsLlRFWFRVUkUxKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oYmFja2VuZCwgaW1hZ2UpIHtcbiAgICAgIHJldHVybiBiYWNrZW5kLmdldENhY2hlZFRleHR1cmUoaW1hZ2UuY2FjaGVLZXksIGltYWdlLl9lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtTWF0cml4IHRvIGFkYXB0IHRoZSBpbWFnZSB0byBibGVuZCBvdmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlLl9lbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlLl9lbGVtZW50LmhlaWdodDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDEgLyBpbWFnZS5zY2FsZVgsIDAsIDAsXG4gICAgICAgIDAsIDEgLyBpbWFnZS5zY2FsZVksIDAsXG4gICAgICAgIC1pbWFnZS5sZWZ0IC8gd2lkdGgsIC1pbWFnZS50b3AgLyBoZWlnaHQsIDFcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmxlbmRJbWFnZTtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oaW1hZ2Uuc2NhbGVYLCAwLCAwLCBpbWFnZS5zY2FsZVksIGltYWdlLmxlZnQsIGltYWdlLnRvcCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZS5fZWxlbWVudCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBibGVuZERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgICB0ciA9IGJsZW5kRGF0YVtpXTtcbiAgICAgICAgdGcgPSBibGVuZERhdGFbaSArIDFdO1xuICAgICAgICB0YiA9IGJsZW5kRGF0YVtpICsgMl07XG4gICAgICAgIHRhID0gYmxlbmREYXRhW2kgKyAzXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSBhICogdGEgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VHJhbnNmb3JtTWF0cml4JyksXG4gICAgICAgIHVJbWFnZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW1hZ2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUltYWdlLCAxKTsgLy8gdGV4dHVyZSB1bml0IDEuXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVuaWZvcm1Mb2NhdGlvbnMudVRyYW5zZm9ybU1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGltYWdlOiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UudG9PYmplY3QoKSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdChvYmplY3QuaW1hZ2UsIGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QpO1xuICAgICAgb3B0aW9ucy5pbWFnZSA9IGltYWdlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uob3B0aW9ucykpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLCBwb3cgPSBNYXRoLnBvdywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnMsIHJvdW5kID0gTWF0aC5yb3VuZCwgc2luID0gTWF0aC5zaW4sXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVzaXplIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUmVzaXplID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1Jlc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdHlwZVxuICAgICAqIGZvciB3ZWJnbCByZXNpemVUeXBlIGlzIGp1c3QgbGFuY3pvcywgZm9yIGNhbnZhczJkIGNhbiBiZTpcbiAgICAgKiBiaWxpbmVhciwgaGVybWl0ZSwgc2xpY2VIYWNrLCBsYW5jem9zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXNpemVUeXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXNpemVUeXBlOiAnaGVybWl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBMYW5jem9zTG9iZXMgcGFyYW1ldGVyIGZvciBsYW5jem9zIGZpbHRlciwgdmFsaWQgZm9yIHJlc2l6ZVR5cGUgbGFuY3pvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYW5jem9zTG9iZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxhbmN6b3NMb2JlczogMyxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVEZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgICAgdVRhcHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRhcHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy51RGVsdGEsIHRoaXMuaG9yaXpvbnRhbCA/IFsxIC8gdGhpcy53aWR0aCwgMF0gOiBbMCwgMSAvIHRoaXMuaGVpZ2h0XSk7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudVRhcHMsIHRoaXMudGFwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBmaWx0ZXJXaW5kb3c7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdlbmVyYXRlU2hhZGVyKGZpbHRlcldpbmRvdyk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGdldEZpbHRlcldpbmRvdzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5sYW5jem9zTG9iZXMgLyBzY2FsZSk7XG4gICAgfSxcblxuICAgIGdldFRhcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvYmVGdW5jdGlvbiA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksIHNjYWxlID0gdGhpcy50ZW1wU2NhbGUsXG4gICAgICAgICAgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgdGFwcyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgdGFwc1tpIC0gMV0gPSBsb2JlRnVuY3Rpb24oaSAqIHNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB2ZXJ0ZXggYW5kIHNoYWRlciBzb3VyY2VzIGZyb20gdGhlIG5lY2Vzc2FyeSBzdGVwcyBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlcldpbmRvd1xuICAgICAqL1xuICAgIGdlbmVyYXRlU2hhZGVyOiBmdW5jdGlvbihmaWx0ZXJXaW5kb3cpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyksXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U291cmNlVE9QLCBmaWx0ZXJXaW5kb3c7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaSAtIDFdID0gaSArICcuMCAqIHVEZWx0YSc7XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd1bmlmb3JtIGZsb2F0IHVUYXBzWycgKyBmaWx0ZXJXaW5kb3cgKyAnXTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3ZvaWQgbWFpbigpIHtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZmxvYXQgc3VtID0gMS4wO1xcbic7XG5cbiAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbihvZmZzZXQsIGkpIHtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkIC0gJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBzdW0gKz0gMi4wICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHN1bTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ30nO1xuICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgIH0sXG5cbiAgICBmcmFnbWVudFNvdXJjZVRPUDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXNpemUgZmlsdGVyIHRvIHRoZSBpbWFnZVxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kVyA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHRoaXMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5kSCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZFcgLyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoID0gdGhpcy5kVztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcblxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kSCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kSCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCA9IHRoaXMuZEg7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlSGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxO1xuICAgIH0sXG5cbiAgICBsYW5jem9zQ3JlYXRlOiBmdW5jdGlvbihsb2Jlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPj0gbG9iZXMgfHwgeCA8PSAtbG9iZXMpIHtcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcgJiYgeCA+IC0xLjE5MjA5MjkwRS0wNykge1xuICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgeCAqPSBNYXRoLlBJO1xuICAgICAgICB2YXIgeHggPSB4IC8gbG9iZXM7XG4gICAgICAgIHJldHVybiAoc2luKHgpIC8geCkgKiBzaW4oeHgpIC8geHg7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cbiAgICAgIHRoaXMucmNwU2NhbGVYID0gMSAvIHNjYWxlWDtcbiAgICAgIHRoaXMucmNwU2NhbGVZID0gMSAvIHNjYWxlWTtcblxuICAgICAgdmFyIG9XID0gaW1hZ2VEYXRhLndpZHRoLCBvSCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgZFcgPSByb3VuZChvVyAqIHNjYWxlWCksIGRIID0gcm91bmQob0ggKiBzY2FsZVkpLFxuICAgICAgICAgIG5ld0RhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdzbGljZUhhY2snKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLnNsaWNlQnlUd28ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnaGVybWl0ZScpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnYmlsaW5lYXInKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmJpbGluZWFyRmlsdGVyaW5nKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2xhbmN6b3MnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmxhbmN6b3NSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBuZXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgc2xpY2VCeVR3b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgc2xpY2VCeVR3bzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBtdWx0ID0gMC41LCBkb25lVyA9IGZhbHNlLCBkb25lSCA9IGZhbHNlLCBzdGVwVyA9IG9XICogbXVsdCxcbiAgICAgICAgICBzdGVwSCA9IG9IICogbXVsdCwgcmVzb3VyY2VzID0gZmFicmljLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIHRtcENhbnZhcywgY3R4LCBzWCA9IDAsIHNZID0gMCwgZFggPSBvVywgZFkgPSAwO1xuICAgICAgaWYgKCFyZXNvdXJjZXMuc2xpY2VCeVR3bykge1xuICAgICAgICByZXNvdXJjZXMuc2xpY2VCeVR3byA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gcmVzb3VyY2VzLnNsaWNlQnlUd287XG4gICAgICBpZiAodG1wQ2FudmFzLndpZHRoIDwgb1cgKiAxLjUgfHwgdG1wQ2FudmFzLmhlaWdodCA8IG9IKSB7XG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IG9XICogMS41O1xuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gb0g7XG4gICAgICB9XG4gICAgICBjdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb1cgKiAxLjUsIG9IKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgZFcgPSBmbG9vcihkVyk7XG4gICAgICBkSCA9IGZsb29yKGRIKTtcblxuICAgICAgd2hpbGUgKCFkb25lVyB8fCAhZG9uZUgpIHtcbiAgICAgICAgb1cgPSBzdGVwVztcbiAgICAgICAgb0ggPSBzdGVwSDtcbiAgICAgICAgaWYgKGRXIDwgZmxvb3Ioc3RlcFcgKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBXID0gZmxvb3Ioc3RlcFcgKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwVyA9IGRXO1xuICAgICAgICAgIGRvbmVXID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZEggPCBmbG9vcihzdGVwSCAqIG11bHQpKSB7XG4gICAgICAgICAgc3RlcEggPSBmbG9vcihzdGVwSCAqIG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBIID0gZEg7XG4gICAgICAgICAgZG9uZUggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCBzWCwgc1ksIG9XLCBvSCwgZFgsIGRZLCBzdGVwVywgc3RlcEgpO1xuICAgICAgICBzWCA9IGRYO1xuICAgICAgICBzWSA9IGRZO1xuICAgICAgICBkWSArPSBzdGVwSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKHNYLCBzWSwgZFcsIGRIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGxhbmN6b3NSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGxhbmN6b3NSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3ModSkge1xuICAgICAgICB2YXIgdiwgaSwgd2VpZ2h0LCBpZHgsIGEsIHJlZCwgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLCBhbHBoYSwgZlgsIGZZO1xuICAgICAgICBjZW50ZXIueCA9ICh1ICsgMC41KSAqIHJhdGlvWDtcbiAgICAgICAgaWNlbnRlci54ID0gZmxvb3IoY2VudGVyLngpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZEg7IHYrKykge1xuICAgICAgICAgIGNlbnRlci55ID0gKHYgKyAwLjUpICogcmF0aW9ZO1xuICAgICAgICAgIGljZW50ZXIueSA9IGZsb29yKGNlbnRlci55KTtcbiAgICAgICAgICBhID0gMDsgcmVkID0gMDsgZ3JlZW4gPSAwOyBibHVlID0gMDsgYWxwaGEgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IGljZW50ZXIueCAtIHJhbmdlMlg7IGkgPD0gaWNlbnRlci54ICsgcmFuZ2UyWDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBvVykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZYID0gZmxvb3IoMTAwMCAqIGFicyhpIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXSkge1xuICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdID0geyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGljZW50ZXIueSAtIHJhbmdlMlk7IGogPD0gaWNlbnRlci55ICsgcmFuZ2UyWTsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IG9IKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZlkgPSBmbG9vcigxMDAwICogYWJzKGogLSBjZW50ZXIueSkpO1xuICAgICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF1bZlldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXVtmWV0gPSBsYW5jem9zKHNxcnQocG93KGZYICogcmNwUmF0aW9YLCAyKSArIHBvdyhmWSAqIHJjcFJhdGlvWSwgMikpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2VpZ2h0ID0gY2FjaGVMYW5jW2ZYXVtmWV07XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGogKiBvVyArIGkpICogNDtcbiAgICAgICAgICAgICAgICBhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICByZWQgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHhdO1xuICAgICAgICAgICAgICAgIGdyZWVuICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgYmx1ZSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIGFscGhhICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4ID0gKHYgKiBkVyArIHUpICogNDtcbiAgICAgICAgICBkZXN0RGF0YVtpZHhdID0gcmVkIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAxXSA9IGdyZWVuIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAyXSA9IGJsdWUgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDNdID0gYWxwaGEgLyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrdSA8IGRXKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3ModSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3RJbWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0RhdGEgPSBvcHRpb25zLmltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGRlc3RJbWcgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0RGF0YSA9IGRlc3RJbWcuZGF0YSxcbiAgICAgICAgICBsYW5jem9zID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSxcbiAgICAgICAgICByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmNwUmF0aW9YID0gMiAvIHRoaXMucmNwU2NhbGVYLCByY3BSYXRpb1kgPSAyIC8gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmFuZ2UyWCA9IGNlaWwocmF0aW9YICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICByYW5nZTJZID0gY2VpbChyYXRpb1kgKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIGNhY2hlTGFuYyA9IHsgfSwgY2VudGVyID0geyB9LCBpY2VudGVyID0geyB9O1xuXG4gICAgICByZXR1cm4gcHJvY2VzcygwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmlsaW5lYXJGaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGJpbGluZWFyRmlsdGVyaW5nOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGEsIGIsIGMsIGQsIHgsIHksIGksIGosIHhEaWZmLCB5RGlmZiwgY2hubCxcbiAgICAgICAgICBjb2xvciwgb2Zmc2V0ID0gMCwgb3JpZ1BpeCwgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsXG4gICAgICAgICAgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgdzQgPSA0ICogKG9XIC0gMSksIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHBpeGVscyA9IGltZy5kYXRhLCBkZXN0SW1hZ2UgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0UGl4ZWxzID0gZGVzdEltYWdlLmRhdGE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZEg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZFc7IGorKykge1xuICAgICAgICAgIHggPSBmbG9vcihyYXRpb1ggKiBqKTtcbiAgICAgICAgICB5ID0gZmxvb3IocmF0aW9ZICogaSk7XG4gICAgICAgICAgeERpZmYgPSByYXRpb1ggKiBqIC0geDtcbiAgICAgICAgICB5RGlmZiA9IHJhdGlvWSAqIGkgLSB5O1xuICAgICAgICAgIG9yaWdQaXggPSA0ICogKHkgKiBvVyArIHgpO1xuXG4gICAgICAgICAgZm9yIChjaG5sID0gMDsgY2hubCA8IDQ7IGNobmwrKykge1xuICAgICAgICAgICAgYSA9IHBpeGVsc1tvcmlnUGl4ICsgY2hubF07XG4gICAgICAgICAgICBiID0gcGl4ZWxzW29yaWdQaXggKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIGNobmxdO1xuICAgICAgICAgICAgZCA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjb2xvciA9IGEgKiAoMSAtIHhEaWZmKSAqICgxIC0geURpZmYpICsgYiAqIHhEaWZmICogKDEgLSB5RGlmZikgK1xuICAgICAgICAgICAgICAgICAgICBjICogeURpZmYgKiAoMSAtIHhEaWZmKSArIGQgKiB4RGlmZiAqIHlEaWZmO1xuICAgICAgICAgICAgZGVzdFBpeGVsc1tvZmZzZXQrK10gPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0SW1hZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlcm1pdGVGYXN0UmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBoZXJtaXRlRmFzdFJlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciByYXRpb1cgPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9IID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmF0aW9XSGFsZiA9IGNlaWwocmF0aW9XIC8gMiksXG4gICAgICAgICAgcmF0aW9ISGFsZiA9IGNlaWwocmF0aW9IIC8gMiksXG4gICAgICAgICAgaW1nID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWcuZGF0YSxcbiAgICAgICAgICBpbWcyID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksIGRhdGEyID0gaW1nMi5kYXRhO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkSDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZFc7IGkrKykge1xuICAgICAgICAgIHZhciB4MiA9IChpICsgaiAqIGRXKSAqIDQsIHdlaWdodCA9IDAsIHdlaWdodHMgPSAwLCB3ZWlnaHRzQWxwaGEgPSAwLFxuICAgICAgICAgICAgICBneFIgPSAwLCBneEcgPSAwLCBneEIgPSAwLCBneEEgPSAwLCBjZW50ZXJZID0gKGogKyAwLjUpICogcmF0aW9IO1xuICAgICAgICAgIGZvciAodmFyIHl5ID0gZmxvb3IoaiAqIHJhdGlvSCk7IHl5IDwgKGogKyAxKSAqIHJhdGlvSDsgeXkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSEhhbGYsXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IChpICsgMC41KSAqIHJhdGlvVywgdzAgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yICh2YXIgeHggPSBmbG9vcihpICogcmF0aW9XKTsgeHggPCAoaSArIDEpICogcmF0aW9XOyB4eCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dIYWxmLFxuICAgICAgICAgICAgICAgICAgdyA9IHNxcnQodzAgKyBkeCAqIGR4KTtcbiAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICAgIGlmICh3ID4gMSAmJiB3IDwgLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2hlcm1pdGUgZmlsdGVyXG4gICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGR4ID0gNCAqICh4eCArIHl5ICogb1cpO1xuICAgICAgICAgICAgICAgIC8vYWxwaGFcbiAgICAgICAgICAgICAgICBneEEgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgIHdlaWdodHNBbHBoYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtkeCArIDNdIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM10gLyAyNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd4UiArPSB3ZWlnaHQgKiBkYXRhW2R4XTtcbiAgICAgICAgICAgICAgICBneEcgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDFdO1xuICAgICAgICAgICAgICAgIGd4QiArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMl07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YTJbeDJdID0gZ3hSIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDFdID0gZ3hHIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDJdID0gZ3hCIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDNdID0gZ3hBIC8gd2VpZ2h0c0FscGhhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgcmVzaXplVHlwZTogdGhpcy5yZXNpemVUeXBlLFxuICAgICAgICBsYW5jem9zTG9iZXM6IHRoaXMubGFuY3pvc0xvYmVzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb250cmFzdCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCh7XG4gICAqICAgY29udHJhc3Q6IDAuMjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db250cmFzdCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbnRyYXN0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUNvbnRyYXN0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGNvbnRyYXN0RiA9IDEuMDE1ICogKHVDb250cmFzdCArIDEuMCkgLyAoMS4wICogKDEuMDE1IC0gdUNvbnRyYXN0KSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgPSBjb250cmFzdEYgKiAoY29sb3IucmdiIC0gMC41KSArIDAuNTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogY29udHJhc3QgdmFsdWUsIHJhbmdlIGZyb20gLTEgdG8gMS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgY29udHJhc3Q6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnY29udHJhc3QnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wXSBWYWx1ZSB0byBjb250cmFzdCB0aGUgaW1hZ2UgdXAgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAgKiBBcHBseSB0aGUgQ29udHJhc3Qgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRyYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSwgaSwgbGVuLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgY29udHJhc3QgPSBNYXRoLmZsb29yKHRoaXMuY29udHJhc3QgKiAyNTUpLFxuICAgICAgICAgIGNvbnRyYXN0RiA9IDI1OSAqIChjb250cmFzdCArIDI1NSkgLyAoMjU1ICogKDI1OSAtIGNvbnRyYXN0KSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gY29udHJhc3RGICogKGRhdGFbaV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAxXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDJdID0gY29udHJhc3RGICogKGRhdGFbaSArIDJdIC0gMTI4KSArIDEyODtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb250cmFzdDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29udHJhc3QnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVDb250cmFzdCwgdGhpcy5jb250cmFzdCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTYXR1cmF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbih7XG4gICAqICAgc2F0dXJhdGlvbjogMVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlNhdHVyYXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1NhdHVyYXRpb24nLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ01heCA9IG1heChjb2xvci5yLCBjb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnYk1heCA9IG1heChyZ01heCwgY29sb3IuYik7XFxuJyArXG4gICAgICAgICdjb2xvci5yICs9IHJnYk1heCAhPSBjb2xvci5yID8gKHJnYk1heCAtIGNvbG9yLnIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSByZ2JNYXggIT0gY29sb3IuZyA/IChyZ2JNYXggLSBjb2xvci5nKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gcmdiTWF4ICE9IGNvbG9yLmIgPyAocmdiTWF4IC0gY29sb3IuYikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIFNhdHVyYXRpb24gdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiBJbmNyZWFzZXMvZGVjcmVhc2VzIHRoZSBjb2xvciBzYXR1cmF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgMCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzYXR1cmF0aW9uOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3NhdHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0ZT0wXSBWYWx1ZSB0byBzYXR1cmF0ZSB0aGUgaW1hZ2UgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBTYXR1cmF0aW9uIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhZGp1c3QgPSAtdGhpcy5zYXR1cmF0aW9uLCBpLCBtYXg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVNhdHVyYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhdHVyYXRpb24nKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTYXR1cmF0aW9uLCAtdGhpcy5zYXR1cmF0aW9uKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBWaWJyYW5jZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZSh7XG4gICAqICAgdmlicmFuY2U6IDFcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5WaWJyYW5jZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1ZpYnJhbmNlJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVZpYnJhbmNlO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG1heCA9IG1heChjb2xvci5yLCBtYXgoY29sb3IuZywgY29sb3IuYikpO1xcbicgK1xuICAgICAgICAnZmxvYXQgYXZnID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxuJyArXG4gICAgICAgICdmbG9hdCBhbXQgPSAoYWJzKG1heCAtIGF2ZykgKiAyLjApICogdVZpYnJhbmNlO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSBtYXggIT0gY29sb3IuciA/IChtYXggLSBjb2xvci5yKSAqIGFtdCA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5nICs9IG1heCAhPSBjb2xvci5nID8gKG1heCAtIGNvbG9yLmcpICogYW10IDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gbWF4ICE9IGNvbG9yLmIgPyAobWF4IC0gY29sb3IuYikgKiBhbXQgOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBWaWJyYW5jZSB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIEluY3JlYXNlcy9kZWNyZWFzZXMgdGhlIHNhdHVyYXRpb24gb2YgbW9yZSBtdXRlZCBjb2xvcnMgd2l0aCBsZXNzIGVmZmVjdCBvbiBzYXR1cmF0ZWQgY29sb3JzLlxuICAgICAqIEEgdmFsdWUgb2YgMCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2aWJyYW5jZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlicmFuY2U6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAndmlicmFuY2UnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWJyYW5jZT0wXSBWaWJyYW5jZSB2YWx1ZSBmb3IgdGhlIGltYWdlIChiZXR3ZWVuIC0xIGFuZCAxKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFZpYnJhbmNlIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMudmlicmFuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRqdXN0ID0gLXRoaXMudmlicmFuY2UsIGksIG1heCwgYXZnLCBhbXQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBhdmcgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgYW10ID0gKChNYXRoLmFicyhtYXggLSBhdmcpICogMiAvIDI1NSkgKiBhZGp1c3QpO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFtdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYW10IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhbXQgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVZpYnJhbmNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VWaWJyYW5jZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVZpYnJhbmNlLCAtdGhpcy52aWJyYW5jZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCbHVyIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1clxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyKHtcbiAgICogICBibHVyOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJsdXIgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ci5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0JsdXInLFxuXG4gICAgLypcbidnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC03ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC02ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0xICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICAgICAgICAgICAgICApKjAuMTU5NTc2OTEyMTYxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAxICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA1ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnY29uc3QgZmxvYXQgblNhbXBsZXMgPSAxNS4wO1xcbicgK1xuICAgICAgJ3ZlYzMgdjNvZmZzZXQgPSB2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlKSB7XFxuJyArXG4gICAgICAgIC8qIHVzZSB0aGUgZnJhZ21lbnQgcG9zaXRpb24gZm9yIGEgZGlmZmVyZW50IHNlZWQgcGVyLXBpeGVsICovXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6LCBzY2FsZSkpICogNDM3NTguNTQ1Myk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuJyArXG4gICAgICAgICdmbG9hdCB0b3RhbCA9IDAuMDtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG9mZnNldCA9IHJhbmRvbSh2M29mZnNldCk7XFxuJyArXG4gICAgICAgICdmb3IgKGZsb2F0IHQgPSAtblNhbXBsZXM7IHQgPD0gblNhbXBsZXM7IHQrKykge1xcbicgK1xuICAgICAgICAgICdmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gblNhbXBsZXM7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4nICtcbiAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyB1RGVsdGEgKiBwZXJjZW50KSAqIHdlaWdodDtcXG4nICtcbiAgICAgICAgICAndG90YWwgKz0gd2VpZ2h0O1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4nICtcbiAgICAgICd9JyxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgIC8qKlxuICAgICAqIGJsdXIgdmFsdWUsIGluIHBlcmNlbnRhZ2Ugb2YgaW1hZ2UgZGltZW5zaW9ucy5cbiAgICAgKiBzcGVjaWZpYyB0byBrZWVwIHRoZSBpbWFnZSBibHVyIGNvbnN0YW50IGF0IGRpZmZlcmVudCByZXNvbHV0aW9uc1xuICAgICAqIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmx1cicsXG5cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICAvLyB0aGlzIGFzcGVjdFJhdGlvIGlzIHVzZWQgdG8gZ2l2ZSB0aGUgc2FtZSBibHVyIHRvIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsXG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBvcHRpb25zLnNvdXJjZVdpZHRoIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIHBhaW50IGNhbnZhc0VsIHdpdGggY3VycmVudCBpbWFnZSBkYXRhLlxuICAgICAgLy9vcHRpb25zLmN0eC5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSB0aGlzLnNpbXBsZUJsdXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHNpbXBsZUJsdXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLCBjYW52YXMxLCBjYW52YXMyLFxuICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5pbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5pbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICBpZiAoIXJlc291cmNlcy5ibHVyTGF5ZXIxKSB7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIxID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmx1ckxheWVyMTtcbiAgICAgIGNhbnZhczIgPSByZXNvdXJjZXMuYmx1ckxheWVyMjtcbiAgICAgIGlmIChjYW52YXMxLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMxLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhczIud2lkdGggPSBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczIuaGVpZ2h0ID0gY2FudmFzMS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgY3R4MSA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBjdHgyID0gY2FudmFzMi5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIG5TYW1wbGVzID0gMTUsXG4gICAgICAgICAgcmFuZG9tLCBwZXJjZW50LCBqLCBpLFxuICAgICAgICAgIGJsdXIgPSB0aGlzLmJsdXIgKiAwLjA2ICogMC41O1xuXG4gICAgICAvLyBsb2FkIGZpcnN0IGNhbnZhc1xuICAgICAgY3R4MS5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIHdpZHRoICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCBqLCByYW5kb20pO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIGhlaWdodCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgcmFuZG9tLCBqKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmN0eC5kcmF3SW1hZ2UoY2FudmFzMSwgMCwgMCk7XG4gICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gb3B0aW9ucy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIGN0eDEuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4MS5jbGVhclJlY3QoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5jaG9vc2VSaWdodERlbHRhKCk7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMuZGVsdGEsIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2hvb3NlIHJpZ2h0IHZhbHVlIG9mIGltYWdlIHBlcmNlbnRhZ2UgdG8gYmx1ciB3aXRoXG4gICAgICogQHJldHVybnMge0FycmF5fSBhIG51bWVyaWMgYXJyYXkgd2l0aCBkZWx0YSB2YWx1ZXNcbiAgICAgKi9cbiAgICBjaG9vc2VSaWdodERlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibHVyU2NhbGUgPSAxLCBkZWx0YSA9IFswLCAwXSwgYmx1cjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPiAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgd2lkZSwgaSB3YW50IHRvIHNocmluayByYWRpdXMgaG9yaXpvbnRhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IDEgLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPCAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgdGFsbCwgaSB3YW50IHRvIHNocmluayByYWRpdXMgdmVydGljYWxcbiAgICAgICAgICBibHVyU2NhbGUgPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBibHVyID0gYmx1clNjYWxlICogdGhpcy5ibHVyICogMC4xMjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgZGVsdGFbMF0gPSBibHVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbHRhWzFdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBCbHVyRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZpbHRlcnMuQmx1ci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR2FtbWEgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEoe1xuICAgKiAgIGdhbW1hOiBbMSwgMC41LCAyLjFdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuR2FtbWEgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHYW1tYScsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzMgdUdhbW1hO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ3ZlYzMgY29ycmVjdGlvbiA9ICgxLjAgLyB1R2FtbWEpO1xcbicgK1xuICAgICAgICAnY29sb3IuciA9IHBvdyhjb2xvci5yLCBjb3JyZWN0aW9uLnIpO1xcbicgK1xuICAgICAgICAnY29sb3IuZyA9IHBvdyhjb2xvci5nLCBjb3JyZWN0aW9uLmcpO1xcbicgK1xuICAgICAgICAnY29sb3IuYiA9IHBvdyhjb2xvci5iLCBjb3JyZWN0aW9uLmIpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yLmE7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBHYW1tYSBhcnJheSB2YWx1ZSwgZnJvbSAwLjAxIHRvIDIuMi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBnYW1tYVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2FtbWE6IFsxLCAxLCAxXSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdnYW1tYScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmdhbW1hID0gWzEsIDEsIDFdO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHYW1tYSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBnYW1tYSA9IHRoaXMuZ2FtbWEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHJJbnYgPSAxIC8gZ2FtbWFbMF0sIGdJbnYgPSAxIC8gZ2FtbWFbMV0sXG4gICAgICAgICAgYkludiA9IDEgLyBnYW1tYVsyXSwgaTtcblxuICAgICAgaWYgKCF0aGlzLnJWYWxzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuZ1ZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5iVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gcHJlLWNvbXB1dGUgYSBsb29rLXVwIHRhYmxlIGZvciBlYWNoIGNvbG9yIGNoYW5uZWxcbiAgICAgIC8vIGluc3RlYWQgb2YgcGVyZm9ybWluZyB0aGVzZSBwb3cgY2FsbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGltYWdlLlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gMjU2OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5yVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIHJJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmdWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgZ0ludikgKiAyNTU7XG4gICAgICAgIHRoaXMuYlZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBiSW52KSAqIDI1NTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IHRoaXMuclZhbHNbZGF0YVtpXV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gdGhpcy5nVmFsc1tkYXRhW2kgKyAxXV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gdGhpcy5iVmFsc1tkYXRhW2kgKyAyXV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1R2FtbWE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUdhbW1hJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbnMudUdhbW1hLCB0aGlzLmdhbW1hKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEEgY29udGFpbmVyIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIGFwcGx5IGEgc2VxdWVuY2Ugb2YgZmlsdGVycyB0byBhbiBpbnB1dCBpbWFnZS5cbiAgICovXG4gIGZpbHRlcnMuQ29tcG9zZWQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdDb21wb3NlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG5vbiBzcGFyc2UgYXJyYXkgb2YgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIHN1YkZpbHRlcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLnN1YkZpbHRlcnMgPSB0aGlzLnN1YkZpbHRlcnMuc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgY29udGFpbmVyJ3MgZmlsdGVycyB0byB0aGUgaW5wdXQgaW1hZ2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5wYXNzZXMgKz0gdGhpcy5zdWJGaWx0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnN1YkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyLmFwcGx5VG8ob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgZmlsdGVyIGludG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpbHRlci5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLnRvT2JqZWN0KCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zdWJGaWx0ZXJzLnNvbWUoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQ29tcG9zZWRGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVycyA9IG9iamVjdC5zdWJGaWx0ZXJzIHx8IFtdLFxuICAgICAgICBzdWJGaWx0ZXJzID0gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tmaWx0ZXIudHlwZV0oZmlsdGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkKHsgc3ViRmlsdGVyczogc3ViRmlsdGVycyB9KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEh1ZVJvdGF0aW9uIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uKHtcbiAgICogICByb3RhdGlvbjogLTAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkh1ZVJvdGF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0h1ZVJvdGF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdGhlIHVuaXQgaXMgcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBteVBhcmFtZXRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAncm90YXRpb24nLFxuXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgY29zID0gZmFicmljLnV0aWwuY29zKHJhZCksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWQpLFxuICAgICAgICAgIGFUaGlyZCA9IDEgLyAzLCBhVGhpcmRTcXRTaW4gPSBNYXRoLnNxcnQoYVRoaXJkKSAqIHNpbiwgT25lTWludXNDb3MgPSAxIC0gY29zO1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF07XG4gICAgICB0aGlzLm1hdHJpeFswXSA9IGNvcyArIE9uZU1pbnVzQ29zIC8gMztcbiAgICAgIHRoaXMubWF0cml4WzFdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsyXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzZdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgICB0aGlzLm1hdHJpeFs3XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTBdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEyXSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIHJldHVybiBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmlzTmV1dHJhbFN0YXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmFwcGx5VG8uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBpZiAoZmFicmljLlRleHQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRleHQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFkZGl0aW9uYWxQcm9wcyA9XG4gICAgKCdmb250RmFtaWx5IGZvbnRXZWlnaHQgZm9udFNpemUgdGV4dCB1bmRlcmxpbmUgb3ZlcmxpbmUgbGluZXRocm91Z2gnICtcbiAgICAnIHRleHRBbGlnbiBmb250U3R5bGUgbGluZUhlaWdodCB0ZXh0QmFja2dyb3VuZENvbG9yIGNoYXJTcGFjaW5nIHN0eWxlcycgK1xuICAgICcgZGlyZWN0aW9uIHBhdGggcGF0aFN0YXJ0T2Zmc2V0IHBhdGhTaWRlIHBhdGhBbGlnbicpLnNwbGl0KCcgJyk7XG5cbiAgLyoqXG4gICAqIFRleHQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjdGV4dH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBbXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dCcsXG4gICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAnc3R5bGVzJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdwYXRoU3RhcnRPZmZzZXQnLFxuICAgICAgJ3BhdGhTaWRlJyxcbiAgICAgICdwYXRoQWxpZ24nXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZXMgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZXNBbmRUYWJzOiAvWyBcXHRcXHJdL2csXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VBbmRUYWI6IC9bIFxcdFxccl0vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBjb25zZWN1dGl2ZSBncm91cHMgb2Ygbm9uIHNwYWNlcy5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVXb3JkczogL1xcUysvZyxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgJ3RleHQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U2l6ZTogICAgICAgICAgICAgNDAsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHdlaWdodCAoZS5nLiBib2xkLCBub3JtYWwsIDQwMCwgNjAwLCA4MDApXG4gICAgICogQHR5cGUgeyhOdW1iZXJ8U3RyaW5nKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRXZWlnaHQ6ICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgZmFtaWx5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250RmFtaWx5OiAgICAgICAgICAgJ1RpbWVzIE5ldyBSb21hbicsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gdW5kZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIGxpbmV0aHJvdWdoLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmV0aHJvdWdoOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IFwibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIsIFwianVzdGlmeVwiLFxuICAgICAqIFwianVzdGlmeS1sZWZ0XCIsIFwianVzdGlmeS1jZW50ZXJcIiBvciBcImp1c3RpZnktcmlnaHRcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogU3VwZXJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdXBlcnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAtMC4zNSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yICh1cHdhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogIDAuMTEgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAoZG93bndhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRleHQgbGluZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICAnJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KGFkZGl0aW9uYWxQcm9wcyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoYWRkaXRpb25hbFByb3BzKSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvci5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInN0cm9rZVN0eWxlXCIgdW50aWwgdjEuMS42XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwidGV4dFNoYWRvd1wiIChTdHJpbmcpIHVudGlsIHYxLjIuMTFcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZhYnJpYy5QYXRoIHRoYXQgdGhlIHRleHQgc2hvdWxkIGZvbGxvdy5cbiAgICAgKiBzaW5jZSA0LjYuMCB0aGUgcGF0aCB3aWxsIGJlIGRyYXduIGF1dG9tYXRpY2FsbHkuXG4gICAgICogaWYgeW91IHdhbnQgdG8gbWFrZSB0aGUgcGF0aCB2aXNpYmxlLCBnaXZlIGl0IGEgc3Ryb2tlIGFuZCBzdHJva2VXaWR0aCBvciBmaWxsIHZhbHVlXG4gICAgICogaWYgeW91IHdhbnQgaXQgdG8gYmUgaGlkZGVuLCBhc3NpZ24gdmlzaWJsZSA9IGZhbHNlIHRvIHRoZSBwYXRoLlxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCRVRBLCBhbmQgU1ZHIGltcG9ydC9leHBvcnQgaXMgbm90IHlldCBzdXBwb3J0ZWQuXG4gICAgICogQHR5cGUgZmFicmljLlBhdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ZXh0UGF0aCA9IG5ldyBmYWJyaWMuVGV4dCgnVGV4dCBvbiBhIHBhdGgnLCB7XG4gICAgICogICAgIHRvcDogMTUwLFxuICAgICAqICAgICBsZWZ0OiAxNTAsXG4gICAgICogICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICogICAgIGNoYXJTcGFjaW5nOiAtNTAsXG4gICAgICogICAgIHBhdGg6IG5ldyBmYWJyaWMuUGF0aCgnTSAwIDAgQyA1MCAtMTAwIDE1MCAtMTAwIDIwMCAwJywge1xuICAgICAqICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICogICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAqICAgICB9KSxcbiAgICAgKiAgICAgcGF0aFNpZGU6ICdsZWZ0JyxcbiAgICAgKiAgICAgcGF0aFN0YXJ0T2Zmc2V0OiAwXG4gICAgICogfSk7XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgYW1vdW50IGZvciB0ZXh0IHBhdGggc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgKiBPbmx5IHVzZWQgd2hlbiB0ZXh0IGhhcyBhIHBhdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGhTdGFydE9mZnNldDogICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hpY2ggc2lkZSBvZiB0aGUgcGF0aCB0aGUgdGV4dCBzaG91bGQgYmUgZHJhd24gb24uXG4gICAgICogT25seSB1c2VkIHdoZW4gdGV4dCBoYXMgYSBwYXRoXG4gICAgICogQHR5cGUge1N0cmluZ30gJ2xlZnR8cmlnaHQnXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoU2lkZTogICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwYXRoLiBUaGlzIHByb3BlcnR5IGRldGVybWluZXNcbiAgICAgKiB0aGUgcGVycGVuZGljdWxhciBwb3NpdGlvbiBvZiBlYWNoIGNoYXJhY3RlciByZWxhdGl2ZSB0byB0aGUgcGF0aC5cbiAgICAgKiAob25lIG9mIFwiYmFzZWxpbmVcIiwgXCJjZW50ZXJcIiwgXCJhc2NlbmRlclwiLCBcImRlc2NlbmRlclwiKVxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCRVRBLCBhbmQgaXRzIGJlaGF2aW9yIG1heSBjaGFuZ2VcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGhBbGlnbjogICAgICAgICAgICAgICAnYmFzZWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9udFNpemVGcmFjdGlvbjogMC4yMjIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9mZnNldHM6IHtcbiAgICAgIHVuZGVybGluZTogMC4xMCxcbiAgICAgIGxpbmV0aHJvdWdoOiAtMC4zMTUsXG4gICAgICBvdmVybGluZTogLTAuODhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBMaW5lIHByb3BvcnRpb24gdG8gZm9udCBTaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfZm9udFNpemVNdWx0OiAgICAgICAgICAgICAxLjEzLFxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlcnNcbiAgICAgKiBleHByZXNzZWQgaW4gdGhvdXNhbmRzIG9mIGVtIHVuaXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNoYXJTcGFjaW5nOiAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGNvbnRhaW5pbmcgY2hhcmFjdGVyIHN0eWxlcyAtIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIC0+IGxpbmUgbnVtYmVycyxcbiAgICAgKiAybmQtbGV2ZWwgcHJvcGVydGllcyAtIGNoYXJhY3RlciBudW1iZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYSBjb250ZXh0IHRvIG1lYXN1cmUgdGV4dCBjaGFyIG9yIGNvdXBsZSBvZiBjaGFyc1xuICAgICAqIHRoZSBjYWNoZUNvbnRleHQgb2YgdGhlIGNhbnZhcyB3aWxsIGJlIHVzZWQgb3IgYSBmcmVzaGx5IGNyZWF0ZWQgb25lIGlmIHRoZSBvYmplY3QgaXMgbm90IG9uIGNhbnZhc1xuICAgICAqIG9uY2UgY3JlYXRlZCBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgb24gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0IHRvIGF2b2lkIGNyZWF0aW5nIGEgY2FudmFzIGZvciBldmVyeVxuICAgICAqIHRleHQgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9tZWFzdXJpbmdDb250ZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQmFzZWxpbmUgc2hpZnQsIHN0eWxlcyBvbmx5LCBrZWVwIGF0IDAgZm9yIHRoZSBtYWluIHRleHQgb2JqZWN0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlbHRhWTogMCxcblxuICAgIC8qKlxuICAgICAqIFdBUk5JTkc6IEVYUEVSSU1FTlRBTC4gTk9UIFNVUFBPUlRFRCBZRVRcbiAgICAgKiBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdGV4dC5cbiAgICAgKiBUaGlzIGhhcyB0byBiZSBzZXQgbWFudWFsbHkgdG9nZXRoZXIgd2l0aCB0ZXh0QWxpZ24gYW5kIG9yaWdpblggZm9yIHByb3BlclxuICAgICAqIGV4cGVyaWVuY2UuXG4gICAgICogc29tZSBpbnRlcmVzdGluZyBsaW5rIGZvciB0aGUgZnV0dXJlXG4gICAgICogaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9sc1xuICAgICAqIEBzaW5jZSA0LjUuMFxuICAgICAqIEB0eXBlIHtTdHJpbmd9ICdsdHJ8cnRsJ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBzdHlsZSB1bml0IChvZiAnc3R5bGVzJykuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX3N0eWxlUHJvcGVydGllczogW1xuICAgICAgJ3N0cm9rZScsXG4gICAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ3VuZGVybGluZScsXG4gICAgICAnb3ZlcmxpbmUnLFxuICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICdkZWx0YVknLFxuICAgICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyBjaGFyYWN0ZXJzIGJvdW5kaW5nIGJveGVzXG4gICAgICovXG4gICAgX19jaGFyQm91bmRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHVzZSB0aGlzIHNpemUgd2hlbiBtZWFzdXJpbmcgdGV4dC4gVG8gYXZvaWQgSUUxMSByb3VuZGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDQUNIRV9GT05UX1NJWkU6IDQwMCxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIHRoZSBtaW4gdGV4dCB3aWR0aCB0byBhdm9pZCBnZXR0aW5nIDBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgTUlOX1RFWFRfV0lEVEg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zdHlsZXMgPSBvcHRpb25zID8gKG9wdGlvbnMuc3R5bGVzIHx8IHsgfSkgOiB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRleHQgaGFzIGEgcGF0aCwgaXQgd2lsbCBhZGQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIG5lZWRlZFxuICAgICAqIGZvciBwYXRoIGFuZCB0ZXh0IGNhbGN1bGF0aW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0UGF0aEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLnNlZ21lbnRzSW5mbyA9IGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8ocGF0aC5wYXRoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29udGV4dCBmb3IgbWVhc3VyZW1lbnQgb2YgdGV4dCBzdHJpbmcuXG4gICAgICogaWYgY3JlYXRlZCBpdCBnZXRzIHN0b3JlZCBmb3IgcmV1c2VcbiAgICAgKiB0aGlzIGlzIGZvciBpbnRlcm5hbCB1c2UsIHBsZWFzZSBkbyBub3QgdXNlIGl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGdldE1lYXN1cmluZ0NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCByZXR1cm4gd2UgaGF2ZSB0byBtZWFzdXJlIHNvbWV0aGluZy5cbiAgICAgIGlmICghZmFicmljLl9tZWFzdXJpbmdDb250ZXh0KSB7XG4gICAgICAgIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRDYWNoZSB8fFxuICAgICAgICAgIGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXZpZGVzIHRleHQgaW50byBsaW5lcyBvZiB0ZXh0IGFuZCBsaW5lcyBvZiBncmFwaGVtZXMuXG4gICAgICovXG4gICAgX3NwbGl0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3TGluZXMgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dExpbmVzID0gbmV3TGluZXMubGluZXM7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBuZXdMaW5lcy5ncmFwaGVtZUxpbmVzO1xuICAgICAgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzID0gbmV3TGluZXMuX3Vud3JhcHBlZExpbmVzO1xuICAgICAgdGhpcy5fdGV4dCA9IG5ld0xpbmVzLmdyYXBoZW1lVGV4dDtcbiAgICAgIHJldHVybiBuZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGV4dCBkaW1lbnNpb25zLlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3BsaXRUZXh0KCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnBhdGgud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5wYXRoLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYWxjVGV4dFdpZHRoKCkgfHwgdGhpcy5jdXJzb3JXaWR0aCB8fCB0aGlzLk1JTl9URVhUX1dJRFRIO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVubGFyZ2Ugc3BhY2UgYm94ZXMgYW5kIHNoaWZ0IHRoZSBvdGhlcnNcbiAgICAgKi9cbiAgICBlbmxhcmdlU3BhY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWZmU3BhY2UsIGN1cnJlbnRMaW5lV2lkdGgsIG51bWJlck9mU3BhY2VzLCBhY2N1bXVsYXRlZFNwYWNlLCBsaW5lLCBjaGFyQm91bmQsIHNwYWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dEFsaWduICE9PSAnanVzdGlmeScgJiYgKGkgPT09IGxlbiAtIDEgfHwgdGhpcy5pc0VuZE9mV3JhcHBpbmcoaSkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSA9IDA7XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPCB0aGlzLndpZHRoICYmIChzcGFjZXMgPSB0aGlzLnRleHRMaW5lc1tpXS5tYXRjaCh0aGlzLl9yZVNwYWNlc0FuZFRhYnMpKSkge1xuICAgICAgICAgIG51bWJlck9mU3BhY2VzID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgICBkaWZmU3BhY2UgPSAodGhpcy53aWR0aCAtIGN1cnJlbnRMaW5lV2lkdGgpIC8gbnVtYmVyT2ZTcGFjZXM7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8PSBqbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoYXJCb3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2pdKSkge1xuICAgICAgICAgICAgICBjaGFyQm91bmQud2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQua2VybmVkV2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlZFNwYWNlICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIHRleHQgbGluZSBpcyBlbmRlZCB3aXRoIGFuIGhhcmQgYnJlYWtcbiAgICAgKiB0ZXh0IGFuZCBpdGV4dCBkbyBub3QgaGF2ZSB3cmFwcGluZywgcmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VuZE9mV3JhcHBpbmc6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIEl0IHJldHVybiBhbHdheXMgZm9yIHRleHQgYW5kIEl0ZXh0LlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlRleHQgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidGV4dFwiOiBcIicgKyB0aGlzLnRleHQgKyAnXCIsIFwiZm9udEZhbWlseVwiOiBcIicgKyB0aGlzLmZvbnRGYW1pbHkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5jYWxsU3VwZXIoJ19nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMnKTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgICBkaW1zLndpZHRoICs9IGZvbnRTaXplICogZGltcy56b29tWDtcbiAgICAgIGRpbXMuaGVpZ2h0ICs9IGZvbnRTaXplICogZGltcy56b29tWTtcbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgcGF0aCAmJiAhcGF0aC5pc05vdFZpc2libGUoKSAmJiBwYXRoLl9yZW5kZXIoY3R4KTtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ3VuZGVybGluZScpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAnb3ZlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ2xpbmV0aHJvdWdoJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZm9udCBwYXJhbWV0ZXIgb2YgdGhlIGNvbnRleHQgd2l0aCB0aGUgb2JqZWN0IHByb3BlcnRpZXMgb3Igd2l0aCBjaGFyU3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoYXJTdHlsZV0gb2JqZWN0IHdpdGggZm9udCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udEZhbWlseV0gRm9udCBGYW1pbHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NoYXJTdHlsZS5mb250U2l6ZV0gRm9udCBzaXplIGluIHBpeGVscy4gKCB3aXRob3V0IHB4IHN1ZmZpeCApXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFdlaWdodF0gRm9udCB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250U3R5bGVdIEZvbnQgc3R5bGUgKGl0YWxpY3xub3JtYWwpXG4gICAgICovXG4gICAgX3NldFRleHRTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpY2FsJztcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBhdGhBbGlnbikge1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhc2NlbmRlcic6XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkZXNjZW5kZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIHRleHQgV2lkdGggbWVhc3VyaW5nIGVhY2ggbGluZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE1heGltdW0gd2lkdGggb2YgZmFicmljLlRleHQgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY1RleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmdldExpbmVXaWR0aCgwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudExpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGkpO1xuICAgICAgICBpZiAoY3VycmVudExpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50TGluZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4V2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBNZXRob2QgbmFtZSAoXCJmaWxsVGV4dFwiIG9yIFwic3Ryb2tlVGV4dFwiKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBUZXh0IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZSBpbiBhIHRleHRcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmU6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgdGhpcy5fcmVuZGVyQ2hhcnMobWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdGV4dCBiYWNrZ3JvdW5kIGZvciBsaW5lcywgdGFraW5nIGNhcmUgb2Ygc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIG9yaWdpbmFsRmlsbCA9IGN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgbGluZSwgbGFzdENvbG9yLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgbGluZVRvcE9mZnNldCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuICAgICAgICAgIGJveFN0YXJ0ID0gMCwgYm94V2lkdGggPSAwLCBjaGFyQm94LCBjdXJyZW50Q29sb3IsIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgZHJhd1N0YXJ0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAtY2hhckJveC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgIC1oZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pLFxuICAgICAgICAgICAgICBjaGFyQm94LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgICAgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0Q29sb3I7XG4gICAgICAgICAgICBsYXN0Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgICAgIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbG9yICYmICFwYXRoKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICAgIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3JpZ2luYWxGaWxsO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNsIHN0eWxlIGRlY2xhcmF0aW9uIGZvciBjYWNoZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRGYW1pbHkgZm9udEZhbWlseVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRTdHlsZSBmb250U3R5bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250V2VpZ2h0IGZvbnRXZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlZmVyZW5jZSB0byBjYWNoZVxuICAgICAqL1xuICAgIGdldEZvbnRDYWNoZTogZnVuY3Rpb24oZGVjbCkge1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBkZWNsLmZvbnRGYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldID0geyB9O1xuICAgICAgfVxuICAgICAgdmFyIGNhY2hlID0gZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSxcbiAgICAgICAgICBjYWNoZVByb3AgPSBkZWNsLmZvbnRTdHlsZS50b0xvd2VyQ2FzZSgpICsgJ18nICsgKGRlY2wuZm9udFdlaWdodCArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFjYWNoZVtjYWNoZVByb3BdKSB7XG4gICAgICAgIGNhY2hlW2NhY2hlUHJvcF0gPSB7IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVbY2FjaGVQcm9wXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBhbmQgcmV0dXJuIHRoZSB3aWR0aCBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gICAgICogcG9zc2libHkgb3ZlcnJpZGRlbiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgbWVhc3VyZSBsb2dpYyBvclxuICAgICAqIHRvIGhvb2sgc29tZSBleHRlcm5hbCBsaWIgZm9yIGNoYXJhY3RlciBtZWFzdXJlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyLCBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYXJTdHlsZSBzdHlsZSBvZiBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2aW91c0NoYXJdIHByZXZpb3VzIGNoYXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3ByZXZDaGFyU3R5bGVdIHN0eWxlIG9mIHByZXZpb3VzIGNoYXJcbiAgICAgKi9cbiAgICBfbWVhc3VyZUNoYXI6IGZ1bmN0aW9uKF9jaGFyLCBjaGFyU3R5bGUsIHByZXZpb3VzQ2hhciwgcHJldkNoYXJTdHlsZSkge1xuICAgICAgLy8gZmlyc3QgaSB0cnkgdG8gcmV0dXJuIGZyb20gY2FjaGVcbiAgICAgIHZhciBmb250Q2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZShjaGFyU3R5bGUpLCBmb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlKSxcbiAgICAgICAgICBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihwcmV2Q2hhclN0eWxlKSwgY291cGxlID0gcHJldmlvdXNDaGFyICsgX2NoYXIsXG4gICAgICAgICAgc3R5bGVzQXJlRXF1YWwgPSBmb250RGVjbGFyYXRpb24gPT09IHByZXZpb3VzRm9udERlY2xhcmF0aW9uLCB3aWR0aCwgY291cGxlV2lkdGgsIHByZXZpb3VzV2lkdGgsXG4gICAgICAgICAgZm9udE11bHRpcGxpZXIgPSBjaGFyU3R5bGUuZm9udFNpemUgLyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSwga2VybmVkV2lkdGg7XG5cbiAgICAgIGlmIChwcmV2aW91c0NoYXIgJiYgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2aW91c1dpZHRoID0gZm9udENhY2hlW3ByZXZpb3VzQ2hhcl07XG4gICAgICB9XG4gICAgICBpZiAoZm9udENhY2hlW19jaGFyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gd2lkdGggPSBmb250Q2FjaGVbX2NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGZvbnRDYWNoZVtjb3VwbGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291cGxlV2lkdGggPSBmb250Q2FjaGVbY291cGxlXTtcbiAgICAgICAga2VybmVkV2lkdGggPSBjb3VwbGVXaWR0aCAtIHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgfHwgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXRNZWFzdXJpbmdDb250ZXh0KCk7XG4gICAgICAgIC8vIHNlbmQgYSBUUlVFIHRvIHNwZWNpZnkgbWVhc3VyaW5nIGZvbnQgc2l6ZSBDQUNIRV9GT05UX1NJWkVcbiAgICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgsIGNoYXJTdHlsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KF9jaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW19jaGFyXSA9IHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzV2lkdGggPT09IHVuZGVmaW5lZCAmJiBzdHlsZXNBcmVFcXVhbCAmJiBwcmV2aW91c0NoYXIpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChwcmV2aW91c0NoYXIpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbcHJldmlvdXNDaGFyXSA9IHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzQXJlRXF1YWwgJiYgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB3ZSBjYW4gbWVhc3VyZSB0aGUga2VybmluZyBjb3VwbGUgYW5kIHN1YnRyYWN0IHRoZSB3aWR0aCBvZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgIGNvdXBsZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNvdXBsZSkud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtjb3VwbGVdID0gY291cGxlV2lkdGg7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoICogZm9udE11bHRpcGxpZXIsIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCAqIGZvbnRNdWx0aXBsaWVyIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGhlaWdodCBvZiBjaGFyYWN0ZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZSB0aGUgbGluZSBpbmRleCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gX2NoYXIgdGhlIGNoYXJhY3RlciBpbmRleCBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGZvbnRTaXplIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkNoYXI6IGZ1bmN0aW9uKGxpbmUsIF9jaGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lLCBfY2hhciwgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYSB0ZXh0IGxpbmUgbWVhc3VyaW5nIGFsbCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBtZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZUluZm8gPSB0aGlzLl9tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgbGluZUluZm8ud2lkdGggLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUluZm8ud2lkdGggPCAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBldmVyeSBncmFwaGVtZSBvZiBhIGxpbmUsIHBvcHVsYXRpbmcgX19jaGFyQm91bmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIHRvdGFsIHdpZHRoIG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aE9mU3BhY2VzIGxlbmd0aCBvZiBjaGFycyB0aGF0IG1hdGNoIHRoaXMuX3JlU3BhY2VzQW5kVGFic1xuICAgICAqL1xuICAgIF9tZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBpLCBncmFwaGVtZSwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBwcmV2R3JhcGhlbWUsXG4gICAgICAgICAgZ3JhcGhlbWVJbmZvLCBudW1PZlNwYWNlcyA9IDAsIGxpbmVCb3VuZHMgPSBuZXcgQXJyYXkobGluZS5sZW5ndGgpLFxuICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gMCwgc3RhcnRpbmdQb2ludCwgdG90YWxQYXRoTGVuZ3RoLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIHJldmVyc2UgPSB0aGlzLnBhdGhTaWRlID09PSAncmlnaHQnO1xuXG4gICAgICB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdID0gbGluZUJvdW5kcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lID0gbGluZVtpXTtcbiAgICAgICAgZ3JhcGhlbWVJbmZvID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3goZ3JhcGhlbWUsIGxpbmVJbmRleCwgaSwgcHJldkdyYXBoZW1lKTtcbiAgICAgICAgbGluZUJvdW5kc1tpXSA9IGdyYXBoZW1lSW5mbztcbiAgICAgICAgd2lkdGggKz0gZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoO1xuICAgICAgICBwcmV2R3JhcGhlbWUgPSBncmFwaGVtZTtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbGF0ZXN0IGJvdW5kIGJveCByZXByZXNlbnQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBsaW5lXG4gICAgICAvLyB0byBzaW1wbGlmeSBjdXJzb3IgaGFuZGxpbmcgaW4gaW50ZXJhY3RpdmUgbW9kZS5cbiAgICAgIGxpbmVCb3VuZHNbaV0gPSB7XG4gICAgICAgIGxlZnQ6IGdyYXBoZW1lSW5mbyA/IGdyYXBoZW1lSW5mby5sZWZ0ICsgZ3JhcGhlbWVJbmZvLndpZHRoIDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGtlcm5lZFdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZm9udFNpemVcbiAgICAgIH07XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0b3RhbFBhdGhMZW5ndGggPSBwYXRoLnNlZ21lbnRzSW5mb1twYXRoLnNlZ21lbnRzSW5mby5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQgPSBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aChwYXRoLnBhdGgsIDAsIHBhdGguc2VnbWVudHNJbmZvKTtcbiAgICAgICAgc3RhcnRpbmdQb2ludC54ICs9IHBhdGgucGF0aE9mZnNldC54O1xuICAgICAgICBzdGFydGluZ1BvaW50LnkgKz0gcGF0aC5wYXRoT2Zmc2V0Lnk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50ZXh0QWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gcmV2ZXJzZSA/ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCkgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gKHRvdGFsUGF0aExlbmd0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IHJldmVyc2UgPyAwIDogKHRvdGFsUGF0aExlbmd0aCAtIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vdG9kbyAtIGFkZCBzdXBwb3J0IGZvciBqdXN0aWZ5XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25JblBhdGggKz0gdGhpcy5wYXRoU3RhcnRPZmZzZXQgKiAocmV2ZXJzZSA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoaSA9IHJldmVyc2UgPyBsaW5lLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHJldmVyc2UgPyBpID49IDAgOiBpIDwgbGluZS5sZW5ndGg7XG4gICAgICAgICAgcmV2ZXJzZSA/IGktLSA6IGkrKykge1xuICAgICAgICAgIGdyYXBoZW1lSW5mbyA9IGxpbmVCb3VuZHNbaV07XG4gICAgICAgICAgaWYgKHBvc2l0aW9uSW5QYXRoID4gdG90YWxQYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCAlPSB0b3RhbFBhdGhMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uSW5QYXRoIDwgMCkge1xuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggKz0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpdCB3b3VsZCBwcm9iYWJseSBtdWNoIGZhc3RlciB0byBzZW5kIGFsbCB0aGUgZ3JhcGhlbWUgcG9zaXRpb24gZm9yIGEgbGluZVxuICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgcGF0aCBwb3NpdGlvbi9hbmdsZSBhdCBvbmNlLlxuICAgICAgICAgIHRoaXMuX3NldEdyYXBoZW1lT25QYXRoKHBvc2l0aW9uSW5QYXRoLCBncmFwaGVtZUluZm8sIHN0YXJ0aW5nUG9pbnQpO1xuICAgICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBudW1PZlNwYWNlczogbnVtT2ZTcGFjZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSAgYW5kIHRoZSBsZWZ0LHRvcCBwb3NpdGlvbiBvZiB0aGUgY2hhciB0aGF0IGZvbGxvdyBhIHBhdGguXG4gICAgICogSXQgYXBwZW5kcyBpdCB0byBncmFwaGVtZUluZm8gdG8gYmUgcmV1c2VkIGxhdGVyIGF0IHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uSW5QYXRoIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoZW1lSW5mbyBjdXJyZW50IGdyYXBoZW1lIGJveCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydGluZ1BvaW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9zZXRHcmFwaGVtZU9uUGF0aDogZnVuY3Rpb24ocG9zaXRpb25JblBhdGgsIGdyYXBoZW1lSW5mbywgc3RhcnRpbmdQb2ludCkge1xuICAgICAgdmFyIGNlbnRlclBvc2l0aW9uID0gcG9zaXRpb25JblBhdGggKyBncmFwaGVtZUluZm8ua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIC8vIHdlIGFyZSBhdCBjdXJyZW50UG9zaXRpb25PblBhdGguIHdlIHdhbnQgdG8ga25vdyB3aGF0IHBvaW50IG9uIHRoZSBwYXRoIGlzLlxuICAgICAgdmFyIGluZm8gPSBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aChwYXRoLnBhdGgsIGNlbnRlclBvc2l0aW9uLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyTGVmdCA9IGluZm8ueCAtIHN0YXJ0aW5nUG9pbnQueDtcbiAgICAgIGdyYXBoZW1lSW5mby5yZW5kZXJUb3AgPSBpbmZvLnkgLSBzdGFydGluZ1BvaW50Lnk7XG4gICAgICBncmFwaGVtZUluZm8uYW5nbGUgPSBpbmZvLmFuZ2xlICsgKHRoaXMucGF0aFNpZGUgPT09ICAncmlnaHQnID8gTWF0aC5QSSA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGFuZCByZXR1cm4gdGhlIGluZm8gb2YgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gICAgICogbmVlZHMgdGhlIHRoZSBpbmZvIG9mIHByZXZpb3VzIGdyYXBoZW1lcyBhbHJlYWR5IGZpbGxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyYXBoZW1lIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gaW4gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZHcmFwaGVtZV0gY2hhcmFjdGVyIHByZWNlZGluZyB0aGUgb25lIHRvIGJlIG1lYXN1cmVkXG4gICAgICovXG4gICAgX2dldEdyYXBoZW1lQm94OiBmdW5jdGlvbihncmFwaGVtZSwgbGluZUluZGV4LCBjaGFySW5kZXgsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBwcmV2U3R5bGUgPSBwcmV2R3JhcGhlbWUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCAtIDEpIDogeyB9LFxuICAgICAgICAgIGluZm8gPSB0aGlzLl9tZWFzdXJlQ2hhcihncmFwaGVtZSwgc3R5bGUsIHByZXZHcmFwaGVtZSwgcHJldlN0eWxlKSxcbiAgICAgICAgICBrZXJuZWRXaWR0aCA9IGluZm8ua2VybmVkV2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBpbmZvLndpZHRoLCBjaGFyU3BhY2luZztcblxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgd2lkdGggKz0gY2hhclNwYWNpbmc7XG4gICAgICAgIGtlcm5lZFdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm94ID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCxcbiAgICAgICAgZGVsdGFZOiBzdHlsZS5kZWx0YVksXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJJbmRleCA+IDAgJiYgIXNraXBMZWZ0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c0JveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICAgIGJveC5sZWZ0ID0gcHJldmlvdXNCb3gubGVmdCArIHByZXZpb3VzQm94LndpZHRoICsgaW5mby5rZXJuZWRXaWR0aCAtIGluZm8ud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIGxpbmUgYXQgJ2xpbmVJbmRleCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IG9mIGxpbmUgdG8gY2FsY3VsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodE9mTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIC8vIGNoYXIgMCBpcyBtZWFzdXJlZCBiZWZvcmUgdGhlIGxpbmUgY3ljbGUgYmVjYXVzZSBpdCBubmVkcyB0byBjaGFyXG4gICAgICAgICAgLy8gZW1wdHlsaW5lc1xuICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGxpbmVJbmRleCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbGluZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heCh0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIGkpLCBtYXhIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0gPSBtYXhIZWlnaHQgKiB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0ZXh0IGJveCBoZWlnaHRcbiAgICAgKi9cbiAgICBjYWxjVGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUhlaWdodCwgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBoZWlnaHQgKz0gKGkgPT09IGxlbiAtIDEgPyBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0IDogbGluZUhlaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGVmdE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInID8gLXRoaXMud2lkdGggLyAyIDogdGhpcy53aWR0aCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUb3Agb2Zmc2V0XG4gICAgICovXG4gICAgX2dldFRvcE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBNZXRob2QgbmFtZSAoXCJmaWxsVGV4dFwiIG9yIFwic3Ryb2tlVGV4dFwiKVxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0Q29tbW9uOiBmdW5jdGlvbihjdHgsIG1ldGhvZCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0cyA9IDAsIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgIHRvcCArIGxpbmVIZWlnaHRzICsgbWF4SGVpZ2h0LFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsICYmICF0aGlzLnN0eWxlSGFzKCdmaWxsJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ2ZpbGxUZXh0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0U3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICgoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnc3Ryb2tlVGV4dCcpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIGZpbGxUZXh0IG9yIHN0cm9rZVRleHQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgQ29udGVudCBvZiB0aGUgbGluZSwgc3BsaXR0ZWQgaW4gYW4gYXJyYXkgYnkgZ3JhcGhlbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICovXG4gICAgX3JlbmRlckNoYXJzOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgdGltZVRvUmVuZGVyLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgc2hvcnRDdXQgPSAhaXNKdXN0aWZ5ICYmIHRoaXMuY2hhclNwYWNpbmcgPT09IDAgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKGxpbmVJbmRleCkgJiYgIXBhdGgsXG4gICAgICAgICAgaXNMdHIgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ2x0cicsIHNpZ24gPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ2x0cicgPyAxIDogLTEsXG4gICAgICAgICAgZHJhd2luZ0xlZnQsIGN1cnJlbnREaXJlY3Rpb24gPSBjdHguY2FudmFzLmdldEF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKGN1cnJlbnREaXJlY3Rpb24gIT09IHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICAgIGN0eC5jYW52YXMuc2V0QXR0cmlidXRlKCdkaXInLCBpc0x0ciA/ICdsdHInIDogJ3J0bCcpO1xuICAgICAgICBjdHguZGlyZWN0aW9uID0gaXNMdHIgPyAnbHRyJyA6ICdydGwnO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gaXNMdHIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfVxuICAgICAgdG9wIC09IGxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZUZyYWN0aW9uIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgaWYgKHNob3J0Q3V0KSB7XG4gICAgICAgIC8vIHJlbmRlciBhbGwgdGhlIGxpbmUgaW4gb25lIHBhc3Mgd2l0aG91dCBjaGVja2luZ1xuICAgICAgICAvLyBkcmF3aW5nTGVmdCA9IGlzTHRyID8gbGVmdCA6IGxlZnQgLSB0aGlzLmdldExpbmVXaWR0aChsaW5lSW5kZXgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIDAsIGxpbmUuam9pbignJyksIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lLmxlbmd0aCAtIDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gaSA9PT0gbGVuIHx8IHRoaXMuY2hhclNwYWNpbmcgfHwgcGF0aDtcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgbGVmdCArPSBzaWduICogKGNoYXJCb3gua2VybmVkV2lkdGggLSBjaGFyQm94LndpZHRoKTtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IGZhYnJpYy51dGlsLmhhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIC1ib3hXaWR0aCAvIDIsIDAsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkcmF3aW5nTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIGRyYXdpbmdMZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgbGVmdCArPSBzaWduICogYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyYXdiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59IGEgcGF0dGVybiB0byB1c2UgYXMgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0OiBmdW5jdGlvbihmaWxsZXIpIHtcbiAgICAgIHZhciBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LFxuICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBjb21wYXRpYmlsaXR5IHdpdGggc3Ryb2tlVW5pZm9ybVxuICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUocEN0eCk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShwQ3R4LCBmaWxsZXIpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICByZXR1cm4gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlRmlsbGVyOiBmdW5jdGlvbihjdHgsIHByb3BlcnR5LCBmaWxsZXIpIHtcbiAgICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZO1xuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScgfHwgZmlsbGVyLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgIC8vIGlzIG5vdCB1c2luZyBjYWNoaW5nLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyBpdCBvbi5cbiAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQoZmlsbGVyKTtcbiAgICAgICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXIudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZmlsbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgY3R4W3Byb3BlcnR5XSA9IGZpbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZGVjbC5zdHJva2VXaWR0aDtcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ3N0cm9rZVN0eWxlJywgZGVjbC5zdHJva2UpO1xuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIoY3R4LCAnZmlsbFN0eWxlJywgZGVjbC5maWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aCxcbiAgICAgICAgICBmaWxsT2Zmc2V0cywgc3Ryb2tlT2Zmc2V0cztcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgc2hvdWxkRmlsbCAmJiAoZmlsbE9mZnNldHMgPSB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgZnVsbERlY2wpKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiAoc3Ryb2tlT2Zmc2V0cyA9IHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGZ1bGxEZWNsKTtcblxuXG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLmRlbHRhWSkge1xuICAgICAgICB0b3AgKz0gZGVjbC5kZWx0YVk7XG4gICAgICB9XG4gICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCAtIGZpbGxPZmZzZXRzLm9mZnNldFgsIHRvcCAtIGZpbGxPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgc2hvdWxkU3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KF9jaGFyLCBsZWZ0IC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBzdHJva2VPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGEgJ3N1cGVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1cGVyc2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1cGVyc2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3VwZXJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYW4gJ2luZmVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1YnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdWJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzICdzY2hlbWEnIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfc2V0U2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBzY2hlbWEpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2RlbHRhWScpLFxuICAgICAgICAgIHN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgKiBzY2hlbWEuc2l6ZSwgZGVsdGFZOiBkeSArIGZvbnRTaXplICogc2NoZW1hLmJhc2VsaW5lIH07XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlcyhzdHlsZSwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KSxcbiAgICAgICAgICBsaW5lRGlmZiA9IHRoaXMud2lkdGggLSBsaW5lV2lkdGgsIHRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduLCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbixcbiAgICAgICAgICBpc0VuZE9mV3JhcHBpbmcsIGxlZnRPZmZzZXQgPSAwLCBpc0VuZE9mV3JhcHBpbmcgPSB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicgJiYgIWlzRW5kT2ZXcmFwcGluZylcbiAgICAgICAgfHwgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWxlZnQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmYgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmY7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZiAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1yaWdodCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSBsaW5lRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0T2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19saW5lV2lkdGhzID0gW107XG4gICAgICB0aGlzLl9fbGluZUhlaWdodHMgPSBbXTtcbiAgICAgIHRoaXMuX19jaGFyQm91bmRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fZm9yY2VDbGVhckNhY2hlO1xuICAgICAgc2hvdWxkQ2xlYXIgfHwgKHNob3VsZENsZWFyID0gdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycpKTtcbiAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkQ2xlYXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgYSBzaW5nbGUgbGluZSBnaXZlbiBpdHMgaW5kZXguIFVzZWQgdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsXG4gICAgICogdGV4dCBib3VuZGluZyBib3guIFRoZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYW5kIHN0b3JlZCBpbiBfX2xpbmVXaWR0aHMgY2FjaGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgZ2V0TGluZVdpZHRoOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIHZhciB3aWR0aCA9IGxpbmVJbmZvLndpZHRoO1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IHdpZHRoO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5jaGFyU3BhY2luZyAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBhdCBnaXZlbiBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRoZSBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0c1t0eXBlXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUsIGkpKSB7XG4gICAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFN0YXJ0ID0gMDtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgdHlwZSk7XG4gICAgICAgIGxhc3RGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZmlsbCcpO1xuICAgICAgICB0b3AgPSB0b3BPZmZzZXQgKyBtYXhIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgICBzaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgMCk7XG4gICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZGVsdGFZJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosIHR5cGUpO1xuICAgICAgICAgIGN1cnJlbnRGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZmlsbCcpO1xuICAgICAgICAgIF9zaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgaik7XG4gICAgICAgICAgX2R5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZGVsdGFZJyk7XG4gICAgICAgICAgaWYgKHBhdGggJiYgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdEZpbGw7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgICAgICBvZmZzZXRZICogX3NpemUgKyBfZHksXG4gICAgICAgICAgICAgIGNoYXJCb3gua2VybmVkV2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgKGN1cnJlbnREZWNvcmF0aW9uICE9PSBsYXN0RGVjb3JhdGlvbiB8fCBjdXJyZW50RmlsbCAhPT0gbGFzdEZpbGwgfHwgX3NpemUgIT09IHNpemUgfHwgX2R5ICE9PSBkeSlcbiAgICAgICAgICAgICYmIGJveFdpZHRoID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERlY29yYXRpb24gJiYgbGFzdEZpbGwpIHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgICAgIHRvcCArIG9mZnNldFkgKiBzaXplICsgZHksXG4gICAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uID0gY3VycmVudERlY29yYXRpb247XG4gICAgICAgICAgICBsYXN0RmlsbCA9IGN1cnJlbnRGaWxsO1xuICAgICAgICAgICAgc2l6ZSA9IF9zaXplO1xuICAgICAgICAgICAgZHkgPSBfZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICB0b3AgKyBvZmZzZXRZICogc2l6ZSArIGR5LFxuICAgICAgICAgIGJveFdpZHRoIC0gY2hhclNwYWNpbmcsXG4gICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICk7XG4gICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSBpcyB0ZXh0IGJhY2tncm91bmQgY29sb3Igbm9cbiAgICAgIC8vIG90aGVyIHNoYWRvd3Mgc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBmb250IGRlY2xhcmF0aW9uIHN0cmluZyBmb3IgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT2JqZWN0XSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBmb250IGRlY2xhcmF0aW9uIGZvcm1hdHRlZCBmb3IgY2FudmFzIGNvbnRleHQuXG4gICAgICovXG4gICAgX2dldEZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24oc3R5bGVPYmplY3QsIGZvck1lYXN1cmluZykge1xuICAgICAgdmFyIHN0eWxlID0gc3R5bGVPYmplY3QgfHwgdGhpcywgZmFtaWx5ID0gdGhpcy5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRJc0dlbmVyaWMgPSBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMuaW5kZXhPZihmYW1pbHkudG9Mb3dlckNhc2UoKSkgPiAtMTtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZmFtaWx5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcXCcnKSA+IC0xIHx8IGZhbWlseS5pbmRleE9mKCcsJykgPiAtMSB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1wiJykgPiAtMSB8fCBmb250SXNHZW5lcmljXG4gICAgICAgID8gc3R5bGUuZm9udEZhbWlseSA6ICdcIicgKyBzdHlsZS5mb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8vIG5vZGUtY2FudmFzIG5lZWRzIFwid2VpZ2h0IHN0eWxlXCIsIHdoaWxlIGJyb3dzZXJzIG5lZWQgXCJzdHlsZSB3ZWlnaHRcIlxuICAgICAgICAvLyB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgZml4ZWQgaW4gSlNET01cbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250V2VpZ2h0IDogc3R5bGUuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250U3R5bGUgOiBzdHlsZS5mb250V2VpZ2h0KSxcbiAgICAgICAgZm9yTWVhc3VyaW5nID8gdGhpcy5DQUNIRV9GT05UX1NJWkUgKyAncHgnIDogc3R5bGUuZm9udFNpemUgKyAncHgnLFxuICAgICAgICBmb250RmFtaWx5XG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBMaW5lcyBpbiB0aGUgdGV4dFxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSxcbiAgICAgICAgICBuZXdMaW5lcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpLFxuICAgICAgICAgIG5ld0xpbmUgPSBbJ1xcbiddLFxuICAgICAgICAgIG5ld1RleHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TGluZXNbaV0gPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChsaW5lc1tpXSk7XG4gICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LmNvbmNhdChuZXdMaW5lc1tpXSwgbmV3TGluZSk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgcmV0dXJuIHsgX3Vud3JhcHBlZExpbmVzOiBuZXdMaW5lcywgbGluZXM6IGxpbmVzLCBncmFwaGVtZVRleHQ6IG5ld1RleHQsIGdyYXBoZW1lTGluZXM6IG5ld0xpbmVzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0aWVzID0gYWRkaXRpb25hbFByb3BzLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIHZhciBvYmogPSB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBhbGxQcm9wZXJ0aWVzKTtcbiAgICAgIG9iai5zdHlsZXMgPSBmYWJyaWMudXRpbC5zdHlsZXNUb0FycmF5KHRoaXMuc3R5bGVzLCB0aGlzLnRleHQpO1xuICAgICAgaWYgKG9iai5wYXRoKSB7XG4gICAgICAgIG9iai5wYXRoID0gdGhpcy5wYXRoLnRvT2JqZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgUHJvcGVydHkgbmFtZSBvciBvYmplY3QgKGlmIG9iamVjdCwgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3QgcHJvcGVydGllcylcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdzZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHZhciBuZWVkc0RpbXMgPSBmYWxzZTtcbiAgICAgIHZhciBpc0FkZGluZ1BhdGggPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBfa2V5IGluIGtleSkge1xuICAgICAgICAgIGlmIChfa2V5ID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNEaW1zID0gbmVlZHNEaW1zIHx8IHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2YoX2tleSkgIT09IC0xO1xuICAgICAgICAgIGlzQWRkaW5nUGF0aCA9IGlzQWRkaW5nUGF0aCB8fCBfa2V5ID09PSAncGF0aCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZWVkc0RpbXMgPSB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKGtleSkgIT09IC0xO1xuICAgICAgICBpc0FkZGluZ1BhdGggPSBrZXkgPT09ICdwYXRoJztcbiAgICAgIH1cbiAgICAgIGlmIChpc0FkZGluZ1BhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzRGltcykge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlRleHQuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvdGV4dC5odG1sI1RleHRFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICd4IHkgZHggZHkgZm9udC1mYW1pbHkgZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUgbGV0dGVyLXNwYWNpbmcgdGV4dC1kZWNvcmF0aW9uIHRleHQtYW5jaG9yJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBTVkcgZm9udCBzaXplXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkUgPSAxNjtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50ICg8Yj5ub3QgeWV0IGltcGxlbWVudGVkPC9iPilcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcGFyc2VkQW5jaG9yID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0QW5jaG9yIHx8ICdsZWZ0JztcbiAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCgob3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgaWYgKHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb247XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLm92ZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5saW5ldGhyb3VnaCA9IHRydWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0aW9ucy50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gICAgaWYgKCdkeCcgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHg7XG4gICAgfVxuICAgIGlmICgnZHknIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHk7XG4gICAgfVxuICAgIGlmICghKCdmb250U2l6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250ZW50ID0gJyc7XG5cbiAgICAvLyBUaGUgWE1MIGlzIG5vdCBwcm9wZXJseSBwYXJzZWQgaW4gSUU5IHNvIGEgd29ya2Fyb3VuZCB0byBnZXRcbiAgICAvLyB0ZXh0Q29udGVudCBpcyB0aHJvdWdoIGZpcnN0Q2hpbGQuZGF0YS4gQW5vdGhlciB3b3JrYXJvdW5kIHdvdWxkIGJlXG4gICAgLy8gdG8gY29udmVydCBYTUwgbG9hZGVkIGZyb20gYSBmaWxlIHRvIGJlIGNvbnZlcnRlZCB1c2luZyBET01QYXJzZXIgKHNhbWUgd2F5IGxvYWRTVkdGcm9tU3RyaW5nKCkgZG9lcylcbiAgICBpZiAoISgndGV4dENvbnRlbnQnIGluIGVsZW1lbnQpKSB7XG4gICAgICBpZiAoJ2ZpcnN0Q2hpbGQnIGluIGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgnZGF0YScgaW4gZWxlbWVudC5maXJzdENoaWxkICYmIGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskfFxcbisvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB2YXIgb3JpZ2luYWxTdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgb3B0aW9ucy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICB2YXIgdGV4dCA9IG5ldyBmYWJyaWMuVGV4dCh0ZXh0Q29udGVudCwgb3B0aW9ucyksXG4gICAgICAgIHRleHRIZWlnaHRTY2FsZUZhY3RvciA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgLyB0ZXh0LmhlaWdodCxcbiAgICAgICAgbGluZUhlaWdodERpZmYgPSAodGV4dC5oZWlnaHQgKyB0ZXh0LnN0cm9rZVdpZHRoKSAqIHRleHQubGluZUhlaWdodCAtIHRleHQuaGVpZ2h0LFxuICAgICAgICBzY2FsZWREaWZmID0gbGluZUhlaWdodERpZmYgKiB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IsXG4gICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpICsgc2NhbGVkRGlmZixcbiAgICAgICAgb2ZmWCA9IDA7XG4gICAgLypcbiAgICAgIEFkanVzdCBwb3NpdGlvbmluZzpcbiAgICAgICAgeC95IGF0dHJpYnV0ZXMgaW4gU1ZHIGNvcnJlc3BvbmQgdG8gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICAgICBmYWJyaWMgb3V0cHV0IGJ5IGRlZmF1bHQgYXQgdG9wLCBsZWZ0LlxuICAgICovXG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCkgLyAyO1xuICAgIH1cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpO1xuICAgIH1cbiAgICB0ZXh0LnNldCh7XG4gICAgICBsZWZ0OiB0ZXh0LmxlZnQgLSBvZmZYLFxuICAgICAgdG9wOiB0ZXh0LnRvcCAtICh0ZXh0SGVpZ2h0IC0gdGV4dC5mb250U2l6ZSAqICgwLjA3ICsgdGV4dC5fZm9udFNpemVGcmFjdGlvbikpIC8gdGV4dC5saW5lSGVpZ2h0LFxuICAgICAgc3Ryb2tlV2lkdGg6IHR5cGVvZiBvcmlnaW5hbFN0cm9rZVdpZHRoICE9PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsU3Ryb2tlV2lkdGggOiAxLFxuICAgIH0pO1xuICAgIGNhbGxiYWNrKHRleHQpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgcGxhaW4ganMgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHQgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0Q29weSA9IGNsb25lKG9iamVjdCksIHBhdGggPSBvYmplY3QucGF0aDtcbiAgICBkZWxldGUgb2JqZWN0Q29weS5wYXRoO1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUZXh0Jywgb2JqZWN0Q29weSwgZnVuY3Rpb24odGV4dEluc3RhbmNlKSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uuc3R5bGVzID0gZmFicmljLnV0aWwuc3R5bGVzRnJvbUFycmF5KG9iamVjdC5zdHlsZXMsIG9iamVjdC50ZXh0KTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBwYXRoLCBmdW5jdGlvbihwYXRoSW5zdGFuY2UpIHtcbiAgICAgICAgICB0ZXh0SW5zdGFuY2Uuc2V0KCdwYXRoJywgcGF0aEluc3RhbmNlKTtcbiAgICAgICAgICBjYWxsYmFjayh0ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9LCAncGF0aCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRleHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSwgJ3RleHQnKTtcbiAgfTtcblxuICBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMgPSBbJ3NhbnMtc2VyaWYnLCAnc2VyaWYnLCAnY3Vyc2l2ZScsICdmYW50YXN5JywgJ21vbm9zcGFjZSddO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyAmJiBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMoZmFicmljLlRleHQpO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmcgb3Igbm8gc3R5bGluZyBpbiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4ICwgbGluZUluZGV4IGlzIG9uIHdyYXBwZWQgbGluZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBmb3IgKHZhciBwMyBpbiBvYmpbcDFdW3AyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIGEgc3R5bGUgcHJvcGVydHkgb3IgaGFzIGl0IGluYSBzcGVjaWZpZWQgbGluZVxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlY3QgaWYgYSB0ZXh0IHdpbGwgdXNlIGEgcGFydGljdWxhciBwcm9wZXJ0eSBvciBub3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IHRvIGNoZWNrIGZvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggdG8gY2hlY2sgdGhlIHN0eWxlIG9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgMDogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtwMV1bcDJdW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjaGFyYWN0ZXJzIGluIGEgdGV4dCBoYXZlIGEgdmFsdWUgZm9yIGEgcHJvcGVydHlcbiAgICAgKiB3aG9zZSB2YWx1ZSBtYXRjaGVzIHRoZSB0ZXh0Ym94J3MgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuICBJZiBzbyxcbiAgICAgKiB0aGUgY2hhcmFjdGVyLWxldmVsIHByb3BlcnR5IGlzIGRlbGV0ZWQuICBJZiB0aGUgY2hhcmFjdGVyXG4gICAgICogaGFzIG5vIG90aGVyIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYWxzbyBkZWxldGVkLiAgRmluYWxseSxcbiAgICAgKiBpZiB0aGUgbGluZSBjb250YWluaW5nIHRoYXQgY2hhcmFjdGVyIGhhcyBubyBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICogdGhlbiBpdCBhbHNvIGlzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNvbXBhcmUgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBzdHlsZXNDb3VudCA9IDAsIGxldHRlckNvdW50LCBzdHlsZVByb3BlcnR5VmFsdWUsXG4gICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSB0cnVlLCBncmFwaGVtZUNvdW50ID0gMCwgc3R5bGVPYmplY3Q7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBsZXR0ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgdmFyIHN0eWxlT2JqZWN0ID0gb2JqW3AxXVtwMl0sXG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0ID0gc3R5bGVPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgc3R5bGVzQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdHlsZVByb3BlcnR5SGFzQmVlblNldCkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eVZhbHVlID0gc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldICE9PSBzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSA9PT0gdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZU9iamVjdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBsZXR0ZXJDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdW3AyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV0dGVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3AxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgZXZlcnkgZ3JhcGhlbWUgaGFzIHRoZSBzYW1lIHN0eWxlIHNldCB0aGVuXG4gICAgICAvLyBkZWxldGUgdGhvc2Ugc3R5bGVzIGFuZCBzZXQgaXQgb24gdGhlIHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWVDb3VudCArPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoICYmIHN0eWxlc0NvdW50ID09PSBncmFwaGVtZUNvdW50KSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gc3R5bGVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkgb3IgcHJvcGVydGllcyBmcm9tIGFsbCBpbmRpdmlkdWFsIGNoYXJhY3RlciBzdHlsZXNcbiAgICAgKiBpbiBhIHRleHQgb2JqZWN0LiAgRGVsZXRlcyB0aGUgY2hhcmFjdGVyIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBzdHlsZVxuICAgICAqIHByb3BzLiAgRGVsZXRlcyBhIGxpbmUgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcHMgVGhlIHByb3BlcnR5IHRvIHJlbW92ZSBmcm9tIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBsaW5lLCBsaW5lTnVtLCBjaGFyTnVtO1xuICAgICAgZm9yIChsaW5lTnVtIGluIG9iaikge1xuICAgICAgICBsaW5lID0gb2JqW2xpbmVOdW1dO1xuICAgICAgICBmb3IgKGNoYXJOdW0gaW4gbGluZSkge1xuICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZVtjaGFyTnVtXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbbGluZU51bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSwgc3R5bGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAyZCByZXByZXNlbnRhdGlvbiAobGluZUluZGV4IGFuZCBjaGFySW5kZXgpIG9mIGN1cnNvciAob3Igc2VsZWN0aW9uIHN0YXJ0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VsZWN0aW9uU3RhcnRdIE9wdGlvbmFsIGluZGV4LiBXaGVuIG5vdCBnaXZlbiwgY3VycmVudCBzZWxlY3Rpb25TdGFydCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBXcmFwcGluZ10gY29uc2lkZXIgdGhlIGxvY2F0aW9uIGZvciB1bndyYXBwZWQgbGluZXMuIHVzZWZ1bCB0byBtYW5hZ2Ugc3R5bGVzLlxuICAgICAqL1xuICAgIGdldDJEQ3Vyc29yTG9jYXRpb246IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBza2lwV3JhcHBpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lcyA9IHNraXBXcmFwcGluZyA/IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lcyA6IHRoaXMuX3RleHRMaW5lcyxcbiAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA8PSBsaW5lc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZUluZGV4OiBpLFxuICAgICAgICAgICAgY2hhckluZGV4OiBzZWxlY3Rpb25TdGFydFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgLT0gbGluZXNbaV0ubGVuZ3RoICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmRleDogaSAtIDEsXG4gICAgICAgIGNoYXJJbmRleDogbGluZXNbaSAtIDFdLmxlbmd0aCA8IHNlbGVjdGlvblN0YXJ0ID8gbGluZXNbaSAtIDFdLmxlbmd0aCA6IHNlbGVjdGlvblN0YXJ0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIChhdCB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICogaWYgc3RhcnRJbmRleCBvciBlbmRJbmRleCBhcmUgbm90IHByb3ZpZGVkLCBzZWxlY3Rpb25TdGFydCBvciBzZWxlY3Rpb25FbmQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBnZXQgZnVsbCBzdHlsZSBvciBub3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3R5bGVzIGFuIGFycmF5IHdpdGggb25lLCB6ZXJvIG9yIG1vcmUgU3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgsIGNvbXBsZXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgc3R5bGVzLnB1c2godGhpcy5nZXRTdHlsZUF0UG9zaXRpb24oaSwgY29tcGxldGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gIHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZnVsbCBzdHlsZSBpZiB0cnVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBTdHlsZSBvYmplY3QgYXQgYSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFN0eWxlQXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKSxcbiAgICAgICAgICBzdHlsZSA9IGNvbXBsZXRlID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkgOlxuICAgICAgICAgICAgdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KTtcbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uLCBpZiBubyBzZWxlY3Rpb24gZXhpc3QsIGRvIG5vdCBzZXQgYW55dGhpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kU3R5bGVzKGksIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICAvKiBub3QgaW5jbHVkZWQgaW4gX2V4dGVuZFN0eWxlcyB0byBhdm9pZCBjbGVhcmluZyBjYWNoZSBtb3JlIHRoYW4gb25jZSAqL1xuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHJlZmVyZW5jZSwgbm90IGEgY2xvbmUsIG9mIHRoZSBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIGxpbmVTdHlsZSA9IHRoaXMuc3R5bGVzICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgICBpZiAoIWxpbmVTdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lU3R5bGVbY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIGEgY2hhcmFjdGVyXG4gICAgICogdGhlIG9iamVjdCByZXR1cm5lZCBpcyBuZXdseSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhcmFjdGVyIGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hhcmFjdGVyIG9uIHRoZSBsaW5lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB8fCB7IH0sXG4gICAgICAgICAgc3R5bGVPYmplY3QgPSB7IH0sIHByb3A7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0eWxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wID0gdGhpcy5fc3R5bGVQcm9wZXJ0aWVzW2ldO1xuICAgICAgICBzdHlsZU9iamVjdFtwcm9wXSA9IHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzW3Byb3BdIDogc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxpbmUgc3R5bGUgdG8gYW4gZW1wdHkgb2JqZWN0IHNvIHRoYXQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZUxpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNvcmF0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QudGV4dERlY29yYXRpb24pIHtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSA+IC0xICYmIChvYmplY3QudW5kZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgPiAtMSAmJiAob2JqZWN0LmxpbmV0aHJvdWdoID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSA+IC0xICYmIChvYmplY3Qub3ZlcmxpbmUgPSB0cnVlKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QudGV4dERlY29yYXRpb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElUZXh0IGNsYXNzIChpbnRyb2R1Y2VkIGluIDxiPnYxLjQ8L2I+KSBFdmVudHMgYXJlIGFsc28gZmlyZWQgd2l0aCBcInRleHQ6XCJcbiAgICogcHJlZml4IHdoZW4gb2JzZXJ2aW5nIGNhbnZhcy5cbiAgICogQGNsYXNzIGZhYnJpYy5JVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuVGV4dFxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICpcbiAgICogQGZpcmVzIGNoYW5nZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjaGFuZ2VkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmVudGVyZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZXhpdGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSVRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIGtleSBjb21iaW5hdGlvbnM6PC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIE1vdmUgY3Vyc29yOiAgICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHQsIHVwLCBkb3duXG4gICAqICAgU2VsZWN0IGNoYXJhY3RlcjogICAgICAgICAgICAgICBzaGlmdCArIGxlZnQsIHNoaWZ0ICsgcmlnaHRcbiAgICogICBTZWxlY3QgdGV4dCB2ZXJ0aWNhbGx5OiAgICAgICAgIHNoaWZ0ICsgdXAsIHNoaWZ0ICsgZG93blxuICAgKiAgIE1vdmUgY3Vyc29yIGJ5IHdvcmQ6ICAgICAgICAgICAgYWx0ICsgbGVmdCwgYWx0ICsgcmlnaHRcbiAgICogICBTZWxlY3Qgd29yZHM6ICAgICAgICAgICAgICAgICAgIHNoaWZ0ICsgYWx0ICsgbGVmdCwgc2hpZnQgKyBhbHQgKyByaWdodFxuICAgKiAgIE1vdmUgY3Vyc29yIHRvIGxpbmUgc3RhcnQvZW5kOiAgY21kICsgbGVmdCwgY21kICsgcmlnaHQgb3IgaG9tZSwgZW5kXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIGxpbmU6ICBjbWQgKyBzaGlmdCArIGxlZnQsIGNtZCArIHNoaWZ0ICsgcmlnaHQgb3Igc2hpZnQgKyBob21lLCBzaGlmdCArIGVuZFxuICAgKiAgIEp1bXAgdG8gc3RhcnQvZW5kIG9mIHRleHQ6ICAgICAgY21kICsgdXAsIGNtZCArIGRvd25cbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgdGV4dDogIGNtZCArIHNoaWZ0ICsgdXAsIGNtZCArIHNoaWZ0ICsgZG93biBvciBzaGlmdCArIHBnVXAsIHNoaWZ0ICsgcGdEb3duXG4gICAqICAgRGVsZXRlIGNoYXJhY3RlcjogICAgICAgICAgICAgICBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgd29yZDogICAgICAgICAgICAgICAgICAgIGFsdCArIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSBsaW5lOiAgICAgICAgICAgICAgICAgICAgY21kICsgYmFja3NwYWNlXG4gICAqICAgRm9yd2FyZCBkZWxldGU6ICAgICAgICAgICAgICAgICBkZWxldGVcbiAgICogICBDb3B5IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgY1xuICAgKiAgIFBhc3RlIHRleHQ6ICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB2XG4gICAqICAgQ3V0IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHhcbiAgICogICBTZWxlY3QgZW50aXJlIHRleHQ6ICAgICAgICAgICAgIGN0cmwvY21kICsgYVxuICAgKiAgIFF1aXQgZWRpdGluZyAgICAgICAgICAgICAgICAgICAgdGFiIG9yIGVzY1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIG1vdXNlL3RvdWNoIGNvbWJpbmF0aW9uPC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIFBvc2l0aW9uIGN1cnNvcjogICAgICAgICAgICAgICAgY2xpY2svdG91Y2hcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoICYgZHJhZ1xuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2sgJiBzaGlmdCArIGNsaWNrXG4gICAqICAgU2VsZWN0IHdvcmQ6ICAgICAgICAgICAgICAgICAgICBkb3VibGUgY2xpY2tcbiAgICogICBTZWxlY3QgbGluZTogICAgICAgICAgICAgICAgICAgIHRyaXBsZSBjbGlja1xuICAgKiA8L3ByZT5cbiAgICovXG4gIGZhYnJpYy5JVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5UZXh0LCBmYWJyaWMuT2JzZXJ2YWJsZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnaS10ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIHN0YXJ0cyAob3Igd2hlcmUgY3Vyc29yIGlzIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uU3RhcnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBlbmRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25FbmQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDE3LDExOSwyNTUsMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0ZXh0IGlzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIHRleHQgY2FuIGJlIGVkaXRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQm9yZGVyIGNvbG9yIG9mIHRleHQgb2JqZWN0IHdoaWxlIGl0J3MgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0aW5nQm9yZGVyQ29sb3I6ICdyZ2JhKDEwMiwxNTMsMjU1LDAuMjUpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGN1cnNvciAoaW4gcHgpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JXaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgY3Vyc29yIGNvbG9yIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKiBpZiBub3Qgc2V0IChkZWZhdWx0KSB3aWxsIHRha2UgY29sb3IgZnJvbSB0aGUgdGV4dC5cbiAgICAgKiBpZiBzZXQgdG8gYSBjb2xvciB2YWx1ZSB0aGF0IGZhYnJpYyBjYW4gdW5kZXJzdGFuZCwgaXQgd2lsbFxuICAgICAqIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY29sb3Igb2YgdGhlIHRleHQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBEZWxheSBiZXR3ZWVuIGN1cnNvciBibGluayAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEZWxheTogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIGN1cnNvciBmYWRlaW4gKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRHVyYXRpb246IDYwMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGludGVybmFsIHRleHQgY2hhciB3aWR0aHMgY2FuIGJlIGNhY2hlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBET00gY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgaGlkZGVuVGV4dGFyZWEuXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYXR0YWNoaW5nIHRvIHRoZSBkb2N1bWVudC5ib2R5LlxuICAgICAqIFVzZWZ1bCB0byByZWR1Y2UgbGFnZ2lzaCByZWRyYXcgb2YgdGhlIGZ1bGwgZG9jdW1lbnQuYm9keSB0cmVlIGFuZFxuICAgICAqIGFsc28gd2l0aCBtb2RhbHMgZXZlbnQgY2FwdHVyaW5nIHRoYXQgd29uJ3QgbGV0IHRoZSB0ZXh0YXJlYSB0YWtlIGZvY3VzLlxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoaWRkZW5UZXh0YXJlYUNvbnRhaW5lcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwcyBkZXRlcm1pbmluZyB3aGVuIHRoZSB0ZXh0IGlzIGluIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZSBjdXJzb3JcbiAgICAgKiByZW5kZXJpbmcgaXMgYWx0ZXJlZC5cbiAgICAgKi9cbiAgICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdERpbWVuc2lvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3JPZmZzZXRDYWNoZSwgc28gd2UgZW5zdXJlIHRvIGNhbGN1bGF0ZSBvbmNlIHBlciByZW5kZXJDdXJzb3JcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGJ1dCBub3QgYXQgZXZlcnkgY3Vyc29yIGFuaW1hdGlvbi5cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGFuZCBjbGVhbiB0aGUgY29udGV4dFRvcFxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dFRvcDogZnVuY3Rpb24oc2tpcFJlc3RvcmUpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9jbGVhclRleHRBcmVhKGN0eCk7XG4gICAgICBza2lwUmVzdG9yZSB8fCBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICogaXQgZG9lcyBvbiB0aGUgY29udGV4dFRvcC4gSWYgY29udGV4dFRvcCBpcyBub3QgYXZhaWxhYmxlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvck9yU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcygpLFxuICAgICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCArIDQsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICBsaW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4LFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXg7XG4gICAgICBsaW5lSW5kZXggPSBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cbiAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICAgIHZhciBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICAgIGJvdW5kICYmIChsZWZ0T2Zmc2V0ID0gYm91bmQubGVmdCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiBjaGFySW5kZXggPT09IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxpbmVMZWZ0T2Zmc2V0ICsgKGxlZnRPZmZzZXQgPiAwID8gbGVmdE9mZnNldCA6IDApLFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICo9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbigpLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4IC0gMSA6IDAsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLnNjYWxlWCAqIHRoaXMuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgICBjdXJzb3JXaWR0aCA9IHRoaXMuY3Vyc29yV2lkdGggLyBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRvcE9mZnNldCA9IGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2RlbHRhWScpO1xuICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgIC0gY2hhckhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJzb3JDb2xvciB8fCB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmF3U3RhcnQgPSBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBkcmF3V2lkdGggPSBib3hFbmQgLSBib3hTdGFydCxcbiAgICAgICAgICAgIGRyYXdIZWlnaHQgPSBsaW5lSGVpZ2h0LCBleHRyYVRvcCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGRyYXdIZWlnaHQgPSAxO1xuICAgICAgICAgIGV4dHJhVG9wID0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGRyYXdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBleHRyYVRvcCxcbiAgICAgICAgICBkcmF3V2lkdGgsXG4gICAgICAgICAgZHJhd0hlaWdodCk7XG4gICAgICAgIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICs9IHJlYWxMaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRvIGtub3cgdGhlIGhlaWdodCBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgZm9udFNpemUgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBVbnVzZWQgZnJvbSB0aGUgbGlicmFyeSwgaXMgZm9yIHRoZSBlbmQgdXNlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIGlmIHRoZSB0ZXh0IG9iamVjdCBoYXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IGZvciBmaWxsZXIsIGl0IHdpbGwgcmV0dXJuIHRoYXQuXG4gICAgICogVW51c2VkIGJ5IHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7U3RyaW5nIHwgZmFicmljLkdyYWRpZW50IHwgZmFicmljLlBhdHRlcm59IENoYXJhY3RlciBjb2xvciAoZmlsbClcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjcCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGNwLmwsIGNwLmMsICdmaWxsJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdldEN1cnJlbnQuLiBmdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50Q2hhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4IC0gMSA6IDA7XG4gICAgICByZXR1cm4geyBsOiBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXgsIGM6IGNoYXJJbmRleCB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5JVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXMgPSBmYWJyaWMudXRpbC5zdHlsZXNGcm9tQXJyYXkob2JqZWN0LnN0eWxlcywgb2JqZWN0LnRleHQpO1xuICAgIC8vY29weSBvYmplY3QgdG8gcHJldmVudCBtdXRhdGlvblxuICAgIHZhciBvYmpDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0LCB7IHN0eWxlczogc3R5bGVzIH0pO1xuICAgIHBhcnNlRGVjb3JhdGlvbihvYmpDb3B5KTtcbiAgICBpZiAob2JqQ29weS5zdHlsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqQ29weS5zdHlsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBvYmpDb3B5LnN0eWxlc1tpXSkge1xuICAgICAgICAgIHBhcnNlRGVjb3JhdGlvbihvYmpDb3B5LnN0eWxlc1tpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnSVRleHQnLCBvYmpDb3B5LCBjYWxsYmFjaywgJ3RleHQnKTtcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbGwgdGhlIGludGVyYWN0aXZlIGJlaGF2aW9yIG9mIElUZXh0XG4gICAgICovXG4gICAgaW5pdEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5pdEFkZGVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0UmVtb3ZlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmluaXREb3VibGVDbGlja1NpbXVsYXRpb24oKTtcbiAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IHRoaXMubW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJhZGRlZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0QWRkZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgaWYgKCFjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5faW5pdENhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMucHVzaChfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0UmVtb3ZlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheShjYW52YXMuX2lUZXh0SW5zdGFuY2VzLCBfdGhpcyk7XG4gICAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0Q2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgb2JqLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNhbnZhcy5vbignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUNhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5vZmYoJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlID0gdGhpcy5fYW5pbWF0ZUN1cnNvcih0aGlzLCAxLCB0aGlzLmN1cnNvckR1cmF0aW9uLCAnX29uVGlja0NvbXBsZXRlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVDdXJzb3I6IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0T3BhY2l0eSwgZHVyYXRpb24sIGNvbXBsZXRlTWV0aG9kKSB7XG5cbiAgICAgIHZhciB0aWNrU3RhdGU7XG5cbiAgICAgIHRpY2tTdGF0ZSA9IHtcbiAgICAgICAgaXNBYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG9iai5hbmltYXRlKCdfY3VycmVudEN1cnNvck9wYWNpdHknLCB0YXJnZXRPcGFjaXR5LCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aWNrU3RhdGUuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvYmpbY29tcGxldGVNZXRob2RdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYW5pbWF0ZSBhIHNlbGVjdGlvbiwgb25seSBjdXJzb3JcbiAgICAgICAgICBpZiAob2JqLmNhbnZhcyAmJiBvYmouc2VsZWN0aW9uU3RhcnQgPT09IG9iai5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9iai5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aWNrU3RhdGUuaXNBYm9ydGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aWNrU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uVGlja0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2N1cnNvclRpbWVvdXQxKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgPSBfdGhpcy5fYW5pbWF0ZUN1cnNvcihfdGhpcywgMCwgdGhpcy5jdXJzb3JEdXJhdGlvbiAvIDIsICdfdGljaycpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZGVsYXllZCBjdXJzb3JcbiAgICAgKi9cbiAgICBpbml0RGVsYXllZEN1cnNvcjogZnVuY3Rpb24ocmVzdGFydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBkZWxheSA9IHJlc3RhcnQgPyAwIDogdGhpcy5jdXJzb3JEZWxheTtcblxuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdGljaygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgY3Vyc29yIGFuaW1hdGlvbiBhbmQgY2xlYXJzIGFsbCB0aW1lb3V0c1xuICAgICAqL1xuICAgIGFib3J0Q3Vyc29yQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLFxuICAgICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmFib3J0KCk7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmFib3J0KCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICAvLyB0byBjbGVhciBqdXN0IGl0ZXh0IGFyZWEgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlIGNvbnRleHRcbiAgICAgIC8vIGl0IG1heSBub3QgYmUgd29ydGggaXRcbiAgICAgIGlmIChzaG91bGRDbGVhciAmJiBjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLmNsZWFyQ29udGV4dChjYW52YXMuY29udGV4dFRvcCB8fCBjYW52YXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBlbnRpcmUgdGV4dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWxlY3RlZCB0ZXh0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYmVmb3JlIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYWZ0ZXIgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA8IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQsXG4gICAgICAgICAgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRleHRbc2VsZWN0aW9uU3RhcnRdKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRleHRbaW5kZXhdLFxuICAgICAgICAgIC8vIHdyb25nXG4gICAgICAgICAgcmVOb25Xb3JkID0gZmFicmljLnJlTm9uV29yZDtcblxuICAgICAgd2hpbGUgKCFyZU5vbldvcmQudGVzdChfY2hhcikgJiYgaW5kZXggPiAwICYmIGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uO1xuICAgICAgICBfY2hhciA9IHRleHRbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHJlTm9uV29yZC50ZXN0KF9jaGFyKSkge1xuICAgICAgICBpbmRleCArPSBkaXJlY3Rpb24gPT09IDEgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIHdvcmQgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICovXG4gICAgc2VsZWN0V29yZDogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAtMSksIC8qIHNlYXJjaCBiYWNrd2FyZHMgKi9cbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgMSk7IC8qIHNlYXJjaCBmb3J3YXJkICovXG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBsaW5lIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5TGVmdChzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5UmlnaHQoc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVudGVycyBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGVudGVyRWRpdGluZzogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmNhbGNPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5leGl0RWRpdGluZ09uT3RoZXJzKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmluaXRIaWRkZW5UZXh0YXJlYShlKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5fc2F2ZUVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fc2V0RWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl90ZXh0QmVmb3JlRWRpdCA9IHRoaXMudGV4dDtcblxuICAgICAgdGhpcy5fdGljaygpO1xuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmVudGVyZWQnKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmVudGVyZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuaW5pdE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBleGl0RWRpdGluZ09uT3RoZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAob2JqLmlzRWRpdGluZykge1xuICAgICAgICAgICAgb2JqLmV4aXRFZGl0aW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZW1vdmVcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdE1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYW52YXMub24oJ21vdXNlOm1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5fX2lzTW91c2Vkb3duIHx8ICF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZ2FpbiBmb2N1c1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG5cbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpLFxuICAgICAgICAgIGN1cnJlbnRTdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgY3VycmVudEVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgaWYgKFxuICAgICAgICAobmV3U2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duIHx8IGN1cnJlbnRTdGFydCA9PT0gY3VycmVudEVuZClcbiAgICAgICAgJiZcbiAgICAgICAgKGN1cnJlbnRTdGFydCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQgfHwgY3VycmVudEVuZCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSBjdXJyZW50U3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25FbmQgIT09IGN1cnJlbnRFbmQpIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0Q3Vyc29ySWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9ICd0ZXh0JztcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gJ3RleHQnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5lZGl0aW5nQm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gdGV4dGFyZWEgdG8gZ3JhcGhlbWUgaW5kZXhlc1xuICAgICAqL1xuICAgIGZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICB2YXIgc21hbGxlclRleHRTdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChzbWFsbGVyVGV4dFN0YXJ0KS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0IH07XG4gICAgICB9XG4gICAgICB2YXIgc21hbGxlclRleHRFbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRFbmQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgKyBncmFwaGVtZUVuZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gZmFicmljIHRvIHRleHRhcmVhIHZhbHVlc1xuICAgICAqL1xuICAgIGZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCBfdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSBfdGV4dC5zbGljZSgwLCBzdGFydCksXG4gICAgICAgICAgZ3JhcGhlbWVTdGFydCA9IHNtYWxsZXJUZXh0U3RhcnQuam9pbignJykubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gX3RleHQuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgZ3JhcGhlbWVFbmQgPSBzbWFsbGVyVGV4dEVuZC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuX3RleHQpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVGcm9tVGV4dEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmICghdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlVGV4dGFyZWFQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5sZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS50b3AgPSBzdHlsZS50b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBjb250YWlucyBzdHlsZSBmb3IgaGlkZGVuVGV4dGFyZWFcbiAgICAgKi9cbiAgICBfY2FsY1RleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4geyB4OiAxLCB5OiAxIH07XG4gICAgICB9XG4gICAgICB2YXIgZGVzaXJlZFBvc2l0aW9uID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuY29tcG9zaXRpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihkZXNpcmVkUG9zaXRpb24pLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpICogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSBib3VuZGFyaWVzLmxlZnRPZmZzZXQsXG4gICAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIHAgPSB7XG4gICAgICAgICAgICB4OiBib3VuZGFyaWVzLmxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgeTogYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGNoYXJIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgdXBwZXJDYW52YXMgPSB0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIHVwcGVyQ2FudmFzV2lkdGggPSB1cHBlckNhbnZhcy53aWR0aCAvIHJldGluYVNjYWxpbmcsXG4gICAgICAgICAgdXBwZXJDYW52YXNIZWlnaHQgPSB1cHBlckNhbnZhcy5oZWlnaHQgLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXNXaWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXNIZWlnaHQgLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IHVwcGVyQ2FudmFzLmNsaWVudFdpZHRoIC8gdXBwZXJDYW52YXNXaWR0aCxcbiAgICAgICAgICBzY2FsZVkgPSB1cHBlckNhbnZhcy5jbGllbnRIZWlnaHQgLyB1cHBlckNhbnZhc0hlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHAueCAqPSBzY2FsZVg7XG4gICAgICBwLnkgKj0gc2NhbGVZO1xuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgKyAncHgnLCBjaGFySGVpZ2h0OiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIHNlbGVjdGFibGU6IHRoaXMuc2VsZWN0YWJsZSxcbiAgICAgICAgZGVmYXVsdEN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvcixcbiAgICAgICAgbW92ZUN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMubW92ZUN1cnNvclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3NhdmVkUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5ob3ZlckN1cnNvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuX3NhdmVkUHJvcHMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLl9zYXZlZFByb3BzLnNlbGVjdGFibGU7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFg7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5kZWZhdWx0Q3Vyc29yO1xuICAgICAgICB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5tb3ZlQ3Vyc29yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGl0cyBmcm9tIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZXhpdEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzVGV4dENoYW5nZWQgPSAodGhpcy5fdGV4dEJlZm9yZUVkaXQgIT09IHRoaXMudGV4dCk7XG4gICAgICB2YXIgaGlkZGVuVGV4dGFyZWEgPSB0aGlzLmhpZGRlblRleHRhcmVhO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgICBpZiAoaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgaGlkZGVuVGV4dGFyZWEuYmx1ciAmJiBoaWRkZW5UZXh0YXJlYS5ibHVyKCk7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUgJiYgaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWRkZW5UZXh0YXJlYSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX3Jlc3RvcmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmV4aXRlZCcpO1xuICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmZpcmUoJ21vZGlmaWVkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMub2ZmKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmV4aXRlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuY2FudmFzLmZpcmUoJ29iamVjdDptb2RpZmllZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW5kIHJlZmxvdyBhIHN0eWxlIGJsb2NrIGZyb20gc3RhcnQgdG8gZW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsaW5lYXIgc3RhcnQgcG9zaXRpb24gZm9yIHJlbW92YWwgKGluY2x1ZGVkIGluIHJlbW92YWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBsaW5lYXIgZW5kIHBvc2l0aW9uIGZvciByZW1vdmFsICggZXhjbHVkZWQgZnJvbSByZW1vdmFsIClcbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZUZyb21UbzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGN1cnNvclN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjdXJzb3JFbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZW5kLCB0cnVlKSxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjdXJzb3JTdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhclN0YXJ0ID0gY3Vyc29yU3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGxpbmVFbmQgPSBjdXJzb3JFbmQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJFbmQgPSBjdXJzb3JFbmQuY2hhckluZGV4LFxuICAgICAgICAgIGksIHN0eWxlT2JqO1xuICAgICAgaWYgKGxpbmVTdGFydCAhPT0gbGluZUVuZCkge1xuICAgICAgICAvLyBzdGVwMSByZW1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVTdGFydFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lU3RhcnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDIgbW92ZSB0aGUgdHJhaWxpbmcgb2YgbGluZUVuZCB0byBsaW5lU3RhcnQgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lRW5kXSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJFbmQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUVuZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlT2JqID0gdGhpcy5zdHlsZXNbbGluZUVuZF1baV07XG4gICAgICAgICAgICBpZiAoc3R5bGVPYmopIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSB8fCAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSA9IHsgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1bY2hhclN0YXJ0ICsgaSAtIGNoYXJFbmRdID0gc3R5bGVPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAzIGRldGVjdHMgbGluZXMgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgIGZvciAoaSA9IGxpbmVTdGFydCArIDE7IGkgPD0gbGluZUVuZDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXA0IHNoaWZ0IHJlbWFpbmluZyBsaW5lcy5cbiAgICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUVuZCwgbGluZVN0YXJ0IC0gbGluZUVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFuZCBzaGlmdCBsZWZ0IG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVTdGFydF07XG4gICAgICAgICAgdmFyIGRpZmYgPSBjaGFyRW5kIC0gY2hhclN0YXJ0LCBudW1lcmljQ2hhciwgX2NoYXI7XG4gICAgICAgICAgZm9yIChpID0gY2hhclN0YXJ0OyBpIDwgY2hhckVuZDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVPYmpbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2NoYXIgaW4gdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgICAgbnVtZXJpY0NoYXIgPSBwYXJzZUludChfY2hhciwgMTApO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNDaGFyID49IGNoYXJFbmQpIHtcbiAgICAgICAgICAgICAgc3R5bGVPYmpbbnVtZXJpY0NoYXIgLSBkaWZmXSA9IHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgQ2FuIGFueSBudW1iZXI/XG4gICAgICovXG4gICAgc2hpZnRMaW5lU3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgsIG9mZnNldCkge1xuICAgICAgLy8gc2hpZnQgYWxsIGxpbmUgc3R5bGVzIGJ5IG9mZnNldCB1cHdhcmQgb3IgZG93bndhcmRcbiAgICAgIC8vIGRvIG5vdCBjbG9uZSBkZWVwLiB3ZSBuZWVkIG5ldyBhcnJheSwgbm90IG5ldyBzdHlsZSBvYmplY3RzXG4gICAgICB2YXIgY2xvbmVkU3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMpO1xuICAgICAgZm9yICh2YXIgbGluZSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICB2YXIgbnVtZXJpY0xpbmUgPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0YXJ0Q3Vyc29ySWZOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuaXNBYm9ydGVkXG4gICAgICAgIHx8ICF0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmlzQWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluc2VydGlvbiBvZiBtb3JlIGNvbnNlY3V0aXZlIHN0eWxlIGxpbmVzIGZvciB3aGVuIG9uZSBvciBtb3JlXG4gICAgICogbmV3bGluZXMgZ2V0cyBhZGRlZCB0byB0aGUgdGV4dC4gU2luY2UgY3VycmVudCBzdHlsZSBuZWVkcyB0byBiZSBzaGlmdGVkXG4gICAgICogZmlyc3Qgd2Ugc2hpZnQgdGhlIGN1cnJlbnQgc3R5bGUgb2YgdGhlIG51bWJlciBsaW5lcyBuZWVkZWQsIHRoZW4gd2UgYWRkXG4gICAgICogbmV3IGxpbmVzIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXR5IG51bWJlciBvZiBsaW5lcyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBBcnJheSBvZiBvYmplY3RzIHN0eWxlc1xuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJyZW50Q2hhclN0eWxlLFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgPSB7fSxcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IGZhbHNlLFxuICAgICAgICAgIGlzRW5kT2ZMaW5lID0gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoID09PSBjaGFySW5kZXg7XG5cbiAgICAgIHF0eSB8fCAocXR5ID0gMSk7XG4gICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lSW5kZXgsIHF0eSk7XG4gICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICBjdXJyZW50Q2hhclN0eWxlID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggPT09IDAgPyBjaGFySW5kZXggOiBjaGFySW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGNsb25lIHN0eWxlcyBvZiBhbGwgY2hhcnNcbiAgICAgIC8vIGFmdGVyIGN1cnNvciBvbnRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgdmFyIG51bUluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bUluZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzW251bUluZGV4IC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIC8vIHJlbW92ZSBsaW5lcyBmcm9tIHRoZSBwcmV2aW91cyBsaW5lIHNpbmNlIHRoZXkncmUgb24gYSBuZXcgbGluZSBub3dcbiAgICAgICAgICBpZiAoIShpc0VuZE9mTGluZSAmJiBjaGFySW5kZXggPT09IDApKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVDYXJyaWVkT3ZlciA9IGZhbHNlO1xuICAgICAgaWYgKHNvbWV0aGluZ0FkZGVkICYmICFpc0VuZE9mTGluZSkge1xuICAgICAgICAvLyBpZiBpcyBlbmQgb2YgbGluZSwgdGhlIGV4dHJhIHN0eWxlIHdlIGNvcGllZFxuICAgICAgICAvLyBpcyBwcm9iYWJseSBub3Qgc29tZXRoaW5nIHdlIHdhbnRcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IG5ld0xpbmVTdHlsZXM7XG4gICAgICAgIHN0eWxlQ2FycmllZE92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlQ2FycmllZE92ZXIpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCBsaW5lIG9mIHNpbmNlIHdlIGFscmVhZHkgcHJlcGFyZWQgaXQuXG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBhbGwgdGhlIGxpbmVzIG9yIGFsbCB0aGUgb3RoZXIgbGluZXNcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIHdoaWxlIChxdHkgPiAwKSB7XG4gICAgICAgIGlmIChjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZVtxdHkgLSAxXSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGNvcGllZFN0eWxlW3F0eSAtIDFdKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjdXJyZW50Q2hhclN0eWxlKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldO1xuICAgICAgICB9XG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gbGluZS9jaGFyIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFudGl0eSBudW1iZXIgU3R5bGUgb2JqZWN0IHRvIGluc2VydCwgaWYgZ2l2ZW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXVhbnRpdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY3VycmVudExpbmVTdHlsZXMgPyBjbG9uZShjdXJyZW50TGluZVN0eWxlcykgOiB7fTtcblxuICAgICAgcXVhbnRpdHkgfHwgKHF1YW50aXR5ID0gMSk7XG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgcXVhbnRpdHkgZm9yd2FyZFxuICAgICAgLy8gMCwxLDIsMyAtPiAoY2hhckluZGV4PTIpIC0+IDAsMSwzLDQgLT4gKGluc2VydCAyKSAtPiAwLDEsMiwzLDRcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkKSB7XG4gICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIHF1YW50aXR5XSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgdGhlIHN0eWxlIGlmIHRoZXJlIHdhcyBub3RoaW5nIG1vdmVkIHRoZXJlXG4gICAgICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXggLSBxdWFudGl0eV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICB3aGlsZSAocXVhbnRpdHktLSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29waWVkU3R5bGVbcXVhbnRpdHldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShjb3BpZWRTdHlsZVtxdWFudGl0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0eWxlID0gY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4ID8gY2hhckluZGV4IC0gMSA6IDFdO1xuICAgICAgd2hpbGUgKG5ld1N0eWxlICYmIHF1YW50aXR5LS0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShuZXdTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0KHMpXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5zZXJ0ZWRUZXh0IENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGN1cnNvciBpbmRleCBmb3IgaW5zZXJ0aW5nIHN0eWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvcGllZFN0eWxlXSBhcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGluc2VydC5cbiAgICAgKi9cbiAgICBpbnNlcnROZXdTdHlsZUJsb2NrOiBmdW5jdGlvbihpbnNlcnRlZFRleHQsIHN0YXJ0LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnNvckxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgYWRkZWRMaW5lcyA9IFswXSwgbGluZXNMZW5ndGggPSAwO1xuICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIGhvdyBtYW55IGNoYXIgcGVyIGxpbmVzIGFyZSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnNlcnRlZFRleHRbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgbGluZXNMZW5ndGgrKztcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ3RoXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBmaXJzdCBsaW5lIGNvcHkgdGhlIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgY2hhciBwb3NpdGlvbi5cbiAgICAgIGlmIChhZGRlZExpbmVzWzBdID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4LCBhZGRlZExpbmVzWzBdLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1swXSArIDEpO1xuICAgICAgfVxuICAgICAgbGluZXNMZW5ndGggJiYgdGhpcy5pbnNlcnROZXdsaW5lU3R5bGVPYmplY3QoXG4gICAgICAgIGN1cnNvckxvYy5saW5lSW5kZXgsIGN1cnNvckxvYy5jaGFySW5kZXggKyBhZGRlZExpbmVzWzBdLCBsaW5lc0xlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCArIGksIDAsIGFkZGVkTGluZXNbaV0sIGNvcGllZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICAgIC8vIHRoaXMgdGVzdCBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBjbG9zZSAjNjg0MVxuICAgICAgICAgIC8vIHdoZW4gYSBwYXN0ZWQgYnVmZmVyIGJlZ2lucyB3aXRoIGEgbmV3bGluZSB0aGVuXG4gICAgICAgICAgLy8gdGhpcy5zdHlsZXNbY3Vyc29yTG9jLmxpbmVJbmRleCArIGldIGFuZCBjb3BpZWRTdHlsZVswXVxuICAgICAgICAgIC8vIG1heSBiZSB1bmRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXSAmJiBjb3BpZWRTdHlsZVswXSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbY3Vyc29yTG9jLmxpbmVJbmRleCArIGldWzBdID0gY29waWVkU3R5bGVbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1tpXSArIDEpO1xuICAgICAgfVxuICAgICAgLy8gd2UgdXNlIGkgb3V0c2lkZSB0aGUgbG9vcCB0byBnZXQgaXQgbGlrZSBsaW5lc0xlbmd0aFxuICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBhY2NvcmRpbmcgdG8gdGhlIG5ldyBwb3NpdGlvbiBvZiBjdXJzb3JcbiAgICAgKiBtaW1pYyB0aGUga2V5IC0gbW91c2UgbmF2aWdhdGlvbiB3aGVuIHNoaWZ0IGlzIHByZXNzZWQuXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKG5ld1NlbGVjdGlvbiA8PSBzdGFydCkge1xuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobmV3U2VsZWN0aW9uID4gc3RhcnQgJiYgbmV3U2VsZWN0aW9uIDwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmV3U2VsZWN0aW9uIGlzID4gc2VsZWN0aW9uIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwiZGJjbGlja1wiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXREb3VibGVDbGlja1NpbXVsYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gZm9yIGRvdWJsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAvLyBmb3IgdHJpcGxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSB7IH07XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIHRvIHNpbXVsYXRlIHRyaXBsZSBjbGlja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19uZXdDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbmV3UG9pbnRlciA9IG9wdGlvbnMucG9pbnRlcjtcbiAgICBpZiAodGhpcy5pc1RyaXBsZUNsaWNrKG5ld1BvaW50ZXIpKSB7XG4gICAgICB0aGlzLmZpcmUoJ3RyaXBsZWNsaWNrJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zdG9wRXZlbnQob3B0aW9ucy5lKTtcbiAgICB9XG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gdGhpcy5fX2xhc3RDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSB0aGlzLl9fbmV3Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgdGhpcy5fX2xhc3RJc0VkaXRpbmcgPSB0aGlzLmlzRWRpdGluZztcbiAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgfSxcblxuICBpc1RyaXBsZUNsaWNrOiBmdW5jdGlvbihuZXdQb2ludGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXdDbGlja1RpbWUgLSB0aGlzLl9fbGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdENsaWNrVGltZSAtIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueCA9PT0gbmV3UG9pbnRlci54ICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci55ID09PSBuZXdQb2ludGVyLnk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RvcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24gJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnQgaGFuZGxlcnMgcmVsYXRlZCB0byBjdXJzb3Igb3Igc2VsZWN0aW9uXG4gICAqL1xuICBpbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdE1vdXNlZG93bkhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRNb3VzZXVwSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdENsaWNrcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIGRvdWJsZSBjbGljaywgc2VsZWN0IGEgd29yZFxuICAgKi9cbiAgZG91YmxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdFdvcmQodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIHRyaXBsZSBjbGljaywgc2VsZWN0IGEgbGluZVxuICAgKi9cbiAgdHJpcGxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdExpbmUodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBkb3VibGUgYW5kIHRyaXBsZSBjbGljayBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgaW5pdENsaWNrczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2VkYmxjbGljaycsIHRoaXMuZG91YmxlQ2xpY2tIYW5kbGVyKTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIHRoaXMudHJpcGxlQ2xpY2tIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBfbW91c2VEb3duXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IGZpbmQgdGhlIGNsaWNrIHBvc2l0aW9uLCBzZXQgc2VsZWN0aW9uU3RhcnRcbiAgICogZmluZCBzZWxlY3Rpb25FbmQsIGluaXRpYWxpemUgdGhlIGRyYXdpbmcgb2YgZWl0aGVyIGN1cnNvciBvciBzZWxlY3Rpb24gYXJlYVxuICAgKiBpbml0aWFsaXppbmcgYSBtb3VzZWREb3duIG9uIGEgdGV4dCBhcmVhIHdpbGwgY2FuY2VsIGZhYnJpY2pzIGtub3dsZWRnZSBvZlxuICAgKiBjdXJyZW50IGNvbXBvc2l0aW9uTW9kZS4gSXQgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0Q3Vyc29yQnlDbGljayhvcHRpb25zLmUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRWRpdGluZykge1xuICAgICAgdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gbW91c2Vkb3duOmJlZm9yZVxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiB2ZXJpZnkgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHNlbGVjdGVkIHdoZW4gbW91c2luZyBkb3duXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlckJlZm9yZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gd2Ugd2FudCB0byBhdm9pZCB0aGF0IGFuIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZCBhbmQgdGhlbiBiZWNvbWVzIHVuc2VsZWN0YWJsZSxcbiAgICAvLyBtYXkgdHJpZ2dlciBlZGl0aW5nIG1vZGUgaW4gc29tZSB3YXkuXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMgPT09IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNlZG93bkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIpO1xuICAgIHRoaXMub24oJ21vdXNlZG93bjpiZWZvcmUnLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyQmVmb3JlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZXVwXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNldXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHN0YW5kYXJkIGhhbmRsZXIgZm9yIG1vdXNlIHVwLCBvdmVycmlkYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHwgdGhpcy5ncm91cCB8fFxuICAgICAgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9wdGlvbnMudHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCkgfHxcbiAgICAgIChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZSA9IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZSAmJiBjdXJyZW50QWN0aXZlICE9PSB0aGlzKSB7XG4gICAgICAgIC8vIGF2b2lkIHJ1bm5pbmcgdGhpcyBsb2dpYyB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZSBvYmplY3RcbiAgICAgICAgLy8gdGhpcyBiZWNhdXNlIGlzIHBvc3NpYmxlIHdpdGggc2hpZnQgY2xpY2sgYW5kIGZhc3QgY2xpY2tzLFxuICAgICAgICAvLyB0byByYXBpZGx5IGRlc2VsZWN0IGFuZCByZXNlbGVjdCB0aGlzIG9iamVjdCBhbmQgdHJpZ2dlciBhbiBlbnRlckVkaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLl9fY29ybmVyKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJzb3IgbG9jYXRpb24gaW4gYSB0ZXh0IGRlcGVuZGluZyBvbiBwYXNzZWQgcG9pbnRlciAoeC95KSBvYmplY3RcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHNldEN1cnNvckJ5Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKGUpLFxuICAgICAgICBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGhlaWdodCA8PSBtb3VzZU9mZnNldC55KSB7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsaW5lSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBjaGFySW5kZXggKz0gdGhpcy5fdGV4dExpbmVzW2kgLSAxXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgd2lkdGggPSBsaW5lTGVmdE9mZnNldCAqIHRoaXMuc2NhbGVYO1xuICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XTtcbiAgICAvLyBoYW5kbGluZyBvZiBSVEw6IGluIG9yZGVyIHRvIGdldCB0aGluZ3Mgd29yayBjb3JyZWN0bHksXG4gICAgLy8gd2UgYXNzdW1lIFJUTCB3cml0aW5nIGlzIG1pcnJvcmVkIGNvbXBhcmVkIHRvIExUUiB3cml0aW5nLlxuICAgIC8vIHNvIGluIHBvc2l0aW9uIGRldGVjdGlvbiB3ZSBtaXJyb3IgdGhlIFggb2Zmc2V0LCBhbmQgd2hlbiBpcyB0aW1lXG4gICAgLy8gb2YgcmVuZGVyaW5nIGl0LCB3ZSBtaXJyb3IgaXQgYWdhaW4uXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgbW91c2VPZmZzZXQueCA9IHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCAtIG1vdXNlT2Zmc2V0LnggKyB3aWR0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICAvLyBpIHJlbW92ZWQgc29tZXRoaW5nIGFib3V0IGZsaXBYIGhlcmUsIGNoZWNrLlxuICAgICAgd2lkdGggKz0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS5rZXJuZWRXaWR0aCAqIHRoaXMuc2NhbGVYO1xuICAgICAgaWYgKHdpZHRoIDw9IG1vdXNlT2Zmc2V0LngpIHtcbiAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQobW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGNoYXJJbmRleCwgamxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0OiBmdW5jdGlvbihtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pIHtcbiAgICAvLyB3ZSBuZWVkIE1hdGguYWJzIGJlY2F1c2Ugd2hlbiB3aWR0aCBpcyBhZnRlciB0aGUgbGFzdCBjaGFyLCB0aGUgb2Zmc2V0IGlzIGdpdmVuIGFzIDEsIHdoaWxlIGlzIDBcbiAgICB2YXIgZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciA9IG1vdXNlT2Zmc2V0LnggLSBwcmV2V2lkdGgsXG4gICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPSB3aWR0aCAtIG1vdXNlT2Zmc2V0LngsXG4gICAgICAgIG9mZnNldCA9IGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPiBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yIHx8XG4gICAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA8IDAgPyAwIDogMSxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBpbmRleCArIG9mZnNldDtcbiAgICAvLyBpZiBvYmplY3QgaXMgaG9yaXpvbnRhbGx5IGZsaXBwZWQsIG1pcnJvciBjdXJzb3IgbG9jYXRpb24gZnJvbSB0aGUgZW5kXG4gICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gamxlbiAtIG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTZWxlY3Rpb25TdGFydDtcbiAgfVxufSk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBoaWRkZW4gdGV4dGFyZWEgKG5lZWRlZCB0byBicmluZyB1cCBrZXlib2FyZCBpbiBpT1MpXG4gICAqL1xuICBpbml0SGlkZGVuVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnZGF0YS1mYWJyaWMtaGlkZGVudGV4dGFyZWEnLCAnJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3dyYXAnLCAnb2ZmJyk7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAvLyBsaW5lLWhlaWdodDogMXB4OyB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBzdHlsZSB0byBmaXggdGhpczpcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04NzA5NjZcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBzdHlsZS50b3AgK1xuICAgICc7IGxlZnQ6ICcgKyBzdHlsZS5sZWZ0ICsgJzsgei1pbmRleDogLTk5OTsgb3BhY2l0eTogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxcHg7IGZvbnQtc2l6ZTogMXB4OycgK1xuICAgICcgcGFkZGluZy10b3A6ICcgKyBzdHlsZS5mb250U2l6ZSArICc7JztcblxuICAgIGlmICh0aGlzLmhpZGRlblRleHRhcmVhQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuVGV4dGFyZWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuVGV4dGFyZWEpO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleXVwJywgdGhpcy5vbktleVVwLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdpbnB1dCcsIHRoaXMub25JbnB1dC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29weScsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY3V0JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdwYXN0ZScsIHRoaXMucGFzdGUuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9uc3RhcnQnLCB0aGlzLm9uQ29tcG9zaXRpb25TdGFydC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb251cGRhdGUnLCB0aGlzLm9uQ29tcG9zaXRpb25VcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9uZW5kJywgdGhpcy5vbkNvbXBvc2l0aW9uRW5kLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duXG4gICAqIE1hcCBhIHNwZWNpYWwga2V5IHRvIGEgZnVuY3Rpb24gb2YgdGhlIGluc3RhbmNlL3Byb3RvdHlwZVxuICAgKiBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgYmVoYXZpb3VyIGZvciBFU0Mgb3IgVEFCIG9yIGFycm93cywgeW91IGhhdmUgdG8gY2hhbmdlXG4gICAqIHRoaXMgbWFwIHNldHRpbmcgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IHlvdSBidWlsZCBvbiB0aGUgZmFicmljLkl0ZXh0IG9yXG4gICAqIHlvdXIgcHJvdG90eXBlLlxuICAgKiB0aGUgbWFwIGNoYW5nZSB3aWxsIGFmZmVjdCBhbGwgSW5zdGFuY2VzIHVubGVzcyB5b3UgbmVlZCBmb3Igb25seSBzb21lIHRleHQgSW5zdGFuY2VzXG4gICAqIGluIHRoYXQgY2FzZSB5b3UgaGF2ZSB0byBjbG9uZSB0aGlzIG9iamVjdCBhbmQgYXNzaWduIHlvdXIgSW5zdGFuY2UuXG4gICAqIHRoaXMua2V5c01hcCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmtleXNNYXApO1xuICAgKiBUaGUgZnVuY3Rpb24gbXVzdCBiZSBpbiBmYWJyaWMuSXRleHQucHJvdG90eXBlLm15RnVuY3Rpb24gQW5kIHdpbGwgcmVjZWl2ZSBldmVudCBhcyBhcmdzWzBdXG4gICAqL1xuICBrZXlzTWFwOiB7XG4gICAgOTogICdleGl0RWRpdGluZycsXG4gICAgMjc6ICdleGl0RWRpdGluZycsXG4gICAgMzM6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM0OiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDM1OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzNjogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzNzogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzODogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzk6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDQwOiAnbW92ZUN1cnNvckRvd24nLFxuICB9LFxuXG4gIGtleXNNYXBSdGw6IHtcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAzMzogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzQ6ICdtb3ZlQ3Vyc29yRG93bicsXG4gICAgMzU6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM3OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzODogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzk6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgNDA6ICdtb3ZlQ3Vyc29yRG93bicsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5VXAgKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBVcDoge1xuICAgIDY3OiAnY29weScsXG4gICAgODg6ICdjdXQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93biArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcERvd246IHtcbiAgICA2NTogJ3NlbGVjdEFsbCdcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAvLyBObyBuZWVkIHRvIHRyaWdnZXIgY2xpY2sgZXZlbnQgaGVyZSwgZm9jdXMgaXMgZW5vdWdoIHRvIGhhdmUgdGhlIGtleWJvYXJkIGFwcGVhciBvbiBBbmRyb2lkXG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudFxuICAgKiBvbmx5IHVzZWQgZm9yIGFycm93cyBhbmQgY29tYmluYXRpb24gb2YgbW9kaWZpZXIga2V5cy5cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5RG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleU1hcCA9IHRoaXMuZGlyZWN0aW9uID09PSAncnRsJyA/IHRoaXMua2V5c01hcFJ0bCA6IHRoaXMua2V5c01hcDtcbiAgICBpZiAoZS5rZXlDb2RlIGluIGtleU1hcCkge1xuICAgICAgdGhpc1trZXlNYXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcERvd24pICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwRG93bltlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmtleUNvZGUgPj0gMzMgJiYgZS5rZXlDb2RlIDw9IDQwKSB7XG4gICAgICAvLyBpZiBpIHByZXNzIGFuIGFycm93IGtleSBqdXN0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudFxuICAgKiBXZSBoYW5kbGUgS2V5VXAgYmVjYXVzZSBpZTExIGFuZCBlZGdlIGhhdmUgZGlmZmljdWx0aWVzIGNvcHkvcGFzdGluZ1xuICAgKiBpZiBhIGNvcHkvY3V0IGV2ZW50IGZpcmVkLCBrZXl1cCBpcyBkaXNtaXNzZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8IHRoaXMuX2NvcHlEb25lIHx8IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgIHRoaXMuX2NvcHlEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBVcCkgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBVcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBvbklucHV0IGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbklucHV0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZyb21QYXN0ZSA9IHRoaXMuZnJvbVBhc3RlO1xuICAgIHRoaXMuZnJvbVBhc3RlID0gZmFsc2U7XG4gICAgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVjaXNpb25zIGFib3V0IHN0eWxlIGNoYW5nZXMuXG4gICAgdmFyIG5leHRUZXh0ID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpLmdyYXBoZW1lVGV4dCxcbiAgICAgICAgY2hhckNvdW50ID0gdGhpcy5fdGV4dC5sZW5ndGgsXG4gICAgICAgIG5leHRDaGFyQ291bnQgPSBuZXh0VGV4dC5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWRUZXh0LCBpbnNlcnRlZFRleHQsXG4gICAgICAgIGNoYXJEaWZmID0gbmV4dENoYXJDb3VudCAtIGNoYXJDb3VudCxcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCxcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgY29waWVkU3R5bGUsIHJlbW92ZUZyb20sIHJlbW92ZVRvO1xuICAgIGlmICh0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID09PSAnJykge1xuICAgICAgdGhpcy5zdHlsZXMgPSB7IH07XG4gICAgICB0aGlzLnVwZGF0ZUZyb21UZXh0QXJlYSgpO1xuICAgICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dGFyZWFTZWxlY3Rpb24gPSB0aGlzLmZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uKFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZVxuICAgICk7XG4gICAgdmFyIGJhY2tEZWxldGUgPSBzZWxlY3Rpb25TdGFydCA+IHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgY2hhckRpZmYgKz0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5leHRDaGFyQ291bnQgPCBjaGFyQ291bnQpIHtcbiAgICAgIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25FbmQgKyBjaGFyRGlmZiwgc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0IC0gY2hhckRpZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRlZFRleHQgPSBuZXh0VGV4dC5zbGljZSh0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQgLSBjaGFyRGlmZiwgdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kKTtcbiAgICBpZiAocmVtb3ZlZFRleHQgJiYgcmVtb3ZlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoaW5zZXJ0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBsZXQncyBjb3B5IHNvbWUgc3R5bGUgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAvLyB3ZSB3YW50IHRvIGNvcHkgdGhlIHN0eWxlIGJlZm9yZSB0aGUgY3Vyc29yIE9SIHRoZSBzdHlsZSBhdCB0aGUgY3Vyc29yIGlmIHNlbGVjdGlvblxuICAgICAgICAvLyBpcyBiaWdnZXIgdGhhbiAwLlxuICAgICAgICBjb3BpZWRTdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25TdGFydCArIDEsIGZhbHNlKTtcbiAgICAgICAgLy8gbm93IGR1cGxpY2F0ZSB0aGUgc3R5bGUgb25lIGZvciBlYWNoIGluc2VydGVkIHRleHQuXG4gICAgICAgIGNvcGllZFN0eWxlID0gaW5zZXJ0ZWRUZXh0Lm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB0aGlzIHJldHVybiBhbiBhcnJheSBvZiByZWZlcmVuY2VzLCBidXQgdGhhdCBpcyBmaW5lIHNpbmNlIHdlIGFyZVxuICAgICAgICAgIC8vIGNvcHlpbmcgdGhlIHN0eWxlIGxhdGVyLlxuICAgICAgICAgIHJldHVybiBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIC8vIGRldGVjdCBkaWZmZXJlbmNlcyBiZXR3ZWVuIGZvcndhcmREZWxldGUgYW5kIGJhY2tEZWxldGVcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvbkVuZCAtIHJlbW92ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQgKyByZW1vdmVkVGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHJlbW92ZUZyb20sIHJlbW92ZVRvKTtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChmcm9tUGFzdGUgJiYgaW5zZXJ0ZWRUZXh0LmpvaW4oJycpID09PSBmYWJyaWMuY29waWVkVGV4dCAmJiAhZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSkge1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGZhYnJpYy5jb3BpZWRUZXh0U3R5bGU7XG4gICAgICB9XG4gICAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soaW5zZXJ0ZWRUZXh0LCBzZWxlY3Rpb25TdGFydCwgY29waWVkU3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUZyb21UZXh0QXJlYSgpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQ29tcG9zaXRpb24gc3RhcnRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIGVuZFxuICAgKi9cbiAgb25Db21wb3NpdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICB9LFxuXG4gIC8vIC8qKlxuICAvLyAgKiBDb21wb3NpdGlvbiB1cGRhdGVcbiAgLy8gICovXG4gIG9uQ29tcG9zaXRpb25VcGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICB0aGlzLmNvbXBvc2l0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kO1xuICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3BpZXMgc2VsZWN0ZWQgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAvL2RvIG5vdCBjdXQtY29weSBpZiBubyBzZWxlY3Rpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMuY29waWVkVGV4dCA9IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCk7XG4gICAgaWYgKCFmYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlKSB7XG4gICAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jb3B5RG9uZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhc3RlcyB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBwYXN0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IENsaXBib2FyZCBkYXRhIG9iamVjdFxuICAgKi9cbiAgX2dldENsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS5jbGlwYm9hcmREYXRhKSB8fCBmYWJyaWMud2luZG93LmNsaXBib2FyZERhdGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSB3aWR0aCBpbiBwaXhlbHMgYmVmb3JlIHRoZSBjdXJzb3Igb24gdGhlIHNhbWUgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aEJlZm9yZUN1cnNvciB3aWR0aCBiZWZvcmUgY3Vyc29yXG4gICAqL1xuICBfZ2V0V2lkdGhCZWZvcmVDdXJzb3I6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KSwgYm91bmQ7XG5cbiAgICBpZiAoY2hhckluZGV4ID4gMCkge1xuICAgICAgYm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgKz0gYm91bmQubGVmdCArIGJvdW5kLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGhCZWZvcmVDdXJzb3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgc3RhcnQgb2Zmc2V0IG9mIGEgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXREb3duQ3Vyc29yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgdmFyIHNlbGVjdGlvblByb3AgPSB0aGlzLl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQoZSwgaXNSaWdodCksXG4gICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblByb3ApLFxuICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXg7XG4gICAgLy8gaWYgb24gbGFzdCBsaW5lLCBkb3duIGN1cnNvciBnb2VzIHRvIGVuZCBvZiBsaW5lXG4gICAgaWYgKGxpbmVJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDEgfHwgZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIC8vIG1vdmUgdG8gdGhlIGVuZCBvZiBhIHRleHRcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0Lmxlbmd0aCAtIHNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4ICsgMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QWZ0ZXJDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZShjaGFySW5kZXgpO1xuICAgIHJldHVybiB0ZXh0QWZ0ZXJDdXJzb3IubGVuZ3RoICsgaW5kZXhPbk90aGVyTGluZSArIDEgKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGxpbmVJbmRleCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHByaXZhdGVcbiAgICogSGVscHMgZmluZGluZyBpZiB0aGUgb2Zmc2V0IHNob3VsZCBiZSBjb3VudGVkIGZyb20gU3RhcnQgb3IgRW5kXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQgJiYgaXNSaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFVwQ3Vyc29yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgdmFyIHNlbGVjdGlvblByb3AgPSB0aGlzLl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQoZSwgaXNSaWdodCksXG4gICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblByb3ApLFxuICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXg7XG4gICAgaWYgKGxpbmVJbmRleCA9PT0gMCB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzMykge1xuICAgICAgLy8gaWYgb24gZmlyc3QgbGluZSwgdXAgY3Vyc29yIGdvZXMgdG8gc3RhcnQgb2YgbGluZVxuICAgICAgcmV0dXJuIC1zZWxlY3Rpb25Qcm9wO1xuICAgIH1cbiAgICB2YXIgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgaW5kZXhPbk90aGVyTGluZSA9IHRoaXMuX2dldEluZGV4T25MaW5lKGxpbmVJbmRleCAtIDEsIHdpZHRoQmVmb3JlQ3Vyc29yKSxcbiAgICAgICAgdGV4dEJlZm9yZUN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKDAsIGNoYXJJbmRleCksXG4gICAgICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0ID0gdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChsaW5lSW5kZXggLSAxKTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGhcbiAgICAgKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGggKyAoMSAtIG1pc3NpbmdOZXdsaW5lT2Zmc2V0KTtcbiAgfSxcblxuICAvKipcbiAgICogZm9yIGEgZ2l2ZW4gd2lkdGggaXQgZm91bmRzIHRoZSBtYXRjaGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5kZXhPbkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgd2lkdGgpIHtcblxuICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KSxcbiAgICAgICAgd2lkdGhPZkNoYXJzT25MaW5lID0gbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGluZGV4T25MaW5lID0gMCwgY2hhcldpZHRoLCBmb3VuZE1hdGNoO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgY2hhcldpZHRoID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS53aWR0aDtcbiAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAod2lkdGhPZkNoYXJzT25MaW5lID4gd2lkdGgpIHtcbiAgICAgICAgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSAtIGNoYXJXaWR0aCxcbiAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSxcbiAgICAgICAgICAgIG9mZnNldEZyb21MZWZ0RWRnZSA9IE1hdGguYWJzKGxlZnRFZGdlIC0gd2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbVJpZ2h0RWRnZSA9IE1hdGguYWJzKHJpZ2h0RWRnZSAtIHdpZHRoKTtcblxuICAgICAgICBpbmRleE9uTGluZSA9IG9mZnNldEZyb21SaWdodEVkZ2UgPCBvZmZzZXRGcm9tTGVmdEVkZ2UgPyBqIDogKGogLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhY2hlZCBlbmRcbiAgICBpZiAoIWZvdW5kTWF0Y2gpIHtcbiAgICAgIGluZGV4T25MaW5lID0gbGluZS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleE9uTGluZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgZG93blxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ0Rvd24nLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ1VwJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCBvciBkb3duLCBmaXJlcyB0aGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ1VwJyBvciAnRG93bidcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yVXBPckRvd246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIC8vIGdldFVwQ3Vyc29yT2Zmc2V0XG4gICAgLy8gZ2V0RG93bkN1cnNvck9mZnNldFxuICAgIHZhciBhY3Rpb24gPSAnZ2V0JyArIGRpcmVjdGlvbiArICdDdXJzb3JPZmZzZXQnLFxuICAgICAgICBvZmZzZXQgPSB0aGlzW2FjdGlvbl0oZSwgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB3aXRoIHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0J1xuICAgICAgPyB0aGlzLnNlbGVjdGlvblN0YXJ0ICsgb2Zmc2V0XG4gICAgICA6IHRoaXMuc2VsZWN0aW9uRW5kICsgb2Zmc2V0O1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIHdpdGhvdXQgc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhvdXRTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdMZWZ0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIF9tb3ZlOiBmdW5jdGlvbihlLCBwcm9wLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV3VmFsdWU7XG4gICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRXb3JkQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzUgfHwgIGUua2V5Q29kZSA9PT0gMzYgKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRMaW5lQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzW3Byb3BdICs9IGRpcmVjdGlvbiA9PT0gJ0xlZnQnID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHRoaXNbcHJvcF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUxlZnQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnTGVmdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVSaWdodDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdSaWdodCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuXG4gICAgLy8gb25seSBtb3ZlIGN1cnNvciB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbixcbiAgICAvLyBvdGhlcndpc2Ugd2UgZGlzY2FyZCBpdCwgYW5kIGxlYXZlIGN1cnNvciBvbiBzYW1lIHBsYWNlXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApIHtcbiAgICAgIGNoYW5nZSA9IHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuXG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApe1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ1JpZ2h0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCBvciBMZWZ0LCBmaXJlcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdMZWZ0JywgJ1JpZ2h0J1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JMZWZ0T3JSaWdodDogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgdmFyIGFjdGlvbk5hbWUgPSAnbW92ZUN1cnNvcicgKyBkaXJlY3Rpb24gKyAnV2l0aCc7XG4gICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ1NoaWZ0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdvdXRTaGlmdCc7XG4gICAgfVxuICAgIGlmICh0aGlzW2FjdGlvbk5hbWVdKGUpKSB7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kICE9PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjaGFuZ2VkID0gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hhcmFjdGVycyBmcm9tIHN0YXJ0L2VuZFxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgcmVtb3ZlQ2hhcnM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB0aGlzLl90ZXh0LnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpbnNlcnQgY2hhcmFjdGVycyBhdCBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIHN0YXJ0IHBvc2l0aW9uLlxuICAgKiBzdGFydCAgZXF1YWwgMSBpdCBtZWFucyB0aGUgdGV4dCBnZXQgaW5zZXJ0ZWQgYmV0d2VlbiBhY3R1YWwgZ3JhcGhlbWUgMCBhbmQgMVxuICAgKiBpZiBzdHlsZSBhcnJheSBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBhcyB0aGUgc2FtZSBsZW5ndGggb2YgdGV4dCBpbiBncmFwaGVtZXNcbiAgICogaWYgZW5kIGlzIHByb3ZpZGVkIGFuZCBpcyBiaWdnZXIgdGhhbiBzdGFydCwgb2xkIHRleHQgaXMgcmVwbGFjZWQuXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlIGFycmF5IG9mIHN0eWxlIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIGluc2VydENoYXJzOiBmdW5jdGlvbih0ZXh0LCBzdHlsZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdmFyIGdyYXBoZW1lcyA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHRleHQpO1xuICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhncmFwaGVtZXMsIHN0YXJ0LCBzdHlsZSk7XG4gICAgdGhpcy5fdGV4dCA9IFtdLmNvbmNhdCh0aGlzLl90ZXh0LnNsaWNlKDAsIHN0YXJ0KSwgZ3JhcGhlbWVzLCB0aGlzLl90ZXh0LnNsaWNlKGVuZCkpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBtdWx0aXBsZVNwYWNlc1JlZ2V4ID0gLyAgKy9nO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTVkdUZXh0QW5kQmcodGV4dEFuZEJnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKFxuICAgICAgICB0aGlzLl90b1NWRygpLFxuICAgICAgICB7IHJldml2ZXI6IHJldml2ZXIsIG5vU3R5bGU6IHRydWUsIHdpdGhTaGFkb3c6IHRydWUgfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGVmdFRvcE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dExlZnQ6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgdGV4dFRvcDogLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGluZVRvcDogdGhpcy5nZXRIZWlnaHRPZkxpbmUoMClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dyYXBTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRBbmRCZykge1xuICAgICAgdmFyIG5vU2hhZG93ID0gdHJ1ZSxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dFRvcE9mZnNldCBUZXh0IHRvcCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dExlZnRPZmZzZXQgVGV4dCBsZWZ0IG9mZnNldFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0U1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0VG9wT2Zmc2V0LCB0ZXh0TGVmdE9mZnNldCkge1xuICAgICAgdmFyIHRleHRTcGFucyA9IFtdLFxuICAgICAgICAgIHRleHRCZ1JlY3RzID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gdGV4dFRvcE9mZnNldCwgbGluZU9mZnNldDtcbiAgICAgIC8vIGJvdW5kaW5nLWJveCBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLl9zZXRTVkdCZyh0ZXh0QmdSZWN0cyk7XG5cbiAgICAgIC8vIHRleHQgYW5kIHRleHQtYmFja2dyb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyh0ZXh0QmdSZWN0cywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lVGV4dCh0ZXh0U3BhbnMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0U3BhbnM6IHRleHRTcGFucyxcbiAgICAgICAgdGV4dEJnUmVjdHM6IHRleHRCZ1JlY3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVUZXh0Q2hhclNwYW46IGZ1bmN0aW9uKF9jaGFyLCBzdHlsZURlY2wsIGxlZnQsIHRvcCkge1xuICAgICAgdmFyIHNob3VsZFVzZVdoaXRlc3BhY2UgPSBfY2hhciAhPT0gX2NoYXIudHJpbSgpIHx8IF9jaGFyLm1hdGNoKG11bHRpcGxlU3BhY2VzUmVnZXgpLFxuICAgICAgICAgIHN0eWxlUHJvcHMgPSB0aGlzLmdldFN2Z1NwYW5TdHlsZXMoc3R5bGVEZWNsLCBzaG91bGRVc2VXaGl0ZXNwYWNlKSxcbiAgICAgICAgICBmaWxsU3R5bGVzID0gc3R5bGVQcm9wcyA/ICdzdHlsZT1cIicgKyBzdHlsZVByb3BzICsgJ1wiJyA6ICcnLFxuICAgICAgICAgIGR5ID0gc3R5bGVEZWNsLmRlbHRhWSwgZHlTcGFuID0gJycsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIGlmIChkeSkge1xuICAgICAgICBkeVNwYW4gPSAnIGR5PVwiJyArIHRvRml4ZWQoZHksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHRzcGFuIHg9XCInLCB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcsIGR5U3BhbixcbiAgICAgICAgZmlsbFN0eWxlcywgJz4nLFxuICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKF9jaGFyKSxcbiAgICAgICAgJzwvdHNwYW4+J1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lVGV4dDogZnVuY3Rpb24odGV4dFNwYW5zLCBsaW5lSW5kZXgsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsIHN0eWxlLFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgdGltZVRvUmVuZGVyO1xuXG4gICAgICB0ZXh0VG9wT2Zmc2V0ICs9IGxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZztcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSBmYWJyaWMudXRpbC5oYXNTdHlsZUNoYW5nZWQoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpIHx8IHsgfTtcbiAgICAgICAgICB0ZXh0U3BhbnMucHVzaCh0aGlzLl9jcmVhdGVUZXh0Q2hhclNwYW4oY2hhcnNUb1JlbmRlciwgc3R5bGUsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHVzaFRleHRCZ1JlY3Q6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBjb2xvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyhjb2xvciksXG4gICAgICAgICcgeD1cIicsXG4gICAgICAgIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICB0b0ZpeGVkKHdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgIHRvRml4ZWQoaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBpLCBsZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgYm94U3RhcnQgPSAwLFxuICAgICAgICAgIGNoYXJCb3gsIGN1cnJlbnRDb2xvcixcbiAgICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICBsYXN0Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGxhc3RDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGN1cnJlbnRDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRvYmUgSWxsdXN0cmF0b3IgKGF0IGxlYXN0IENTNSkgaXMgdW5hYmxlIHRvIHJlbmRlciByZ2JhKCktYmFzZWQgZmlsbCB2YWx1ZXNcbiAgICAgKiB3ZSB3b3JrIGFyb3VuZCBpdCBieSBcIm1vdmluZ1wiIGFscGhhIGNoYW5uZWwgaW50byBvcGFjaXR5IGF0dHJpYnV0ZSBhbmQgc2V0dGluZyBmaWxsJ3MgYWxwaGEgdG8gMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRGaWxsQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSA6ICcnO1xuICAgICAgaWYgKCFmaWxsQ29sb3IgfHwgIWZpbGxDb2xvci5nZXRTb3VyY2UoKSB8fCBmaWxsQ29sb3IuZ2V0QWxwaGEoKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ZpbGw9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvcGFjaXR5PVwiJyArIGZpbGxDb2xvci5nZXRBbHBoYSgpICsgJ1wiIGZpbGw9XCInICsgZmlsbENvbG9yLnNldEFscGhhKDEpLnRvUmdiKCkgKyAnXCInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICB9XG4gICAgICBsYXN0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lVG9wOiBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICBvZmZzZXQ6ICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIGxhc3RIZWlnaHQgLyAodGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuICAgICAgdmFyIHN2Z1N0eWxlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuZ2V0U3ZnU3R5bGVzLmNhbGwodGhpcywgc2tpcFNoYWRvdyk7XG4gICAgICByZXR1cm4gc3ZnU3R5bGUgKyAnIHdoaXRlLXNwYWNlOiBwcmU7JztcbiAgICB9LFxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0ge30pO1xuXG4gIC8qKlxuICAgKiBUZXh0Ym94IGNsYXNzLCBiYXNlZCBvbiBJVGV4dCwgYWxsb3dzIHRoZSB1c2VyIHRvIHJlc2l6ZSB0aGUgdGV4dCByZWN0YW5nbGVcbiAgICogYW5kIHdyYXBzIGxpbmVzIGF1dG9tYXRpY2FsbHkuIFRleHRib3hlcyBoYXZlIHRoZWlyIFkgc2NhbGluZyBsb2NrZWQsIHRoZVxuICAgKiB1c2VyIGNhbiBvbmx5IGNoYW5nZSB3aWR0aC4gSGVpZ2h0IGlzIGFkanVzdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlXG4gICAqIHdyYXBwaW5nIG9mIGxpbmVzLlxuICAgKiBAY2xhc3MgZmFicmljLlRleHRib3hcbiAgICogQGV4dGVuZHMgZmFicmljLklUZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dGJveH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dGJveCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHRib3ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuSVRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RleHRib3gnLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSB3aWR0aCBvZiB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5XaWR0aDogMjAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGNhbGN1bGF0ZWQgd2lkdGggb2YgYSB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogZml4ZWQgdG8gMiBzbyB0aGF0IGFuIGVtcHR5IHRleHRib3ggY2Fubm90IGdvIHRvIDBcbiAgICAgKiBhbmQgaXMgc3RpbGwgc2VsZWN0YWJsZSB3aXRob3V0IHRleHQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkeW5hbWljTWluV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgYXJyYXkgb2YgdGV4dCB3cmFwcGluZy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIF9fY2FjaGVkTGluZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqIFRleHRib3ggbmVlZHMgdGhpcyBvbiBmYWxzZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmNvbmNhdCgnd2lkdGgnKSxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCBzdHJpbmdzIGluIGJyZWFrYWJsZSBsaW5lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dvcmRKb2luZXJzOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGJvb2xlYW4gcHJvcGVydHkgaW4gb3JkZXIgdG8gc3BsaXQgc3RyaW5ncyB0aGF0IGhhdmUgbm8gd2hpdGUgc3BhY2UgY29uY2VwdC5cbiAgICAgKiB0aGlzIGlzIGEgY2hlYXAgd2F5IHRvIGhlbHAgd2l0aCBjaGluZXNlL2phcGFuZXNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqL1xuICAgIHNwbGl0QnlHcmFwaGVtZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBVbmxpa2Ugc3VwZXJjbGFzcydzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgVGV4dGJveCBkb2VzIG5vdCB1cGRhdGVcbiAgICAgKiBpdHMgd2lkdGguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcbiAgICAgIC8vIHdyYXAgbGluZXNcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCh0aGlzLl9zcGxpdFRleHQoKSk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIG9iamVjdCB0aGF0IHRyYW5zbGF0ZXMgdGhlIHN0eWxlIG9iamVjdCBzbyB0aGF0IGl0IGlzXG4gICAgICogYnJva2VuIHVwIGJ5IHZpc3VhbCBsaW5lcyAobmV3IGxpbmVzIGFuZCBhdXRvbWF0aWMgd3JhcHBpbmcpLlxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHN0eWxlcyBvYmplY3QgaXMgYnJva2VuIHVwIGJ5IGFjdHVhbCBsaW5lcyAobmV3IGxpbmVzIG9ubHkpLFxuICAgICAqIHdoaWNoIGlzIG9ubHkgc3VmZmljaWVudCBmb3IgVGV4dCAvIElUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVTdHlsZU1hcDogZnVuY3Rpb24odGV4dEluZm8pIHtcbiAgICAgIHZhciByZWFsTGluZUNvdW50ICAgICA9IDAsXG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgPSAwLFxuICAgICAgICAgIGNoYXJDb3VudCAgICAgICAgID0gMCxcbiAgICAgICAgICBtYXAgICAgICAgICAgICAgICA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRJbmZvLmdyYXBoZW1lTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHRJbmZvLmdyYXBoZW1lVGV4dFtjaGFyQ291bnRdID09PSAnXFxuJyAmJiBpID4gMCkge1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMDtcbiAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgICByZWFsTGluZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3BsaXRCeUdyYXBoZW1lICYmIHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBvbiBhIHNwZWNpZmllZCBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuc3R5bGVIYXMuY2FsbCh0aGlzLCBwcm9wZXJ0eSwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSAwLCBuZXh0TGluZUluZGV4ID0gbGluZUluZGV4ICsgMSwgbmV4dE9mZnNldCwgb2JqLCBzaG91bGRMaW1pdCA9IGZhbHNlLFxuICAgICAgICAgIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0sIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgc3R5bGUgbGluZSB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHdyYXBwZWQgbGluZUluZGV4IGxpbmVcbiAgICAgKiBVc2VkIGp1c3QgdG8gdmVyaWZ5IGlmIHRoZSBsaW5lIGRvZXMgZXhpc3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSAwLFxuICAgICAgICAgIHNwbGl0QnlHcmFwaGVtZSA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSBbXSxcbiAgICAgICAgICBsaW5lID0gW10sXG4gICAgICAgICAgLy8gc3BhY2VzIGluIGRpZmZlcmVudCBsYW5ndWFnZXM/XG4gICAgICAgICAgd29yZHMgPSBzcGxpdEJ5R3JhcGhlbWUgPyBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChfbGluZSkgOiBfbGluZS5zcGxpdCh0aGlzLl93b3JkSm9pbmVycyksXG4gICAgICAgICAgd29yZCA9ICcnLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgaW5maXggPSBzcGxpdEJ5R3JhcGhlbWUgPyAnJyA6ICcgJyxcbiAgICAgICAgICB3b3JkV2lkdGggPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcbiAgICAgIC8vIGZpeCBhIGRpZmZlcmVuY2UgYmV0d2VlbiBzcGxpdCBhbmQgZ3JhcGhlbWVTcGxpdFxuICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3b3Jkcy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGRlc2lyZWRXaWR0aCAtPSByZXNlcnZlZFNwYWNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBpZiB1c2luZyBzcGxpdEJ5R3JhcGhlbWUgd29yZHMgYXJlIGFscmVhZHkgaW4gZ3JhcGhlbWVzLlxuICAgICAgICB3b3JkID0gc3BsaXRCeUdyYXBoZW1lID8gd29yZHNbaV0gOiBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh3b3Jkc1tpXSk7XG4gICAgICAgIHdvcmRXaWR0aCA9IHRoaXMuX21lYXN1cmVXb3JkKHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHdvcmQubGVuZ3RoO1xuXG4gICAgICAgIGxpbmVXaWR0aCArPSBpbmZpeFdpZHRoICsgd29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICBpZiAobGluZVdpZHRoID4gZGVzaXJlZFdpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBncmFwaGVtZUxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgIGxpbmVXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxpbmVXaWR0aCArPSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpbmVKdXN0U3RhcnRlZCAmJiAhc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgICAgbGluZS5wdXNoKGluZml4KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQod29yZCk7XG5cbiAgICAgICAgaW5maXhXaWR0aCA9IHNwbGl0QnlHcmFwaGVtZSA/IDAgOiB0aGlzLl9tZWFzdXJlV29yZChbaW5maXhdLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBsYXJnZXN0IHdvcmRcbiAgICAgICAgaWYgKHdvcmRXaWR0aCA+IGxhcmdlc3RXb3JkV2lkdGgpIHtcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgJiYgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgICBpZiAobGFyZ2VzdFdvcmRXaWR0aCArIHJlc2VydmVkU3BhY2UgPiB0aGlzLmR5bmFtaWNNaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IGxhcmdlc3RXb3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2UgKyByZXNlcnZlZFNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpID8gMSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBHZXRzIGxpbmVzIG9mIHRleHQgdG8gcmVuZGVyIGluIHRoZSBUZXh0Ym94LiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXNcbiAgICAqIHRleHQgd3JhcHBpbmcgb24gdGhlIGZseSBldmVyeSB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZXMgaW4gdGhlIFRleHRib3guXG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBuZXdUZXh0ID0gZmFicmljLlRleHQucHJvdG90eXBlLl9zcGxpdFRleHRJbnRvTGluZXMuY2FsbCh0aGlzLCB0ZXh0KSxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzID0gdGhpcy5fd3JhcFRleHQobmV3VGV4dC5saW5lcywgdGhpcy53aWR0aCksXG4gICAgICAgICAgbGluZXMgPSBuZXcgQXJyYXkoZ3JhcGhlbWVMaW5lcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzVG9LZWVwID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBsaW5lc1RvS2VlcFt0aGlzLl9zdHlsZU1hcFtwcm9wXS5saW5lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCFsaW5lc1RvS2VlcFtwcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsnbWluV2lkdGgnLCAnc3BsaXRCeUdyYXBoZW1lJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHRib3ggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHRib3guZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3R5bGVzID0gZmFicmljLnV0aWwuc3R5bGVzRnJvbUFycmF5KG9iamVjdC5zdHlsZXMsIG9iamVjdC50ZXh0KTtcbiAgICAvL2NvcHkgb2JqZWN0IHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICB2YXIgb2JqQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCwgeyBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iakNvcHksIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY29udHJvbHNVdGlscyA9IGZhYnJpYy5jb250cm9sc1V0aWxzLFxuICAgICAgc2NhbGVTa2V3U3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsZVN0eWxlSGFuZGxlciA9IGNvbnRyb2xzVXRpbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsaW5nRXF1YWxseSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ0VxdWFsbHksXG4gICAgICBzY2FsaW5nWU9yU2tld2luZ1ggPSBjb250cm9sc1V0aWxzLnNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICAgIHNjYWxpbmdYT3JTa2V3aW5nWSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgICAgc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gY29udHJvbHNVdGlscy5zY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gICAgICBvYmplY3RDb250cm9scyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNvbnRyb2xzO1xuXG4gIG9iamVjdENvbnRyb2xzLm1sID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdYT3JTa2V3aW5nWSxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm1iID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWU9yU2tld2luZ1gsXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tdCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy50ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5ibCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5iciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25XaXRoU25hcHBpbmcsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBjb250cm9sc1V0aWxzLnJvdGF0aW9uU3R5bGVIYW5kbGVyLFxuICAgIG9mZnNldFk6IC00MCxcbiAgICB3aXRoQ29ubmVjdGlvbjogdHJ1ZSxcbiAgICBhY3Rpb25OYW1lOiAncm90YXRlJyxcbiAgfSk7XG5cbiAgaWYgKGZhYnJpYy5UZXh0Ym94KSB7XG4gICAgLy8gdGhpcyBpcyBicmVha2luZyB0aGUgcHJvdG90eXBlIGluaGVyaXRhbmNlLCBubyB0aW1lIC8gaWRlYXMgdG8gZml4IGl0LlxuICAgIC8vIGlzIGltcG9ydGFudCB0byBkb2N1bWVudCB0aGF0IGlmIHlvdSB3YW50IHRvIGhhdmUgYWxsIG9iamVjdHMgdG8gaGF2ZSBhXG4gICAgLy8gc3BlY2lmaWMgY3VzdG9tIGNvbnRyb2wsIHlvdSBoYXZlIHRvIGFkZCBpdCB0byBPYmplY3QgcHJvdG90eXBlIGFuZCB0byBUZXh0Ym94XG4gICAgLy8gcHJvdG90eXBlLiBUaGUgY29udHJvbHMgYXJlIHNoYXJlZCBhcyByZWZlcmVuY2VzLiBTbyBjaGFuZ2VzIHRvIGNvbnRyb2wgYHRyYFxuICAgIC8vIGNhbiBzdGlsbCBhcHBseSB0byBhbGwgb2JqZWN0cyBpZiBuZWVkZWQuXG4gICAgdmFyIHRleHRCb3hDb250cm9scyA9IGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZS5jb250cm9scyA9IHsgfTtcblxuICAgIHRleHRCb3hDb250cm9scy5tdHIgPSBvYmplY3RDb250cm9scy5tdHI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRyID0gb2JqZWN0Q29udHJvbHMudHI7XG4gICAgdGV4dEJveENvbnRyb2xzLmJyID0gb2JqZWN0Q29udHJvbHMuYnI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRsID0gb2JqZWN0Q29udHJvbHMudGw7XG4gICAgdGV4dEJveENvbnRyb2xzLmJsID0gb2JqZWN0Q29udHJvbHMuYmw7XG4gICAgdGV4dEJveENvbnRyb2xzLm10ID0gb2JqZWN0Q29udHJvbHMubXQ7XG4gICAgdGV4dEJveENvbnRyb2xzLm1iID0gb2JqZWN0Q29udHJvbHMubWI7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogLTAuNSxcbiAgICAgIHk6IDAsXG4gICAgICBhY3Rpb25IYW5kbGVyOiBjb250cm9sc1V0aWxzLmNoYW5nZVdpZHRoLFxuICAgICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgICBhY3Rpb25OYW1lOiAncmVzaXppbmcnLFxuICAgIH0pO1xuICB9XG59KSgpO1xuXG4iXSwibmFtZXMiOlsiZmFicmljIiwidmVyc2lvbiIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiLCJkb2N1bWVudCIsIkhUTUxEb2N1bWVudCIsIkRvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJ3aW5kb3ciLCJqc2RvbSIsInJlcXVpcmUiLCJ2aXJ0dWFsV2luZG93IiwiSlNET00iLCJkZWNvZGVVUklDb21wb25lbnQiLCJmZWF0dXJlcyIsIkZldGNoRXh0ZXJuYWxSZXNvdXJjZXMiLCJyZXNvdXJjZXMiLCJqc2RvbUltcGxGb3JXcmFwcGVyIiwiaW1wbEZvcldyYXBwZXIiLCJub2RlQ2FudmFzIiwiQ2FudmFzIiwiRE9NUGFyc2VyIiwiaXNUb3VjaFN1cHBvcnRlZCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiaXNMaWtlbHlOb2RlIiwiQnVmZmVyIiwiU0hBUkVEX0FUVFJJQlVURVMiLCJEUEkiLCJyZU51bSIsImNvbW1hV3NwIiwicmVQYXRoQ29tbWFuZCIsInJlTm9uV29yZCIsImZvbnRQYXRocyIsImlNYXRyaXgiLCJzdmdOUyIsInBlcmZMaW1pdFNpemVUb3RhbCIsIm1heENhY2hlU2lkZUxpbWl0IiwibWluQ2FjaGVTaWRlTGltaXQiLCJjaGFyV2lkdGhzQ2FjaGUiLCJ0ZXh0dXJlU2l6ZSIsImRpc2FibGVTdHlsZUNvcHlQYXN0ZSIsImVuYWJsZUdMRmlsdGVyaW5nIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndlYmtpdERldmljZVBpeGVsUmF0aW8iLCJtb3pEZXZpY2VQaXhlbFJhdGlvIiwiYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCIsImFyY1RvU2VnbWVudHNDYWNoZSIsImJvdW5kc09mQ3VydmVDYWNoZSIsImNhY2hlc0JvdW5kc09mQ3VydmUiLCJmb3JjZUdMUHV0SW1hZ2VEYXRhIiwiaW5pdEZpbHRlckJhY2tlbmQiLCJpc1dlYmdsU3VwcG9ydGVkIiwiY29uc29sZSIsImxvZyIsIm1heFRleHR1cmVTaXplIiwiV2ViZ2xGaWx0ZXJCYWNrZW5kIiwidGlsZVNpemUiLCJDYW52YXMyZEZpbHRlckJhY2tlbmQiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJfX2V2ZW50TGlzdGVuZXJzIiwiZXZlbnRMaXN0ZW5lciIsImluZGV4T2YiLCJ1dGlsIiwiYXJyYXkiLCJmaWxsIiwib24iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwcm9wIiwicHVzaCIsIl9vbmNlIiwiX2hhbmRsZXIiLCJhcHBseSIsIm9mZiIsImJpbmQiLCJvbmNlIiwiY2FsbCIsImZpcmUiLCJvcHRpb25zIiwibGlzdGVuZXJzRm9yRXZlbnQiLCJpIiwibGVuIiwiZmlsdGVyIiwidmFsdWUiLCJPYnNlcnZhYmxlIiwiQ29sbGVjdGlvbiIsIl9vYmplY3RzIiwiYWRkIiwiX29uT2JqZWN0QWRkZWQiLCJyZW5kZXJPbkFkZFJlbW92ZSIsInJlcXVlc3RSZW5kZXJBbGwiLCJpbnNlcnRBdCIsIm9iamVjdCIsImluZGV4Iiwibm9uU3BsaWNpbmciLCJvYmplY3RzIiwic3BsaWNlIiwicmVtb3ZlIiwic29tZXRoaW5nUmVtb3ZlZCIsIl9vbk9iamVjdFJlbW92ZWQiLCJmb3JFYWNoT2JqZWN0IiwiY2FsbGJhY2siLCJjb250ZXh0IiwiZ2V0T2JqZWN0cyIsInR5cGUiLCJjb25jYXQiLCJvIiwiaXRlbSIsImlzRW1wdHkiLCJzaXplIiwiY29udGFpbnMiLCJkZWVwIiwic29tZSIsIm9iaiIsImNvbXBsZXhpdHkiLCJyZWR1Y2UiLCJtZW1vIiwiY3VycmVudCIsIkNvbW1vbk1ldGhvZHMiLCJfc2V0T3B0aW9ucyIsInNldCIsIl9pbml0R3JhZGllbnQiLCJmaWxsZXIiLCJwcm9wZXJ0eSIsImNvbG9yU3RvcHMiLCJHcmFkaWVudCIsIl9pbml0UGF0dGVybiIsInNvdXJjZSIsIlBhdHRlcm4iLCJfc2V0T2JqZWN0IiwiX3NldCIsImtleSIsInRvZ2dsZSIsImdldCIsImdsb2JhbCIsInNxcnQiLCJNYXRoIiwiYXRhbjIiLCJwb3ciLCJQaUJ5MTgwIiwiUEkiLCJQaUJ5MiIsImNvcyIsImFuZ2xlIiwiYW5nbGVTbGljZSIsInNpbiIsInNpZ24iLCJyZW1vdmVGcm9tQXJyYXkiLCJpZHgiLCJnZXRSYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJmbG9vciIsInJhbmRvbSIsImRlZ3JlZXNUb1JhZGlhbnMiLCJkZWdyZWVzIiwicmFkaWFuc1RvRGVncmVlcyIsInJhZGlhbnMiLCJyb3RhdGVQb2ludCIsInBvaW50Iiwib3JpZ2luIiwibmV3UG9pbnQiLCJQb2ludCIsIngiLCJ5IiwidiIsInJvdGF0ZVZlY3RvciIsImFkZEVxdWFscyIsInZlY3RvciIsInJ4IiwicnkiLCJjcmVhdGVWZWN0b3IiLCJmcm9tIiwidG8iLCJjYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyIsImEiLCJiIiwiYWNvcyIsImh5cG90IiwiZ2V0SGF0VmVjdG9yIiwibXVsdGlwbHkiLCJnZXRCaXNlY3RvciIsIkEiLCJCIiwiQyIsIkFCIiwiQUMiLCJhbHBoYSIsInJvIiwicGhpIiwicHJvamVjdFN0cm9rZU9uUG9pbnRzIiwicG9pbnRzIiwib3BlblBhdGgiLCJjb29yZHMiLCJzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VVbmlmb3JtU2NhbGFyIiwic3Ryb2tlVW5pZm9ybSIsInNjYWxlWCIsInNjYWxlWSIsImdldFN0cm9rZUhhdFZlY3RvciIsInNjYWxhciIsImZvckVhY2giLCJwIiwiYmlzZWN0b3IiLCJiaXNlY3RvclZlY3RvciIsIm1pdGVyVmVjdG9yIiwic3Ryb2tlTGluZUpvaW4iLCJzdHJva2VNaXRlckxpbWl0Iiwic3VidHJhY3QiLCJTUVJUMiIsInRyYW5zZm9ybVBvaW50IiwidCIsImlnbm9yZU9mZnNldCIsIm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMiLCJ0cmFuc2Zvcm0iLCJ4UG9pbnRzIiwibWluWCIsIm1heFgiLCJ3aWR0aCIsInlQb2ludHMiLCJtaW5ZIiwibWF4WSIsImhlaWdodCIsImxlZnQiLCJ0b3AiLCJpbnZlcnRUcmFuc2Zvcm0iLCJyIiwidG9GaXhlZCIsIm51bWJlciIsImZyYWN0aW9uRGlnaXRzIiwicGFyc2VGbG9hdCIsIk51bWJlciIsInBhcnNlVW5pdCIsImZvbnRTaXplIiwidW5pdCIsImV4ZWMiLCJUZXh0IiwiREVGQVVMVF9TVkdfRk9OVF9TSVpFIiwiZmFsc2VGdW5jdGlvbiIsImdldEtsYXNzIiwibmFtZXNwYWNlIiwic3RyaW5nIiwiY2FtZWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwicmVzb2x2ZU5hbWVzcGFjZSIsImdldFN2Z0F0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwicGFydHMiLCJzcGxpdCIsImxvYWRJbWFnZSIsInVybCIsImNyb3NzT3JpZ2luIiwiaW1nIiwiY3JlYXRlSW1hZ2UiLCJvbkxvYWRDYWxsYmFjayIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJ1bmRlZmluZWQiLCJzdWJzdHJpbmciLCJsb2FkSW1hZ2VJbkRvbSIsImRpdiIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwiYXBwZW5kQ2hpbGQiLCJxdWVyeVNlbGVjdG9yIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW5saXZlbk9iamVjdHMiLCJyZXZpdmVyIiwiZW5saXZlbmVkT2JqZWN0cyIsIm51bUxvYWRlZE9iamVjdHMiLCJudW1Ub3RhbE9iamVjdHMiLCJvbkxvYWRlZCIsImtsYXNzIiwiZnJvbU9iamVjdCIsImVycm9yIiwiZW5saXZlbk9iamVjdEVubGl2YWJsZXMiLCJlbmxpdmVuUHJvcHMiLCJPYmplY3QiLCJFTkxJVkVOX1BST1BTIiwibWFwIiwiZW5saXZlZFByb3BzIiwiZW5saXZlblBhdHRlcm5zIiwicGF0dGVybnMiLCJudW1Mb2FkZWRQYXR0ZXJucyIsIm51bVBhdHRlcm5zIiwiZW5saXZlbmVkUGF0dGVybnMiLCJwYXR0ZXJuIiwiZ3JvdXBTVkdFbGVtZW50cyIsImVsZW1lbnRzIiwicGF0aCIsInNvdXJjZVBhdGgiLCJjZW50ZXJQb2ludCIsIkdyb3VwIiwicG9wdWxhdGVXaXRoUHJvcGVydGllcyIsImRlc3RpbmF0aW9uIiwicHJvcGVydGllcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZUNhbnZhc0VsZW1lbnQiLCJjb3B5Q2FudmFzRWxlbWVudCIsImNhbnZhcyIsIm5ld0NhbnZhcyIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJjYW52YXNFbCIsImZvcm1hdCIsInF1YWxpdHkiLCJtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzIiwiaXMyeDIiLCJxckRlY29tcG9zZSIsImRlbm9tIiwic2tld1giLCJza2V3WSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwiY2FsY1JvdGF0ZU1hdHJpeCIsInRoZXRhIiwiY2FsY0RpbWVuc2lvbnNNYXRyaXgiLCJzY2FsZU1hdHJpeCIsImZsaXBYIiwiZmxpcFkiLCJ0YW4iLCJjb21wb3NlTWF0cml4IiwibWF0cml4IiwicmVzZXRPYmplY3RUcmFuc2Zvcm0iLCJ0YXJnZXQiLCJyb3RhdGUiLCJzYXZlT2JqZWN0VHJhbnNmb3JtIiwiaXNUcmFuc3BhcmVudCIsImN0eCIsInRvbGVyYW5jZSIsIl9pc1RyYW5zcGFyZW50IiwidGVtcCIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImwiLCJkYXRhIiwicGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlIiwiYXR0cmlidXRlIiwibWVldE9yU2xpY2UiLCJhbGlnblgiLCJhbGlnblkiLCJhc3BlY3RSYXRpb0F0dHJzIiwiYWxpZ24iLCJwb3AiLCJjbGVhckZhYnJpY0ZvbnRDYWNoZSIsImZvbnRGYW1pbHkiLCJ0b0xvd2VyQ2FzZSIsImxpbWl0RGltc0J5QXJlYSIsImFyIiwibWF4aW11bUFyZWEiLCJyb3VnaFdpZHRoIiwicGVyZkxpbWl0U2l6ZVkiLCJjYXBWYWx1ZSIsImZpbmRTY2FsZVRvRml0IiwiZmluZFNjYWxlVG9Db3ZlciIsIm1hdHJpeFRvU1ZHIiwiTlVNX0ZSQUNUSU9OX0RJR0lUUyIsImpvaW4iLCJyZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0IiwiaW52ZXJ0ZWQiLCJmaW5hbFRyYW5zZm9ybSIsImNhbGNPd25NYXRyaXgiLCJhcHBseVRyYW5zZm9ybVRvT2JqZWN0IiwiYWRkVHJhbnNmb3JtVG9PYmplY3QiLCJjZW50ZXIiLCJzZXRQb3NpdGlvbkJ5T3JpZ2luIiwic2l6ZUFmdGVyVHJhbnNmb3JtIiwiZGltWCIsImRpbVkiLCJ0cmFuc2Zvcm1NYXRyaXgiLCJiYm94IiwibWVyZ2VDbGlwUGF0aHMiLCJjMSIsImMyIiwiY2FsY1RyYW5zZm9ybU1hdHJpeCIsImNsaXBQYXRoIiwiaGFzU3R5bGVDaGFuZ2VkIiwicHJldlN0eWxlIiwidGhpc1N0eWxlIiwiZm9yVGV4dFNwYW5zIiwic3Ryb2tlIiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsInRleHRCYWNrZ3JvdW5kQ29sb3IiLCJkZWx0YVkiLCJvdmVybGluZSIsInVuZGVybGluZSIsImxpbmV0aHJvdWdoIiwic3R5bGVzVG9BcnJheSIsInN0eWxlcyIsInRleHQiLCJjbG9uZSIsInRleHRMaW5lcyIsImNoYXJJbmRleCIsInN0eWxlc0FycmF5IiwiYyIsImtleXMiLCJzdHlsZUNoYW5nZWQiLCJzdGFydCIsImVuZCIsInN0eWxlc0Zyb21BcnJheSIsInN0eWxlSW5kZXgiLCJzdHlsZXNPYmplY3QiLCJhc3NpZ24iLCJfam9pbiIsInByb3RvdHlwZSIsImNvbW1hbmRMZW5ndGhzIiwibSIsImgiLCJxIiwicmVwZWF0ZWRDb21tYW5kcyIsIk0iLCJzZWdtZW50VG9CZXppZXIiLCJ0aDIiLCJ0aDMiLCJjb3NUaCIsInNpblRoIiwiY3gxIiwiY3kxIiwibVQiLCJmcm9tWCIsImZyb21ZIiwiY29zdGgyIiwic2ludGgyIiwiY29zdGgzIiwic2ludGgzIiwidG9YIiwidG9ZIiwiY3AxWCIsImNwMVkiLCJjcDJYIiwiY3AyWSIsImFyY1RvU2VnbWVudHMiLCJsYXJnZSIsInN3ZWVwIiwicm90YXRlWCIsInRoIiwiYWJzIiwicHgiLCJweSIsInJ4MiIsInJ5MiIsInB5MiIsInB4MiIsInBsIiwicm9vdCIsImN4IiwiY3kiLCJtVGhldGEiLCJjYWxjVmVjdG9yQW5nbGUiLCJkdGhldGEiLCJzZWdtZW50cyIsImNlaWwiLCJyZXN1bHQiLCJtRGVsdGEiLCJ1eCIsInV5IiwidngiLCJ2eSIsInRhIiwidGIiLCJnZXRCb3VuZHNPZkN1cnZlIiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImFyZ3NTdHJpbmciLCJ0dmFsdWVzIiwiYm91bmRzIiwidDEiLCJ0MiIsImIyYWMiLCJzcXJ0YjJhYyIsImoiLCJqbGVuIiwibXQiLCJmcm9tQXJjVG9CZXppZXJzIiwiZngiLCJmeSIsInJvdCIsInR4IiwidHkiLCJzZWdzTm9ybSIsIm1ha2VQYXRoU2ltcGxlciIsImNvbnZlcnRlZCIsImRlc3RpbmF0aW9uUGF0aCIsInByZXZpb3VzIiwiY29udHJvbFgiLCJjb250cm9sWSIsImNhbGNMaW5lTGVuZ3RoIiwiQ0IxIiwiQ0IyIiwiQ0IzIiwiQ0I0IiwiZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJwNHgiLCJwNHkiLCJwY3QiLCJjMyIsImM0IiwiZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IiLCJpbnZUIiwidGFuZ2VudFgiLCJ0YW5nZW50WSIsIlFCMSIsIlFCMiIsIlFCMyIsImdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvciIsImdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvciIsInBhdGhJdGVyYXRvciIsIml0ZXJhdG9yIiwidGVtcFAiLCJ0bXBMZW4iLCJwZXJjIiwiZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZSIsInNlZ0luZm8iLCJkaXN0YW5jZSIsIm5leHRMZW4iLCJuZXh0U3RlcCIsImFuZ2xlRmluZGVyIiwibGFzdFBlcmMiLCJnZXRQYXRoU2VnbWVudHNJbmZvIiwidG90YWxMZW5ndGgiLCJpbmZvIiwidGVtcEluZm8iLCJjb21tYW5kIiwiZGVzdFgiLCJkZXN0WSIsImdldFBvaW50T25QYXRoIiwiaW5mb3MiLCJzZWdQZXJjZW50Iiwic2VnbWVudCIsImxlcnAiLCJwYXJzZVBhdGgiLCJwYXRoU3RyaW5nIiwiY3VycmVudFBhdGgiLCJwYXJzZWQiLCJyZSIsInJOdW1iZXIiLCJyTnVtYmVyQ29tbWFXc3AiLCJyRmxhZ0NvbW1hV3NwIiwickFyY1NlcSIsInJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UiLCJSZWdFeHAiLCJtYXRjaCIsImNvb3Jkc1N0ciIsImNvb3Jkc1BhcnNlZCIsInRyaW0iLCJhcmdzIiwiaXNOYU4iLCJjb21tYW5kTGVuZ3RoIiwicmVwZWF0ZWRDb21tYW5kIiwiayIsImtsZW4iLCJnZXRTbW9vdGhQYXRoRnJvbVBvaW50cyIsImNvcnJlY3Rpb24iLCJwMSIsInAyIiwibXVsdFNpZ25YIiwibXVsdFNpZ25ZIiwibWFueVBvaW50cyIsImVxIiwibWlkUG9pbnQiLCJtaWRQb2ludEZyb20iLCJ0cmFuc2Zvcm1QYXRoIiwicGF0aE9mZnNldCIsInBhdGhTZWdtZW50IiwibmV3U2VnbWVudCIsImpvaW5QYXRoIiwicGF0aERhdGEiLCJpbnZva2UiLCJtZXRob2QiLCJieVByb3BlcnR5IiwiZmluZCIsInZhbHVlMSIsInZhbHVlMiIsImNvbmRpdGlvbiIsImV4dGVuZCIsIkVsZW1lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInJlcGxhY2UiLCJjaGFyYWN0ZXIiLCJjYXBpdGFsaXplIiwiZmlyc3RMZXR0ZXJPbmx5IiwiZXNjYXBlWG1sIiwiZ3JhcGhlbWVTcGxpdCIsInRleHRzdHJpbmciLCJjaHIiLCJncmFwaGVtZXMiLCJnZXRXaG9sZUNoYXIiLCJzdHIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIm5leHQiLCJwcmV2IiwiZW1wdHlGdW5jdGlvbiIsIklTX0RPTlRFTlVNX0JVR0dZIiwidG9TdHJpbmciLCJhZGRNZXRob2RzIiwicGFyZW50Iiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwicmV0dXJuVmFsdWUiLCJ2YWx1ZU9mIiwiU3ViY2xhc3MiLCJjYWxsU3VwZXIiLCJtZXRob2ROYW1lIiwicGFyZW50TWV0aG9kIiwiX3RoaXMiLCJzdXBlckNsYXNzTWV0aG9kIiwiY3JlYXRlQ2xhc3MiLCJzaGlmdCIsImluaXRpYWxpemUiLCJzdWJjbGFzc2VzIiwiY291bGRVc2VBdHRhY2hFdmVudCIsImF0dGFjaEV2ZW50IiwidG91Y2hFdmVudHMiLCJhZGRMaXN0ZW5lciIsImVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0VG91Y2hJbmZvIiwiZXZlbnQiLCJ0b3VjaFByb3AiLCJjaGFuZ2VkVG91Y2hlcyIsImdldFBvaW50ZXIiLCJzY3JvbGwiLCJnZXRTY3JvbGxMZWZ0VG9wIiwiX2V2dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNUb3VjaEV2ZW50IiwicG9pbnRlclR5cGUiLCJzZXRTdHlsZSIsImVsZW1lbnRTdHlsZSIsImNzc1RleHQiLCJzZXRPcGFjaXR5Iiwibm9ybWFsaXplZFByb3BlcnR5Iiwic3R5bGVGbG9hdCIsInNldFByb3BlcnR5IiwicGFyc2VFbCIsInN1cHBvcnRzT3BhY2l0eSIsIm9wYWNpdHkiLCJzdXBwb3J0c0ZpbHRlcnMiLCJyZU9wYWNpdHkiLCJlcyIsImN1cnJlbnRTdHlsZSIsImhhc0xheW91dCIsInpvb20iLCJ0ZXN0IiwiX3NsaWNlIiwiZ2V0QnlJZCIsImlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMiLCJ0b0FycmF5IiwiYXJyYXlMaWtlIiwiY2hpbGROb2RlcyIsImVyciIsImFyciIsIm1ha2VFbGVtZW50IiwidGFnTmFtZSIsImVsIiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsInNldEF0dHJpYnV0ZSIsImFkZENsYXNzIiwid3JhcEVsZW1lbnQiLCJ3cmFwcGVyIiwicmVwbGFjZUNoaWxkIiwiZG9jRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaG9zdCIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudE9mZnNldCIsImRvY0VsZW0iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiYm94Iiwib2Zmc2V0Iiwic2Nyb2xsTGVmdFRvcCIsIm9mZnNldEF0dHJpYnV0ZXMiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsImF0dHIiLCJwYXJzZUludCIsImdldEVsZW1lbnRTdHlsZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJzZWxlY3RQcm9wIiwibWFrZUVsZW1lbnRVbnNlbGVjdGFibGUiLCJvbnNlbGVjdHN0YXJ0IiwidW5zZWxlY3RhYmxlIiwibWFrZUVsZW1lbnRTZWxlY3RhYmxlIiwiZ2V0Tm9kZUNhbnZhcyIsImltcGwiLCJfY2FudmFzIiwiX2ltYWdlIiwiY2xlYW5VcEpzZG9tTm9kZSIsIl9jdXJyZW50U3JjIiwiX2F0dHJpYnV0ZXMiLCJfY2xhc3NMaXN0Iiwic2V0SW1hZ2VTbW9vdGhpbmciLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm9JbWFnZVNtb290aGluZ0VuYWJsZWQiLCJhZGRQYXJhbVRvVXJsIiwicGFyYW0iLCJlbXB0eUZuIiwicmVxdWVzdCIsIm9uQ29tcGxldGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInBhcmFtZXRlcnMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwid2FybiIsIlJVTk5JTkdfQU5JTUFUSU9OUyIsImNhbmNlbEFsbCIsImFuaW1hdGlvbnMiLCJhbmltYXRpb24iLCJjYW5jZWwiLCJjYW5jZWxCeUNhbnZhcyIsImNhbmNlbGxlZCIsImNhbmNlbEJ5VGFyZ2V0IiwiZmluZEFuaW1hdGlvbnNCeVRhcmdldCIsImZpbmRBbmltYXRpb25JbmRleCIsImNhbmNlbEZ1bmMiLCJmaW5kQW5pbWF0aW9uIiwibm9vcCIsImRlZmF1bHRFYXNpbmciLCJkIiwiYW5pbWF0ZSIsInJlbW92ZUZyb21SZWdpc3RyeSIsInJ1bm5pbmdBbmltYXRpb25zIiwiY3VycmVudFZhbHVlIiwic3RhcnRWYWx1ZSIsImNvbXBsZXRpb25SYXRlIiwiZHVyYXRpb25SYXRlIiwicmVxdWVzdEFuaW1GcmFtZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJkdXJhdGlvbiIsImZpbmlzaCIsInRpbWUiLCJvbkNoYW5nZSIsImFib3J0IiwiZWFzaW5nIiwiaXNNYW55IiwiZW5kVmFsdWUiLCJieVZhbHVlIiwib25TdGFydCIsInRpY2siLCJ0aWNrdGltZSIsImN1cnJlbnRUaW1lIiwidGltZVBlcmMiLCJfdmFsdWUiLCJ2YWx1ZVBlcmMiLCJfcmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJfY2FuY2VsQW5pbUZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbmltRnJhbWUiLCJjYWxjdWxhdGVDb2xvciIsImJlZ2luIiwicG9zIiwiY29sb3IiLCJhbmltYXRlQ29sb3IiLCJmcm9tQ29sb3IiLCJ0b0NvbG9yIiwic3RhcnRDb2xvciIsIkNvbG9yIiwiZ2V0U291cmNlIiwiZW5kQ29sb3IiLCJvcmlnaW5hbE9uQ29tcGxldGUiLCJvcmlnaW5hbE9uQ2hhbmdlIiwicG9zVmFsdWUiLCJjb2xvckVhc2luZyIsIm5vcm1hbGl6ZSIsImFzaW4iLCJlbGFzdGljIiwib3B0cyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNlIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwic3ZnVmFsaWRUYWdOYW1lcyIsInN2Z1ZpZXdCb3hFbGVtZW50cyIsInN2Z0ludmFsaWRBbmNlc3RvcnMiLCJzdmdWYWxpZFBhcmVudHMiLCJhdHRyaWJ1dGVzTWFwIiwiZGlzcGxheSIsInZpc2liaWxpdHkiLCJjb2xvckF0dHJpYnV0ZXMiLCJmU2l6ZSIsImNQYXRoIiwic3ZnVmFsaWRUYWdOYW1lc1JlZ0V4IiwiZ2V0U3ZnUmVnZXgiLCJzdmdWaWV3Qm94RWxlbWVudHNSZWdFeCIsInN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCIsInN2Z1ZhbGlkUGFyZW50c1JlZ0V4IiwiY3NzUnVsZXMiLCJncmFkaWVudERlZnMiLCJjbGlwUGF0aHMiLCJub3JtYWxpemVBdHRyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJlbnRBdHRyaWJ1dGVzIiwicGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUiLCJ2aXNpYmxlIiwiZmlsbEluZGV4Iiwic3Ryb2tlSW5kZXgiLCJfc2V0U3Ryb2tlRmlsbE9wYWNpdHkiLCJzZXRBbHBoYSIsImdldEFscGhhIiwidG9SZ2JhIiwiX2dldE11bHRpcGxlTm9kZXMiLCJub2RlTmFtZXMiLCJub2RlTmFtZSIsIm5vZGVBcnJheSIsIm5vZGVMaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJyb3RhdGVNYXRyaXgiLCJtdWx0aXBsaWVyWCIsIm11bHRpcGxpZXJZIiwic2tld01hdHJpeCIsInRyYW5zbGF0ZU1hdHJpeCIsInNjYWxlIiwidHJhbnNsYXRlIiwidHJhbnNmb3JtcyIsInRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybSIsImF0dHJpYnV0ZVZhbHVlIiwibWF0cmljZXMiLCJvcGVyYXRpb24iLCJjb21iaW5lZE1hdHJpeCIsInBhcnNlU3R5bGVTdHJpbmciLCJvU3R5bGUiLCJjaHVuayIsInBhaXIiLCJwYXJzZVN0eWxlT2JqZWN0IiwiZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudCIsInN2Z1VpZCIsInJ1bGUiLCJlbGVtZW50TWF0Y2hlc1J1bGUiLCJzZWxlY3RvcnMiLCJmaXJzdE1hdGNoaW5nIiwicGFyZW50TWF0Y2hpbmciLCJzZWxlY3Rvck1hdGNoZXMiLCJkb2VzU29tZVBhcmVudE1hdGNoIiwic2VsZWN0b3IiLCJjbGFzc05hbWVzIiwiZ2V0QXR0cmlidXRlIiwibWF0Y2hlciIsImVsZW1lbnRCeUlkIiwibm9kZSIsIm5vZGVsaXN0IiwicGFyc2VVc2VEaXJlY3RpdmVzIiwieGxpbmtBdHRyaWJ1dGUiLCJ4bGluayIsImVsMiIsImNsb25lTm9kZSIsImN1cnJlbnRUcmFucyIsIm9sZExlbmd0aCIsImF0dHJzIiwiYXBwbHlWaWV3Ym94VHJhbnNmb3JtIiwiZWwzIiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cmlidXRlTlMiLCJub2RlVmFsdWUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQXR0cmlidXRlIiwicmVWaWV3Qm94QXR0clZhbHVlIiwidmlld0JveEF0dHIiLCJ2aWV3Qm94V2lkdGgiLCJ2aWV3Qm94SGVpZ2h0Iiwid2lkdGhBdHRyIiwiaGVpZ2h0QXR0ciIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJtaXNzaW5nVmlld0JveCIsIm1pc3NpbmdEaW1BdHRyIiwidG9CZVBhcnNlZCIsInBhcnNlZERpbSIsIndpZHRoRGlmZiIsImhlaWdodERpZmYiLCJoYXNBbmNlc3RvcldpdGhOb2RlTmFtZSIsInBhcnNlU1ZHRG9jdW1lbnQiLCJwYXJzaW5nT3B0aW9ucyIsIl9fdWlkIiwiZGVzY2VuZGFudHMiLCJzZWxlY3ROb2RlcyIsImdldEdyYWRpZW50RGVmcyIsImdldENTU1J1bGVzIiwicGFyc2VFbGVtZW50cyIsImluc3RhbmNlcyIsInJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayIsImdyYWRpZW50IiwiZ3JhZGllbnRzQXR0cnMiLCJ4bGlua0F0dHIiLCJ4TGluayIsInJlZmVyZW5jZWRHcmFkaWVudCIsImhhc0F0dHJpYnV0ZSIsImNoaWxkcmVuIiwicmVmZXJlbmNlQ2xvbmUiLCJyZUZvbnREZWNsYXJhdGlvbiIsInBhcnNlRm9udERlY2xhcmF0aW9uIiwibGluZUhlaWdodCIsInRhZ0FycmF5IiwiZWxMaXN0IiwicGFyc2VBdHRyaWJ1dGVzIiwicGFyZW50Rm9udFNpemUiLCJvd25BdHRyaWJ1dGVzIiwiY3NzQXR0cnMiLCJwYXJzZVN0eWxlQXR0cmlidXRlIiwibm9ybWFsaXplZEF0dHIiLCJub3JtYWxpemVkVmFsdWUiLCJub3JtYWxpemVkU3R5bGUiLCJmb250IiwibWVyZ2VkQXR0cnMiLCJFbGVtZW50c1BhcnNlciIsInBhcnNlIiwicGFyc2VQb2ludHNBdHRyaWJ1dGUiLCJwYXJzZWRQb2ludHMiLCJhbGxSdWxlcyIsInJ1bGVzIiwic3R5bGVDb250ZW50cyIsInRleHRDb250ZW50IiwicnVsZU9iaiIsImRlY2xhcmF0aW9uIiwicHJvcGVydHlWYWx1ZVBhaXJzIiwiX3J1bGUiLCJsb2FkU1ZHRnJvbVVSTCIsInhtbCIsInJlc3BvbnNlWE1MIiwicmVzdWx0cyIsIl9vcHRpb25zIiwiYWxsRWxlbWVudHMiLCJsb2FkU1ZHRnJvbVN0cmluZyIsInBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJlZ2V4VXJsIiwicHJvdG8iLCJudW1FbGVtZW50cyIsImNyZWF0ZU9iamVjdHMiLCJjcmVhdGVPYmplY3QiLCJmaW5kVGFnIiwiZnJvbUVsZW1lbnQiLCJjcmVhdGVDYWxsYmFjayIsImNoZWNrSWZEb25lIiwicmVzb2x2ZUdyYWRpZW50IiwiSW1hZ2UiLCJfb3JpZ2luYWxFbGVtZW50IiwiX3JlbW92ZVRyYW5zZm9ybU1hdHJpeCIsInJlc29sdmVDbGlwUGF0aCIsImV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24iLCJzdG9yYWdlIiwicmVnZXgiLCJsYXN0SW5kZXgiLCJncmFkaWVudERlZiIsIm9wYWNpdHlBdHRyIiwiY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayIsImNvbnRhaW5lciIsIl9uZXdPYmoiLCJmaWxsUnVsZSIsImNsaXBSdWxlIiwidXNpbmdFbGVtZW50Iiwib2JqVHJhbnNmb3JtSW52IiwiZ1RyYW5zZm9ybSIsImNsaXBQYXRoVGFnIiwiY2xpcFBhdGhPd25lciIsInRoYXQiLCJzY2FsYXJBZGQiLCJzY2FsYXJBZGRFcXVhbHMiLCJzdWJ0cmFjdEVxdWFscyIsInNjYWxhclN1YnRyYWN0Iiwic2NhbGFyU3VidHJhY3RFcXVhbHMiLCJtdWx0aXBseUVxdWFscyIsImRpdmlkZSIsImRpdmlkZUVxdWFscyIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJkaXN0YW5jZUZyb20iLCJkeCIsImR5Iiwic2V0WFkiLCJzZXRYIiwic2V0WSIsInNldEZyb21Qb2ludCIsInN3YXAiLCJJbnRlcnNlY3Rpb24iLCJzdGF0dXMiLCJhcHBlbmRQb2ludCIsImFwcGVuZFBvaW50cyIsImludGVyc2VjdExpbmVMaW5lIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJ1YVQiLCJ1YlQiLCJ1QiIsInVhIiwidWIiLCJpbnRlcnNlY3RMaW5lUG9seWdvbiIsImludGVyIiwiaW50ZXJzZWN0UG9seWdvblBvbHlnb24iLCJwb2ludHMxIiwicG9pbnRzMiIsImludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUiLCJyMSIsInIyIiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiaW50ZXIxIiwiaW50ZXIyIiwiaW50ZXIzIiwiaW50ZXI0Iiwic2V0U291cmNlIiwiX3RyeVBhcnNpbmdDb2xvciIsImNvbG9yTmFtZU1hcCIsInNvdXJjZUZyb21IZXgiLCJzb3VyY2VGcm9tUmdiIiwic291cmNlRnJvbUhzbCIsIl9yZ2JUb0hzbCIsImciLCJyb3VuZCIsIl9zb3VyY2UiLCJ0b1JnYiIsInRvSHNsIiwiaHNsIiwidG9Ic2xhIiwidG9IZXgiLCJ0b0hleGEiLCJ0b0dyYXlzY2FsZSIsImF2ZXJhZ2UiLCJjdXJyZW50QWxwaGEiLCJ0b0JsYWNrV2hpdGUiLCJ0aHJlc2hvbGQiLCJvdmVybGF5V2l0aCIsIm90aGVyQ29sb3IiLCJvdGhlckFscGhhIiwib3RoZXJTb3VyY2UiLCJyZVJHQmEiLCJyZUhTTGEiLCJyZUhleCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmV5IiwiZGFya2dyZWVuIiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JleSIsImxpZ2h0Z3JlZW4iLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJtZWRpdW1hcXVhbWFyaW5lIiwibWVkaXVtYmx1ZSIsIm1lZGl1bW9yY2hpZCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bXNlYWdyZWVuIiwibWVkaXVtc2xhdGVibHVlIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJtZWRpdW10dXJxdW9pc2UiLCJtZWRpdW12aW9sZXRyZWQiLCJtaWRuaWdodGJsdWUiLCJtaW50Y3JlYW0iLCJtaXN0eXJvc2UiLCJtb2NjYXNpbiIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9sZGxhY2UiLCJvbGl2ZSIsIm9saXZlZHJhYiIsIm9yYW5nZSIsIm9yYW5nZXJlZCIsIm9yY2hpZCIsInBhbGVnb2xkZW5yb2QiLCJwYWxlZ3JlZW4iLCJwYWxldHVycXVvaXNlIiwicGFsZXZpb2xldHJlZCIsInBhcGF5YXdoaXAiLCJwZWFjaHB1ZmYiLCJwZXJ1IiwicGluayIsInBsdW0iLCJwb3dkZXJibHVlIiwicHVycGxlIiwicmViZWNjYXB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwiaHVlMnJnYiIsImZyb21SZ2IiLCJmcm9tU291cmNlIiwiZnJvbVJnYmEiLCJmcm9tSHNsIiwiZnJvbUhzbGEiLCJmcm9tSGV4IiwiaXNTaG9ydE5vdGF0aW9uIiwiaXNSR0JhIiwib0NvbG9yIiwic2NhbGVNYXAiLCJza2V3TWFwIiwiY29udHJvbHMiLCJMRUZUIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJDRU5URVIiLCJvcHBvc2l0ZSIsImJvdHRvbSIsInJpZ2h0IiwiZmluZENvcm5lclF1YWRyYW50IiwiZmFicmljT2JqZWN0IiwiY29udHJvbCIsImNvcm5lckFuZ2xlIiwiZmlyZUV2ZW50IiwiY2FudmFzT3B0aW9ucyIsInNjYWxlSXNQcm9wb3J0aW9uYWwiLCJldmVudERhdGEiLCJ1bmlTY2FsZUtleSIsInVuaWZvcm1Jc1RvZ2dsZWQiLCJ1bmlmb3JtU2NhbGluZyIsImlzVHJhbnNmb3JtQ2VudGVyZWQiLCJvcmlnaW5YIiwib3JpZ2luWSIsInNjYWxpbmdJc0ZvcmJpZGRlbiIsImJ5Iiwic2NhbGVQcm9wb3J0aW9uYWxseSIsImxvY2tYIiwibG9ja1NjYWxpbmdYIiwibG9ja1kiLCJsb2NrU2NhbGluZ1kiLCJzY2FsZUN1cnNvclN0eWxlSGFuZGxlciIsIm5vdEFsbG93ZWQiLCJuIiwic2tld0N1cnNvclN0eWxlSGFuZGxlciIsImxvY2tTa2V3aW5nWSIsImxvY2tTa2V3aW5nWCIsInNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlciIsImFsdEFjdGlvbktleSIsInNjYWxlT3JTa2V3QWN0aW9uTmFtZSIsImlzQWx0ZXJuYXRpdmUiLCJyb3RhdGlvblN0eWxlSGFuZGxlciIsImxvY2tSb3RhdGlvbiIsImN1cnNvclN0eWxlIiwiY29tbW9uRXZlbnRJbmZvIiwiZSIsInBvaW50ZXIiLCJ3cmFwV2l0aEZpeGVkQW5jaG9yIiwiYWN0aW9uSGFuZGxlciIsImdldENlbnRlclBvaW50IiwiY29uc3RyYWludCIsInRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQiLCJhY3Rpb25QZXJmb3JtZWQiLCJ3cmFwV2l0aEZpcmVFdmVudCIsImdldExvY2FsUG9pbnQiLCJjb3JuZXIiLCJnZXRab29tIiwicGFkZGluZyIsImxvY2FsUG9pbnQiLCJ0b0xvY2FsUG9pbnQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInRhcmdldEhhc09uZUZsaXAiLCJjb21wZW5zYXRlU2NhbGVGb3JTa2V3Iiwib3Bwb3NpdGVTa2V3Iiwic2NhbGVUb0NvbXBlbnNhdGUiLCJheGlzIiwicmVmZXJlbmNlIiwibmV3RGltIiwiX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucyIsIm5ld1ZhbHVlIiwic2tld09iamVjdFgiLCJkaW1Ob1NrZXciLCJ0b3RhbFNrZXdTaXplIiwiY3VycmVudFNrZXciLCJuZXdTa2V3IiwiaGFzU2tld2VkIiwiZGltQmVmb3JlU2tld2luZyIsInNrZXdPYmplY3RZIiwic2tld0hhbmRsZXJYIiwibG9jYWxQb2ludEZyb21DZW50ZXIiLCJmaW5hbEhhbmRsZXIiLCJza2V3SGFuZGxlclkiLCJyb3RhdGlvbldpdGhTbmFwcGluZyIsInBpdm90UG9pbnQiLCJsYXN0QW5nbGUiLCJleSIsImV4IiwiY3VyQW5nbGUiLCJoYXNSb3RhdGVkIiwic25hcEFuZ2xlIiwic25hcFRocmVzaG9sZCIsInJpZ2h0QW5nbGVMb2NrZWQiLCJsZWZ0QW5nbGVMb2NrZWQiLCJzY2FsZU9iamVjdCIsImRpbSIsImZvcmJpZFNjYWxpbmciLCJzaWduWCIsInNpZ25ZIiwiZ2VzdHVyZVNjYWxlIiwibG9ja1NjYWxpbmdGbGlwIiwib3JpZ2luYWwiLCJvcmlnaW5hbERpc3RhbmNlIiwib2xkU2NhbGVYIiwib2xkU2NhbGVZIiwic2NhbGVPYmplY3RGcm9tQ29ybmVyIiwic2NhbGVPYmplY3RYIiwic2NhbGVPYmplY3RZIiwic2NhbGluZ1lPclNrZXdpbmdYIiwic2NhbGluZ1kiLCJzY2FsaW5nWE9yU2tld2luZ1kiLCJzY2FsaW5nWCIsImNoYW5nZVdpZHRoIiwic3Ryb2tlUGFkZGluZyIsIm11bHRpcGxpZXIiLCJvbGRXaWR0aCIsIm5ld1dpZHRoIiwiZHJhZ0hhbmRsZXIiLCJuZXdMZWZ0IiwibmV3VG9wIiwibW92ZVgiLCJtb3ZlWSIsInNjYWxpbmdFcXVhbGx5IiwiY29udHJvbHNVdGlscyIsInJlbmRlckNpcmNsZUNvbnRyb2wiLCJzdHlsZU92ZXJyaWRlIiwieFNpemUiLCJzaXplWCIsImNvcm5lclNpemUiLCJ5U2l6ZSIsInNpemVZIiwidHJhbnNwYXJlbnRDb3JuZXJzIiwiY29ybmVyU3Ryb2tlQ29sb3IiLCJteUxlZnQiLCJteVRvcCIsInNhdmUiLCJmaWxsU3R5bGUiLCJjb3JuZXJDb2xvciIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwiYXJjIiwicmVzdG9yZSIsInJlbmRlclNxdWFyZUNvbnRyb2wiLCJ4U2l6ZUJ5MiIsInlTaXplQnkyIiwic3Ryb2tlUmVjdCIsIkNvbnRyb2wiLCJhY3Rpb25OYW1lIiwidG91Y2hTaXplWCIsInRvdWNoU2l6ZVkiLCJ3aXRoQ29ubmVjdGlvbiIsIm1vdXNlRG93bkhhbmRsZXIiLCJtb3VzZVVwSGFuZGxlciIsImdldEFjdGlvbkhhbmRsZXIiLCJnZXRNb3VzZURvd25IYW5kbGVyIiwiZ2V0TW91c2VVcEhhbmRsZXIiLCJjdXJzb3JTdHlsZUhhbmRsZXIiLCJnZXRBY3Rpb25OYW1lIiwiZ2V0VmlzaWJpbGl0eSIsImNvbnRyb2xLZXkiLCJvYmplY3RWaXNpYmlsaXR5IiwiX2NvbnRyb2xzVmlzaWJpbGl0eSIsInNldFZpc2liaWxpdHkiLCJwb3NpdGlvbkhhbmRsZXIiLCJmaW5hbE1hdHJpeCIsImNhbGNDb3JuZXJDb29yZHMiLCJvYmplY3RBbmdsZSIsIm9iamVjdENvcm5lclNpemUiLCJjZW50ZXJYIiwiY2VudGVyWSIsImlzVG91Y2giLCJjb3NIYWxmT2Zmc2V0Iiwic2luSGFsZk9mZnNldCIsImNvc0hhbGZPZmZzZXRDb21wIiwic2luSGFsZk9mZnNldENvbXAiLCJjb250cm9sVHJpYW5nbGVBbmdsZSIsImNvcm5lckh5cG90ZW51c2UiLCJuZXdUaGV0YSIsIm5ld1RoZXRhQ29tcCIsInRsIiwidHIiLCJibCIsImJyIiwicmVuZGVyIiwiY29ybmVyU3R5bGUiLCJnZXRDb2xvclN0b3AiLCJjb2xvckFscGhhIiwia2V5VmFsdWVQYWlycyIsImdldExpbmVhckNvb3JkcyIsImdldFJhZGlhbENvb3JkcyIsImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnRVbml0cyIsIm9wdGlvbiIsImFkZENvbG9yU3RvcCIsInRvT2JqZWN0IiwicHJvcGVydGllc1RvSW5jbHVkZSIsInRvU1ZHIiwibWFya3VwIiwiY29tbW9uQXR0cmlidXRlcyIsIm5lZWRzU3dhcCIsIndpdGhWaWV3cG9ydCIsImFkZGl0aW9uYWxUcmFuc2Zvcm0iLCJzb3J0IiwicmV2ZXJzZSIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsInBlcmNlbnRhZ2VTaGlmdCIsImNvbG9yU3RvcCIsInRvTGl2ZSIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJpbnN0YW5jZSIsInN2Z09wdGlvbnMiLCJjb2xvclN0b3BFbHMiLCJfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyIsInByb3BWYWx1ZSIsImZpbmFsVmFsdWUiLCJyZXBlYXQiLCJwYXR0ZXJuVHJhbnNmb3JtIiwic2V0T3B0aW9ucyIsImlzRXJyb3IiLCJwYXR0ZXJuU291cmNlIiwicGF0dGVybldpZHRoIiwicGF0dGVybkhlaWdodCIsInBhdHRlcm5PZmZzZXRYIiwicGF0dGVybk9mZnNldFkiLCJwYXR0ZXJuSW1nU3JjIiwiY29tcGxldGUiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiY3JlYXRlUGF0dGVybiIsIlNoYWRvdyIsImJsdXIiLCJhZmZlY3RTdHJva2UiLCJpbmNsdWRlRGVmYXVsdFZhbHVlcyIsIm5vblNjYWxpbmciLCJfcGFyc2VTaGFkb3ciLCJzaGFkb3ciLCJzaGFkb3dTdHIiLCJvZmZzZXRzQW5kQmx1ciIsInJlT2Zmc2V0c0FuZEJsdXIiLCJmQm94WCIsImZCb3hZIiwiQkxVUl9CT1giLCJTdGF0aWNDYW52YXMiLCJDQU5WQVNfSU5JVF9FUlJPUiIsIkVycm9yIiwicmVuZGVyQW5kUmVzZXRCb3VuZCIsInJlbmRlckFuZFJlc2V0IiwicmVxdWVzdFJlbmRlckFsbEJvdW5kIiwiX2luaXRTdGF0aWMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJvdmVybGF5Q29sb3IiLCJvdmVybGF5SW1hZ2UiLCJzdGF0ZWZ1bCIsImNvbnRyb2xzQWJvdmVPdmVybGF5IiwiYWxsb3dUb3VjaFNjcm9sbGluZyIsInZpZXdwb3J0VHJhbnNmb3JtIiwiYmFja2dyb3VuZFZwdCIsIm92ZXJsYXlWcHQiLCJlbmFibGVSZXRpbmFTY2FsaW5nIiwidnB0Q29vcmRzIiwic2tpcE9mZnNjcmVlbiIsImNiIiwiX2NyZWF0ZUxvd2VyQ2FudmFzIiwiX2luaXRPcHRpb25zIiwiaW50ZXJhY3RpdmUiLCJfaW5pdFJldGluYVNjYWxpbmciLCJzZXRPdmVybGF5SW1hZ2UiLCJzZXRCYWNrZ3JvdW5kSW1hZ2UiLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJzZXRPdmVybGF5Q29sb3IiLCJjYWxjT2Zmc2V0IiwiX2lzUmV0aW5hU2NhbGluZyIsImdldFJldGluYVNjYWxpbmciLCJzY2FsZVJhdGlvIiwiX19pbml0UmV0aW5hU2NhbGluZyIsImxvd2VyQ2FudmFzRWwiLCJjb250ZXh0Q29udGFpbmVyIiwidXBwZXJDYW52YXNFbCIsImNvbnRleHRUb3AiLCJfb2Zmc2V0IiwiaW1hZ2UiLCJfX3NldEJnT3ZlcmxheUltYWdlIiwiX19zZXRCZ092ZXJsYXlDb2xvciIsIl9jcmVhdGVDYW52YXNFbGVtZW50IiwiX29yaWdpbmFsQ2FudmFzU3R5bGUiLCJfYXBwbHlDYW52YXNTdHlsZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0Iiwic2V0V2lkdGgiLCJzZXREaW1lbnNpb25zIiwic2V0SGVpZ2h0IiwiZGltZW5zaW9ucyIsImNzc1ZhbHVlIiwiY3NzT25seSIsIl9zZXRCYWNrc3RvcmVEaW1lbnNpb24iLCJoYXNMb3N0Q29udGV4dCIsImJhY2tzdG9yZU9ubHkiLCJfc2V0Q3NzRGltZW5zaW9uIiwiX2lzQ3VycmVudGx5RHJhd2luZyIsImZyZWVEcmF3aW5nQnJ1c2giLCJfc2V0QnJ1c2hTdHlsZXMiLCJjYWNoZUNhbnZhc0VsIiwid3JhcHBlckVsIiwic2V0Vmlld3BvcnRUcmFuc2Zvcm0iLCJ2cHQiLCJhY3RpdmVPYmplY3QiLCJfYWN0aXZlT2JqZWN0IiwiYmFja2dyb3VuZE9iamVjdCIsIm92ZXJsYXlPYmplY3QiLCJncm91cCIsInNldENvb3JkcyIsImNhbGNWaWV3cG9ydEJvdW5kYXJpZXMiLCJ6b29tVG9Qb2ludCIsImJlZm9yZSIsImFmdGVyIiwic2V0Wm9vbSIsImFic29sdXRlUGFuIiwicmVsYXRpdmVQYW4iLCJnZXRFbGVtZW50Iiwic2V0dXBTdGF0ZSIsImNsZWFyQ29udGV4dCIsImNsZWFyUmVjdCIsImNsZWFyIiwiX2hhc0lUZXh0SGFuZGxlcnMiLCJfbW91c2VVcElUZXh0SGFuZGxlciIsIl9pVGV4dEluc3RhbmNlcyIsInJlbmRlckFsbCIsImNhbnZhc1RvRHJhd09uIiwicmVuZGVyQ2FudmFzIiwiaXNSZW5kZXJpbmciLCJpVnB0IiwiY2FuY2VsUmVxdWVzdGVkUmVuZGVyIiwiX3JlbmRlckJhY2tncm91bmQiLCJfcmVuZGVyT2JqZWN0cyIsImRyYXdDb250cm9scyIsInNob3VsZENhY2hlIiwiX3RyYW5zZm9ybURvbmUiLCJyZW5kZXJDYWNoZSIsImZvckNsaXBwaW5nIiwiZHJhd0NsaXBQYXRoT25DYW52YXMiLCJfcmVuZGVyT3ZlcmxheSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsInpvb21YIiwiem9vbVkiLCJfY2FjaGVDYW52YXMiLCJjYWNoZVRyYW5zbGF0aW9uWCIsImNhY2hlVHJhbnNsYXRpb25ZIiwiX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkiLCJuZWVkc1ZwdCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImdldENlbnRlciIsImNlbnRlck9iamVjdEgiLCJfY2VudGVyT2JqZWN0IiwiY2VudGVyT2JqZWN0ViIsImNlbnRlck9iamVjdCIsInZpZXdwb3J0Q2VudGVyT2JqZWN0IiwidnBDZW50ZXIiLCJnZXRWcENlbnRlciIsInZpZXdwb3J0Q2VudGVyT2JqZWN0SCIsInZpZXdwb3J0Q2VudGVyT2JqZWN0ViIsInRvRGF0YWxlc3NKU09OIiwidG9EYXRhbGVzc09iamVjdCIsIl90b09iamVjdE1ldGhvZCIsIl90b09iamVjdHMiLCJleGNsdWRlRnJvbUV4cG9ydCIsIl90b09iamVjdCIsIl9fc2VyaWFsaXplQmdPdmVybGF5Iiwib3JpZ2luYWxWYWx1ZSIsImJnSW1hZ2UiLCJiZ0NvbG9yIiwiYmFja2dyb3VuZCIsIm92ZXJsYXkiLCJzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uIiwiX3NldFNWR1ByZWFtYmxlIiwiX3NldFNWR0hlYWRlciIsImNsaXBQYXRoSWQiLCJfc2V0U1ZHQmdPdmVybGF5Q29sb3IiLCJfc2V0U1ZHQmdPdmVybGF5SW1hZ2UiLCJfc2V0U1ZHT2JqZWN0cyIsInN1cHByZXNzUHJlYW1ibGUiLCJlbmNvZGluZyIsInZpZXdCb3giLCJjcmVhdGVTVkdGb250RmFjZXNNYXJrdXAiLCJjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCIsImNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwIiwidG9DbGlwUGF0aFNWRyIsInNob3VsZFRyYW5zZm9ybSIsImZvbnRMaXN0Iiwicm93Iiwicm93SW5kZXgiLCJfY2hhciIsIl9zZXRTVkdPYmplY3QiLCJmaW5hbFdpZHRoIiwiZmluYWxIZWlnaHQiLCJzaG91bGRJbnZlcnQiLCJzZW5kVG9CYWNrIiwiYWN0aXZlU2VsZWN0aW9uIiwib2JqcyIsInVuc2hpZnQiLCJicmluZ1RvRnJvbnQiLCJzZW5kQmFja3dhcmRzIiwiaW50ZXJzZWN0aW5nIiwibmV3SWR4Iiwib2Jqc01vdmVkIiwiX2ZpbmROZXdMb3dlckluZGV4IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3RzV2l0aE9iamVjdCIsImlzQ29udGFpbmVkV2l0aGluT2JqZWN0IiwiYnJpbmdGb3J3YXJkIiwiX2ZpbmROZXdVcHBlckluZGV4IiwiZGlzcG9zZSIsImNsYXNzTGlzdCIsIkRhdGFVUkxFeHBvcnRlciIsIkVNUFRZX0pTT04iLCJzdXBwb3J0cyIsInNldExpbmVEYXNoIiwidG9KU09OIiwiY3JlYXRlUE5HU3RyZWFtIiwiY3JlYXRlSlBFR1N0cmVhbSIsIkJhc2VCcnVzaCIsInN0cm9rZUxpbmVDYXAiLCJzdHJva2VEYXNoQXJyYXkiLCJsaW1pdGVkVG9DYW52YXNTaXplIiwibGluZUNhcCIsIm1pdGVyTGltaXQiLCJsaW5lSm9pbiIsIl9zYXZlQW5kVHJhbnNmb3JtIiwiX3NldFNoYWRvdyIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwibmVlZHNGdWxsUmVuZGVyIiwiX3Jlc2V0U2hhZG93IiwiX2lzT3V0U2lkZUNhbnZhcyIsIlBlbmNpbEJydXNoIiwiZGVjaW1hdGUiLCJkcmF3U3RyYWlnaHRMaW5lIiwic3RyYWlnaHRMaW5lS2V5IiwiX3BvaW50cyIsIl9oYXNTdHJhaWdodExpbmUiLCJfZHJhd1NlZ21lbnQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwib25Nb3VzZURvd24iLCJfaXNNYWluRXZlbnQiLCJfcHJlcGFyZUZvckRyYXdpbmciLCJfY2FwdHVyZURyYXdpbmdQYXRoIiwiX3JlbmRlciIsIm9uTW91c2VNb3ZlIiwib2xkRW5kIiwib25Nb3VzZVVwIiwiX2ZpbmFsaXplQW5kQWRkUGF0aCIsIl9yZXNldCIsIl9hZGRQb2ludCIsInBvaW50ZXJQb2ludCIsImNvbnZlcnRQb2ludHNUb1NWR1BhdGgiLCJfaXNFbXB0eVNWR1BhdGgiLCJjcmVhdGVQYXRoIiwiUGF0aCIsImRlY2ltYXRlUG9pbnRzIiwiYWRqdXN0ZWREaXN0YW5jZSIsImxhc3RQb2ludCIsIm5ld1BvaW50cyIsImNEaXN0YW5jZSIsIkNpcmNsZUJydXNoIiwiZHJhd0RvdCIsImFkZFBvaW50IiwiZG90IiwicmFkaXVzIiwib3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSIsImNpcmNsZXMiLCJjaXJjbGUiLCJDaXJjbGUiLCJjaXJjbGVSYWRpdXMiLCJjaXJjbGVDb2xvciIsIlNwcmF5QnJ1c2giLCJkZW5zaXR5IiwiZG90V2lkdGgiLCJkb3RXaWR0aFZhcmlhbmNlIiwicmFuZG9tT3BhY2l0eSIsIm9wdGltaXplT3ZlcmxhcHBpbmciLCJzcHJheUNodW5rcyIsImFkZFNwcmF5Q2h1bmsiLCJzcHJheUNodW5rUG9pbnRzIiwicmVjdHMiLCJpbGVuIiwic3ByYXlDaHVuayIsInJlY3QiLCJSZWN0IiwiX2dldE9wdGltaXplZFJlY3RzIiwidW5pcXVlUmVjdHMiLCJ1bmlxdWVSZWN0c0FycmF5IiwiZ2xvYmFsQWxwaGEiLCJmaWxsUmVjdCIsIlBhdHRlcm5CcnVzaCIsImdldFBhdHRlcm5TcmMiLCJkb3REaXN0YW5jZSIsInBhdHRlcm5DYW52YXMiLCJwYXR0ZXJuQ3R4IiwiZ2V0UGF0dGVyblNyY0Z1bmN0aW9uIiwiU3RyaW5nIiwiZ2V0UGF0dGVybiIsInRvcExlZnQiLCJfZ2V0TGVmdFRvcENvb3JkcyIsIl9pbml0SW50ZXJhY3RpdmUiLCJfY3JlYXRlQ2FjaGVDYW52YXMiLCJjZW50ZXJlZFNjYWxpbmciLCJjZW50ZXJlZFJvdGF0aW9uIiwiY2VudGVyZWRLZXkiLCJzZWxlY3Rpb24iLCJzZWxlY3Rpb25LZXkiLCJhbHRTZWxlY3Rpb25LZXkiLCJzZWxlY3Rpb25Db2xvciIsInNlbGVjdGlvbkRhc2hBcnJheSIsInNlbGVjdGlvbkJvcmRlckNvbG9yIiwic2VsZWN0aW9uTGluZVdpZHRoIiwic2VsZWN0aW9uRnVsbHlDb250YWluZWQiLCJob3ZlckN1cnNvciIsIm1vdmVDdXJzb3IiLCJkZWZhdWx0Q3Vyc29yIiwiZnJlZURyYXdpbmdDdXJzb3IiLCJub3RBbGxvd2VkQ3Vyc29yIiwiY29udGFpbmVyQ2xhc3MiLCJwZXJQaXhlbFRhcmdldEZpbmQiLCJ0YXJnZXRGaW5kVG9sZXJhbmNlIiwic2tpcFRhcmdldEZpbmQiLCJpc0RyYXdpbmdNb2RlIiwicHJlc2VydmVPYmplY3RTdGFja2luZyIsInN0b3BDb250ZXh0TWVudSIsImZpcmVSaWdodENsaWNrIiwiZmlyZU1pZGRsZUNsaWNrIiwidGFyZ2V0cyIsImVuYWJsZVBvaW50ZXJFdmVudHMiLCJfaG92ZXJlZFRhcmdldCIsIl9ob3ZlcmVkVGFyZ2V0cyIsIl9jdXJyZW50VHJhbnNmb3JtIiwiX2dyb3VwU2VsZWN0b3IiLCJfaW5pdFdyYXBwZXJFbGVtZW50IiwiX2NyZWF0ZVVwcGVyQ2FudmFzIiwiX2luaXRFdmVudExpc3RlbmVycyIsIl9jaG9vc2VPYmplY3RzVG9SZW5kZXIiLCJhY3RpdmVPYmplY3RzIiwiZ2V0QWN0aXZlT2JqZWN0cyIsIm9ianNUb1JlbmRlciIsImFjdGl2ZUdyb3VwT2JqZWN0cyIsImNvbnRleHRUb3BEaXJ0eSIsInJlbmRlclRvcExheWVyIiwiX2RyYXdTZWxlY3Rpb24iLCJyZW5kZXJUb3AiLCJfbm9ybWFsaXplUG9pbnRlciIsImludmVydGVkTSIsInZwdFBvaW50ZXIiLCJyZXN0b3JlUG9pbnRlclZwdCIsImlzVGFyZ2V0VHJhbnNwYXJlbnQiLCJub3JtYWxpemVkUG9pbnRlciIsInRhcmdldFJlbGF0aXZlWCIsInRhcmdldFJlbGF0aXZlWSIsIl9jYWNoZUNvbnRleHQiLCJjb250ZXh0Q2FjaGUiLCJvcmlnaW5hbENvbG9yIiwic2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIiwiX2lzU2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbktleVByZXNzZWQiLCJfc2hvdWxkQ2xlYXJTZWxlY3Rpb24iLCJldmVudGVkIiwic2VsZWN0YWJsZSIsIl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0iLCJhY3Rpb24iLCJhbHRLZXkiLCJjZW50ZXJUcmFuc2Zvcm0iLCJfZ2V0T3JpZ2luRnJvbUNvcm5lciIsIl9nZXRBY3Rpb25Gcm9tQ29ybmVyIiwiYWxyZWFkeVNlbGVjdGVkIiwiX3NldHVwQ3VycmVudFRyYW5zZm9ybSIsIl9fY29ybmVyIiwibGFzdFgiLCJsYXN0WSIsInNoaWZ0S2V5IiwiX2JlZm9yZVRyYW5zZm9ybSIsInNldEN1cnNvciIsImN1cnNvciIsInZpZXdwb3J0U3RhcnQiLCJ2aWV3cG9ydEV4dGVudCIsImV4dGVudCIsInN0cm9rZU9mZnNldCIsIl9zZXRMaW5lRGFzaCIsImZpbmRUYXJnZXQiLCJza2lwR3JvdXAiLCJpZ25vcmVab29tIiwiYU9iamVjdHMiLCJhY3RpdmVUYXJnZXQiLCJhY3RpdmVUYXJnZXRTdWJzIiwic2hvdWxkTG9va0ZvckFjdGl2ZSIsIl9maW5kVGFyZ2V0Q29ybmVyIiwiX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyIsIl9jaGVja1RhcmdldCIsImdsb2JhbFBvaW50ZXIiLCJjb250YWluc1BvaW50IiwiaXNFZGl0aW5nIiwic3ViVGFyZ2V0Iiwib2JqVG9DaGVjayIsInBvaW50ZXJUb1VzZSIsInN1YlRhcmdldENoZWNrIiwiX2Fic29sdXRlUG9pbnRlciIsIl9wb2ludGVyIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJjc3NTY2FsZSIsInJldGluYVNjYWxpbmciLCJsb3dlckNhbnZhc0NsYXNzIiwiX2NvcHlDYW52YXNTdHlsZSIsImdldFRvcENvbnRleHQiLCJmcm9tRWwiLCJ0b0VsIiwiZ2V0U2VsZWN0aW9uQ29udGV4dCIsImdldFNlbGVjdGlvbkVsZW1lbnQiLCJnZXRBY3RpdmVPYmplY3QiLCJhY3RpdmUiLCJfZGlzY2FyZEFjdGl2ZU9iamVjdCIsIl9maXJlU2VsZWN0aW9uRXZlbnRzIiwib2xkT2JqZWN0cyIsInNvbWV0aGluZ0NoYW5nZWQiLCJhZGRlZCIsInJlbW92ZWQiLCJvbGRPYmplY3QiLCJzZWxlY3RlZCIsImRlc2VsZWN0ZWQiLCJzZXRBY3RpdmVPYmplY3QiLCJjdXJyZW50QWN0aXZlcyIsIl9zZXRBY3RpdmVPYmplY3QiLCJvblNlbGVjdCIsIm9uRGVzZWxlY3QiLCJkaXNjYXJkQWN0aXZlT2JqZWN0IiwicmVtb3ZlTGlzdGVuZXJzIiwiX3JlbmRlckNvbnRyb2xzIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwiX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0IiwiX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QiLCJsYXlvdXRQcm9wcyIsIm9yaWdpbmFsVmFsdWVzIiwiY2xlYXJDb250ZXh0VG9wIiwiUklHSFRfQ0xJQ0siLCJNSURETEVfQ0xJQ0siLCJMRUZUX0NMSUNLIiwiYWRkRXZlbnRPcHRpb25zIiwicGFzc2l2ZSIsImNoZWNrQ2xpY2siLCJidXR0b24iLCJtYWluVG91Y2hJZCIsIl9iaW5kRXZlbnRzIiwiYWRkT3JSZW1vdmUiLCJfZ2V0RXZlbnRQcmVmaXgiLCJmdW5jdG9yIiwiZXZlbnRqc0Z1bmN0b3IiLCJjYW52YXNFbGVtZW50IiwiZXZlbnRUeXBlUHJlZml4IiwiX29uUmVzaXplIiwiX29uTW91c2VEb3duIiwiX29uTW91c2VNb3ZlIiwiX29uTW91c2VPdXQiLCJfb25Nb3VzZUVudGVyIiwiX29uTW91c2VXaGVlbCIsIl9vbkNvbnRleHRNZW51IiwiX29uRG91YmxlQ2xpY2siLCJfb25EcmFnT3ZlciIsIl9vbkRyYWdFbnRlciIsIl9vbkRyYWdMZWF2ZSIsIl9vbkRyb3AiLCJfb25Ub3VjaFN0YXJ0IiwiZXZlbnRqcyIsIl9vbkdlc3R1cmUiLCJfb25EcmFnIiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfb25TaGFrZSIsIl9vbkxvbmdQcmVzcyIsIl9vbk1vdXNlVXAiLCJfb25Ub3VjaEVuZCIsImV2ZW50c0JvdW5kIiwiX3NpbXBsZUV2ZW50SGFuZGxlciIsInNlbGYiLCJfX29uVHJhbnNmb3JtR2VzdHVyZSIsIl9fb25EcmFnIiwiX19vbk1vdXNlV2hlZWwiLCJfdGFyZ2V0IiwiX19vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX19vblNoYWtlIiwiX19vbkxvbmdQcmVzcyIsInByZXZlbnREZWZhdWx0IiwiX2ZpcmVFbnRlckxlYXZlRXZlbnRzIiwic3RvcFByb3BhZ2F0aW9uIiwiX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhIiwiX2hhbmRsZUV2ZW50IiwiX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhIiwiZ2V0UG9pbnRlcklkIiwiZXZ0IiwiaWRlbnRpZmllciIsInBvaW50ZXJJZCIsImlzUHJpbWFyeSIsInRvdWNoZXMiLCJfX29uTW91c2VEb3duIiwiX19vbk1vdXNlVXAiLCJfd2lsbEFkZE1vdXNlRG93biIsIl9fb25Nb3VzZU1vdmUiLCJfc2hvdWxkUmVuZGVyIiwiZ3JvdXBTZWxlY3RvciIsInNob3VsZFJlbmRlciIsImlzQ2xpY2siLCJfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZSIsIl9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm0iLCJ0YXJnZXRXYXNBY3RpdmUiLCJfbWF5YmVHcm91cE9iamVjdHMiLCJhY3RpdmVPbiIsImlzTW92aW5nIiwib3JpZ2luYWxDb250cm9sIiwib3JpZ2luYWxNb3VzZVVwSGFuZGxlciIsIl9zZXRDdXJzb3JGcm9tRXZlbnQiLCJldmVudFR5cGUiLCJzdWJUYXJnZXRzIiwiYWJzb2x1dGVQb2ludGVyIiwiY3VycmVudFRhcmdldCIsImN1cnJlbnRTdWJUYXJnZXRzIiwiX3NjYWxpbmciLCJoYXNTdGF0ZUNoYW5nZWQiLCJfZmlyZSIsIl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUiLCJfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlIiwiX3ByZXZpb3VzUG9pbnRlciIsInNob3VsZEdyb3VwIiwiX3Nob3VsZEdyb3VwIiwiX2hhbmRsZUdyb3VwaW5nIiwic2F2ZVN0YXRlIiwiX2ZpcmVPdmVyT3V0RXZlbnRzIiwiX3RyYW5zZm9ybU9iamVjdCIsImZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyIsIm9sZFRhcmdldCIsImV2dE91dCIsImNhbnZhc0V2dE91dCIsImV2dEluIiwiY2FudmFzRXZ0SW4iLCJfZHJhZ2dlZG92ZXJUYXJnZXQiLCJjb25maWciLCJpbk9wdCIsIm91dE9wdCIsIm91dEZpcmVzIiwiaW5GaXJlcyIsInRhcmdldENoYW5nZWQiLCJwcmV2aW91c1RhcmdldCIsIm5leHRUYXJnZXQiLCJyZXNldCIsIl9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uIiwiZ2V0Q29ybmVyQ3Vyc29yIiwiX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbiIsIl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24iLCJjdXJyZW50QWN0aXZlT2JqZWN0cyIsInJlbW92ZVdpdGhVcGRhdGUiLCJhZGRXaXRoVXBkYXRlIiwiX2NyZWF0ZUdyb3VwIiwiaXNBY3RpdmVMb3dlciIsImdyb3VwT2JqZWN0cyIsImV4aXRFZGl0aW5nIiwiQWN0aXZlU2VsZWN0aW9uIiwiX2dyb3VwU2VsZWN0ZWRPYmplY3RzIiwiX2NvbGxlY3RPYmplY3RzIiwiYUdyb3VwIiwiY3VycmVudE9iamVjdCIsInNlbGVjdGlvblgxWTEiLCJzZWxlY3Rpb25YMlkyIiwiYWxsb3dJbnRlcnNlY3QiLCJpbnRlcnNlY3RzV2l0aFJlY3QiLCJpc0NvbnRhaW5lZFdpdGhpblJlY3QiLCJ0b0NhbnZhc0VsZW1lbnQiLCJjcm9wcGluZyIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwib3JpZ2luYWxXaWR0aCIsIm9yaWdpbmFsSGVpZ2h0IiwibmV3Wm9vbSIsInZwIiwib3JpZ2luYWxJbnRlcmFjdGl2ZSIsIm5ld1ZwIiwib3JpZ2luYWxSZXRpbmEiLCJvcmlnaW5hbENvbnRleHRUb3AiLCJsb2FkRnJvbUpTT04iLCJqc29uIiwic2VyaWFsaXplZCIsIkpTT04iLCJfZW5saXZlbk9iamVjdHMiLCJfc2V0QmdPdmVybGF5IiwiZW5saXZlbmVkQ2FudmFzQ2xpcCIsIl9fc2V0dXBDYW52YXMiLCJsb2FkZWQiLCJjYklmTG9hZGVkIiwiX19zZXRCZ092ZXJsYXkiLCJlbmxpdmVkT2JqZWN0IiwiX3RvRGF0YVVSTCIsIl90b0RhdGFVUkxXaXRoTXVsdGlwbGllciIsInRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyIiwic3RyaW5naWZ5IiwiY2xvbmVXaXRob3V0RGF0YSIsImJhY2tncm91bmRJbWFnZU9wYWNpdHkiLCJiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoIiwib2JqZWN0Q2FjaGluZyIsIkFMSUFTSU5HX0xJTUlUIiwidG91Y2hDb3JuZXJTaXplIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJEYXNoQXJyYXkiLCJjb3JuZXJEYXNoQXJyYXkiLCJzdHJva2VEYXNoT2Zmc2V0IiwiYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmciLCJib3JkZXJTY2FsZUZhY3RvciIsIm1pblNjYWxlTGltaXQiLCJoYXNDb250cm9scyIsImhhc0JvcmRlcnMiLCJsb2NrTW92ZW1lbnRYIiwibG9ja01vdmVtZW50WSIsInN0YXRlZnVsbENhY2hlIiwibm9TY2FsZUNhY2hlIiwiZGlydHkiLCJwYWludEZpcnN0Iiwic3RhdGVQcm9wZXJ0aWVzIiwiY2FjaGVQcm9wZXJ0aWVzIiwiY29sb3JQcm9wZXJ0aWVzIiwiYWJzb2x1dGVQb3NpdGlvbmVkIiwiX2NhY2hlUHJvcGVydGllcyIsIl91cGRhdGVDYWNoZUNhbnZhcyIsIl9saW1pdENhY2hlU2l6ZSIsImRpbXMiLCJsaW1pdGVkRGltcyIsImNhcHBlZCIsIl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMiLCJvYmplY3RTY2FsZSIsImdldFRvdGFsT2JqZWN0U2NhbGluZyIsIm5lZWRlZFgiLCJuZWVkZWRZIiwidGFyZ2V0Q2FudmFzIiwibWluQ2FjaGVTaXplIiwiZHJhd2luZ1dpZHRoIiwiZHJhd2luZ0hlaWdodCIsImRpbWVuc2lvbnNDaGFuZ2VkIiwiY2FjaGVXaWR0aCIsImNhY2hlSGVpZ2h0Iiwiem9vbUNoYW5nZWQiLCJzaG91bGRSZWRyYXciLCJhZGRpdGlvbmFsV2lkdGgiLCJhZGRpdGlvbmFsSGVpZ2h0Iiwic2hvdWxkUmVzaXplQ2FudmFzIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJzaXplR3Jvd2luZyIsInNpemVTaHJpbmtpbmciLCJnZXRIZWlnaHRPZkxpbmUiLCJzZXRUcmFuc2Zvcm0iLCJuZWVkRnVsbFRyYW5zZm9ybSIsIl9yZW1vdmVEZWZhdWx0VmFsdWVzIiwiZ2V0T2JqZWN0U2NhbGluZyIsInJldGluYSIsImdldE9iamVjdE9wYWNpdHkiLCJzaG91bGRDb25zdHJhaW5WYWx1ZSIsImlzQ2hhbmdlZCIsImdyb3VwTmVlZHNVcGRhdGUiLCJfY29uc3RyYWluU2NhbGUiLCJpc09uQUNhY2hlIiwic2V0T25Hcm91cCIsImdldFZpZXdwb3J0VHJhbnNmb3JtIiwiaXNOb3RWaXNpYmxlIiwiaXNPblNjcmVlbiIsIl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbiIsImRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kIiwiX3NldE9wYWNpdHkiLCJkcmF3Q2FjaGVPbkNhbnZhcyIsIl9yZW1vdmVDYWNoZUNhbnZhcyIsImRyYXdPYmplY3QiLCJwcm9wZXJ0eVNldCIsImlzQ2FjaGVEaXJ0eSIsImhhc1N0cm9rZSIsImhhc0ZpbGwiLCJuZWVkc0l0c093bkNhY2hlIiwib3duQ2FjaGluZyIsIndpbGxEcmF3U2hhZG93IiwiZHJhd0NsaXBQYXRoT25DYWNoZSIsIm9yaWdpbmFsRmlsbCIsIm9yaWdpbmFsU3Ryb2tlIiwiX3NldENsaXBwaW5nUHJvcGVydGllcyIsIl9kcmF3Q2xpcFBhdGgiLCJza2lwQ2FudmFzIiwiX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucyIsIl9yZW1vdmVTaGFkb3ciLCJfc2V0U3Ryb2tlU3R5bGVzIiwiZGVjbCIsImxpbmVEYXNoT2Zmc2V0IiwiX2FwcGx5UGF0dGVybkZvclRyYW5zZm9ybWVkR3JhZGllbnQiLCJfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0iLCJfc2V0RmlsbFN0eWxlcyIsImRhc2hBcnJheSIsImRyYXdCb3JkZXJzIiwiZm9yQWN0aXZlU2VsZWN0aW9uIiwiZHJhd0JvcmRlcnNJbkdyb3VwIiwic2NhbGluZyIsIm11bHRYIiwibXVsdFkiLCJfcmVuZGVyUGFpbnRJbk9yZGVyIiwiX3JlbmRlclN0cm9rZSIsIl9yZW5kZXJGaWxsIiwicENhbnZhcyIsInBDdHgiLCJfZmluZENlbnRlckZyb21FbGVtZW50IiwiX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzIiwicHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMiLCJjcm9wWCIsImNyb3BZIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9iamVjdEZvcm0iLCJfZnJvbU9iamVjdCIsImNsb25lQXNJbWFnZSIsInV0aWxzIiwib3JpZ1BhcmFtcyIsIm9yaWdpbmFsR3JvdXAiLCJvcmlnaW5hbFNoYWRvdyIsIndpdGhvdXRUcmFuc2Zvcm0iLCJ3aXRob3V0U2hhZG93IiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdSZWN0Iiwic2hhZG93T2Zmc2V0Iiwib3JpZ2luYWxDYW52YXMiLCJpc1R5cGUiLCJpbmNsdWRlcyIsInNob3VsZENlbnRlck9yaWdpbiIsIl9zZXRPcmlnaW5Ub0NlbnRlciIsIl9yZXNldE9yaWdpbiIsImNlbnRlckgiLCJ2aWV3cG9ydENlbnRlckgiLCJjZW50ZXJWIiwidmlld3BvcnRDZW50ZXJWIiwidmlld3BvcnRDZW50ZXIiLCJnZXRMb2NhbFBvaW50ZXIiLCJwQ2xpY2tlZCIsIm9iamVjdExlZnRUb3AiLCJjcmVhdGVBY2Nlc3NvcnMiLCJleHRyYVBhcmFtIiwib3JpZ2luWE9mZnNldCIsIm9yaWdpbllPZmZzZXQiLCJ0cmFuc2xhdGVUb0dpdmVuT3JpZ2luIiwiZnJvbU9yaWdpblgiLCJmcm9tT3JpZ2luWSIsInRvT3JpZ2luWCIsInRvT3JpZ2luWSIsInRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQiLCJsZWZ0VG9wIiwiZ2V0UG9pbnRCeU9yaWdpbiIsImFkanVzdFBvc2l0aW9uIiwiaHlwb3RGdWxsIiwiZ2V0U2NhbGVkV2lkdGgiLCJ4RnVsbCIsInlGdWxsIiwib2Zmc2V0RnJvbSIsIm9mZnNldFRvIiwiX29yaWdpbmFsT3JpZ2luWCIsIl9vcmlnaW5hbE9yaWdpblkiLCJvcmlnaW5Qb2ludCIsImFycmF5RnJvbUNvb3JkcyIsIm11bHRpcGx5TWF0cmljZXMiLCJvQ29vcmRzIiwiYUNvb3JkcyIsImxpbmVDb29yZHMiLCJvd25NYXRyaXhDYWNoZSIsIm1hdHJpeENhY2hlIiwiX2dldENvb3JkcyIsImFic29sdXRlIiwiY2FsY3VsYXRlIiwiY2FsY0FDb29yZHMiLCJjYWxjTGluZUNvb3JkcyIsImdldENvb3JkcyIsInBvaW50VEwiLCJwb2ludEJSIiwiaW50ZXJzZWN0aW9uIiwib3RoZXIiLCJvdGhlckNvb3JkcyIsImxpbmVzIiwiX2dldEltYWdlTGluZXMiLCJfZmluZENyb3NzUG9pbnRzIiwiX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMiLCJpc1BhcnRpYWxseU9uU2NyZWVuIiwiYWxsUG9pbnRzQXJlT3V0c2lkZSIsImV2ZXJ5IiwidG9wbGluZSIsInJpZ2h0bGluZSIsImJvdHRvbWxpbmUiLCJsZWZ0bGluZSIsInhpIiwieGNvdW50IiwiaUxpbmUiLCJsaW5lS2V5IiwiZ2V0U2NhbGVkSGVpZ2h0Iiwic2NhbGVUb1dpZHRoIiwiYm91bmRpbmdSZWN0RmFjdG9yIiwic2NhbGVUb0hlaWdodCIsImNvc1AiLCJzaW5QIiwiY29zUFNpblAiLCJjb3NQTWludXNTaW5QIiwiY2FsY09Db29yZHMiLCJfY2FsY1JvdGF0ZU1hdHJpeCIsIl9jYWxjVHJhbnNsYXRlTWF0cml4Iiwic3RhcnRNYXRyaXgiLCJfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMiLCJmb3JFYWNoQ29udHJvbCIsInciLCJza2lwQ29ybmVycyIsIl9zZXRDb3JuZXJDb29yZHMiLCJ0cmFuc2Zvcm1NYXRyaXhLZXkiLCJzZXAiLCJwcmVmaXgiLCJjYWNoZSIsInRNYXRyaXgiLCJub1NrZXciLCJfZmluYWxpemVEaW1lbnNpb25zIiwiZ2V0U3ZnQ29sb3JTdHJpbmciLCJnZXRTdmdTdHlsZXMiLCJza2lwU2hhZG93IiwiZ2V0U3ZnRmlsdGVyIiwiZ2V0U3ZnU3BhblN0eWxlcyIsInVzZVdoaXRlU3BhY2UiLCJ0ZXJtIiwidGV4dERlY29yYXRpb24iLCJnZXRTdmdUZXh0RGVjb3JhdGlvbiIsImRlY29yYXRpb24iLCJnZXRTdmdDb21tb25zIiwiZ2V0U3ZnVHJhbnNmb3JtIiwiZnVsbCIsInN2Z1RyYW5zZm9ybSIsIl9zZXRTVkdCZyIsInRleHRCZ1JlY3RzIiwiX2dldEZpbGxBdHRyaWJ1dGVzIiwiX2NyZWF0ZUJhc2VTVkdNYXJrdXAiLCJfdG9TVkciLCJfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwIiwib2JqZWN0TWFya3VwIiwiY29tbW9uUGllY2VzIiwibm9TdHlsZSIsInN0eWxlSW5mbyIsInNoYWRvd0luZm8iLCJ3aXRoU2hhZG93IiwidmVjdG9yRWZmZWN0IiwiYWJzb2x1dGVDbGlwUGF0aCIsImNsaXBQYXRoTWFya3VwIiwiYWRkUGFpbnRPcmRlciIsIm9yaWdpbmFsU2V0Iiwic2F2ZVByb3BzIiwicHJvcHMiLCJ0bXBPYmoiLCJfaXNFcXVhbCIsIm9yaWdWYWx1ZSIsImZpcnN0UGFzcyIsImRhc2hlZFByb3BlcnR5U2V0IiwiZm9yVG91Y2giLCJpc0NvbnRyb2xWaXNpYmxlIiwidG91Y2hDb3JuZXIiLCJmbiIsImNvbnRyb2xPYmplY3QiLCJ3aCIsInNob3VsZFN0cm9rZSIsInNldENvbnRyb2xWaXNpYmxlIiwic2V0Q29udHJvbHNWaXNpYmlsaXR5IiwiRlhfRFVSQVRJT04iLCJmeENlbnRlck9iamVjdEgiLCJjYWxsYmFja3MiLCJlbXB0eSIsImZ4Q2VudGVyT2JqZWN0ViIsImZ4UmVtb3ZlIiwicHJvcHNUb0FuaW1hdGUiLCJza2lwQ2FsbGJhY2tzIiwib3V0IiwiX2FuaW1hdGUiLCJwcm9wUGFpciIsInByb3BJc0NvbG9yIiwidmFsdWVQcm9ncmVzcyIsInRpbWVQcm9ncmVzcyIsImNvb3JkUHJvcHMiLCJMaW5lIiwiX3NldFdpZHRoSGVpZ2h0IiwiX2dldExlZnRUb09yaWdpblgiLCJfZ2V0VG9wVG9PcmlnaW5ZIiwibWFrZUVkZ2VUb09yaWdpbkdldHRlciIsImF4aXMxIiwiYXhpczIiLCJkaW1lbnNpb24iLCJuZWFyZXN0IiwiZmFydGhlc3QiLCJjYWxjTGluZVBvaW50cyIsIm9yaWdTdHJva2VTdHlsZSIsInhNdWx0IiwieU11bHQiLCJBVFRSSUJVVEVfTkFNRVMiLCJwYXJzZWRBdHRyaWJ1dGVzIiwiX2NhbGxiYWNrIiwicHJvcGVydHlOYW1lcyIsIm9yaWdpblZhbHVlcyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInNldFJhZGl1cyIsInN2Z1N0cmluZyIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwibGFyZ2VGbGFnIiwiZ2V0UmFkaXVzWCIsImdldFJhZGl1c1kiLCJpc1ZhbGlkUmFkaXVzIiwiVHJpYW5nbGUiLCJ3aWR0aEJ5MiIsImhlaWdodEJ5MiIsInBpQnkyIiwiRWxsaXBzZSIsImdldFJ4IiwiZ2V0UnkiLCJfaW5pdFJ4UnkiLCJpc1JvdW5kZWQiLCJiZXppZXJDdXJ2ZVRvIiwiUG9seWxpbmUiLCJleGFjdEJvdW5kaW5nQm94IiwiX3NldFBvc2l0aW9uRGltZW5zaW9ucyIsIl9wcm9qZWN0U3Ryb2tlT25Qb2ludHMiLCJjYWxjRGltIiwiX2NhbGNEaW1lbnNpb25zIiwiY29ycmVjdExlZnRUb3AiLCJjb3JyZWN0U2l6ZSIsImZyb21TVkciLCJkaWZmWCIsImRpZmZZIiwiY29tbW9uUmVuZGVyIiwiZnJvbUVsZW1lbnRHZW5lcmF0b3IiLCJfY2xhc3MiLCJQb2x5Z29uIiwiX3NldFBhdGgiLCJfcmVuZGVyUGF0aENvbW1hbmRzIiwic3VicGF0aFN0YXJ0WCIsInN1YnBhdGhTdGFydFkiLCJfZ2V0T2Zmc2V0VHJhbnNmb3JtIiwiZGlnaXRzIiwiYVgiLCJhWSIsImRlbHRhWCIsInBhdGhVcmwiLCJlbGl2ZW5lZE9iamVjdHMiLCJ1c2VTZXRPbkdyb3VwIiwiaXNBbHJlYWR5R3JvdXBlZCIsIl9jYWxjQm91bmRzIiwiX3VwZGF0ZU9iamVjdHNDb29yZHMiLCJfdXBkYXRlT2JqZWN0c0FDb29yZHMiLCJza2lwQ29udHJvbHMiLCJfdXBkYXRlT2JqZWN0Q29vcmRzIiwib2JqZWN0TGVmdCIsIm9iamVjdFRvcCIsIm5lc3RlZCIsIl9yZXN0b3JlT2JqZWN0c1N0YXRlIiwiX2luY2x1ZGVEZWZhdWx0VmFsdWVzIiwib2Jqc1RvT2JqZWN0Iiwib3JpZ2luYWxEZWZhdWx0cyIsIl9vYmoiLCJvd25DYWNoZSIsImdyb3VwTWF0cml4IiwiZGVzdHJveSIsInRvQWN0aXZlU2VsZWN0aW9uIiwidW5ncm91cE9uQ2FudmFzIiwic2V0T2JqZWN0c0Nvb3JkcyIsIm9ubHlXaWR0aEhlaWdodCIsImlMZW4iLCJqTGVuIiwiX2dldEJvdW5kcyIsIm1pblhZIiwibWF4WFkiLCJ0b0dyb3VwIiwibmV3R3JvdXAiLCJjaGlsZHJlbk92ZXJyaWRlIiwic3JjRnJvbUF0dHJpYnV0ZSIsIl9sYXN0U2NhbGVYIiwiX2xhc3RTY2FsZVkiLCJfZmlsdGVyU2NhbGluZ1giLCJfZmlsdGVyU2NhbGluZ1kiLCJtaW5pbXVtU2NhbGVUcmlnZ2VyIiwiY2FjaGVLZXkiLCJpbWFnZVNtb290aGluZyIsImZpbHRlcnMiLCJfaW5pdEVsZW1lbnQiLCJfZWxlbWVudCIsInNldEVsZW1lbnQiLCJyZW1vdmVUZXh0dXJlIiwiX2luaXRDb25maWciLCJhcHBseUZpbHRlcnMiLCJyZXNpemVGaWx0ZXIiLCJhcHBseVJlc2l6ZUZpbHRlcnMiLCJiYWNrZW5kIiwiZmlsdGVyQmFja2VuZCIsImV2aWN0Q2FjaGVzRm9yS2V5IiwiZ2V0Q3Jvc3NPcmlnaW4iLCJnZXRPcmlnaW5hbFNpemUiLCJfc3Ryb2tlIiwiZmlsdGVyT2JqIiwiZ2V0U3JjIiwiaGFzQ3JvcCIsImltYWdlTWFya3VwIiwic3Ryb2tlU3ZnIiwiaW1hZ2VSZW5kZXJpbmciLCJnZXRTdmdTcmMiLCJvcmlnRmlsbCIsImZpbHRlcmVkIiwic2V0U3JjIiwibWluaW11bVNjYWxlIiwiZWxlbWVudFRvRmlsdGVyIiwiX2ZpbHRlcmVkRWwiLCJzb3VyY2VXaWR0aCIsInNvdXJjZUhlaWdodCIsImlzTmV1dHJhbFN0YXRlIiwiaW1nRWxlbWVudCIsIl9uZWVkc1Jlc2l6ZSIsImVsZW1lbnRUb0RyYXciLCJlbFdpZHRoIiwiZWxIZWlnaHQiLCJzWCIsInNZIiwic1ciLCJzSCIsIm1heERlc3RXIiwibWF4RGVzdEgiLCJfcmVzZXRXaWR0aEhlaWdodCIsIkNTU19DQU5WQVMiLCJfaW5pdEZpbHRlcnMiLCJwQVIiLCJyV2lkdGgiLCJySGVpZ2h0IiwicFdpZHRoIiwicEhlaWdodCIsIl9vYmplY3QiLCJyZXNpemVGaWx0ZXJzIiwiZnJvbVVSTCIsImltZ09wdGlvbnMiLCJfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4iLCJzdHJhaWdodGVuIiwiZnhTdHJhaWdodGVuIiwic3RyYWlnaHRlbk9iamVjdCIsImZ4U3RyYWlnaHRlbk9iamVjdCIsInRlc3RQcmVjaXNpb24iLCJnbCIsInByZWNpc2lvbiIsImZyYWdtZW50U291cmNlIiwiZnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJpc1N1cHBvcnRlZCIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJwcmVjaXNpb25zIiwid2ViR2xQcmVjaXNpb24iLCJzZXR1cEdMQ29udGV4dCIsImNhcHR1cmVHUFVJbmZvIiwiY3JlYXRlV2ViR0xDYW52YXMiLCJhUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCIsImNhbk1lYXN1cmVQZXJmIiwicGVyZm9ybWFuY2UiLCJjYW5Vc2VJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJjYW5Vc2VBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiY2FuVXNlVWludDhDbGFtcGVkIiwiVWludDhDbGFtcGVkQXJyYXkiLCJpbWFnZUJ1ZmZlciIsImNvcHlHTFRvMkQiLCJjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhIiwidGVzdENvbnRleHQiLCJkZXN0aW5hdGlvbldpZHRoIiwiZGVzdGluYXRpb25IZWlnaHQiLCJzdGFydFRpbWUiLCJkcmF3SW1hZ2VUaW1lIiwicHV0SW1hZ2VEYXRhVGltZSIsIm5vdyIsImNvcHlHTFRvMkREcmF3SW1hZ2UiLCJnbE9wdGlvbnMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJjbGVhckNvbG9yIiwiY2FjaGVkVGV4dHVyZSIsImdldENhY2hlZFRleHR1cmUiLCJwaXBlbGluZVN0YXRlIiwic291cmNlVGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJ0YXJnZXRUZXh0dXJlIiwib3JpZ2luYWxUZXh0dXJlIiwicGFzc2VzIiwid2ViZ2wiLCJwcm9ncmFtQ2FjaGUiLCJwYXNzIiwidGVtcEZibyIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJhcHBseVRvIiwicmVzaXplQ2FudmFzSWZOZWVkZWQiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJkZWxldGVUZXh0dXJlIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJjbGVhcldlYkdMQ2FjaGVzIiwidGV4dHVyZUNhY2hlIiwidGV4dHVyZUltYWdlU291cmNlIiwiZmlsdGVyVHlwZSIsInRleHR1cmUiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwidW5pcXVlSWQiLCJncHVJbmZvIiwicmVuZGVyZXIiLCJ2ZW5kb3IiLCJleHQiLCJnZXRFeHRlbnNpb24iLCJVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCIsIlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCIsImRXaWR0aCIsImRIZWlnaHQiLCJnbENhbnZhcyIsInNvdXJjZVkiLCJudW1CeXRlcyIsInU4IiwiVWludDhBcnJheSIsInU4Q2xhbXBlZCIsInJlYWRQaXhlbHMiLCJpbWdEYXRhIiwicHV0SW1hZ2VEYXRhIiwic291cmNlRWxlbWVudCIsIm9yaWdpbmFsSW1hZ2VEYXRhIiwib3JpZ2luYWxFbCIsIkJhc2VGaWx0ZXIiLCJ2ZXJ0ZXhTb3VyY2UiLCJjcmVhdGVQcm9ncmFtIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImdldFNoYWRlckluZm9Mb2ciLCJwcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImdldEF0dHJpYnV0ZUxvY2F0aW9ucyIsInVuaWZvcm1Mb2NhdGlvbnMiLCJnZXRVbmlmb3JtTG9jYXRpb25zIiwidVN0ZXBXIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwidVN0ZXBIIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJzZW5kQXR0cmlidXRlRGF0YSIsImFQb3NpdGlvbkRhdGEiLCJhdHRyaWJ1dGVMb2NhdGlvbiIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsIl9zZXR1cEZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsIl9zd2FwVGV4dHVyZXMiLCJtYWluIiwibWFpblBhcmFtZXRlciIsImFwcGx5VG9XZWJHTCIsImFwcGx5VG8yZCIsInJldHJpZXZlU2hhZGVyIiwic2hhZGVyIiwidXNlUHJvZ3JhbSIsInVuaWZvcm0xZiIsInNlbmRVbmlmb3JtRGF0YSIsInZpZXdwb3J0IiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwiYmluZEFkZGl0aW9uYWxUZXh0dXJlIiwidGV4dHVyZVVuaXQiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ1bmJpbmRBZGRpdGlvbmFsVGV4dHVyZSIsImdldE1haW5QYXJhbWV0ZXIiLCJzZXRNYWluUGFyYW1ldGVyIiwiY3JlYXRlSGVscExheWVyIiwiaGVscExheWVyIiwibWFpblAiLCJDb2xvck1hdHJpeCIsImNvbG9yc09ubHkiLCJ1Q29sb3JNYXRyaXgiLCJ1Q29uc3RhbnRzIiwiY29uc3RhbnRzIiwidW5pZm9ybU1hdHJpeDRmdiIsInVuaWZvcm00ZnYiLCJCcmlnaHRuZXNzIiwiYnJpZ2h0bmVzcyIsInVCcmlnaHRuZXNzIiwiQ29udm9sdXRlIiwib3BhcXVlIiwiQ29udm9sdXRlXzNfMSIsIkNvbnZvbHV0ZV8zXzAiLCJDb252b2x1dGVfNV8xIiwiQ29udm9sdXRlXzVfMCIsIkNvbnZvbHV0ZV83XzEiLCJDb252b2x1dGVfN18wIiwiQ29udm9sdXRlXzlfMSIsIkNvbnZvbHV0ZV85XzAiLCJ3ZWlnaHRzIiwic2lkZSIsImhhbGZTaWRlIiwic3ciLCJzaCIsIm91dHB1dCIsImNyZWF0ZUltYWdlRGF0YSIsImRzdCIsImFscGhhRmFjIiwiZHN0T2ZmIiwic2N4Iiwic2N5Iiwic3JjT2ZmIiwid3QiLCJ1TWF0cml4IiwidU9wYXF1ZSIsInVIYWxmU2l6ZSIsInVTaXplIiwidW5pZm9ybTFmdiIsIkdyYXlzY2FsZSIsImxpZ2h0bmVzcyIsImx1bWlub3NpdHkiLCJtb2RlIiwidU1vZGUiLCJ1bmlmb3JtMWkiLCJJbnZlcnQiLCJpbnZlcnQiLCJ1SW52ZXJ0IiwiTm9pc2UiLCJub2lzZSIsInJhbmQiLCJ1Tm9pc2UiLCJ1U2VlZCIsIlBpeGVsYXRlIiwiYmxvY2tzaXplIiwiX2kiLCJfaiIsIl9pTGVuIiwiX2pMZW4iLCJ1QmxvY2tzaXplIiwiUmVtb3ZlQ29sb3IiLCJ1c2VBbHBoYSIsImxvd0MiLCJoaWdoQyIsInVMb3ciLCJ1SGlnaCIsIkJyb3duaWUiLCJWaW50YWdlIiwiS29kYWNocm9tZSIsIlRlY2huaWNvbG9yIiwiUG9sYXJvaWQiLCJTZXBpYSIsIkJsYWNrV2hpdGUiLCJCbGVuZENvbG9yIiwic2NyZWVuIiwiZGlmZiIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJleGNsdXNpb24iLCJ0aW50IiwiYnVpbGRTb3VyY2UiLCJ0ZyIsImFscGhhMSIsInVDb2xvciIsIkJsZW5kSW1hZ2UiLCJtYXNrIiwiVEVYVFVSRTEiLCJjYWxjdWxhdGVNYXRyaXgiLCJjYW52YXMxIiwiYmxlbmREYXRhIiwiYmxlbmRJbWFnZSIsInVUcmFuc2Zvcm1NYXRyaXgiLCJ1SW1hZ2UiLCJ1bmlmb3JtTWF0cml4M2Z2IiwiUmVzaXplIiwicmVzaXplVHlwZSIsImxhbmN6b3NMb2JlcyIsInVEZWx0YSIsInVUYXBzIiwidW5pZm9ybTJmdiIsImhvcml6b250YWwiLCJ0YXBzIiwiZmlsdGVyV2luZG93IiwiZ2V0RmlsdGVyV2luZG93IiwiZ2VuZXJhdGVTaGFkZXIiLCJ0ZW1wU2NhbGUiLCJnZXRUYXBzIiwibG9iZUZ1bmN0aW9uIiwibGFuY3pvc0NyZWF0ZSIsIm9mZnNldHMiLCJmcmFnbWVudFNvdXJjZVRPUCIsImRXIiwiZEgiLCJsb2JlcyIsInh4IiwicmNwU2NhbGVYIiwicmNwU2NhbGVZIiwib1ciLCJvSCIsIm5ld0RhdGEiLCJzbGljZUJ5VHdvIiwiaGVybWl0ZUZhc3RSZXNpemUiLCJiaWxpbmVhckZpbHRlcmluZyIsImxhbmN6b3NSZXNpemUiLCJtdWx0IiwiZG9uZVciLCJkb25lSCIsInN0ZXBXIiwic3RlcEgiLCJ0bXBDYW52YXMiLCJkWCIsImRZIiwicHJvY2VzcyIsInUiLCJ3ZWlnaHQiLCJmWCIsImZZIiwicmF0aW9YIiwiaWNlbnRlciIsInJhdGlvWSIsInJhbmdlMlgiLCJjYWNoZUxhbmMiLCJyYW5nZTJZIiwibGFuY3pvcyIsInJjcFJhdGlvWCIsInJjcFJhdGlvWSIsInNyY0RhdGEiLCJkZXN0RGF0YSIsImRlc3RJbWciLCJ4RGlmZiIsInlEaWZmIiwiY2hubCIsIm9yaWdQaXgiLCJ3NCIsInBpeGVscyIsImRlc3RJbWFnZSIsImRlc3RQaXhlbHMiLCJyYXRpb1ciLCJyYXRpb0giLCJyYXRpb1dIYWxmIiwicmF0aW9ISGFsZiIsImltZzIiLCJkYXRhMiIsIndlaWdodHNBbHBoYSIsImd4UiIsImd4RyIsImd4QiIsImd4QSIsInl5IiwidzAiLCJDb250cmFzdCIsImNvbnRyYXN0IiwiY29udHJhc3RGIiwidUNvbnRyYXN0IiwiU2F0dXJhdGlvbiIsInNhdHVyYXRpb24iLCJhZGp1c3QiLCJ1U2F0dXJhdGlvbiIsIlZpYnJhbmNlIiwidmlicmFuY2UiLCJhdmciLCJhbXQiLCJ1VmlicmFuY2UiLCJCbHVyIiwiYXNwZWN0UmF0aW8iLCJzaW1wbGVCbHVyIiwiY2FudmFzMiIsImJsdXJMYXllcjEiLCJibHVyTGF5ZXIyIiwiY3R4MSIsImN0eDIiLCJuU2FtcGxlcyIsInBlcmNlbnQiLCJuZXdJbWFnZURhdGEiLCJkZWx0YSIsImNob29zZVJpZ2h0RGVsdGEiLCJibHVyU2NhbGUiLCJHYW1tYSIsImdhbW1hIiwickludiIsImdJbnYiLCJiSW52IiwiclZhbHMiLCJnVmFscyIsImJWYWxzIiwidUdhbW1hIiwidW5pZm9ybTNmdiIsIkNvbXBvc2VkIiwic3ViRmlsdGVycyIsIkh1ZVJvdGF0aW9uIiwicm90YXRpb24iLCJyYWQiLCJhVGhpcmQiLCJhVGhpcmRTcXRTaW4iLCJPbmVNaW51c0NvcyIsImFkZGl0aW9uYWxQcm9wcyIsIl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcyIsIl9yZU5ld2xpbmUiLCJfcmVTcGFjZXNBbmRUYWJzIiwiX3JlU3BhY2VBbmRUYWIiLCJfcmVXb3JkcyIsInRleHRBbGlnbiIsInN1cGVyc2NyaXB0IiwiYmFzZWxpbmUiLCJzdWJzY3JpcHQiLCJwYXRoU3RhcnRPZmZzZXQiLCJwYXRoU2lkZSIsInBhdGhBbGlnbiIsIl9mb250U2l6ZUZyYWN0aW9uIiwiX2ZvbnRTaXplTXVsdCIsImNoYXJTcGFjaW5nIiwiX21lYXN1cmluZ0NvbnRleHQiLCJkaXJlY3Rpb24iLCJfc3R5bGVQcm9wZXJ0aWVzIiwiX19jaGFyQm91bmRzIiwiQ0FDSEVfRk9OVF9TSVpFIiwiTUlOX1RFWFRfV0lEVEgiLCJfX3NraXBEaW1lbnNpb24iLCJzZXRQYXRoSW5mbyIsImluaXREaW1lbnNpb25zIiwic2VnbWVudHNJbmZvIiwiZ2V0TWVhc3VyaW5nQ29udGV4dCIsIl9zcGxpdFRleHQiLCJuZXdMaW5lcyIsIl9zcGxpdFRleHRJbnRvTGluZXMiLCJfdGV4dExpbmVzIiwiZ3JhcGhlbWVMaW5lcyIsIl91bndyYXBwZWRUZXh0TGluZXMiLCJfdW53cmFwcGVkTGluZXMiLCJfdGV4dCIsImdyYXBoZW1lVGV4dCIsIl9jbGVhckNhY2hlIiwiY2FsY1RleHRXaWR0aCIsImN1cnNvcldpZHRoIiwiY2FsY1RleHRIZWlnaHQiLCJlbmxhcmdlU3BhY2VzIiwiZGlmZlNwYWNlIiwiY3VycmVudExpbmVXaWR0aCIsIm51bWJlck9mU3BhY2VzIiwiYWNjdW11bGF0ZWRTcGFjZSIsImxpbmUiLCJjaGFyQm91bmQiLCJzcGFjZXMiLCJpc0VuZE9mV3JhcHBpbmciLCJnZXRMaW5lV2lkdGgiLCJrZXJuZWRXaWR0aCIsImxpbmVJbmRleCIsIm1pc3NpbmdOZXdsaW5lT2Zmc2V0IiwiX3NldFRleHRTdHlsZXMiLCJfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZCIsIl9yZW5kZXJUZXh0RGVjb3JhdGlvbiIsIl9yZW5kZXJUZXh0IiwiX3JlbmRlclRleHRTdHJva2UiLCJfcmVuZGVyVGV4dEZpbGwiLCJjaGFyU3R5bGUiLCJmb3JNZWFzdXJpbmciLCJ0ZXh0QmFzZWxpbmUiLCJfZ2V0Rm9udERlY2xhcmF0aW9uIiwibWF4V2lkdGgiLCJfcmVuZGVyVGV4dExpbmUiLCJfcmVuZGVyQ2hhcnMiLCJzdHlsZUhhcyIsImhlaWdodE9mTGluZSIsImxpbmVMZWZ0T2Zmc2V0IiwibGFzdENvbG9yIiwibGVmdE9mZnNldCIsIl9nZXRMZWZ0T2Zmc2V0IiwibGluZVRvcE9mZnNldCIsIl9nZXRUb3BPZmZzZXQiLCJib3hTdGFydCIsImJveFdpZHRoIiwiY2hhckJveCIsImN1cnJlbnRDb2xvciIsImRyYXdTdGFydCIsIl9nZXRMaW5lTGVmdE9mZnNldCIsImdldFZhbHVlT2ZQcm9wZXJ0eUF0IiwicmVuZGVyTGVmdCIsImdldEZvbnRDYWNoZSIsImNhY2hlUHJvcCIsIl9tZWFzdXJlQ2hhciIsInByZXZpb3VzQ2hhciIsInByZXZDaGFyU3R5bGUiLCJmb250Q2FjaGUiLCJmb250RGVjbGFyYXRpb24iLCJwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiIsImNvdXBsZSIsInN0eWxlc0FyZUVxdWFsIiwiY291cGxlV2lkdGgiLCJwcmV2aW91c1dpZHRoIiwiZm9udE11bHRpcGxpZXIiLCJtZWFzdXJlVGV4dCIsImdldEhlaWdodE9mQ2hhciIsIm1lYXN1cmVMaW5lIiwibGluZUluZm8iLCJfbWVhc3VyZUxpbmUiLCJfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nIiwiZ3JhcGhlbWUiLCJwcmV2R3JhcGhlbWUiLCJncmFwaGVtZUluZm8iLCJudW1PZlNwYWNlcyIsImxpbmVCb3VuZHMiLCJwb3NpdGlvbkluUGF0aCIsInN0YXJ0aW5nUG9pbnQiLCJ0b3RhbFBhdGhMZW5ndGgiLCJfZ2V0R3JhcGhlbWVCb3giLCJfc2V0R3JhcGhlbWVPblBhdGgiLCJjZW50ZXJQb3NpdGlvbiIsInNraXBMZWZ0IiwiZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uIiwicHJldmlvdXNCb3giLCJfX2xpbmVIZWlnaHRzIiwibWF4SGVpZ2h0IiwiX3JlbmRlclRleHRDb21tb24iLCJsaW5lSGVpZ2h0cyIsImlzRW1wdHlTdHlsZXMiLCJpc0p1c3RpZnkiLCJhY3R1YWxTdHlsZSIsIm5leHRTdHlsZSIsImNoYXJzVG9SZW5kZXIiLCJ0aW1lVG9SZW5kZXIiLCJzaG9ydEN1dCIsImlzTHRyIiwiZHJhd2luZ0xlZnQiLCJjdXJyZW50RGlyZWN0aW9uIiwiX3JlbmRlckNoYXIiLCJfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0IiwiaGFuZGxlRmlsbGVyIiwiX2dldFN0eWxlRGVjbGFyYXRpb24iLCJmdWxsRGVjbCIsInNob3VsZEZpbGwiLCJmaWxsT2Zmc2V0cyIsInN0cm9rZU9mZnNldHMiLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJzZXRTdXBlcnNjcmlwdCIsIl9zZXRTY3JpcHQiLCJzZXRTdWJzY3JpcHQiLCJzY2hlbWEiLCJsb2MiLCJnZXQyREN1cnNvckxvY2F0aW9uIiwic2V0U2VsZWN0aW9uU3R5bGVzIiwibGluZURpZmYiLCJfX2xpbmVXaWR0aHMiLCJfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSIsInNob3VsZENsZWFyIiwiX2ZvcmNlQ2xlYXJDYWNoZSIsIl9zaXplIiwiX2R5IiwibGFzdERlY29yYXRpb24iLCJ0b3BPZmZzZXQiLCJjdXJyZW50RGVjb3JhdGlvbiIsImN1cnJlbnRGaWxsIiwibGFzdEZpbGwiLCJzdHlsZU9iamVjdCIsImZhbWlseSIsImZvbnRJc0dlbmVyaWMiLCJnZW5lcmljRm9udHMiLCJuZXdMaW5lIiwibmV3VGV4dCIsImFsbFByb3BlcnRpZXMiLCJuZWVkc0RpbXMiLCJpc0FkZGluZ1BhdGgiLCJfa2V5IiwicGFyc2VkQW5jaG9yIiwidGV4dEFuY2hvciIsIm9yaWdpbmFsU3Ryb2tlV2lkdGgiLCJ0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IiLCJsaW5lSGVpZ2h0RGlmZiIsInNjYWxlZERpZmYiLCJ0ZXh0SGVpZ2h0Iiwib2ZmWCIsIm9iamVjdENvcHkiLCJ0ZXh0SW5zdGFuY2UiLCJwYXRoSW5zdGFuY2UiLCJwMyIsImNsZWFuU3R5bGUiLCJzdHlsZXNDb3VudCIsImxldHRlckNvdW50Iiwic3R5bGVQcm9wZXJ0eVZhbHVlIiwiYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2giLCJncmFwaGVtZUNvdW50Iiwic3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQiLCJyZW1vdmVTdHlsZSIsImxpbmVOdW0iLCJjaGFyTnVtIiwiX2V4dGVuZFN0eWxlcyIsIl9nZXRMaW5lU3R5bGUiLCJfc2V0TGluZVN0eWxlIiwiX3NldFN0eWxlRGVjbGFyYXRpb24iLCJzZWxlY3Rpb25TdGFydCIsInNraXBXcmFwcGluZyIsImdldFNlbGVjdGlvblN0eWxlcyIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInNlbGVjdGlvbkVuZCIsImdldFN0eWxlQXRQb3NpdGlvbiIsImxpbmVTdHlsZSIsIl9kZWxldGVTdHlsZURlY2xhcmF0aW9uIiwiX2RlbGV0ZUxpbmVTdHlsZSIsInBhcnNlRGVjb3JhdGlvbiIsIklUZXh0IiwiZWRpdGFibGUiLCJlZGl0aW5nQm9yZGVyQ29sb3IiLCJjdXJzb3JDb2xvciIsImN1cnNvckRlbGF5IiwiY3Vyc29yRHVyYXRpb24iLCJjYWNoaW5nIiwiaGlkZGVuVGV4dGFyZWFDb250YWluZXIiLCJfcmVTcGFjZSIsIl9jdXJyZW50Q3Vyc29yT3BhY2l0eSIsIl9zZWxlY3Rpb25EaXJlY3Rpb24iLCJfYWJvcnRDdXJzb3JBbmltYXRpb24iLCJfX3dpZHRoT2ZTcGFjZSIsImluQ29tcG9zaXRpb25Nb2RlIiwiaW5pdEJlaGF2aW9yIiwic2V0U2VsZWN0aW9uU3RhcnQiLCJfdXBkYXRlQW5kRmlyZSIsInNldFNlbGVjdGlvbkVuZCIsIl9maXJlU2VsZWN0aW9uQ2hhbmdlZCIsIl91cGRhdGVUZXh0YXJlYSIsImluaXREZWxheWVkQ3Vyc29yIiwiY3Vyc29yT2Zmc2V0Q2FjaGUiLCJyZW5kZXJDdXJzb3JPclNlbGVjdGlvbiIsInNraXBSZXN0b3JlIiwiX2NsZWFyVGV4dEFyZWEiLCJib3VuZGFyaWVzIiwiX2dldEN1cnNvckJvdW5kYXJpZXMiLCJyZW5kZXJDdXJzb3IiLCJyZW5kZXJTZWxlY3Rpb24iLCJfZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHMiLCJjdXJzb3JQb3NpdGlvbiIsImJvdW5kIiwiY3Vyc29yTG9jYXRpb24iLCJjaGFySGVpZ2h0IiwiX19pc01vdXNlZG93biIsImhpZGRlblRleHRhcmVhIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsInN0YXJ0Q2hhciIsImVuZENoYXIiLCJsaW5lT2Zmc2V0IiwicmVhbExpbmVIZWlnaHQiLCJib3hFbmQiLCJkcmF3V2lkdGgiLCJkcmF3SGVpZ2h0IiwiZXh0cmFUb3AiLCJjb21wb3NpdGlvbkNvbG9yIiwiZ2V0Q3VycmVudENoYXJGb250U2l6ZSIsImNwIiwiX2dldEN1cnJlbnRDaGFySW5kZXgiLCJnZXRDdXJyZW50Q2hhckNvbG9yIiwib2JqQ29weSIsImluaXRBZGRlZEhhbmRsZXIiLCJpbml0UmVtb3ZlZEhhbmRsZXIiLCJpbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnMiLCJpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uIiwibW91c2VNb3ZlSGFuZGxlciIsIl9pbml0Q2FudmFzSGFuZGxlcnMiLCJfcmVtb3ZlQ2FudmFzSGFuZGxlcnMiLCJfdGljayIsIl9jdXJyZW50VGlja1N0YXRlIiwiX2FuaW1hdGVDdXJzb3IiLCJ0YXJnZXRPcGFjaXR5IiwiY29tcGxldGVNZXRob2QiLCJ0aWNrU3RhdGUiLCJpc0Fib3J0ZWQiLCJfb25UaWNrQ29tcGxldGUiLCJfY3Vyc29yVGltZW91dDEiLCJfY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIiwicmVzdGFydCIsImRlbGF5IiwiYWJvcnRDdXJzb3JBbmltYXRpb24iLCJfY3Vyc29yVGltZW91dDIiLCJzZWxlY3RBbGwiLCJnZXRTZWxlY3RlZFRleHQiLCJmaW5kV29yZEJvdW5kYXJ5TGVmdCIsInN0YXJ0RnJvbSIsImZpbmRXb3JkQm91bmRhcnlSaWdodCIsImZpbmRMaW5lQm91bmRhcnlMZWZ0IiwiZmluZExpbmVCb3VuZGFyeVJpZ2h0Iiwic2VhcmNoV29yZEJvdW5kYXJ5Iiwic2VsZWN0V29yZCIsIm5ld1NlbGVjdGlvblN0YXJ0IiwibmV3U2VsZWN0aW9uRW5kIiwic2VsZWN0TGluZSIsImVudGVyRWRpdGluZyIsImV4aXRFZGl0aW5nT25PdGhlcnMiLCJpbml0SGlkZGVuVGV4dGFyZWEiLCJmb2N1cyIsIl9zYXZlRWRpdGluZ1Byb3BzIiwiX3NldEVkaXRpbmdQcm9wcyIsIl90ZXh0QmVmb3JlRWRpdCIsImluaXRNb3VzZU1vdmVIYW5kbGVyIiwiYWN0aXZlRWxlbWVudCIsImdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50RW5kIiwiX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duIiwicmVzdGFydEN1cnNvcklmTmVlZGVkIiwiZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24iLCJzbWFsbGVyVGV4dFN0YXJ0IiwiZ3JhcGhlbWVTdGFydCIsInNtYWxsZXJUZXh0RW5kIiwiZ3JhcGhlbWVFbmQiLCJmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbiIsIm5ld1NlbGVjdGlvbiIsInVwZGF0ZVRleHRhcmVhUG9zaXRpb24iLCJ1cGRhdGVGcm9tVGV4dEFyZWEiLCJfY2FsY1RleHRhcmVhUG9zaXRpb24iLCJkZXNpcmVkUG9zaXRpb24iLCJjb21wb3NpdGlvblN0YXJ0IiwidXBwZXJDYW52YXMiLCJ1cHBlckNhbnZhc1dpZHRoIiwidXBwZXJDYW52YXNIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9zYXZlZFByb3BzIiwiX3Jlc3RvcmVFZGl0aW5nUHJvcHMiLCJpc1RleHRDaGFuZ2VkIiwiX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMiLCJyZW1vdmVTdHlsZUZyb21UbyIsImN1cnNvclN0YXJ0IiwiY3Vyc29yRW5kIiwibGluZVN0YXJ0IiwiY2hhclN0YXJ0IiwibGluZUVuZCIsImNoYXJFbmQiLCJzdHlsZU9iaiIsInNoaWZ0TGluZVN0eWxlcyIsIm51bWVyaWNDaGFyIiwiY2xvbmVkU3R5bGVzIiwibnVtZXJpY0xpbmUiLCJpbnNlcnROZXdsaW5lU3R5bGVPYmplY3QiLCJxdHkiLCJjb3BpZWRTdHlsZSIsImN1cnJlbnRDaGFyU3R5bGUiLCJuZXdMaW5lU3R5bGVzIiwic29tZXRoaW5nQWRkZWQiLCJpc0VuZE9mTGluZSIsIm51bUluZGV4Iiwic3R5bGVDYXJyaWVkT3ZlciIsImluc2VydENoYXJTdHlsZU9iamVjdCIsInF1YW50aXR5IiwiY3VycmVudExpbmVTdHlsZXMiLCJjdXJyZW50TGluZVN0eWxlc0Nsb25lZCIsIm51bWVyaWNJbmRleCIsIm5ld1N0eWxlIiwiaW5zZXJ0TmV3U3R5bGVCbG9jayIsImluc2VydGVkVGV4dCIsImN1cnNvckxvYyIsImFkZGVkTGluZXMiLCJsaW5lc0xlbmd0aCIsInNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0Iiwic2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzIiwiX19sYXN0Q2xpY2tUaW1lIiwiX19sYXN0TGFzdENsaWNrVGltZSIsIl9fbGFzdFBvaW50ZXIiLCJfX25ld0NsaWNrVGltZSIsIm5ld1BvaW50ZXIiLCJpc1RyaXBsZUNsaWNrIiwiX3N0b3BFdmVudCIsIl9fbGFzdElzRWRpdGluZyIsIl9fbGFzdFNlbGVjdGVkIiwiaW5pdE1vdXNlZG93bkhhbmRsZXIiLCJpbml0TW91c2V1cEhhbmRsZXIiLCJpbml0Q2xpY2tzIiwiZG91YmxlQ2xpY2tIYW5kbGVyIiwidHJpcGxlQ2xpY2tIYW5kbGVyIiwiX21vdXNlRG93bkhhbmRsZXIiLCJzZXRDdXJzb3JCeUNsaWNrIiwiX21vdXNlRG93bkhhbmRsZXJCZWZvcmUiLCJjdXJyZW50QWN0aXZlIiwibW91c2VPZmZzZXQiLCJwcmV2V2lkdGgiLCJfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0IiwiZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciIsImRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IiLCJvbktleURvd24iLCJvbktleVVwIiwib25JbnB1dCIsImNvcHkiLCJwYXN0ZSIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uRW5kIiwiX2NsaWNrSGFuZGxlckluaXRpYWxpemVkIiwib25DbGljayIsImtleXNNYXAiLCJrZXlzTWFwUnRsIiwiY3RybEtleXNNYXBVcCIsImN0cmxLZXlzTWFwRG93biIsImtleU1hcCIsImtleUNvZGUiLCJjdHJsS2V5IiwibWV0YUtleSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9jb3B5RG9uZSIsImZyb21QYXN0ZSIsIm5leHRUZXh0IiwiY2hhckNvdW50IiwibmV4dENoYXJDb3VudCIsInJlbW92ZWRUZXh0IiwiY2hhckRpZmYiLCJyZW1vdmVGcm9tIiwicmVtb3ZlVG8iLCJ0ZXh0YXJlYVNlbGVjdGlvbiIsImJhY2tEZWxldGUiLCJjb3BpZWRUZXh0IiwiY29waWVkVGV4dFN0eWxlIiwiY29tcG9zaXRpb25FbmQiLCJfZ2V0Q2xpcGJvYXJkRGF0YSIsImNsaXBib2FyZERhdGEiLCJfZ2V0V2lkdGhCZWZvcmVDdXJzb3IiLCJ3aWR0aEJlZm9yZUN1cnNvciIsImdldERvd25DdXJzb3JPZmZzZXQiLCJpc1JpZ2h0Iiwic2VsZWN0aW9uUHJvcCIsIl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQiLCJpbmRleE9uT3RoZXJMaW5lIiwiX2dldEluZGV4T25MaW5lIiwidGV4dEFmdGVyQ3Vyc29yIiwiZ2V0VXBDdXJzb3JPZmZzZXQiLCJ0ZXh0QmVmb3JlQ3Vyc29yIiwid2lkdGhPZkNoYXJzT25MaW5lIiwiaW5kZXhPbkxpbmUiLCJjaGFyV2lkdGgiLCJmb3VuZE1hdGNoIiwibGVmdEVkZ2UiLCJyaWdodEVkZ2UiLCJvZmZzZXRGcm9tTGVmdEVkZ2UiLCJvZmZzZXRGcm9tUmlnaHRFZGdlIiwibW92ZUN1cnNvckRvd24iLCJfbW92ZUN1cnNvclVwT3JEb3duIiwibW92ZUN1cnNvclVwIiwibW92ZUN1cnNvcldpdGhTaGlmdCIsIm1vdmVDdXJzb3JXaXRob3V0U2hpZnQiLCJtb3ZlQ3Vyc29yTGVmdCIsIl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQiLCJfbW92ZSIsIl9tb3ZlTGVmdCIsIl9tb3ZlUmlnaHQiLCJtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdCIsImNoYW5nZSIsIm1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0IiwibW92ZUN1cnNvclJpZ2h0IiwibW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0IiwibW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0IiwiY2hhbmdlZCIsInJlbW92ZUNoYXJzIiwiaW5zZXJ0Q2hhcnMiLCJtdWx0aXBsZVNwYWNlc1JlZ2V4IiwiX2dldFNWR0xlZnRUb3BPZmZzZXRzIiwidGV4dEFuZEJnIiwiX2dldFNWR1RleHRBbmRCZyIsInRleHRUb3AiLCJ0ZXh0TGVmdCIsIl93cmFwU1ZHVGV4dEFuZEJnIiwibGluZVRvcCIsIm5vU2hhZG93IiwidGV4dFNwYW5zIiwidGV4dFRvcE9mZnNldCIsInRleHRMZWZ0T2Zmc2V0IiwiX3NldFNWR1RleHRMaW5lQmciLCJfc2V0U1ZHVGV4dExpbmVUZXh0IiwiX2NyZWF0ZVRleHRDaGFyU3BhbiIsInN0eWxlRGVjbCIsInNob3VsZFVzZVdoaXRlc3BhY2UiLCJzdHlsZVByb3BzIiwiZmlsbFN0eWxlcyIsImR5U3BhbiIsIl9wdXNoVGV4dEJnUmVjdCIsImZpbGxDb2xvciIsIl9nZXRTVkdMaW5lVG9wT2Zmc2V0IiwibGFzdEhlaWdodCIsInN2Z1N0eWxlIiwiVGV4dGJveCIsIm1pbldpZHRoIiwiZHluYW1pY01pbldpZHRoIiwiX19jYWNoZWRMaW5lcyIsIl93b3JkSm9pbmVycyIsInNwbGl0QnlHcmFwaGVtZSIsIl9zdHlsZU1hcCIsIl9nZW5lcmF0ZVN0eWxlTWFwIiwidGV4dEluZm8iLCJyZWFsTGluZUNvdW50IiwicmVhbExpbmVDaGFyQ291bnQiLCJpc1dyYXBwaW5nIiwibmV4dExpbmVJbmRleCIsIm5leHRPZmZzZXQiLCJzaG91bGRMaW1pdCIsIm1hcE5leHRMaW5lIiwiX3dyYXBUZXh0IiwiZGVzaXJlZFdpZHRoIiwid3JhcHBlZCIsIl93cmFwTGluZSIsIl9tZWFzdXJlV29yZCIsIndvcmQiLCJjaGFyT2Zmc2V0IiwiX2xpbmUiLCJyZXNlcnZlZFNwYWNlIiwid29yZHMiLCJpbmZpeCIsIndvcmRXaWR0aCIsImluZml4V2lkdGgiLCJsYXJnZXN0V29yZFdpZHRoIiwibGluZUp1c3RTdGFydGVkIiwiYWRkaXRpb25hbFNwYWNlIiwiZ2V0TWluV2lkdGgiLCJsaW5lc1RvS2VlcCIsInNjYWxlU2tld1N0eWxlSGFuZGxlciIsInNjYWxlU3R5bGVIYW5kbGVyIiwib2JqZWN0Q29udHJvbHMiLCJtbCIsIm1yIiwibWIiLCJtdHIiLCJ0ZXh0Qm94Q29udHJvbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fabric/dist/fabric.js\n");

/***/ })

};
;