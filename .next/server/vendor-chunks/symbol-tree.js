"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/symbol-tree";
exports.ids = ["vendor-chunks/symbol-tree"];
exports.modules = {

/***/ "(ssr)/./node_modules/symbol-tree/lib/SymbolTree.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-tree/lib/SymbolTree.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */ const SymbolTreeNode = __webpack_require__(/*! ./SymbolTreeNode */ \"(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js\");\nconst TreePosition = __webpack_require__(/*! ./TreePosition */ \"(ssr)/./node_modules/symbol-tree/lib/TreePosition.js\");\nconst TreeIterator = __webpack_require__(/*! ./TreeIterator */ \"(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js\");\nfunction returnTrue() {\n    return true;\n}\nfunction reverseArrayIndex(array, reverseIndex) {\n    return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\nclass SymbolTree {\n    /**\n         * @constructor\n         * @alias module:symbol-tree\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\n         */ constructor(description){\n        this.symbol = Symbol(description || \"SymbolTree data\");\n    }\n    /**\n         * You can use this function to (optionally) initialize an object right after its creation,\n         * to take advantage of V8's fast properties. Also useful if you would like to\n         * freeze your object.\n         *\n         * `O(1)`\n         *\n         * @method\n         * @alias module:symbol-tree#initialize\n         * @param {Object} object\n         * @return {Object} object\n         */ initialize(object) {\n        this._node(object);\n        return object;\n    }\n    _node(object) {\n        if (!object) {\n            return null;\n        }\n        const node = object[this.symbol];\n        if (node) {\n            return node;\n        }\n        return object[this.symbol] = new SymbolTreeNode();\n    }\n    /**\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\n         *\n         * * `O(1)`\n         *\n         * @method hasChildren\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Boolean}\n         */ hasChildren(object) {\n        return this._node(object).hasChildren;\n    }\n    /**\n         * Returns the first child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method firstChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ firstChild(object) {\n        return this._node(object).firstChild;\n    }\n    /**\n         * Returns the last child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method lastChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ lastChild(object) {\n        return this._node(object).lastChild;\n    }\n    /**\n         * Returns the previous sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method previousSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ previousSibling(object) {\n        return this._node(object).previousSibling;\n    }\n    /**\n         * Returns the next sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method nextSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ nextSibling(object) {\n        return this._node(object).nextSibling;\n    }\n    /**\n         * Return the parent of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method parent\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ parent(object) {\n        return this._node(object).parent;\n    }\n    /**\n         * Find the inclusive descendant that is last in tree order of the given object.\n         *\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n         *\n         * @method lastInclusiveDescendant\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ lastInclusiveDescendant(object) {\n        let lastChild;\n        let current = object;\n        while(lastChild = this._node(current).lastChild){\n            current = lastChild;\n        }\n        return current;\n    }\n    /**\n         * Find the preceding object (A) of the given object (B).\n         * An object A is preceding an object B if A and B are in the same tree\n         * and A comes before B in tree order.\n         *\n         * * `O(n)` (worst case)\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method preceding\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @return {?Object}\n         */ preceding(object, options) {\n        const treeRoot = options && options.root;\n        if (object === treeRoot) {\n            return null;\n        }\n        const previousSibling = this._node(object).previousSibling;\n        if (previousSibling) {\n            return this.lastInclusiveDescendant(previousSibling);\n        }\n        // if there is no previous sibling return the parent (might be null)\n        return this._node(object).parent;\n    }\n    /**\n         * Find the following object (A) of the given object (B).\n         * An object A is following an object B if A and B are in the same tree\n         * and A comes after B in tree order.\n         *\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method following\n         * @memberOf module:symbol-tree#\n         * @param {!Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n         * @return {?Object}\n         */ following(object, options) {\n        const treeRoot = options && options.root;\n        const skipChildren = options && options.skipChildren;\n        const firstChild = !skipChildren && this._node(object).firstChild;\n        if (firstChild) {\n            return firstChild;\n        }\n        let current = object;\n        do {\n            if (current === treeRoot) {\n                return null;\n            }\n            const nextSibling = this._node(current).nextSibling;\n            if (nextSibling) {\n                return nextSibling;\n            }\n            current = this._node(current).parent;\n        }while (current);\n        return null;\n    }\n    /**\n         * Append all children of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of children of the given `parent`\n         *\n         * @method childrenToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ childrenToArray(parent, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        const parentNode = this._node(parent);\n        let object = parentNode.firstChild;\n        let index = 0;\n        while(object){\n            const node = this._node(object);\n            node.setCachedIndex(parentNode, index);\n            if (filter.call(thisArg, object)) {\n                array.push(object);\n            }\n            object = node.nextSibling;\n            ++index;\n        }\n        return array;\n    }\n    /**\n         * Append all inclusive ancestors of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\n         *\n         * @method ancestorsToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ ancestorsToArray(object, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        let ancestor = object;\n        while(ancestor){\n            if (filter.call(thisArg, ancestor)) {\n                array.push(ancestor);\n            }\n            ancestor = this._node(ancestor).parent;\n        }\n        return array;\n    }\n    /**\n         * Append all descendants of the given object to an array (in tree order).\n         *\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n         *\n         * @method treeToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ treeToArray(root, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        let object = root;\n        while(object){\n            if (filter.call(thisArg, object)) {\n                array.push(object);\n            }\n            object = this.following(object, {\n                root: root\n            });\n        }\n        return array;\n    }\n    /**\n         * Iterate over all children of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method childrenIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */ childrenIterator(parent, options) {\n        const reverse = options && options.reverse;\n        const parentNode = this._node(parent);\n        return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n    }\n    /**\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method previousSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ previousSiblingsIterator(object) {\n        return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n    }\n    /**\n         * Iterate over all the next siblings of the given object. (in tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method nextSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ nextSiblingsIterator(object) {\n        return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n    }\n    /**\n         * Iterate over all inclusive ancestors of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method ancestorsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ ancestorsIterator(object) {\n        return new TreeIterator(this, object, object, TreeIterator.PARENT);\n    }\n    /**\n         * Iterate over all descendants of the given object (in tree order).\n         *\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\n         *\n         * * `O(n)` (worst case for a single iteration)\n         * * `O(n)` (amortized, when completing the iterator)\n         *\n         * @method treeIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} options\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */ treeIterator(root, options) {\n        const reverse = options && options.reverse;\n        return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n    }\n    /**\n         * Find the index of the given object (the number of preceding siblings).\n         *\n         * * `O(n)` where `n` is the amount of preceding siblings\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method index\n         * @memberOf module:symbol-tree#\n         * @param {Object} child\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n         */ index(child) {\n        const childNode = this._node(child);\n        const parentNode = this._node(childNode.parent);\n        if (!parentNode) {\n            // In principal, you could also find out the number of preceding siblings\n            // for objects that do not have a parent. This method limits itself only to\n            // objects that have a parent because that lets us optimize more.\n            return -1;\n        }\n        let currentIndex = childNode.getCachedIndex(parentNode);\n        if (currentIndex >= 0) {\n            return currentIndex;\n        }\n        currentIndex = 0;\n        let object = parentNode.firstChild;\n        if (parentNode.childIndexCachedUpTo) {\n            const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n            object = cachedUpToNode.nextSibling;\n            currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n        }\n        while(object){\n            const node = this._node(object);\n            node.setCachedIndex(parentNode, currentIndex);\n            if (object === child) {\n                break;\n            }\n            ++currentIndex;\n            object = node.nextSibling;\n        }\n        parentNode.childIndexCachedUpTo = child;\n        return currentIndex;\n    }\n    /**\n         * Calculate the number of children.\n         *\n         * * `O(n)` where `n` is the amount of children\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method childrenCount\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @return {Number}\n         */ childrenCount(parent) {\n        const parentNode = this._node(parent);\n        if (!parentNode.lastChild) {\n            return 0;\n        }\n        return this.index(parentNode.lastChild) + 1;\n    }\n    /**\n         * Compare the position of an object relative to another object. A bit set is returned:\n         *\n         * <ul>\n         *     <li>DISCONNECTED : 1</li>\n         *     <li>PRECEDING : 2</li>\n         *     <li>FOLLOWING : 4</li>\n         *     <li>CONTAINS : 8</li>\n         *     <li>CONTAINED_BY : 16</li>\n         * </ul>\n         *\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n         * DISCONNECTED never occurs with any other bit.\n         *\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n         *\n         * * `O(n + m + o)` (worst case)\n         * * `O(n + m)` (amortized, if the tree is not modified)\n         *\n         * @method compareTreePosition\n         * @memberOf module:symbol-tree#\n         * @param {Object} left\n         * @param {Object} right\n         * @return {Number}\n         */ compareTreePosition(left, right) {\n        // In DOM terms:\n        // left = reference / context object\n        // right = other\n        if (left === right) {\n            return 0;\n        }\n        /* jshint -W016 */ const leftAncestors = [];\n        {\n            let leftAncestor = left;\n            while(leftAncestor){\n                if (leftAncestor === right) {\n                    return TreePosition.CONTAINS | TreePosition.PRECEDING;\n                // other is ancestor of reference\n                }\n                leftAncestors.push(leftAncestor);\n                leftAncestor = this.parent(leftAncestor);\n            }\n        }\n        const rightAncestors = [];\n        {\n            let rightAncestor = right;\n            while(rightAncestor){\n                if (rightAncestor === left) {\n                    return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n                }\n                rightAncestors.push(rightAncestor);\n                rightAncestor = this.parent(rightAncestor);\n            }\n        }\n        const root = reverseArrayIndex(leftAncestors, 0);\n        if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n            // note: unlike DOM, preceding / following is not set here\n            return TreePosition.DISCONNECTED;\n        }\n        // find the lowest common ancestor\n        let commonAncestorIndex = 0;\n        const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n        for(let i = 0; i < ancestorsMinLength; ++i){\n            const leftAncestor = reverseArrayIndex(leftAncestors, i);\n            const rightAncestor = reverseArrayIndex(rightAncestors, i);\n            if (leftAncestor !== rightAncestor) {\n                break;\n            }\n            commonAncestorIndex = i;\n        }\n        // indexes within the common ancestor\n        const leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n        const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n        return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n    }\n    /**\n         * Remove the object from this tree.\n         * Has no effect if already removed.\n         *\n         * * `O(1)`\n         *\n         * @method remove\n         * @memberOf module:symbol-tree#\n         * @param {Object} removeObject\n         * @return {Object} removeObject\n         */ remove(removeObject) {\n        const removeNode = this._node(removeObject);\n        const parentNode = this._node(removeNode.parent);\n        const prevNode = this._node(removeNode.previousSibling);\n        const nextNode = this._node(removeNode.nextSibling);\n        if (parentNode) {\n            if (parentNode.firstChild === removeObject) {\n                parentNode.firstChild = removeNode.nextSibling;\n            }\n            if (parentNode.lastChild === removeObject) {\n                parentNode.lastChild = removeNode.previousSibling;\n            }\n        }\n        if (prevNode) {\n            prevNode.nextSibling = removeNode.nextSibling;\n        }\n        if (nextNode) {\n            nextNode.previousSibling = removeNode.previousSibling;\n        }\n        removeNode.parent = null;\n        removeNode.previousSibling = null;\n        removeNode.nextSibling = null;\n        removeNode.cachedIndex = -1;\n        removeNode.cachedIndexVersion = NaN;\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return removeObject;\n    }\n    /**\n         * Insert the given object before the reference object.\n         * `newObject` is now the previous sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertBefore\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ insertBefore(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const prevNode = this._node(referenceNode.previousSibling);\n        const newNode = this._node(newObject);\n        const parentNode = this._node(referenceNode.parent);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        newNode.parent = referenceNode.parent;\n        newNode.previousSibling = referenceNode.previousSibling;\n        newNode.nextSibling = referenceObject;\n        referenceNode.previousSibling = newObject;\n        if (prevNode) {\n            prevNode.nextSibling = newObject;\n        }\n        if (parentNode && parentNode.firstChild === referenceObject) {\n            parentNode.firstChild = newObject;\n        }\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object after the reference object.\n         * `newObject` is now the next sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertAfter\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ insertAfter(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const nextNode = this._node(referenceNode.nextSibling);\n        const newNode = this._node(newObject);\n        const parentNode = this._node(referenceNode.parent);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        newNode.parent = referenceNode.parent;\n        newNode.previousSibling = referenceObject;\n        newNode.nextSibling = referenceNode.nextSibling;\n        referenceNode.nextSibling = newObject;\n        if (nextNode) {\n            nextNode.previousSibling = newObject;\n        }\n        if (parentNode && parentNode.lastChild === referenceObject) {\n            parentNode.lastChild = newObject;\n        }\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object as the first child of the given reference object.\n         * `newObject` is now the first child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method prependChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ prependChild(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const newNode = this._node(newObject);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        if (referenceNode.hasChildren) {\n            this.insertBefore(referenceNode.firstChild, newObject);\n        } else {\n            newNode.parent = referenceObject;\n            referenceNode.firstChild = newObject;\n            referenceNode.lastChild = newObject;\n            referenceNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object as the last child of the given reference object.\n         * `newObject` is now the last child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method appendChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ appendChild(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const newNode = this._node(newObject);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        if (referenceNode.hasChildren) {\n            this.insertAfter(referenceNode.lastChild, newObject);\n        } else {\n            newNode.parent = referenceObject;\n            referenceNode.firstChild = newObject;\n            referenceNode.lastChild = newObject;\n            referenceNode.childrenChanged();\n        }\n        return newObject;\n    }\n}\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7O0NBR0MsR0FFRCxNQUFNQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDO0FBRTdCLFNBQVNHO0lBQ0QsT0FBTztBQUNmO0FBRUEsU0FBU0Msa0JBQWtCQyxLQUFLLEVBQUVDLFlBQVk7SUFDdEMsT0FBT0QsS0FBSyxDQUFDQSxNQUFNRSxNQUFNLEdBQUcsSUFBSUQsYUFBYSxFQUFFLGdDQUFnQztBQUN2RjtBQUVBLE1BQU1FO0lBRUU7Ozs7U0FJQyxHQUNEQyxZQUFZQyxXQUFXLENBQUU7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLE9BQU9GLGVBQWU7SUFDNUM7SUFFQTs7Ozs7Ozs7Ozs7U0FXQyxHQUNERyxXQUFXQyxNQUFNLEVBQUU7UUFDWCxJQUFJLENBQUNDLEtBQUssQ0FBQ0Q7UUFFWCxPQUFPQTtJQUNmO0lBRUFDLE1BQU1ELE1BQU0sRUFBRTtRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNMLE9BQU87UUFDZjtRQUVBLE1BQU1FLE9BQU9GLE1BQU0sQ0FBQyxJQUFJLENBQUNILE1BQU0sQ0FBQztRQUVoQyxJQUFJSyxNQUFNO1lBQ0YsT0FBT0E7UUFDZjtRQUVBLE9BQVFGLE1BQU0sQ0FBQyxJQUFJLENBQUNILE1BQU0sQ0FBQyxHQUFHLElBQUlaO0lBQzFDO0lBRUE7Ozs7Ozs7OztTQVNDLEdBQ0RrQixZQUFZSCxNQUFNLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxRQUFRRyxXQUFXO0lBQzdDO0lBRUE7Ozs7Ozs7OztTQVNDLEdBQ0RDLFdBQVdKLE1BQU0sRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNELFFBQVFJLFVBQVU7SUFDNUM7SUFFQTs7Ozs7Ozs7O1NBU0MsR0FDREMs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Q0s7WUFDR0UsUUFBUXJFLE1BQU0sR0FBR2tFO1lBQ2pCRSxjQUFjeEUsVUFBVSxHQUFHdUU7WUFDM0JDLGNBQWN2RSxTQUFTLEdBQUdzRTtZQUMxQkMsY0FBY0osZUFBZTtRQUNyQztRQUVBLE9BQU9HO0lBQ2Y7QUFDUjtBQUVBUSxPQUFPQyxPQUFPLEdBQUcxRjtBQUNqQkEsV0FBV1AsWUFBWSxHQUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RpZ21hLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9TeW1ib2xUcmVlLmpzP2JiMjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtb2R1bGUgc3ltYm9sLXRyZWVcbiAqIEBhdXRob3IgSm9yaXMgdmFuIGRlciBXZWwgPGpvcmlzQGpvcmlzdmFuZGVyd2VsLmNvbT5cbiAqL1xuXG5jb25zdCBTeW1ib2xUcmVlTm9kZSA9IHJlcXVpcmUoJy4vU3ltYm9sVHJlZU5vZGUnKTtcbmNvbnN0IFRyZWVQb3NpdGlvbiA9IHJlcXVpcmUoJy4vVHJlZVBvc2l0aW9uJyk7XG5jb25zdCBUcmVlSXRlcmF0b3IgPSByZXF1aXJlKCcuL1RyZWVJdGVyYXRvcicpO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZUFycmF5SW5kZXgoYXJyYXksIHJldmVyc2VJbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMSAtIHJldmVyc2VJbmRleF07IC8vIG5vIG5lZWQgdG8gY2hlY2sgYGluZGV4ID49IDBgXG59XG5cbmNsYXNzIFN5bWJvbFRyZWUge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGFsaWFzIG1vZHVsZTpzeW1ib2wtdHJlZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uPSdTeW1ib2xUcmVlIGRhdGEnXSBEZXNjcmlwdGlvbiB1c2VkIGZvciB0aGUgU3ltYm9sXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sID0gU3ltYm9sKGRlc2NyaXB0aW9uIHx8ICdTeW1ib2xUcmVlIGRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIChvcHRpb25hbGx5KSBpbml0aWFsaXplIGFuIG9iamVjdCByaWdodCBhZnRlciBpdHMgY3JlYXRpb24sXG4gICAgICAgICAqIHRvIHRha2UgYWR2YW50YWdlIG9mIFY4J3MgZmFzdCBwcm9wZXJ0aWVzLiBBbHNvIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0b1xuICAgICAgICAgKiBmcmVlemUgeW91ciBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBhbGlhcyBtb2R1bGU6c3ltYm9sLXRyZWUjaW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUob2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBfbm9kZShvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG9iamVjdFt0aGlzLnN5bWJvbF07XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmplY3RbdGhpcy5zeW1ib2xdID0gbmV3IFN5bWJvbFRyZWVOb2RlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFueSBjaGlsZHJlbi4gT3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBoYXNDaGlsZHJlblxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNDaGlsZHJlbihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLmhhc0NoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZmlyc3RDaGlsZFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGZpcnN0Q2hpbGQob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5maXJzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxhc3QgY2hpbGQgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBsYXN0Q2hpbGRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Q2hpbGQob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByZXZpb3VzU2libGluZ1xuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHByZXZpb3VzU2libGluZyhvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBuZXh0U2libGluZ1xuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIG5leHRTaWJsaW5nKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBwYXJlbnQgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwYXJlbnRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnQob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgaW5jbHVzaXZlIGRlc2NlbmRhbnQgdGhhdCBpcyBsYXN0IGluIHRyZWUgb3JkZXIgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgKHdvcnN0IGNhc2UpIHdoZXJlIGBuYCBpcyB0aGUgZGVwdGggb2YgdGhlIHN1YnRyZWUgb2YgYG9iamVjdGBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBsYXN0SW5jbHVzaXZlRGVzY2VuZGFudFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RJbmNsdXNpdmVEZXNjZW5kYW50KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBvYmplY3Q7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxhc3RDaGlsZCA9IHRoaXMuX25vZGUoY3VycmVudCkubGFzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBwcmVjZWRpbmcgb2JqZWN0IChBKSBvZiB0aGUgZ2l2ZW4gb2JqZWN0IChCKS5cbiAgICAgICAgICogQW4gb2JqZWN0IEEgaXMgcHJlY2VkaW5nIGFuIG9iamVjdCBCIGlmIEEgYW5kIEIgYXJlIGluIHRoZSBzYW1lIHRyZWVcbiAgICAgICAgICogYW5kIEEgY29tZXMgYmVmb3JlIEIgaW4gdHJlZSBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgKHdvcnN0IGNhc2UpXG4gICAgICAgICAqICogYE8oMSlgIChhbW9ydGl6ZWQgd2hlbiB3YWxraW5nIHRoZSBlbnRpcmUgdHJlZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcmVjZWRpbmdcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yb290XSBJZiBzZXQsIGByb290YCBtdXN0IGJlIGFuIGluY2x1c2l2ZSBhbmNlc3RvclxuICAgICAgICAgKiAgICAgICAgb2YgdGhlIHJldHVybiB2YWx1ZSAob3IgZWxzZSBudWxsIGlzIHJldHVybmVkKS4gVGhpcyBjaGVjayBfYXNzdW1lc19cbiAgICAgICAgICogICAgICAgIHRoYXQgYHJvb3RgIGlzIGFsc28gYW4gaW5jbHVzaXZlIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBgb2JqZWN0YFxuICAgICAgICAgKiBAcmV0dXJuIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY2VkaW5nKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVSb290ID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvb3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0ID09PSB0cmVlUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gdGhpcy5fbm9kZShvYmplY3QpLnByZXZpb3VzU2libGluZztcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RJbmNsdXNpdmVEZXNjZW5kYW50KHByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgc2libGluZyByZXR1cm4gdGhlIHBhcmVudCAobWlnaHQgYmUgbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBmb2xsb3dpbmcgb2JqZWN0IChBKSBvZiB0aGUgZ2l2ZW4gb2JqZWN0IChCKS5cbiAgICAgICAgICogQW4gb2JqZWN0IEEgaXMgZm9sbG93aW5nIGFuIG9iamVjdCBCIGlmIEEgYW5kIEIgYXJlIGluIHRoZSBzYW1lIHRyZWVcbiAgICAgICAgICogYW5kIEEgY29tZXMgYWZ0ZXIgQiBpbiB0cmVlIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCAod29yc3QgY2FzZSkgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2Ygb2JqZWN0cyBpbiB0aGUgZW50aXJlIHRyZWVcbiAgICAgICAgICogKiBgTygxKWAgKGFtb3J0aXplZCB3aGVuIHdhbGtpbmcgdGhlIGVudGlyZSB0cmVlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGZvbGxvd2luZ1xuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yb290XSBJZiBzZXQsIGByb290YCBtdXN0IGJlIGFuIGluY2x1c2l2ZSBhbmNlc3RvclxuICAgICAgICAgKiAgICAgICAgb2YgdGhlIHJldHVybiB2YWx1ZSAob3IgZWxzZSBudWxsIGlzIHJldHVybmVkKS4gVGhpcyBjaGVjayBfYXNzdW1lc19cbiAgICAgICAgICogICAgICAgIHRoYXQgYHJvb3RgIGlzIGFsc28gYW4gaW5jbHVzaXZlIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBgb2JqZWN0YFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBDaGlsZHJlbj1mYWxzZV0gSWYgc2V0LCBpZ25vcmUgdGhlIGNoaWxkcmVuIG9mIGBvYmplY3RgXG4gICAgICAgICAqIEByZXR1cm4gez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBmb2xsb3dpbmcob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZVJvb3QgPSBvcHRpb25zICYmIG9wdGlvbnMucm9vdDtcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwQ2hpbGRyZW4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcENoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9ICFza2lwQ2hpbGRyZW4gJiYgdGhpcy5fbm9kZShvYmplY3QpLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBvYmplY3Q7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdHJlZVJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5fbm9kZShjdXJyZW50KS5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX25vZGUoY3VycmVudCkucGFyZW50O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIGFsbCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHRvIGFuIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gYHBhcmVudGBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBjaGlsZHJlblRvQXJyYXlcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmFycmF5PVtdXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maWx0ZXJdIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBvYmplY3QgYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSW52b2tlZCB3aXRoIGFyZ3VtZW50cyAob2JqZWN0KS4gU2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgYW4gb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnRoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZpbHRlcmAuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW5Ub0FycmF5KHBhcmVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ICAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFycmF5KSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHx8IHJldHVyblRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0FyZyA9IChvcHRpb25zICYmIG9wdGlvbnMudGhpc0FyZykgfHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0ID0gcGFyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRDYWNoZWRJbmRleChwYXJlbnROb2RlLCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzQXJnLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCBhbGwgaW5jbHVzaXZlIGFuY2VzdG9ycyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHRvIGFuIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBhbmNlc3RvcnMgb2YgdGhlIGdpdmVuIGBvYmplY3RgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgYW5jZXN0b3JzVG9BcnJheVxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3RbXX0gW29wdGlvbnMuYXJyYXk9W11dXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbHRlcl0gRnVuY3Rpb24gdG8gdGVzdCBlYWNoIG9iamVjdCBiZWZvcmUgaXQgaXMgYWRkZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnZva2VkIHdpdGggYXJndW1lbnRzIChvYmplY3QpLiBTaG91bGQgcmV0dXJuIGB0cnVlYCBpZiBhbiBvYmplY3RcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMudGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgZmlsdGVyYC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICBhbmNlc3RvcnNUb0FycmF5KG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ICAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFycmF5KSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHx8IHJldHVyblRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0FyZyA9IChvcHRpb25zICYmIG9wdGlvbnMudGhpc0FyZykgfHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgbGV0IGFuY2VzdG9yID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmNhbGwodGhpc0FyZywgYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2goYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3IgPSB0aGlzLl9ub2RlKGFuY2VzdG9yKS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIGdpdmVuIG9iamVjdCB0byBhbiBhcnJheSAoaW4gdHJlZSBvcmRlcikuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIG9iamVjdHMgaW4gdGhlIHN1Yi10cmVlIG9mIHRoZSBnaXZlbiBgb2JqZWN0YFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHRyZWVUb0FycmF5XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3RbXX0gW29wdGlvbnMuYXJyYXk9W11dXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbHRlcl0gRnVuY3Rpb24gdG8gdGVzdCBlYWNoIG9iamVjdCBiZWZvcmUgaXQgaXMgYWRkZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnZva2VkIHdpdGggYXJndW1lbnRzIChvYmplY3QpLiBTaG91bGQgcmV0dXJuIGB0cnVlYCBpZiBhbiBvYmplY3RcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMudGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgZmlsdGVyYC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICB0cmVlVG9BcnJheShyb290LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgICA9IChvcHRpb25zICYmIG9wdGlvbnMuYXJyYXkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikgfHwgcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzQXJnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50aGlzQXJnKSB8fCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0ID0gcm9vdDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzQXJnLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IHRoaXMuZm9sbG93aW5nKG9iamVjdCwge3Jvb3Q6IHJvb3R9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgIGZvciBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBjaGlsZHJlbkl0ZXJhdG9yXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldmVyc2U9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaXRlcmFibGUgaXRlcmF0b3IgKEVTNilcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuSXRlcmF0b3IocGFyZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXZlcnNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVJdGVyYXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID8gcGFyZW50Tm9kZS5sYXN0Q2hpbGQgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID8gVHJlZUl0ZXJhdG9yLlBSRVYgOiBUcmVlSXRlcmF0b3IuTkVYVFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcHJldmlvdXMgc2libGluZ3Mgb2YgdGhlIGdpdmVuIG9iamVjdC4gKGluIHJldmVyc2UgdHJlZSBvcmRlcilcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWAgZm9yIGEgc2luZ2xlIGl0ZXJhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByZXZpb3VzU2libGluZ3NJdGVyYXRvclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaXRlcmFibGUgaXRlcmF0b3IgKEVTNilcbiAgICAgICAgICovXG4gICAgICAgIHByZXZpb3VzU2libGluZ3NJdGVyYXRvcihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVJdGVyYXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlKG9iamVjdCkucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgVHJlZUl0ZXJhdG9yLlBSRVZcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIG5leHQgc2libGluZ3Mgb2YgdGhlIGdpdmVuIG9iamVjdC4gKGluIHRyZWUgb3JkZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgIGZvciBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBuZXh0U2libGluZ3NJdGVyYXRvclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaXRlcmFibGUgaXRlcmF0b3IgKEVTNilcbiAgICAgICAgICovXG4gICAgICAgIG5leHRTaWJsaW5nc0l0ZXJhdG9yKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUl0ZXJhdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGUob2JqZWN0KS5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyZWVJdGVyYXRvci5ORVhUXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIGluY2x1c2l2ZSBhbmNlc3RvcnMgb2YgdGhlIGdpdmVuIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYCBmb3IgYSBzaW5nbGUgaXRlcmF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgYW5jZXN0b3JzSXRlcmF0b3JcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGl0ZXJhYmxlIGl0ZXJhdG9yIChFUzYpXG4gICAgICAgICAqL1xuICAgICAgICBhbmNlc3RvcnNJdGVyYXRvcihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVJdGVyYXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmVlSXRlcmF0b3IuUEFSRU5UXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiBvYmplY3QgKGluIHRyZWUgb3JkZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBvYmplY3RzIGluIHRoZSBzdWItdHJlZSBvZiB0aGUgZ2l2ZW4gYHJvb3RgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCAod29yc3QgY2FzZSBmb3IgYSBzaW5nbGUgaXRlcmF0aW9uKVxuICAgICAgICAgKiAqIGBPKG4pYCAoYW1vcnRpemVkLCB3aGVuIGNvbXBsZXRpbmcgdGhlIGl0ZXJhdG9yKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHRyZWVJdGVyYXRvclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldmVyc2U9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaXRlcmFibGUgaXRlcmF0b3IgKEVTNilcbiAgICAgICAgICovXG4gICAgICAgIHRyZWVJdGVyYXRvcihyb290LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXZlcnNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPyB0aGlzLmxhc3RJbmNsdXNpdmVEZXNjZW5kYW50KHJvb3QpIDogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPyBUcmVlSXRlcmF0b3IuUFJFQ0VESU5HIDogVHJlZUl0ZXJhdG9yLkZPTExPV0lOR1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG9iamVjdCAodGhlIG51bWJlciBvZiBwcmVjZWRpbmcgc2libGluZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBwcmVjZWRpbmcgc2libGluZ3NcbiAgICAgICAgICogKiBgTygxKWAgKGFtb3J0aXplZCwgaWYgdGhlIHRyZWUgaXMgbm90IG1vZGlmaWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluZGV4XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZFxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgcHJlY2VkaW5nIHNpYmxpbmdzLCBvciAtMSBpZiB0aGUgb2JqZWN0IGhhcyBubyBwYXJlbnRcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4KGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gdGhpcy5fbm9kZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUoY2hpbGROb2RlLnBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHByaW5jaXBhbCwgeW91IGNvdWxkIGFsc28gZmluZCBvdXQgdGhlIG51bWJlciBvZiBwcmVjZWRpbmcgc2libGluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYSBwYXJlbnQuIFRoaXMgbWV0aG9kIGxpbWl0cyBpdHNlbGYgb25seSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB0aGF0IGhhdmUgYSBwYXJlbnQgYmVjYXVzZSB0aGF0IGxldHMgdXMgb3B0aW1pemUgbW9yZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gY2hpbGROb2RlLmdldENhY2hlZEluZGV4KHBhcmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdCA9IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmNoaWxkSW5kZXhDYWNoZWRVcFRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRVcFRvTm9kZSA9IHRoaXMuX25vZGUocGFyZW50Tm9kZS5jaGlsZEluZGV4Q2FjaGVkVXBUbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBjYWNoZWRVcFRvTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGNhY2hlZFVwVG9Ob2RlLmdldENhY2hlZEluZGV4KHBhcmVudE5vZGUpICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRDYWNoZWRJbmRleChwYXJlbnROb2RlLCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0ID09PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgKytjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRJbmRleENhY2hlZFVwVG8gPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIGNoaWxkcmVuXG4gICAgICAgICAqICogYE8oMSlgIChhbW9ydGl6ZWQsIGlmIHRoZSB0cmVlIGlzIG5vdCBtb2RpZmllZClcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBjaGlsZHJlbkNvdW50XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW5Db3VudChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShwYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgocGFyZW50Tm9kZS5sYXN0Q2hpbGQpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIHRoZSBwb3NpdGlvbiBvZiBhbiBvYmplY3QgcmVsYXRpdmUgdG8gYW5vdGhlciBvYmplY3QuIEEgYml0IHNldCBpcyByZXR1cm5lZDpcbiAgICAgICAgICpcbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiAgICAgPGxpPkRJU0NPTk5FQ1RFRCA6IDE8L2xpPlxuICAgICAgICAgKiAgICAgPGxpPlBSRUNFRElORyA6IDI8L2xpPlxuICAgICAgICAgKiAgICAgPGxpPkZPTExPV0lORyA6IDQ8L2xpPlxuICAgICAgICAgKiAgICAgPGxpPkNPTlRBSU5TIDogODwvbGk+XG4gICAgICAgICAqICAgICA8bGk+Q09OVEFJTkVEX0JZIDogMTY8L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc2VtYW50aWNzIGFyZSB0aGUgc2FtZSBhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpbiBET00sIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0XG4gICAgICAgICAqIERJU0NPTk5FQ1RFRCBuZXZlciBvY2N1cnMgd2l0aCBhbnkgb3RoZXIgYml0LlxuICAgICAgICAgKlxuICAgICAgICAgKiB3aGVyZSBgbmAgYW5kIGBtYCBhcmUgdGhlIGFtb3VudCBvZiBhbmNlc3RvcnMgb2YgYGxlZnRgIGFuZCBgcmlnaHRgO1xuICAgICAgICAgKiB3aGVyZSBgb2AgaXMgdGhlIGFtb3VudCBvZiBjaGlsZHJlbiBvZiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBgbGVmdGAgYW5kIGByaWdodGA6XG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obiArIG0gKyBvKWAgKHdvcnN0IGNhc2UpXG4gICAgICAgICAqICogYE8obiArIG0pYCAoYW1vcnRpemVkLCBpZiB0aGUgdHJlZSBpcyBub3QgbW9kaWZpZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgY29tcGFyZVRyZWVQb3NpdGlvblxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVmdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmlnaHRcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZVRyZWVQb3NpdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIEluIERPTSB0ZXJtczpcbiAgICAgICAgICAgICAgICAvLyBsZWZ0ID0gcmVmZXJlbmNlIC8gY29udGV4dCBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyByaWdodCA9IG90aGVyXG5cbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxNiAqL1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFuY2VzdG9ycyA9IFtdOyB7IC8vIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnRBbmNlc3RvciA9IGxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZWZ0QW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRBbmNlc3RvciA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJlZVBvc2l0aW9uLkNPTlRBSU5TIHwgVHJlZVBvc2l0aW9uLlBSRUNFRElORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBpcyBhbmNlc3RvciBvZiByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBbmNlc3RvcnMucHVzaChsZWZ0QW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QW5jZXN0b3IgPSB0aGlzLnBhcmVudChsZWZ0QW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRBbmNlc3RvcnMgPSBbXTsge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0QW5jZXN0b3IgPSByaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJpZ2h0QW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0QW5jZXN0b3IgPT09IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJlZVBvc2l0aW9uLkNPTlRBSU5FRF9CWSB8IFRyZWVQb3NpdGlvbi5GT0xMT1dJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodEFuY2VzdG9ycy5wdXNoKHJpZ2h0QW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodEFuY2VzdG9yID0gdGhpcy5wYXJlbnQocmlnaHRBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBjb25zdCByb290ID0gcmV2ZXJzZUFycmF5SW5kZXgobGVmdEFuY2VzdG9ycywgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QgfHwgcm9vdCAhPT0gcmV2ZXJzZUFycmF5SW5kZXgocmlnaHRBbmNlc3RvcnMsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB1bmxpa2UgRE9NLCBwcmVjZWRpbmcgLyBmb2xsb3dpbmcgaXMgbm90IHNldCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJlZVBvc2l0aW9uLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgbGV0IGNvbW1vbkFuY2VzdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yc01pbkxlbmd0aCA9IE1hdGgubWluKGxlZnRBbmNlc3RvcnMubGVuZ3RoLCByaWdodEFuY2VzdG9ycy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNlc3RvcnNNaW5MZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdEFuY2VzdG9yICA9IHJldmVyc2VBcnJheUluZGV4KGxlZnRBbmNlc3RvcnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHRBbmNlc3RvciA9IHJldmVyc2VBcnJheUluZGV4KHJpZ2h0QW5jZXN0b3JzLCBpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRBbmNlc3RvciAhPT0gcmlnaHRBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uQW5jZXN0b3JJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhlcyB3aXRoaW4gdGhlIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRJbmRleCAgPSB0aGlzLmluZGV4KHJldmVyc2VBcnJheUluZGV4KGxlZnRBbmNlc3RvcnMsIGNvbW1vbkFuY2VzdG9ySW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRJbmRleCA9IHRoaXMuaW5kZXgocmV2ZXJzZUFycmF5SW5kZXgocmlnaHRBbmNlc3RvcnMsIGNvbW1vbkFuY2VzdG9ySW5kZXggKyAxKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRJbmRleCA8IGxlZnRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBUcmVlUG9zaXRpb24uUFJFQ0VESU5HXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFRyZWVQb3NpdGlvbi5GT0xMT1dJTkc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGlzIHRyZWUuXG4gICAgICAgICAqIEhhcyBubyBlZmZlY3QgaWYgYWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3ZlT2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVtb3ZlT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmUocmVtb3ZlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlTm9kZSA9IHRoaXMuX25vZGUocmVtb3ZlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShyZW1vdmVOb2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLl9ub2RlKHJlbW92ZU5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuX25vZGUocmVtb3ZlTm9kZS5uZXh0U2libGluZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9PT0gcmVtb3ZlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IHJlbW92ZU5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmxhc3RDaGlsZCA9PT0gcmVtb3ZlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUubGFzdENoaWxkID0gcmVtb3ZlTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZS5uZXh0U2libGluZyA9IHJlbW92ZU5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgPSByZW1vdmVOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZS5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUuY2FjaGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlLmNhY2hlZEluZGV4VmVyc2lvbiA9IE5hTjtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVPYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IHRoZSBnaXZlbiBvYmplY3QgYmVmb3JlIHRoZSByZWZlcmVuY2Ugb2JqZWN0LlxuICAgICAgICAgKiBgbmV3T2JqZWN0YCBpcyBub3cgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYHJlZmVyZW5jZU9iamVjdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5zZXJ0QmVmb3JlXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG5ld09iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRCZWZvcmUocmVmZXJlbmNlT2JqZWN0LCBuZXdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuX25vZGUobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VOb2RlLnBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZS5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR2l2ZW4gb2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWUsIHJlbW92ZSBpdCBmaXJzdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcmVmZXJlbmNlTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5wcmV2aW91c1NpYmxpbmcgPSByZWZlcmVuY2VOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICBuZXdOb2RlLm5leHRTaWJsaW5nID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUucHJldmlvdXNTaWJsaW5nID0gbmV3T2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZS5uZXh0U2libGluZyA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPT09IHJlZmVyZW5jZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IHRoZSBnaXZlbiBvYmplY3QgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICAgICAqIGBuZXdPYmplY3RgIGlzIG5vdyB0aGUgbmV4dCBzaWJsaW5nIG9mIGByZWZlcmVuY2VPYmplY3RgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluc2VydEFmdGVyXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG5ld09iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRBZnRlcihyZWZlcmVuY2VPYmplY3QsIG5ld09iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLl9ub2RlKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlTm9kZS5wYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld05vZGUuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dpdmVuIG9iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlLCByZW1vdmUgaXQgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdOb2RlLnBhcmVudCA9IHJlZmVyZW5jZU5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIG5ld05vZGUucHJldmlvdXNTaWJsaW5nID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgICAgICAgICAgICAgIG5ld05vZGUubmV4dFNpYmxpbmcgPSByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcgPSBuZXdPYmplY3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLnByZXZpb3VzU2libGluZyA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmxhc3RDaGlsZCA9PT0gcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmxhc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgZ2l2ZW4gb2JqZWN0IGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZ2l2ZW4gcmVmZXJlbmNlIG9iamVjdC5cbiAgICAgICAgICogYG5ld09iamVjdGAgaXMgbm93IHRoZSBmaXJzdCBjaGlsZCBvZiBgcmVmZXJlbmNlT2JqZWN0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcmVwZW5kQ2hpbGRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbmV3T2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWVcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHByZXBlbmRDaGlsZChyZWZlcmVuY2VPYmplY3QsIG5ld09iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuX25vZGUobmV3T2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdHaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZSwgcmVtb3ZlIGl0IGZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGUuaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHJlZmVyZW5jZU5vZGUuZmlyc3RDaGlsZCwgbmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnBhcmVudCA9IHJlZmVyZW5jZU9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUuZmlyc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUubGFzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgZ2l2ZW4gb2JqZWN0IGFzIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBnaXZlbiByZWZlcmVuY2Ugb2JqZWN0LlxuICAgICAgICAgKiBgbmV3T2JqZWN0YCBpcyBub3cgdGhlIGxhc3QgY2hpbGQgb2YgYHJlZmVyZW5jZU9iamVjdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgYXBwZW5kQ2hpbGRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbmV3T2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWVcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGFwcGVuZENoaWxkKHJlZmVyZW5jZU9iamVjdCwgbmV3T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5fbm9kZShuZXdPYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld05vZGUuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dpdmVuIG9iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlLCByZW1vdmUgaXQgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZS5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRBZnRlcihyZWZlcmVuY2VOb2RlLmxhc3RDaGlsZCwgbmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnBhcmVudCA9IHJlZmVyZW5jZU9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUuZmlyc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUubGFzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgICAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sVHJlZTtcblN5bWJvbFRyZWUuVHJlZVBvc2l0aW9uID0gVHJlZVBvc2l0aW9uO1xuIl0sIm5hbWVzIjpbIlN5bWJvbFRyZWVOb2RlIiwicmVxdWlyZSIsIlRyZWVQb3NpdGlvbiIsIlRyZWVJdGVyYXRvciIsInJldHVyblRydWUiLCJyZXZlcnNlQXJyYXlJbmRleCIsImFycmF5IiwicmV2ZXJzZUluZGV4IiwibGVuZ3RoIiwiU3ltYm9sVHJlZSIsImNvbnN0cnVjdG9yIiwiZGVzY3JpcHRpb24iLCJzeW1ib2wiLCJTeW1ib2wiLCJpbml0aWFsaXplIiwib2JqZWN0IiwiX25vZGUiLCJub2RlIiwiaGFzQ2hpbGRyZW4iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJwYXJlbnQiLCJsYXN0SW5jbHVzaXZlRGVzY2VuZGFudCIsImN1cnJlbnQiLCJwcmVjZWRpbmciLCJvcHRpb25zIiwidHJlZVJvb3QiLCJyb290IiwiZm9sbG93aW5nIiwic2tpcENoaWxkcmVuIiwiY2hpbGRyZW5Ub0FycmF5IiwiZmlsdGVyIiwidGhpc0FyZyIsInVuZGVmaW5lZCIsInBhcmVudE5vZGUiLCJpbmRleCIsInNldENhY2hlZEluZGV4IiwiY2FsbCIsInB1c2giLCJhbmNlc3RvcnNUb0FycmF5IiwiYW5jZXN0b3IiLCJ0cmVlVG9BcnJheSIsImNoaWxkcmVuSXRlcmF0b3IiLCJyZXZlcnNlIiwiUFJFViIsIk5FWFQiLCJwcmV2aW91c1NpYmxpbmdzSXRlcmF0b3IiLCJuZXh0U2libGluZ3NJdGVyYXRvciIsImFuY2VzdG9yc0l0ZXJhdG9yIiwiUEFSRU5UIiwidHJlZUl0ZXJhdG9yIiwiUFJFQ0VESU5HIiwiRk9MTE9XSU5HIiwiY2hpbGQiLCJjaGlsZE5vZGUiLCJjdXJyZW50SW5kZXgiLCJnZXRDYWNoZWRJbmRleCIsImNoaWxkSW5kZXhDYWNoZWRVcFRvIiwiY2FjaGVkVXBUb05vZGUiLCJjaGlsZHJlbkNvdW50IiwiY29tcGFyZVRyZWVQb3NpdGlvbiIsImxlZnQiLCJyaWdodCIsImxlZnRBbmNlc3RvcnMiLCJsZWZ0QW5jZXN0b3IiLCJDT05UQUlOUyIsInJpZ2h0QW5jZXN0b3JzIiwicmlnaHRBbmNlc3RvciIsIkNPTlRBSU5FRF9CWSIsIkRJU0NPTk5FQ1RFRCIsImNvbW1vbkFuY2VzdG9ySW5kZXgiLCJhbmNlc3RvcnNNaW5MZW5ndGgiLCJNYXRoIiwibWluIiwiaSIsImxlZnRJbmRleCIsInJpZ2h0SW5kZXgiLCJyZW1vdmUiLCJyZW1vdmVPYmplY3QiLCJyZW1vdmVOb2RlIiwicHJldk5vZGUiLCJuZXh0Tm9kZSIsImNhY2hlZEluZGV4IiwiY2FjaGVkSW5kZXhWZXJzaW9uIiwiTmFOIiwiY2hpbGRyZW5DaGFuZ2VkIiwiaW5zZXJ0QmVmb3JlIiwicmVmZXJlbmNlT2JqZWN0IiwibmV3T2JqZWN0IiwicmVmZXJlbmNlTm9kZSIsIm5ld05vZGUiLCJpc0F0dGFjaGVkIiwiRXJyb3IiLCJpbnNlcnRBZnRlciIsInByZXBlbmRDaGlsZCIsImFwcGVuZENoaWxkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/SymbolTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js":
/*!********************************************************!*\
  !*** ./node_modules/symbol-tree/lib/SymbolTreeNode.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = class SymbolTreeNode {\n    constructor(){\n        this.parent = null;\n        this.previousSibling = null;\n        this.nextSibling = null;\n        this.firstChild = null;\n        this.lastChild = null;\n        /** This value is incremented anytime a children is added or removed */ this.childrenVersion = 0;\n        /** The last child object which has a cached index */ this.childIndexCachedUpTo = null;\n        /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */ this.cachedIndex = -1;\n        this.cachedIndexVersion = NaN; // NaN is never equal to anything\n    }\n    get isAttached() {\n        return Boolean(this.parent || this.previousSibling || this.nextSibling);\n    }\n    get hasChildren() {\n        return Boolean(this.firstChild);\n    }\n    childrenChanged() {\n        /* jshint -W016 */ // integer wrap around\n        this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n        this.childIndexCachedUpTo = null;\n    }\n    getCachedIndex(parentNode) {\n        // (assumes parentNode is actually the parent)\n        if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n            this.cachedIndexVersion = NaN;\n            // cachedIndex is no longer valid\n            return -1;\n        }\n        return this.cachedIndex; // -1 if not cached\n    }\n    setCachedIndex(parentNode, index) {\n        // (assumes parentNode is actually the parent)\n        this.cachedIndexVersion = parentNode.childrenVersion;\n        this.cachedIndex = index;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWVOb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNmQyxhQUFjO1FBQ04sSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUVuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVqQixxRUFBcUUsR0FDckUsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsbURBQW1ELEdBQ25ELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7UUFFNUI7cUZBQ3FFLEdBQ3JFLElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0MsS0FBSyxpQ0FBaUM7SUFDeEU7SUFFQSxJQUFJQyxhQUFhO1FBQ1QsT0FBT0MsUUFBUSxJQUFJLENBQUNYLE1BQU0sSUFBSSxJQUFJLENBQUNDLGVBQWUsSUFBSSxJQUFJLENBQUNDLFdBQVc7SUFDOUU7SUFFQSxJQUFJVSxjQUFjO1FBQ1YsT0FBT0QsUUFBUSxJQUFJLENBQUNSLFVBQVU7SUFDdEM7SUFFQVUsa0JBQWtCO1FBQ1YsZ0JBQWdCLEdBQ2hCLHNCQUFzQjtRQUN0QixJQUFJLENBQUNSLGVBQWUsR0FBRyxJQUFLLENBQUNBLGVBQWUsR0FBRyxJQUFLO1FBQ3BELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDcEM7SUFFQVEsZUFBZUMsVUFBVSxFQUFFO1FBQ25CLDhDQUE4QztRQUM5QyxJQUFJLElBQUksQ0FBQ1Asa0JBQWtCLEtBQUtPLFdBQVdWLGVBQWUsRUFBRTtZQUNwRCxJQUFJLENBQUNHLGtCQUFrQixHQUFHQztZQUMxQixpQ0FBaUM7WUFDakMsT0FBTyxDQUFDO1FBQ2hCO1FBRUEsT0FBTyxJQUFJLENBQUNGLFdBQVcsRUFBRSxtQkFBbUI7SUFDcEQ7SUFFQVMsZUFBZUQsVUFBVSxFQUFFRSxLQUFLLEVBQUU7UUFDMUIsOENBQThDO1FBQzlDLElBQUksQ0FBQ1Qsa0JBQWtCLEdBQUdPLFdBQVdWLGVBQWU7UUFDcEQsSUFBSSxDQUFDRSxXQUFXLEdBQUdVO0lBQzNCO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWdtYS8uL25vZGVfbW9kdWxlcy9zeW1ib2wtdHJlZS9saWIvU3ltYm9sVHJlZU5vZGUuanM/ZGNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3ltYm9sVHJlZU5vZGUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKiogVGhpcyB2YWx1ZSBpcyBpbmNyZW1lbnRlZCBhbnl0aW1lIGEgY2hpbGRyZW4gaXMgYWRkZWQgb3IgcmVtb3ZlZCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5WZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICAvKiogVGhlIGxhc3QgY2hpbGQgb2JqZWN0IHdoaWNoIGhhcyBhIGNhY2hlZCBpbmRleCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRJbmRleENhY2hlZFVwVG8gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqIFRoaXMgdmFsdWUgcmVwcmVzZW50cyB0aGUgY2FjaGVkIG5vZGUgaW5kZXgsIGFzIGxvbmcgYXNcbiAgICAgICAgICAgICAgICAgKiBjYWNoZWRJbmRleFZlcnNpb24gbWF0Y2hlcyB3aXRoIHRoZSBjaGlsZHJlblZlcnNpb24gb2YgdGhlIHBhcmVudCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluZGV4VmVyc2lvbiA9IE5hTjsgLy8gTmFOIGlzIG5ldmVyIGVxdWFsIHRvIGFueXRoaW5nXG4gICAgICAgIH1cblxuICAgICAgICBnZXQgaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBhcmVudCB8fCB0aGlzLnByZXZpb3VzU2libGluZyB8fCB0aGlzLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRyZW5DaGFuZ2VkKCkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxNiAqL1xuICAgICAgICAgICAgICAgIC8vIGludGVnZXIgd3JhcCBhcm91bmRcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVmVyc2lvbiA9ICh0aGlzLmNoaWxkcmVuVmVyc2lvbiArIDEpICYgMHhGRkZGRkZGRjtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkSW5kZXhDYWNoZWRVcFRvID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENhY2hlZEluZGV4KHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyAoYXNzdW1lcyBwYXJlbnROb2RlIGlzIGFjdHVhbGx5IHRoZSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5kZXhWZXJzaW9uICE9PSBwYXJlbnROb2RlLmNoaWxkcmVuVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleFZlcnNpb24gPSBOYU47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZWRJbmRleCBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRJbmRleDsgLy8gLTEgaWYgbm90IGNhY2hlZFxuICAgICAgICB9XG5cbiAgICAgICAgc2V0Q2FjaGVkSW5kZXgocGFyZW50Tm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyAoYXNzdW1lcyBwYXJlbnROb2RlIGlzIGFjdHVhbGx5IHRoZSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleFZlcnNpb24gPSBwYXJlbnROb2RlLmNoaWxkcmVuVmVyc2lvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlN5bWJvbFRyZWVOb2RlIiwiY29uc3RydWN0b3IiLCJwYXJlbnQiLCJwcmV2aW91c1NpYmxpbmciLCJuZXh0U2libGluZyIsImZpcnN0Q2hpbGQiLCJsYXN0Q2hpbGQiLCJjaGlsZHJlblZlcnNpb24iLCJjaGlsZEluZGV4Q2FjaGVkVXBUbyIsImNhY2hlZEluZGV4IiwiY2FjaGVkSW5kZXhWZXJzaW9uIiwiTmFOIiwiaXNBdHRhY2hlZCIsIkJvb2xlYW4iLCJoYXNDaGlsZHJlbiIsImNoaWxkcmVuQ2hhbmdlZCIsImdldENhY2hlZEluZGV4IiwicGFyZW50Tm9kZSIsInNldENhY2hlZEluZGV4IiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-tree/lib/TreeIterator.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nconst TREE = Symbol();\nconst ROOT = Symbol();\nconst NEXT = Symbol();\nconst ITERATE_FUNC = Symbol();\nclass TreeIterator {\n    constructor(tree, root, firstResult, iterateFunction){\n        this[TREE] = tree;\n        this[ROOT] = root;\n        this[NEXT] = firstResult;\n        this[ITERATE_FUNC] = iterateFunction;\n    }\n    next() {\n        const tree = this[TREE];\n        const iterateFunc = this[ITERATE_FUNC];\n        const root = this[ROOT];\n        if (!this[NEXT]) {\n            return {\n                done: true,\n                value: root\n            };\n        }\n        const value = this[NEXT];\n        if (iterateFunc === 1) {\n            this[NEXT] = tree._node(value).previousSibling;\n        } else if (iterateFunc === 2) {\n            this[NEXT] = tree._node(value).nextSibling;\n        } else if (iterateFunc === 3) {\n            this[NEXT] = tree._node(value).parent;\n        } else if (iterateFunc === 4) {\n            this[NEXT] = tree.preceding(value, {\n                root: root\n            });\n        } else /* if (iterateFunc === 5)*/ {\n            this[NEXT] = tree.following(value, {\n                root: root\n            });\n        }\n        return {\n            done: false,\n            value: value\n        };\n    }\n}\nObject.defineProperty(TreeIterator.prototype, Symbol.iterator, {\n    value: function() {\n        return this;\n    },\n    writable: false\n});\nTreeIterator.PREV = 1;\nTreeIterator.NEXT = 2;\nTreeIterator.PARENT = 3;\nTreeIterator.PRECEDING = 4;\nTreeIterator.FOLLOWING = 5;\nObject.freeze(TreeIterator);\nObject.freeze(TreeIterator.prototype);\nmodule.exports = TreeIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVJdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DO0FBQ2IsTUFBTUMsT0FBT0Q7QUFDYixNQUFNRSxPQUFPRjtBQUNiLE1BQU1HLGVBQWVIO0FBRXJCLE1BQU1JO0lBQ0VDLFlBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLGVBQWUsQ0FBRTtRQUM5QyxJQUFJLENBQUNWLEtBQUssR0FBR087UUFDYixJQUFJLENBQUNMLEtBQUssR0FBR007UUFDYixJQUFJLENBQUNMLEtBQUssR0FBR007UUFDYixJQUFJLENBQUNMLGFBQWEsR0FBR007SUFDN0I7SUFFQUMsT0FBTztRQUNDLE1BQU1KLE9BQU8sSUFBSSxDQUFDUCxLQUFLO1FBQ3ZCLE1BQU1ZLGNBQWMsSUFBSSxDQUFDUixhQUFhO1FBQ3RDLE1BQU1JLE9BQU8sSUFBSSxDQUFDTixLQUFLO1FBRXZCLElBQUksQ0FBQyxJQUFJLENBQUNDLEtBQUssRUFBRTtZQUNULE9BQU87Z0JBQ0NVLE1BQU07Z0JBQ05DLE9BQU9OO1lBQ2Y7UUFDUjtRQUVBLE1BQU1NLFFBQVEsSUFBSSxDQUFDWCxLQUFLO1FBRXhCLElBQUlTLGdCQUFnQixHQUFHO1lBQ2YsSUFBSSxDQUFDVCxLQUFLLEdBQUdJLEtBQUtRLEtBQUssQ0FBQ0QsT0FBT0UsZUFBZTtRQUN0RCxPQUNLLElBQUlKLGdCQUFnQixHQUFHO1lBQ3BCLElBQUksQ0FBQ1QsS0FBSyxHQUFHSSxLQUFLUSxLQUFLLENBQUNELE9BQU9HLFdBQVc7UUFDbEQsT0FDSyxJQUFJTCxnQkFBZ0IsR0FBRztZQUNwQixJQUFJLENBQUNULEtBQUssR0FBR0ksS0FBS1EsS0FBSyxDQUFDRCxPQUFPSSxNQUFNO1FBQzdDLE9BQ0ssSUFBSU4sZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDVCxLQUFLLEdBQUdJLEtBQUtZLFNBQVMsQ0FBQ0wsT0FBTztnQkFBQ04sTUFBTUE7WUFBSTtRQUN0RCxPQUNLLHlCQUF5QixHQUFHO1lBQ3pCLElBQUksQ0FBQ0wsS0FBSyxHQUFHSSxLQUFLYSxTQUFTLENBQUNOLE9BQU87Z0JBQUNOLE1BQU1BO1lBQUk7UUFDdEQ7UUFFQSxPQUFPO1lBQ0NLLE1BQU07WUFDTkMsT0FBT0E7UUFDZjtJQUNSO0FBQ1I7QUFFQU8sT0FBT0MsY0FBYyxDQUFDakIsYUFBYWtCLFNBQVMsRUFBRXRCLE9BQU91QixRQUFRLEVBQUU7SUFDdkRWLE9BQU87UUFDQyxPQUFPLElBQUk7SUFDbkI7SUFDQVcsVUFBVTtBQUNsQjtBQUVBcEIsYUFBYXFCLElBQUksR0FBRztBQUNwQnJCLGFBQWFGLElBQUksR0FBRztBQUNwQkUsYUFBYXNCLE1BQU0sR0FBRztBQUN0QnRCLGFBQWF1QixTQUFTLEdBQUc7QUFDekJ2QixhQUFhd0IsU0FBUyxHQUFHO0FBRXpCUixPQUFPUyxNQUFNLENBQUN6QjtBQUNkZ0IsT0FBT1MsTUFBTSxDQUFDekIsYUFBYWtCLFNBQVM7QUFFcENRLE9BQU9DLE9BQU8sR0FBRzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlnbWEvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVJdGVyYXRvci5qcz84ZmRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVFJFRSA9IFN5bWJvbCgpO1xuY29uc3QgUk9PVCA9IFN5bWJvbCgpO1xuY29uc3QgTkVYVCA9IFN5bWJvbCgpO1xuY29uc3QgSVRFUkFURV9GVU5DID0gU3ltYm9sKCk7XG5cbmNsYXNzIFRyZWVJdGVyYXRvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRyZWUsIHJvb3QsIGZpcnN0UmVzdWx0LCBpdGVyYXRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzW1RSRUVdID0gdHJlZTtcbiAgICAgICAgICAgICAgICB0aGlzW1JPT1RdID0gcm9vdDtcbiAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gZmlyc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhpc1tJVEVSQVRFX0ZVTkNdID0gaXRlcmF0ZUZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlID0gdGhpc1tUUkVFXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRlRnVuYyA9IHRoaXNbSVRFUkFURV9GVU5DXTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290ID0gdGhpc1tST09UXTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpc1tORVhUXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tORVhUXTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlRnVuYyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IHRyZWUuX25vZGUodmFsdWUpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlcmF0ZUZ1bmMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSB0cmVlLl9ub2RlKHZhbHVlKS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlcmF0ZUZ1bmMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSB0cmVlLl9ub2RlKHZhbHVlKS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXJhdGVGdW5jID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gdHJlZS5wcmVjZWRpbmcodmFsdWUsIHtyb290OiByb290fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgLyogaWYgKGl0ZXJhdGVGdW5jID09PSA1KSovIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSB0cmVlLmZvbGxvd2luZyh2YWx1ZSwge3Jvb3Q6IHJvb3R9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZUl0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxufSk7XG5cblRyZWVJdGVyYXRvci5QUkVWID0gMTtcblRyZWVJdGVyYXRvci5ORVhUID0gMjtcblRyZWVJdGVyYXRvci5QQVJFTlQgPSAzO1xuVHJlZUl0ZXJhdG9yLlBSRUNFRElORyA9IDQ7XG5UcmVlSXRlcmF0b3IuRk9MTE9XSU5HID0gNTtcblxuT2JqZWN0LmZyZWV6ZShUcmVlSXRlcmF0b3IpO1xuT2JqZWN0LmZyZWV6ZShUcmVlSXRlcmF0b3IucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlSXRlcmF0b3I7XG4iXSwibmFtZXMiOlsiVFJFRSIsIlN5bWJvbCIsIlJPT1QiLCJORVhUIiwiSVRFUkFURV9GVU5DIiwiVHJlZUl0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJ0cmVlIiwicm9vdCIsImZpcnN0UmVzdWx0IiwiaXRlcmF0ZUZ1bmN0aW9uIiwibmV4dCIsIml0ZXJhdGVGdW5jIiwiZG9uZSIsInZhbHVlIiwiX25vZGUiLCJwcmV2aW91c1NpYmxpbmciLCJuZXh0U2libGluZyIsInBhcmVudCIsInByZWNlZGluZyIsImZvbGxvd2luZyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiaXRlcmF0b3IiLCJ3cml0YWJsZSIsIlBSRVYiLCJQQVJFTlQiLCJQUkVDRURJTkciLCJGT0xMT1dJTkciLCJmcmVlemUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/TreePosition.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-tree/lib/TreePosition.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n/* eslint-disable sort-keys */ module.exports = Object.freeze({\n    // same as DOM DOCUMENT_POSITION_\n    DISCONNECTED: 1,\n    PRECEDING: 2,\n    FOLLOWING: 4,\n    CONTAINS: 8,\n    CONTAINED_BY: 16\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVQb3NpdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDRCQUE0QixHQUM1QkEsT0FBT0MsT0FBTyxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFDdkIsaUNBQWlDO0lBQ2pDQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWdtYS8uL25vZGVfbW9kdWxlcy9zeW1ib2wtdHJlZS9saWIvVHJlZVBvc2l0aW9uLmpzP2JjOTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBzb3J0LWtleXMgKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC8vIHNhbWUgYXMgRE9NIERPQ1VNRU5UX1BPU0lUSU9OX1xuICAgICAgICBESVNDT05ORUNURUQ6IDEsXG4gICAgICAgIFBSRUNFRElORzogMixcbiAgICAgICAgRk9MTE9XSU5HOiA0LFxuICAgICAgICBDT05UQUlOUzogOCxcbiAgICAgICAgQ09OVEFJTkVEX0JZOiAxNixcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJmcmVlemUiLCJESVNDT05ORUNURUQiLCJQUkVDRURJTkciLCJGT0xMT1dJTkciLCJDT05UQUlOUyIsIkNPTlRBSU5FRF9CWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/TreePosition.js\n");

/***/ })

};
;