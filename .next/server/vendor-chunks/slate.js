"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   above: () => (/* binding */ above),\n/* harmony export */   addMark: () => (/* binding */ addMark),\n/* harmony export */   after: () => (/* binding */ after),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   before: () => (/* binding */ before),\n/* harmony export */   collapse: () => (/* binding */ collapse),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   deleteBackward: () => (/* binding */ deleteBackward),\n/* harmony export */   deleteForward: () => (/* binding */ deleteForward),\n/* harmony export */   deleteFragment: () => (/* binding */ deleteFragment),\n/* harmony export */   deleteText: () => (/* binding */ deleteText),\n/* harmony export */   deselect: () => (/* binding */ deselect),\n/* harmony export */   edges: () => (/* binding */ edges),\n/* harmony export */   elementReadOnly: () => (/* binding */ elementReadOnly),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getDirtyPaths: () => (/* binding */ getDirtyPaths),\n/* harmony export */   getFragment: () => (/* binding */ getFragment),\n/* harmony export */   getVoid: () => (/* binding */ getVoid),\n/* harmony export */   hasBlocks: () => (/* binding */ hasBlocks),\n/* harmony export */   hasInlines: () => (/* binding */ hasInlines),\n/* harmony export */   hasPath: () => (/* binding */ hasPath),\n/* harmony export */   hasTexts: () => (/* binding */ hasTexts),\n/* harmony export */   insertBreak: () => (/* binding */ insertBreak),\n/* harmony export */   insertFragment: () => (/* binding */ insertFragment),\n/* harmony export */   insertNode: () => (/* binding */ insertNode),\n/* harmony export */   insertNodes: () => (/* binding */ insertNodes),\n/* harmony export */   insertSoftBreak: () => (/* binding */ insertSoftBreak),\n/* harmony export */   insertText: () => (/* binding */ insertText),\n/* harmony export */   isBlock: () => (/* binding */ isBlock),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isEditor: () => (/* binding */ isEditor),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEnd: () => (/* binding */ isEnd),\n/* harmony export */   isNormalizing: () => (/* binding */ isNormalizing),\n/* harmony export */   isStart: () => (/* binding */ isStart),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   leaf: () => (/* binding */ leaf),\n/* harmony export */   levels: () => (/* binding */ levels),\n/* harmony export */   liftNodes: () => (/* binding */ liftNodes),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   mergeNodes: () => (/* binding */ mergeNodes),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   moveNodes: () => (/* binding */ moveNodes),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   node: () => (/* binding */ node),\n/* harmony export */   nodes: () => (/* binding */ nodes),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeNode: () => (/* binding */ normalizeNode),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   path: () => (/* binding */ path),\n/* harmony export */   pathRef: () => (/* binding */ pathRef),\n/* harmony export */   pathRefs: () => (/* binding */ pathRefs),\n/* harmony export */   point: () => (/* binding */ point),\n/* harmony export */   pointRef: () => (/* binding */ pointRef),\n/* harmony export */   pointRefs: () => (/* binding */ pointRefs),\n/* harmony export */   positions: () => (/* binding */ positions),\n/* harmony export */   previous: () => (/* binding */ previous),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rangeRef: () => (/* binding */ rangeRef),\n/* harmony export */   rangeRefs: () => (/* binding */ rangeRefs),\n/* harmony export */   removeMark: () => (/* binding */ removeMark),\n/* harmony export */   removeNodes: () => (/* binding */ removeNodes),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   setNodes: () => (/* binding */ setNodes),\n/* harmony export */   setNormalizing: () => (/* binding */ setNormalizing),\n/* harmony export */   setPoint: () => (/* binding */ setPoint),\n/* harmony export */   setSelection: () => (/* binding */ setSelection),\n/* harmony export */   shouldNormalize: () => (/* binding */ shouldNormalize),\n/* harmony export */   splitNodes: () => (/* binding */ splitNodes),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   unhangRange: () => (/* binding */ unhangRange),\n/* harmony export */   unsetNodes: () => (/* binding */ unsetNodes),\n/* harmony export */   unwrapNodes: () => (/* binding */ unwrapNodes),\n/* harmony export */   withoutNormalizing: () => (/* binding */ withoutNormalizing),\n/* harmony export */   wrapNodes: () => (/* binding */ wrapNodes)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n\n\nvar PathRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar PointRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\nvar RangeRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    ancestors (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    common (path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    compare (path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    endsAfter (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    endsAt (path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    endsBefore (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    equals (path, another) {\n        return path.length === another.length && path.every((n, i)=>n === another[i]);\n    },\n    hasPrevious (path) {\n        return path[path.length - 1] > 0;\n    },\n    isAfter (path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    isAncestor (path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    isBefore (path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    isChild (path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    isCommon (path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    isDescendant (path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    isParent (path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    isPath (value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    isSibling (path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    levels (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    next (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    operationCanTransformPath (operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    parent (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    previous (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    relative (path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    transform (path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null; // PERF: use destructing instead of immer\n        var p = [\n            ...path\n        ];\n        var { affinity = \"forward\" } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var { path: op } = operation;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _op } = operation;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _op2, position } = operation;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _op3, position: _position } = operation;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _op4, newPath: onp } = operation; // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys$e(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$e(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$e(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$e(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar applyToDraft = (editor, selection, op)=>{\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var { path, node } = op;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    for (var [point, key] of Range.points(selection)){\n                        selection[key] = Point.transform(point, op);\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var { path: _path, offset, text } = op;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    for (var [_point, _key] of Range.points(selection)){\n                        selection[_key] = Point.transform(_point, op);\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    prev.children.push(..._node2.children);\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    for (var [_point2, _key2] of Range.points(selection)){\n                        selection[_key2] = Point.transform(_point2, op);\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    for (var [_point3, _key3] of Range.points(selection)){\n                        selection[_key3] = Point.transform(_point3, op);\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    for (var [_point4, _key4] of Range.points(selection)){\n                        var result = Point.transform(_point4, op);\n                        if (selection != null && result != null) {\n                            selection[_key4] = result;\n                        } else {\n                            var _prev = void 0;\n                            var next = void 0;\n                            for (var [n, p] of Node.texts(editor)){\n                                if (Path.compare(p, _path4) === -1) {\n                                    _prev = [\n                                        n,\n                                        p\n                                    ];\n                                } else {\n                                    next = [\n                                        n,\n                                        p\n                                    ];\n                                    break;\n                                }\n                            }\n                            var preferNext = false;\n                            if (_prev && next) {\n                                if (Path.equals(next[1], _path4)) {\n                                    preferNext = !Path.hasPrevious(next[1]);\n                                } else {\n                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                }\n                            }\n                            if (_prev && !preferNext) {\n                                _point4.path = _prev[1];\n                                _point4.offset = _prev[0].text.length;\n                            } else if (next) {\n                                _point4.path = next[1];\n                                _point4.offset = 0;\n                            } else {\n                                selection = null;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var { path: _path5, offset: _offset, text: _text } = op;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    for (var [_point5, _key5] of Range.points(selection)){\n                        selection[_key5] = Point.transform(_point5, op);\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var { path: _path6, properties, newProperties } = op;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                } // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var { newProperties: _newProperties } = op;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$e({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var { path: _path7, position, properties: _properties } = op;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    for (var [_point6, _key9] of Range.points(selection)){\n                        selection[_key9] = Point.transform(_point6, op);\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n}; // eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    transform (editor, op) {\n        editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n        var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n            if (selection) {\n                editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n    insertNodes (editor, nodes, options) {\n        editor.insertNodes(nodes, options);\n    },\n    liftNodes (editor, options) {\n        editor.liftNodes(options);\n    },\n    mergeNodes (editor, options) {\n        editor.mergeNodes(options);\n    },\n    moveNodes (editor, options) {\n        editor.moveNodes(options);\n    },\n    removeNodes (editor, options) {\n        editor.removeNodes(options);\n    },\n    setNodes (editor, props, options) {\n        editor.setNodes(props, options);\n    },\n    splitNodes (editor, options) {\n        editor.splitNodes(options);\n    },\n    unsetNodes (editor, props, options) {\n        editor.unsetNodes(props, options);\n    },\n    unwrapNodes (editor, options) {\n        editor.unwrapNodes(options);\n    },\n    wrapNodes (editor, element, options) {\n        editor.wrapNodes(element, options);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n    collapse (editor, options) {\n        editor.collapse(options);\n    },\n    deselect (editor) {\n        editor.deselect();\n    },\n    move (editor, options) {\n        editor.move(options);\n    },\n    select (editor, target) {\n        editor.select(target);\n    },\n    setPoint (editor, props, options) {\n        editor.setPoint(props, options);\n    },\n    setSelection (editor, props) {\n        editor.setSelection(props);\n    }\n};\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */ var isDeepEqual = (node, another)=>{\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar _excluded$4 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$d(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$d(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$d(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$d(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Range = {\n    edges (range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var { anchor, focus } = range;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    end (range) {\n        var [, end] = Range.edges(range);\n        return end;\n    },\n    equals (range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    includes (range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var [rs, re] = Range.edges(range);\n            var [ts, te] = Range.edges(target);\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var [start, end] = Range.edges(range);\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    intersection (range, another) {\n        var rest = _objectWithoutProperties(range, _excluded$4);\n        var [s1, e1] = Range.edges(range);\n        var [s2, e2] = Range.edges(another);\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$d({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    isBackward (range) {\n        var { anchor, focus } = range;\n        return Point.isAfter(anchor, focus);\n    },\n    isCollapsed (range) {\n        var { anchor, focus } = range;\n        return Point.equals(anchor, focus);\n    },\n    isExpanded (range) {\n        return !Range.isCollapsed(range);\n    },\n    isForward (range) {\n        return !Range.isBackward(range);\n    },\n    isRange (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    *points (range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    start (range) {\n        var [start] = Range.edges(range);\n        return start;\n    },\n    transform (range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, (r)=>{\n            if (r === null) {\n                return null;\n            }\n            var { affinity = \"inward\" } = options;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\n/**\r\n * Shared the function with isElementType utility\r\n */ var isElement = (value)=>{\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\nvar Element = {\n    isAncestor (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n    },\n    isElement,\n    isElementList (value) {\n        return Array.isArray(value) && value.every((val)=>Element.isElement(val));\n    },\n    isElementProps (props) {\n        return props.children !== undefined;\n    },\n    isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    matches (element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$3 = [\n    \"text\"\n];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Node = {\n    ancestor (root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    *ancestors (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.ancestors(path, options)){\n            var n = Node.ancestor(root, p);\n            var entry = [\n                n,\n                p\n            ];\n            yield entry;\n        }\n    },\n    child (root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    *children (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { reverse = false } = options;\n        var ancestor = Node.ancestor(root, path);\n        var { children } = ancestor;\n        var index = reverse ? children.length - 1 : 0;\n        while(reverse ? index >= 0 : index < children.length){\n            var child = Node.child(ancestor, index);\n            var childPath = path.concat(index);\n            yield [\n                child,\n                childPath\n            ];\n            index = reverse ? index - 1 : index + 1;\n        }\n    },\n    common (root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    descendant (root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    *descendants (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (path.length !== 0) {\n                // NOTE: we have to coerce here because checking the path's length does\n                // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    *elements (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Element.isElement(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    },\n    extractProps (node) {\n        if (Element.isAncestor(node)) {\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            var properties = _objectWithoutProperties(node, _excluded2$3);\n            return properties;\n        }\n    },\n    first (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    fragment (root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n            children: root.children\n        }, (r)=>{\n            var [start, end] = Range.edges(range);\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: (_ref)=>{\n                    var [, path] = _ref;\n                    return !Range.includes(range, path);\n                }\n            });\n            for (var [, path] of nodeEntries){\n                if (!Range.includes(range, path)) {\n                    var parent = Node.parent(r, path);\n                    var index = path[path.length - 1];\n                    parent.children.splice(index, 1);\n                }\n                if (Path.equals(path, end.path)) {\n                    var leaf = Node.leaf(r, path);\n                    leaf.text = leaf.text.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    var _leaf = Node.leaf(r, path);\n                    _leaf.text = _leaf.text.slice(start.offset);\n                }\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    get (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    has (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    isNode (value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    isNodeList (value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every((val)=>Node.isNode(val));\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    last (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    leaf (root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    *levels (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        for (var p of Path.levels(path, options)){\n            var n = Node.get(root, p);\n            yield [\n                n,\n                p\n            ];\n        }\n    },\n    matches (node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    *nodes (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { pass, reverse = false } = options;\n        var { from = [], to } = options;\n        var visited = new Set();\n        var p = [];\n        var n = root;\n        while(true){\n            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                break;\n            }\n            if (!visited.has(n)) {\n                yield [\n                    n,\n                    p\n                ];\n            } // If we're allowed to go downward and we haven't descended yet, do.\n            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                n,\n                p\n            ]) === false)) {\n                visited.add(n);\n                var nextIndex = reverse ? n.children.length - 1 : 0;\n                if (Path.isAncestor(p, from)) {\n                    nextIndex = from[p.length];\n                }\n                p = p.concat(nextIndex);\n                n = Node.get(root, p);\n                continue;\n            } // If we're at the root and we can't go down, we're done.\n            if (p.length === 0) {\n                break;\n            } // If we're going forward...\n            if (!reverse) {\n                var newPath = Path.next(p);\n                if (Node.has(root, newPath)) {\n                    p = newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n            } // If we're going backward...\n            if (reverse && p[p.length - 1] !== 0) {\n                var _newPath = Path.previous(p);\n                p = _newPath;\n                n = Node.get(root, p);\n                continue;\n            } // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n        }\n    },\n    parent (root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    string (node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    *texts (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        for (var [node, path] of Node.nodes(root, options)){\n            if (Text.isText(node)) {\n                yield [\n                    node,\n                    path\n                ];\n            }\n        }\n    }\n};\nfunction ownKeys$c(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$c(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$c(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$c(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Operation = {\n    isNodeOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    isOperation (value) {\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            default:\n                return false;\n        }\n    },\n    isOperationList (value) {\n        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));\n    },\n    isSelectionOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    isTextOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    inverse (op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var { newPath, path } = op; // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    } // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    } // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var { properties, newProperties } = op;\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var { properties: _properties, newProperties: _newProperties } = op;\n                    if (_properties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = (value)=>{\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n    if (cachedIsEditor !== undefined) {\n        return cachedIsEditor;\n    }\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n        return false;\n    }\n    var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isElementReadOnly === \"function\" && typeof value.isInline === \"function\" && typeof value.isSelectable === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n};\nvar Editor = {\n    above (editor, options) {\n        return editor.above(options);\n    },\n    addMark (editor, key, value) {\n        editor.addMark(key, value);\n    },\n    after (editor, at, options) {\n        return editor.after(at, options);\n    },\n    before (editor, at, options) {\n        return editor.before(at, options);\n    },\n    deleteBackward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteBackward(unit);\n    },\n    deleteForward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteForward(unit);\n    },\n    deleteFragment (editor, options) {\n        editor.deleteFragment(options);\n    },\n    edges (editor, at) {\n        return editor.edges(at);\n    },\n    elementReadOnly (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return editor.elementReadOnly(options);\n    },\n    end (editor, at) {\n        return editor.end(at);\n    },\n    first (editor, at) {\n        return editor.first(at);\n    },\n    fragment (editor, at) {\n        return editor.fragment(at);\n    },\n    hasBlocks (editor, element) {\n        return editor.hasBlocks(element);\n    },\n    hasInlines (editor, element) {\n        return editor.hasInlines(element);\n    },\n    hasPath (editor, path) {\n        return editor.hasPath(path);\n    },\n    hasTexts (editor, element) {\n        return editor.hasTexts(element);\n    },\n    insertBreak (editor) {\n        editor.insertBreak();\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertNode (editor, node) {\n        editor.insertNode(node);\n    },\n    insertSoftBreak (editor) {\n        editor.insertSoftBreak();\n    },\n    insertText (editor, text) {\n        editor.insertText(text);\n    },\n    isBlock (editor, value) {\n        return editor.isBlock(value);\n    },\n    isEdge (editor, point, at) {\n        return editor.isEdge(point, at);\n    },\n    isEditor (value) {\n        return isEditor(value);\n    },\n    isElementReadOnly (editor, element) {\n        return editor.isElementReadOnly(element);\n    },\n    isEmpty (editor, element) {\n        return editor.isEmpty(element);\n    },\n    isEnd (editor, point, at) {\n        return editor.isEnd(point, at);\n    },\n    isInline (editor, value) {\n        return editor.isInline(value);\n    },\n    isNormalizing (editor) {\n        return editor.isNormalizing();\n    },\n    isSelectable (editor, value) {\n        return editor.isSelectable(value);\n    },\n    isStart (editor, point, at) {\n        return editor.isStart(point, at);\n    },\n    isVoid (editor, value) {\n        return editor.isVoid(value);\n    },\n    last (editor, at) {\n        return editor.last(at);\n    },\n    leaf (editor, at, options) {\n        return editor.leaf(at, options);\n    },\n    levels (editor, options) {\n        return editor.levels(options);\n    },\n    marks (editor) {\n        return editor.getMarks();\n    },\n    next (editor, options) {\n        return editor.next(options);\n    },\n    node (editor, at, options) {\n        return editor.node(at, options);\n    },\n    nodes (editor, options) {\n        return editor.nodes(options);\n    },\n    normalize (editor, options) {\n        editor.normalize(options);\n    },\n    parent (editor, at, options) {\n        return editor.parent(at, options);\n    },\n    path (editor, at, options) {\n        return editor.path(at, options);\n    },\n    pathRef (editor, path, options) {\n        return editor.pathRef(path, options);\n    },\n    pathRefs (editor) {\n        return editor.pathRefs();\n    },\n    point (editor, at, options) {\n        return editor.point(at, options);\n    },\n    pointRef (editor, point, options) {\n        return editor.pointRef(point, options);\n    },\n    pointRefs (editor) {\n        return editor.pointRefs();\n    },\n    positions (editor, options) {\n        return editor.positions(options);\n    },\n    previous (editor, options) {\n        return editor.previous(options);\n    },\n    range (editor, at, to) {\n        return editor.range(at, to);\n    },\n    rangeRef (editor, range, options) {\n        return editor.rangeRef(range, options);\n    },\n    rangeRefs (editor) {\n        return editor.rangeRefs();\n    },\n    removeMark (editor, key) {\n        editor.removeMark(key);\n    },\n    setNormalizing (editor, isNormalizing) {\n        editor.setNormalizing(isNormalizing);\n    },\n    start (editor, at) {\n        return editor.start(at);\n    },\n    string (editor, at, options) {\n        return editor.string(at, options);\n    },\n    unhangRange (editor, range, options) {\n        return editor.unhangRange(range, options);\n    },\n    void (editor, options) {\n        return editor.void(options);\n    },\n    withoutNormalizing (editor, fn) {\n        editor.withoutNormalizing(fn);\n    }\n};\nvar Location = {\n    isLocation (value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n}; // eslint-disable-next-line no-redeclare\nvar Span = {\n    isSpan (value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nfunction ownKeys$b(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$b(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$b(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$b(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Point = {\n    compare (point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    isAfter (point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    isBefore (point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    equals (point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    isPoint (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    transform (point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, (p)=>{\n            if (p === null) {\n                return null;\n            }\n            var { affinity = \"forward\" } = options;\n            var { path, offset } = p;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber (scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify (value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\nvar _excluded$2 = [\n    \"text\"\n], _excluded2$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$a(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$a(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$a(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$a(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Text = {\n    equals (text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { loose = false } = options;\n        function omitText(obj) {\n            var rest = _objectWithoutProperties(obj, _excluded$2);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    isText (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === \"string\";\n    },\n    isTextList (value) {\n        return Array.isArray(value) && value.every((val)=>Text.isText(val));\n    },\n    isTextProps (props) {\n        return props.text !== undefined;\n    },\n    matches (text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    decorations (node, decorations) {\n        var leaves = [\n            _objectSpread$a({}, node)\n        ];\n        for (var dec of decorations){\n            var rest = _objectWithoutProperties(dec, _excluded2$2);\n            var [start, end] = Range.edges(dec);\n            var next = [];\n            var leafEnd = 0;\n            var decorationStart = start.offset;\n            var decorationEnd = end.offset;\n            for (var leaf of leaves){\n                var { length } = leaf.text;\n                var leafStart = leafEnd;\n                leafEnd += length; // If the range encompasses the entire leaf, add the range.\n                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                    Object.assign(leaf, rest);\n                    next.push(leaf);\n                    continue;\n                } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                    next.push(leaf);\n                    continue;\n                } // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the range to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n                if (decorationEnd < leafEnd) {\n                    var off = decorationEnd - leafStart;\n                    after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(off)\n                    });\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(0, off)\n                    });\n                }\n                if (decorationStart > leafStart) {\n                    var _off = decorationStart - leafStart;\n                    before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(0, _off)\n                    });\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(_off)\n                    });\n                }\n                Object.assign(middle, rest);\n                if (before) {\n                    next.push(before);\n                }\n                next.push(middle);\n                if (after) {\n                    next.push(after);\n                }\n            }\n            leaves = next;\n        }\n        return leaves;\n    }\n};\n/**\r\n * Get the default location to insert content into the editor.\r\n * By default, use the selection as the target location. But if there is\r\n * no selection, insert at the end of the document since that is such a\r\n * common use case when inserting from a non-selected state.\r\n */ var getDefaultInsertLocation = (editor)=>{\n    if (editor.selection) {\n        return editor.selection;\n    } else if (editor.children.length > 0) {\n        return Editor.end(editor, []);\n    } else {\n        return [\n            0\n        ];\n    }\n};\nvar matchPath = (editor, path)=>{\n    var [node] = Editor.node(editor, path);\n    return (n)=>n === node;\n};\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0; // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    for (var char of codepoints){\n        var code = char.codePointAt(0);\n        if (!code) break;\n        var type = getCodepointType(char, code);\n        [left, right] = isLTR ? [\n            right,\n            type\n        ] : [\n            type,\n            left\n        ];\n        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n            if (isLTR) {\n                gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n            } else {\n                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n            }\n            if (!gb11) break;\n        }\n        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n            if (gb12Or13 !== null) {\n                gb12Or13 = !gb12Or13;\n            } else {\n                if (isLTR) {\n                    gb12Or13 = true;\n                } else {\n                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                }\n            }\n            if (!gb12Or13) break;\n        }\n        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n            break;\n        }\n        distance += char.length;\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n        if (isWordCharacter(char, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */ var splitByCharacterDistance = (str, dist, isRTL)=>{\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */ var isWordCharacter = function isWordCharacter(char, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(char)) {\n        return false;\n    } // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(char)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(char)) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isHighSurrogate = (charCode)=>{\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isLowSurrogate = (charCode)=>{\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code)=>{\n    var type = CodepointType.Any;\n    if (char.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (char.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (char.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (char.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (char.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (char.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (char.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (char.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (char.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str)=>{\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str)=>{\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\nvar TextTransforms = {\n    delete (editor, options) {\n        editor.delete(options);\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertText (editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { voids = false } = options;\n            var { at = getDefaultInsertLocation(editor) } = options;\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at,\n                        voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            }) || Editor.elementReadOnly(editor, {\n                at\n            })) {\n                return;\n            }\n            var { path, offset } = at;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path,\n                offset,\n                text\n            });\n        });\n    }\n};\nfunction ownKeys$9(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$9(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$9(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$9(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\nvar apply = (editor, op)=>{\n    for (var ref of Editor.pathRefs(editor)){\n        PathRef.transform(ref, op);\n    }\n    for (var _ref of Editor.pointRefs(editor)){\n        PointRef.transform(_ref, op);\n    }\n    for (var _ref2 of Editor.rangeRefs(editor)){\n        RangeRef.transform(_ref2, op);\n    }\n    var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n    var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n    var dirtyPaths;\n    var dirtyPathKeys;\n    var add = (path)=>{\n        if (path) {\n            var key = path.join(\",\");\n            if (!dirtyPathKeys.has(key)) {\n                dirtyPathKeys.add(key);\n                dirtyPaths.push(path);\n            }\n        }\n    };\n    if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n        for (var path of oldDirtyPaths){\n            var newPath = Path.transform(path, op);\n            add(newPath);\n        }\n    } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n    }\n    var newDirtyPaths = editor.getDirtyPaths(op);\n    for (var _path of newDirtyPaths){\n        add(_path);\n    }\n    DIRTY_PATHS.set(editor, dirtyPaths);\n    DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n    Transforms.transform(editor, op);\n    editor.operations.push(op);\n    Editor.normalize(editor, {\n        operation: op\n    }); // Clear any formats applied to the cursor if the selection changes.\n    if (op.type === \"set_selection\") {\n        editor.marks = null;\n    }\n    if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(()=>{\n            FLUSHING.set(editor, false);\n            editor.onChange({\n                operation: op\n            });\n            editor.operations = [];\n        });\n    }\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */ var getDirtyPaths = (editor, op)=>{\n    switch(op.type){\n        case \"insert_text\":\n        case \"remove_text\":\n        case \"set_node\":\n            {\n                var { path } = op;\n                return Path.levels(path);\n            }\n        case \"insert_node\":\n            {\n                var { node, path: _path } = op;\n                var levels = Path.levels(_path);\n                var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref)=>{\n                    var [, p] = _ref;\n                    return _path.concat(p);\n                });\n                return [\n                    ...levels,\n                    ...descendants\n                ];\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var ancestors = Path.ancestors(_path2);\n                var previousPath = Path.previous(_path2);\n                return [\n                    ...ancestors,\n                    previousPath\n                ];\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.equals(_path3, newPath)) {\n                    return [];\n                }\n                var oldAncestors = [];\n                var newAncestors = [];\n                for (var ancestor of Path.ancestors(_path3)){\n                    var p = Path.transform(ancestor, op);\n                    oldAncestors.push(p);\n                }\n                for (var _ancestor of Path.ancestors(newPath)){\n                    var _p = Path.transform(_ancestor, op);\n                    newAncestors.push(_p);\n                }\n                var newParent = newAncestors[newAncestors.length - 1];\n                var newIndex = newPath[newPath.length - 1];\n                var resultPath = newParent.concat(newIndex);\n                return [\n                    ...oldAncestors,\n                    ...newAncestors,\n                    resultPath\n                ];\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _ancestors = Path.ancestors(_path4);\n                return [\n                    ..._ancestors\n                ];\n            }\n        case \"split_node\":\n            {\n                var { path: _path5 } = op;\n                var _levels = Path.levels(_path5);\n                var nextPath = Path.next(_path5);\n                return [\n                    ..._levels,\n                    nextPath\n                ];\n            }\n        default:\n            {\n                return [];\n            }\n    }\n};\nvar getFragment = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        return Node.fragment(editor, selection);\n    }\n    return [];\n};\nvar normalizeNode = (editor, entry)=>{\n    var [node, path] = entry; // There are no core normalizations for text nodes.\n    if (Text.isText(node)) {\n        return;\n    } // Ensure that block and inline nodes have at least one text child.\n    if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n            text: \"\"\n        };\n        Transforms.insertNodes(editor, child, {\n            at: path.concat(0),\n            voids: true\n        });\n        return;\n    } // Determine whether the node should have block or inline children.\n    var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n    // index that accounts for any added/removed nodes.\n    var n = 0;\n    for(var i = 0; i < node.children.length; i++, n++){\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = currentNode.children[n];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n            Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n            });\n            n--;\n        } else if (Element.isElement(_child)) {\n            // Ensure that inline nodes are surrounded by text nodes.\n            if (editor.isInline(_child)) {\n                if (prev == null || !Text.isText(prev)) {\n                    var newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, newChild, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n++;\n                } else if (isLast) {\n                    var _newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, _newChild, {\n                        at: path.concat(n + 1),\n                        voids: true\n                    });\n                    n++;\n                }\n            }\n        } else {\n            // Merge adjacent text nodes that are empty or match.\n            if (prev != null && Text.isText(prev)) {\n                if (Text.equals(_child, prev, {\n                    loose: true\n                })) {\n                    Transforms.mergeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (prev.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n - 1),\n                        voids: true\n                    });\n                    n--;\n                } else if (_child.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                }\n            }\n        }\n    }\n};\nvar shouldNormalize = (editor, _ref)=>{\n    var { iteration, initialDirtyPathsLength } = _ref;\n    var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n    if (iteration > maxIterations) {\n        throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n    }\n    return true;\n};\nvar above = function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { voids = false, mode = \"lowest\", at = editor.selection, match } = options;\n    if (!at) {\n        return;\n    }\n    var path = Editor.path(editor, at);\n    var reverse = mode === \"lowest\";\n    for (var [n, p] of Editor.levels(editor, {\n        at: path,\n        voids,\n        match,\n        reverse\n    })){\n        if (Text.isText(n)) continue;\n        if (Range.isRange(at)) {\n            if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                return [\n                    n,\n                    p\n                ];\n            }\n        } else {\n            if (!Path.equals(path, p)) {\n                return [\n                    n,\n                    p\n                ];\n            }\n        }\n    }\n};\nfunction ownKeys$8(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$8(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$8(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$8(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar addMark = (editor, key, value)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.setNodes(editor, {\n                [key]: value\n            }, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n                [key]: value\n            });\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$7(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$7(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$7(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar after = function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n        edge: \"end\"\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n        at: range\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nfunction ownKeys$6(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$6(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$6(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$6(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar before = function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n        edge: \"start\"\n    });\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n        at: range,\n        reverse: true\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nvar deleteBackward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit,\n            reverse: true\n        });\n    }\n};\nvar deleteForward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit\n        });\n    }\n};\nvar deleteFragment = function deleteFragment(editor) {\n    var { direction = \"forward\" } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n            reverse: direction === \"backward\"\n        });\n    }\n};\nvar edges = (editor, at)=>{\n    return [\n        Editor.start(editor, at),\n        Editor.end(editor, at)\n    ];\n};\nfunction ownKeys$5(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$5(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$5(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$5(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar elementReadOnly = function elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n    }));\n};\nvar end = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"end\"\n    });\n};\nvar first = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"start\"\n    });\n    return Editor.node(editor, path);\n};\nvar fragment = (editor, at)=>{\n    var range = Editor.range(editor, at);\n    return Node.fragment(editor, range);\n};\nfunction ownKeys$4(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$4(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$4(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar getVoid = function getVoid(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)\n    }));\n};\nvar hasBlocks = (editor, element)=>{\n    return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));\n};\nvar hasInlines = (editor, element)=>{\n    return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));\n};\nvar hasPath = (editor, path)=>{\n    return Node.has(editor, path);\n};\nvar hasTexts = (editor, element)=>{\n    return element.children.every((n)=>Text.isText(n));\n};\nvar insertBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nvar insertNode = (editor, node, options)=>{\n    Transforms.insertNodes(editor, node, options);\n};\nvar insertSoftBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar insertText = function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection, marks } = editor;\n    if (selection) {\n        if (marks) {\n            var node = _objectSpread$3({\n                text\n            }, marks);\n            Transforms.insertNodes(editor, node, {\n                at: options.at,\n                voids: options.voids\n            });\n        } else {\n            Transforms.insertText(editor, text, options);\n        }\n        editor.marks = null;\n    }\n};\nvar isBlock = (editor, value)=>{\n    return !editor.isInline(value);\n};\nvar isEdge = (editor, point, at)=>{\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\nvar isEmpty = (editor, element)=>{\n    var { children } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n};\nvar isEnd = (editor, point, at)=>{\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n};\nvar isNormalizing = (editor)=>{\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n};\nvar isStart = (editor, point, at)=>{\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n        return false;\n    }\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n};\nvar last = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"end\"\n    });\n    return Editor.node(editor, path);\n};\nvar leaf = function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction* levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { at = editor.selection, reverse = false, voids = false } = options;\n    var { match } = options;\n    if (match == null) {\n        match = ()=>true;\n    }\n    if (!at) {\n        return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    for (var [n, p] of Node.levels(editor, path)){\n        if (!match(n, p)) {\n            continue;\n        }\n        levels.push([\n            n,\n            p\n        ]);\n        if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n            break;\n        }\n    }\n    if (reverse) {\n        levels.reverse();\n    }\n    yield* levels;\n}\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"text\"\n];\nvar marks = function marks(editor) {\n    var { marks, selection } = editor;\n    if (!selection) {\n        return null;\n    }\n    if (marks) {\n        return marks;\n    }\n    if (Range.isExpanded(selection)) {\n        var [match] = Editor.nodes(editor, {\n            match: Text.isText\n        });\n        if (match) {\n            var [_node] = match;\n            var _rest = _objectWithoutProperties(_node, _excluded$1);\n            return _rest;\n        } else {\n            return {};\n        }\n    }\n    var { anchor } = selection;\n    var { path } = anchor;\n    var [node] = Editor.leaf(editor, path);\n    if (anchor.offset === 0) {\n        var prev = Editor.previous(editor, {\n            at: path,\n            match: Text.isText\n        });\n        var markedVoid = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n        });\n        if (!markedVoid) {\n            var block = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)\n            });\n            if (prev && block) {\n                var [prevNode, prevPath] = prev;\n                var [, blockPath] = block;\n                if (Path.isAncestor(blockPath, prevPath)) {\n                    node = prevNode;\n                }\n            }\n        }\n    }\n    var rest = _objectWithoutProperties(node, _excluded2$1);\n    return rest;\n};\nvar next = function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointAfterLocation = Editor.after(editor, at, {\n        voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [\n        pointAfterLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the next node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [next] = Editor.nodes(editor, {\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return next;\n};\nvar node = function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction* nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { at = editor.selection, mode = \"all\", universal = false, reverse = false, voids = false, ignoreNonSelectable = false } = options;\n    var { match } = options;\n    if (!match) {\n        match = ()=>true;\n    }\n    if (!at) {\n        return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n        from = at[0];\n        to = at[1];\n    } else {\n        var first = Editor.path(editor, at, {\n            edge: \"start\"\n        });\n        var last = Editor.path(editor, at, {\n            edge: \"end\"\n        });\n        from = reverse ? last : first;\n        to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n        reverse,\n        from,\n        to,\n        pass: (_ref)=>{\n            var [node] = _ref;\n            if (!Element.isElement(node)) return false;\n            if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n            if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n            return false;\n        }\n    });\n    var matches = [];\n    var hit;\n    for (var [node, path] of nodeEntries){\n        if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n            continue;\n        }\n        var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n        if (mode === \"highest\" && isLower) {\n            continue;\n        }\n        if (!match(node, path)) {\n            // If we've arrived at a leaf text node that is not lower than the last\n            // hit, then we've found a branch that doesn't include a match, which\n            // means the match is not universal.\n            if (universal && !isLower && Text.isText(node)) {\n                return;\n            } else {\n                continue;\n            }\n        } // If there's a match and it's lower than the last, update the hit.\n        if (mode === \"lowest\" && isLower) {\n            hit = [\n                node,\n                path\n            ];\n            continue;\n        } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n        var emit = mode === \"lowest\" ? hit : [\n            node,\n            path\n        ];\n        if (emit) {\n            if (universal) {\n                matches.push(emit);\n            } else {\n                yield emit;\n            }\n        }\n        hit = [\n            node,\n            path\n        ];\n    } // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === \"lowest\" && hit) {\n        if (universal) {\n            matches.push(hit);\n        } else {\n            yield hit;\n        }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n        yield* matches;\n    }\n}\nvar normalize = function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { force = false, operation } = options;\n    var getDirtyPaths = (editor)=>{\n        return DIRTY_PATHS.get(editor) || [];\n    };\n    var getDirtyPathKeys = (editor)=>{\n        return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n    var popDirtyPath = (editor)=>{\n        var path = getDirtyPaths(editor).pop();\n        var key = path.join(\",\");\n        getDirtyPathKeys(editor).delete(key);\n        return path;\n    };\n    if (!Editor.isNormalizing(editor)) {\n        return;\n    }\n    if (force) {\n        var allPaths = Array.from(Node.nodes(editor), (_ref)=>{\n            var [, p] = _ref;\n            return p;\n        });\n        var allPathKeys = new Set(allPaths.map((p)=>p.join(\",\")));\n        DIRTY_PATHS.set(editor, allPaths);\n        DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n    if (getDirtyPaths(editor).length === 0) {\n        return;\n    }\n    Editor.withoutNormalizing(editor, ()=>{\n        /*\r\n      Fix dirty elements with no children.\r\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n      Running an initial pass avoids the catch-22 race condition.\r\n    */ for (var dirtyPath of getDirtyPaths(editor)){\n            if (Node.has(editor, dirtyPath)) {\n                var entry = Editor.node(editor, dirtyPath);\n                var [node, _] = entry;\n                /*\r\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n          So there is some risk here.\r\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n          by definition adding children to an empty node can't cause other paths to change.\r\n        */ if (Element.isElement(node) && node.children.length === 0) {\n                    editor.normalizeNode(entry, {\n                        operation\n                    });\n                }\n            }\n        }\n        var dirtyPaths = getDirtyPaths(editor);\n        var initialDirtyPathsLength = dirtyPaths.length;\n        var iteration = 0;\n        while(dirtyPaths.length !== 0){\n            if (!editor.shouldNormalize({\n                dirtyPaths,\n                iteration,\n                initialDirtyPathsLength,\n                operation\n            })) {\n                return;\n            }\n            var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n            if (Node.has(editor, _dirtyPath)) {\n                var _entry = Editor.node(editor, _dirtyPath);\n                editor.normalizeNode(_entry, {\n                    operation\n                });\n            }\n            iteration++;\n            dirtyPaths = getDirtyPaths(editor);\n        }\n    });\n};\nvar parent = function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n};\nvar pathRef = function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: path,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pathRefs = Editor.pathRefs(editor);\n            pathRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pathRefs = (editor)=>{\n    var refs = PATH_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        PATH_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar path = function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { depth, edge } = options;\n    if (Path.isPath(at)) {\n        if (edge === \"start\") {\n            var [, firstPath] = Node.first(editor, at);\n            at = firstPath;\n        } else if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            at = lastPath;\n        }\n    }\n    if (Range.isRange(at)) {\n        if (edge === \"start\") {\n            at = Range.start(at);\n        } else if (edge === \"end\") {\n            at = Range.end(at);\n        } else {\n            at = Path.common(at.anchor.path, at.focus.path);\n        }\n    }\n    if (Point.isPoint(at)) {\n        at = at.path;\n    }\n    if (depth != null) {\n        at = at.slice(0, depth);\n    }\n    return at;\n};\nvar pointRef = function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: point,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pointRefs = Editor.pointRefs(editor);\n            pointRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pointRefs = (editor)=>{\n    var refs = POINT_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        POINT_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar point = function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { edge = \"start\" } = options;\n    if (Path.isPath(at)) {\n        var path;\n        if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            path = lastPath;\n        } else {\n            var [, firstPath] = Node.first(editor, at);\n            path = firstPath;\n        }\n        var node = Node.get(editor, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n        }\n        return {\n            path,\n            offset: edge === \"end\" ? node.text.length : 0\n        };\n    }\n    if (Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        return edge === \"start\" ? start : end;\n    }\n    return at;\n};\nfunction* positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { at = editor.selection, unit = \"offset\", reverse = false, voids = false, ignoreNonSelectable = false } = options;\n    if (!at) {\n        return;\n    }\n    /**\r\n   * Algorithm notes:\r\n   *\r\n   * Each step `distance` is dynamic depending on the underlying text\r\n   * and the `unit` specified.  Each step, e.g., a line or word, may\r\n   * span multiple text nodes, so we iterate through the text both on\r\n   * two levels in step-sync:\r\n   *\r\n   * `leafText` stores the text on a text leaf level, and is advanced\r\n   * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n   *\r\n   * `blockText` stores the text on a block level, and is shortened\r\n   * by `distance` every time it is advanced.\r\n   *\r\n   * We only maintain a window of one blockText and one leafText because\r\n   * a block node always appears before all of its leaf nodes.\r\n   */ var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = \"\";\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (var [node, path] of Editor.nodes(editor, {\n        at,\n        reverse,\n        voids,\n        ignoreNonSelectable\n    })){\n        /*\r\n     * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n     */ if (Element.isElement(node)) {\n            // Void nodes are a special case, so by default we will always\n            // yield their first point. If the `voids` option is set to true,\n            // then we will iterate over their content.\n            if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n                yield Editor.start(editor, path);\n                continue;\n            } // Inline element nodes are ignored as they don't themselves\n            // contribute to `blockText` or `leafText` - their parent and\n            // children do.\n            if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n            if (Editor.hasInlines(editor, node)) {\n                // We always exhaust block nodes before encountering a new one:\n                //   console.assert(blockText === '',\n                //     `blockText='${blockText}' - `+\n                //     `not exhausted before new block node`, path)\n                // Ensure range considered is capped to `range`, in the\n                // start/end edge cases where block extends beyond range.\n                // Equivalent to this, but presumably more performant:\n                //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                //   blockRange = Range.intersection(range, blockRange) // intersect\n                //   blockText = Editor.string(editor, blockRange, { voids })\n                var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                blockText = Editor.string(editor, {\n                    anchor: s,\n                    focus: e\n                }, {\n                    voids\n                });\n                isNewBlock = true;\n            }\n        }\n        /*\r\n     * TEXT LEAF NODE - Iterate through text content, yielding\r\n     * positions every `distance` offset according to `unit`.\r\n     */ if (Text.isText(node)) {\n            var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n            //   console.assert(leafTextRemaining <= 0,\n            //     `leafTextRemaining=${leafTextRemaining} - `+\n            //     `not exhausted before new leaf text node`, path)\n            // Reset `leafText` counters for new text node.\n            if (isFirst) {\n                leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                leafTextOffset = first.offset; // Works for reverse too.\n            } else {\n                leafTextRemaining = node.text.length;\n                leafTextOffset = reverse ? leafTextRemaining : 0;\n            } // Yield position at the start of node (potentially).\n            if (isFirst || isNewBlock || unit === \"offset\") {\n                yield {\n                    path,\n                    offset: leafTextOffset\n                };\n                isNewBlock = false;\n            } // Yield positions every (dynamically calculated) `distance` offset.\n            while(true){\n                // If `leafText` has caught up with `blockText` (distance=0),\n                // and if blockText is exhausted, break to get another block node,\n                // otherwise advance blockText forward by the new `distance`.\n                if (distance === 0) {\n                    if (blockText === \"\") break;\n                    distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n                    // remaining string for the next iteration.\n                    blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                } // Advance `leafText` by the current `distance`.\n                leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n                // and set distance to the overflow amount, so we'll (maybe)\n                // catch up to blockText in the next leaf text node.\n                if (leafTextRemaining < 0) {\n                    distance = -leafTextRemaining;\n                    break;\n                } // Successfully walked `distance` offsets through `leafText`\n                // to catch up with `blockText`, so we can reset `distance`\n                // and yield this position in this node.\n                distance = 0;\n                yield {\n                    path,\n                    offset: leafTextOffset\n                };\n            }\n        }\n    } // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text, unit, reverse) {\n        if (unit === \"character\") {\n            return getCharacterDistance(text, reverse);\n        } else if (unit === \"word\") {\n            return getWordDistance(text, reverse);\n        } else if (unit === \"line\" || unit === \"block\") {\n            return text.length;\n        }\n        return 1;\n    }\n}\nvar previous = function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointBeforeLocation = Editor.before(editor, at, {\n        voids\n    });\n    if (!pointBeforeLocation) {\n        return;\n    }\n    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    var span = [\n        pointBeforeLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [previous] = Editor.nodes(editor, {\n        reverse: true,\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return previous;\n};\nvar rangeRef = function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: range,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var rangeRefs = Editor.rangeRefs(editor);\n            rangeRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar rangeRefs = (editor)=>{\n    var refs = RANGE_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        RANGE_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar range = (editor, at, to)=>{\n    if (Range.isRange(at) && !to) {\n        return at;\n    }\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar removeMark = (editor, key)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.unsetNodes(editor, key, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n            delete marks[key];\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nvar setNormalizing = (editor, isNormalizing)=>{\n    NORMALIZING.set(editor, isNormalizing);\n};\nvar start = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"start\"\n    });\n};\nvar string = function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = \"\";\n    for (var [node, path] of Editor.nodes(editor, {\n        at: range,\n        match: Text.isText,\n        voids\n    })){\n        var t = node.text;\n        if (Path.equals(path, end.path)) {\n            t = t.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n            t = t.slice(start.offset);\n        }\n        text += t;\n    }\n    return text;\n};\nvar unhangRange = function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n        return range;\n    }\n    var endBlock = Editor.above(editor, {\n        at: end,\n        match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n        voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n        anchor: first,\n        focus: end\n    };\n    var skip = true;\n    for (var [node, path] of Editor.nodes(editor, {\n        at: before,\n        match: Text.isText,\n        reverse: true,\n        voids\n    })){\n        if (skip) {\n            skip = false;\n            continue;\n        }\n        if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n            end = {\n                path,\n                offset: node.text.length\n            };\n            break;\n        }\n    }\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nvar withoutNormalizing = (editor, fn)=>{\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n    try {\n        fn();\n    } finally{\n        Editor.setNormalizing(editor, value);\n    }\n    Editor.normalize(editor);\n};\nvar deleteText = function deleteText(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var _Editor$void, _Editor$void2;\n        var { reverse = false, unit = \"character\", distance = 1, voids = false } = options;\n        var { at = editor.selection, hanging = false } = options;\n        if (!at) {\n            return;\n        }\n        var isCollapsed = false;\n        if (Range.isRange(at) && Range.isCollapsed(at)) {\n            isCollapsed = true;\n            at = at.anchor;\n        }\n        if (Point.isPoint(at)) {\n            var furthestVoid = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            if (!voids && furthestVoid) {\n                var [, voidPath] = furthestVoid;\n                at = voidPath;\n            } else {\n                var opts = {\n                    unit,\n                    distance\n                };\n                var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                at = {\n                    anchor: at,\n                    focus: target\n                };\n                hanging = true;\n            }\n        }\n        if (Path.isPath(at)) {\n            Transforms.removeNodes(editor, {\n                at,\n                voids\n            });\n            return;\n        }\n        if (Range.isCollapsed(at)) {\n            return;\n        }\n        if (!hanging) {\n            var [, _end] = Range.edges(at);\n            var endOfDoc = Editor.end(editor, []);\n            if (!Point.equals(_end, endOfDoc)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n        }\n        var [start, end] = Range.edges(at);\n        var startBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: start,\n            voids\n        });\n        var endBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: end,\n            voids\n        });\n        var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n        var isSingleText = Path.equals(start.path, end.path);\n        var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n            at: start,\n            mode: \"highest\"\n        })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n            at: start,\n            mode: \"highest\"\n        });\n        var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n            at: end,\n            mode: \"highest\"\n        })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n            at: end,\n            mode: \"highest\"\n        }); // If the start or end points are inside an inline void, nudge them out.\n        if (startNonEditable) {\n            var before = Editor.before(editor, start);\n            if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                start = before;\n            }\n        }\n        if (endNonEditable) {\n            var after = Editor.after(editor, end);\n            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                end = after;\n            }\n        } // Get the highest nodes that are completely inside the range, as well as\n        // the start and end nodes.\n        var matches = [];\n        var lastPath;\n        for (var entry of Editor.nodes(editor, {\n            at,\n            voids\n        })){\n            var [node, path] = entry;\n            if (lastPath && Path.compare(path, lastPath) === 0) {\n                continue;\n            }\n            if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n                matches.push(entry);\n                lastPath = path;\n            }\n        }\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        var startRef = Editor.pointRef(editor, start);\n        var endRef = Editor.pointRef(editor, end);\n        var removedText = \"\";\n        if (!isSingleText && !startNonEditable) {\n            var _point = startRef.current;\n            var [_node] = Editor.leaf(editor, _point);\n            var { path: _path } = _point;\n            var { offset } = start;\n            var text = _node.text.slice(offset);\n            if (text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path,\n                    offset,\n                    text\n                });\n                removedText = text;\n            }\n        }\n        pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {\n                at: p,\n                voids\n            }));\n        if (!endNonEditable) {\n            var _point2 = endRef.current;\n            var [_node2] = Editor.leaf(editor, _point2);\n            var { path: _path2 } = _point2;\n            var _offset = isSingleText ? start.offset : 0;\n            var _text = _node2.text.slice(_offset, end.offset);\n            if (_text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path2,\n                    offset: _offset,\n                    text: _text\n                });\n                removedText = _text;\n            }\n        }\n        if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n            Transforms.mergeNodes(editor, {\n                at: endRef.current,\n                hanging: true,\n                voids\n            });\n        } // For Thai script, deleting N character(s) backward should delete\n        // N code point(s) instead of an entire grapheme cluster.\n        // Therefore, the remaining code points should be inserted back.\n        if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n            Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n        }\n        var startUnref = startRef.unref();\n        var endUnref = endRef.unref();\n        var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n        if (options.at == null && point) {\n            Transforms.select(editor, point);\n        }\n    });\n};\nvar insertFragment = function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false } = options;\n        var { at = getDefaultInsertLocation(editor) } = options;\n        if (!fragment.length) {\n            return;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                if (!voids && Editor.void(editor, {\n                    at: end\n                })) {\n                    return;\n                }\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        } else if (Path.isPath(at)) {\n            at = Editor.start(editor, at);\n        }\n        if (!voids && Editor.void(editor, {\n            at\n        })) {\n            return;\n        } // If the insert point is at the edge of an inline node, move it outside\n        // instead since it will need to be split otherwise.\n        var inlineElementMatch = Editor.above(editor, {\n            at,\n            match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (inlineElementMatch) {\n            var [, _inlinePath] = inlineElementMatch;\n            if (Editor.isEnd(editor, at, _inlinePath)) {\n                var after = Editor.after(editor, _inlinePath);\n                at = after;\n            } else if (Editor.isStart(editor, at, _inlinePath)) {\n                var before = Editor.before(editor, _inlinePath);\n                at = before;\n            }\n        }\n        var blockMatch = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at,\n            voids\n        });\n        var [, blockPath] = blockMatch;\n        var isBlockStart = Editor.isStart(editor, at, blockPath);\n        var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n        var isBlockEmpty = isBlockStart && isBlockEnd;\n        var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n        var mergeEnd = !isBlockEnd;\n        var [, firstPath] = Node.first({\n            children: fragment\n        }, []);\n        var [, lastPath] = Node.last({\n            children: fragment\n        }, []);\n        var matches = [];\n        var matcher = (_ref)=>{\n            var [n, p] = _ref;\n            var isRoot = p.length === 0;\n            if (isRoot) {\n                return false;\n            }\n            if (isBlockEmpty) {\n                return true;\n            }\n            if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            return true;\n        };\n        for (var entry of Node.nodes({\n            children: fragment\n        }, {\n            pass: matcher\n        })){\n            if (matcher(entry)) {\n                matches.push(entry);\n            }\n        }\n        var starts = [];\n        var middles = [];\n        var ends = [];\n        var starting = true;\n        var hasBlocks = false;\n        for (var [node] of matches){\n            if (Element.isElement(node) && !editor.isInline(node)) {\n                starting = false;\n                hasBlocks = true;\n                middles.push(node);\n            } else if (starting) {\n                starts.push(node);\n            } else {\n                ends.push(node);\n            }\n        }\n        var [inlineMatch] = Editor.nodes(editor, {\n            at,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        var [, inlinePath] = inlineMatch;\n        var isInlineStart = Editor.isStart(editor, at, inlinePath);\n        var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n        var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n        var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        Transforms.splitNodes(editor, {\n            at,\n            match: (n)=>hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n            mode: hasBlocks ? \"lowest\" : \"highest\",\n            always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n            voids\n        });\n        var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        Transforms.insertNodes(editor, starts, {\n            at: startRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n            Transforms.delete(editor, {\n                at: blockPath,\n                voids\n            });\n        }\n        Transforms.insertNodes(editor, middles, {\n            at: middleRef.current,\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            mode: \"lowest\",\n            voids\n        });\n        Transforms.insertNodes(editor, ends, {\n            at: endRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (!options.at) {\n            var path;\n            if (ends.length > 0 && endRef.current) {\n                path = Path.previous(endRef.current);\n            } else if (middles.length > 0 && middleRef.current) {\n                path = Path.previous(middleRef.current);\n            } else if (startRef.current) {\n                path = Path.previous(startRef.current);\n            }\n            if (path) {\n                var _end = Editor.end(editor, path);\n                Transforms.select(editor, _end);\n            }\n        }\n        startRef.unref();\n        middleRef.unref();\n        endRef.unref();\n    });\n};\nvar collapse = function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { edge = \"anchor\" } = options;\n    var { selection } = editor;\n    if (!selection) {\n        return;\n    } else if (edge === \"anchor\") {\n        Transforms.select(editor, selection.anchor);\n    } else if (edge === \"focus\") {\n        Transforms.select(editor, selection.focus);\n    } else if (edge === \"start\") {\n        var [start] = Range.edges(selection);\n        Transforms.select(editor, start);\n    } else if (edge === \"end\") {\n        var [, end] = Range.edges(selection);\n        Transforms.select(editor, end);\n    }\n};\nvar deselect = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: null\n        });\n    }\n};\nvar move = function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    var { distance = 1, unit = \"character\", reverse = false } = options;\n    var { edge = null } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var opts = {\n        distance,\n        unit,\n        ignoreNonSelectable: true\n    };\n    var props = {};\n    if (edge == null || edge === \"anchor\") {\n        var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n        if (point) {\n            props.anchor = point;\n        }\n    }\n    if (edge == null || edge === \"focus\") {\n        var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n        if (_point) {\n            props.focus = _point;\n        }\n    }\n    Transforms.setSelection(editor, props);\n};\nvar select = (editor, target)=>{\n    var { selection } = editor;\n    target = Editor.range(editor, target);\n    if (selection) {\n        Transforms.setSelection(editor, target);\n        return;\n    }\n    if (!Range.isRange(target)) {\n        throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n    editor.apply({\n        type: \"set_selection\",\n        properties: selection,\n        newProperties: target\n    });\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar setPoint = function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection } = editor;\n    var { edge = \"both\" } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var point = edge === \"anchor\" ? anchor : focus;\n    Transforms.setSelection(editor, {\n        [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n};\nvar setSelection = (editor, props)=>{\n    var { selection } = editor;\n    var oldProps = {};\n    var newProps = {};\n    if (!selection) {\n        return;\n    }\n    for(var k in props){\n        if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n            oldProps[k] = selection[k];\n            newProps[k] = props[k];\n        }\n    }\n    if (Object.keys(oldProps).length > 0) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: oldProps,\n            newProperties: newProps\n        });\n    }\n};\nvar insertNodes = function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        var { at, match, select } = options;\n        if (Node.isNode(nodes)) {\n            nodes = [\n                nodes\n            ];\n        }\n        if (nodes.length === 0) {\n            return;\n        }\n        var [node] = nodes;\n        if (!at) {\n            at = getDefaultInsertLocation(editor);\n            select = true;\n        }\n        if (select == null) {\n            select = false;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        }\n        if (Point.isPoint(at)) {\n            if (match == null) {\n                if (Text.isText(node)) {\n                    match = (n)=>Text.isText(n);\n                } else if (editor.isInline(node)) {\n                    match = (n)=>Text.isText(n) || Editor.isInline(editor, n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            var [entry] = Editor.nodes(editor, {\n                at: at.path,\n                match,\n                mode,\n                voids\n            });\n            if (entry) {\n                var [, matchPath] = entry;\n                var pathRef = Editor.pathRef(editor, matchPath);\n                var isAtEnd = Editor.isEnd(editor, at, matchPath);\n                Transforms.splitNodes(editor, {\n                    at,\n                    match,\n                    mode,\n                    voids\n                });\n                var path = pathRef.unref();\n                at = isAtEnd ? Path.next(path) : path;\n            } else {\n                return;\n            }\n        }\n        var parentPath = Path.parent(at);\n        var index = at[at.length - 1];\n        if (!voids && Editor.void(editor, {\n            at: parentPath\n        })) {\n            return;\n        }\n        for (var _node of nodes){\n            var _path = parentPath.concat(index);\n            index++;\n            editor.apply({\n                type: \"insert_node\",\n                path: _path,\n                node: _node\n            });\n            at = Path.next(at);\n        }\n        at = Path.previous(at);\n        if (select) {\n            var point = Editor.end(editor, at);\n            if (point) {\n                Transforms.select(editor, point);\n            }\n        }\n    });\n};\nvar liftNodes = function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!at) {\n            return;\n        }\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path.length < 2) {\n                throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n            }\n            var parentNodeEntry = Editor.node(editor, Path.parent(path));\n            var [parent, parentPath] = parentNodeEntry;\n            var index = path[path.length - 1];\n            var { length } = parent.children;\n            if (length === 1) {\n                var toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: toPath,\n                    voids\n                });\n                Transforms.removeNodes(editor, {\n                    at: parentPath,\n                    voids\n                });\n            } else if (index === 0) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: parentPath,\n                    voids\n                });\n            } else if (index === length - 1) {\n                var _toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath,\n                    voids\n                });\n            } else {\n                var splitPath = Path.next(path);\n                var _toPath2 = Path.next(parentPath);\n                Transforms.splitNodes(editor, {\n                    at: splitPath,\n                    voids\n                });\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath2,\n                    voids\n                });\n            }\n        }\n    });\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nvar hasSingleChildNest = (editor, node)=>{\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar mergeNodes = function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection } = options;\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (Range.isRange(at)) {\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n        }\n        var [current] = Editor.nodes(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        var prev = Editor.previous(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        if (!current || !prev) {\n            return;\n        }\n        var [node, path] = current;\n        var [prevNode, prevPath] = prev;\n        if (path.length === 0 || prevPath.length === 0) {\n            return;\n        }\n        var newPath = Path.next(prevPath);\n        var commonPath = Path.common(path, prevPath);\n        var isPreviousSibling = Path.isSibling(path, prevPath);\n        var levels = Array.from(Editor.levels(editor, {\n            at: path\n        }), (_ref)=>{\n            var [n] = _ref;\n            return n;\n        }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n        // result, in which case we'll want to remove it after merging.\n        var emptyAncestor = Editor.above(editor, {\n            at: path,\n            mode: \"highest\",\n            match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)\n        });\n        var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n        var properties;\n        var position; // Ensure that the nodes are equivalent, and figure out what the position\n        // and extra properties of the merge will be.\n        if (Text.isText(node) && Text.isText(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded);\n            position = prevNode.text.length;\n            properties = rest;\n        } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded2);\n            position = prevNode.children.length;\n            properties = rest;\n        } else {\n            throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n        } // If the node isn't already the next sibling of the previous node, move\n        // it so that it is before merging.\n        if (!isPreviousSibling) {\n            Transforms.moveNodes(editor, {\n                at: path,\n                to: newPath,\n                voids\n            });\n        } // If there was going to be an empty ancestor of the node that was merged,\n        // we remove it from the tree.\n        if (emptyRef) {\n            Transforms.removeNodes(editor, {\n                at: emptyRef.current,\n                voids\n            });\n        } // If the target node that we're merging with is empty, remove it instead\n        // of merging the two. This is a common rich text editor behavior to\n        // prevent losing formatting when deleting entire nodes when you have a\n        // hanging selection.\n        // if prevNode is first child in parent,don't remove it.\n        if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n            Transforms.removeNodes(editor, {\n                at: prevPath,\n                voids\n            });\n        } else {\n            editor.apply({\n                type: \"merge_node\",\n                path: newPath,\n                position,\n                properties\n            });\n        }\n        if (emptyRef) {\n            emptyRef.unref();\n        }\n    });\n};\nvar moveNodes = (editor, options)=>{\n    Editor.withoutNormalizing(editor, ()=>{\n        var { to, at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        var toRef = Editor.pathRef(editor, to);\n        var targets = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(targets, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            var newPath = toRef.current;\n            if (path.length !== 0) {\n                editor.apply({\n                    type: \"move_node\",\n                    path,\n                    newPath\n                });\n            }\n            if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                // When performing a sibling move to a later index, the path at the destination is shifted\n                // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                // in the correct order we increment toRef to account for that\n                toRef.current = Path.next(toRef.current);\n            }\n        }\n        toRef.unref();\n    });\n};\nvar removeNodes = function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        var depths = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(depths, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path) {\n                var [node] = Editor.node(editor, path);\n                editor.apply({\n                    type: \"remove_node\",\n                    path,\n                    node\n                });\n            }\n        }\n    });\n};\nvar setNodes = function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection, compare, merge } = options;\n        var { hanging = false, mode = \"lowest\", split = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (split && Range.isRange(at)) {\n            if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                // set that won't get normalized away\n                return;\n            }\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            var [start, end] = Range.edges(at);\n            var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n            var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                mode: splitMode,\n                voids,\n                always: !endAtEndOfNode\n            });\n            var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                mode: splitMode,\n                voids,\n                always: !startAtStartOfNode\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        if (!compare) {\n            compare = (prop, nodeProp)=>prop !== nodeProp;\n        }\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        })){\n            var properties = {};\n            var newProperties = {}; // You can't set properties on the editor node.\n            if (path.length === 0) {\n                continue;\n            }\n            var hasChanges = false;\n            for(var k in props){\n                if (k === \"children\" || k === \"text\") {\n                    continue;\n                }\n                if (compare(props[k], node[k])) {\n                    hasChanges = true; // Omit new properties from the old properties list\n                    if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n                    if (merge) {\n                        if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                    } else {\n                        if (props[k] != null) newProperties[k] = props[k];\n                    }\n                }\n            }\n            if (hasChanges) {\n                editor.apply({\n                    type: \"set_node\",\n                    path,\n                    properties,\n                    newProperties\n                });\n            }\n        }\n    });\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */ var deleteRange = (editor, range)=>{\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var [, end] = Range.edges(range);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar splitNodes = function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection, height = 0, always = false } = options;\n        if (match == null) {\n            match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Range.isRange(at)) {\n            at = deleteRange(editor, at);\n        } // If the target is a path, the default height-skipping and position\n        // counters need to account for us potentially splitting at a non-leaf.\n        if (Path.isPath(at)) {\n            var path = at;\n            var point = Editor.point(editor, path);\n            var [parent] = Editor.parent(editor, path);\n            match = (n)=>n === parent;\n            height = point.path.length - path.length + 1;\n            at = point;\n            always = true;\n        }\n        if (!at) {\n            return;\n        }\n        var beforeRef = Editor.pointRef(editor, at, {\n            affinity: \"backward\"\n        });\n        var afterRef;\n        try {\n            var [highest] = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            if (!highest) {\n                return;\n            }\n            var voidMatch = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            var nudge = 0;\n            if (!voids && voidMatch) {\n                var [voidNode, voidPath] = voidMatch;\n                if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                    var after = Editor.after(editor, voidPath);\n                    if (!after) {\n                        var text = {\n                            text: \"\"\n                        };\n                        var afterPath = Path.next(voidPath);\n                        Transforms.insertNodes(editor, text, {\n                            at: afterPath,\n                            voids\n                        });\n                        after = Editor.point(editor, afterPath);\n                    }\n                    at = after;\n                    always = true;\n                }\n                var siblingHeight = at.path.length - voidPath.length;\n                height = siblingHeight + 1;\n                always = true;\n            }\n            afterRef = Editor.pointRef(editor, at);\n            var depth = at.path.length - height;\n            var [, highestPath] = highest;\n            var lowestPath = at.path.slice(0, depth);\n            var position = height === 0 ? at.offset : at.path[depth] + nudge;\n            for (var [node, _path] of Editor.levels(editor, {\n                at: lowestPath,\n                reverse: true,\n                voids\n            })){\n                var split = false;\n                if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                    break;\n                }\n                var _point = beforeRef.current;\n                var isEnd = Editor.isEnd(editor, _point, _path);\n                if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n                    split = true;\n                    var properties = Node.extractProps(node);\n                    editor.apply({\n                        type: \"split_node\",\n                        path: _path,\n                        position,\n                        properties\n                    });\n                }\n                position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n            }\n            if (options.at == null) {\n                var _point2 = afterRef.current || Editor.end(editor, []);\n                Transforms.select(editor, _point2);\n            }\n        } finally{\n            var _afterRef;\n            beforeRef.unref();\n            (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n        }\n    });\n};\nvar unsetNodes = function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!Array.isArray(props)) {\n        props = [\n            props\n        ];\n    }\n    var obj = {};\n    for (var key of props){\n        obj[key] = null;\n    }\n    Transforms.setNodes(editor, obj, options);\n};\nvar unwrapNodes = function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Path.isPath(at)) {\n            at = Editor.range(editor, at);\n        }\n        var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        } // unwrapNode will call liftNode which does not support splitting the node when nested.\n        ).reverse();\n        var _loop = function _loop(pathRef) {\n            var path = pathRef.unref();\n            var [node] = Editor.node(editor, path);\n            var range = Editor.range(editor, path);\n            if (split && rangeRef) {\n                range = Range.intersection(rangeRef.current, range);\n            }\n            Transforms.liftNodes(editor, {\n                at: range,\n                match: (n)=>Element.isAncestor(node) && node.children.includes(n),\n                voids\n            });\n        };\n        for (var pathRef of pathRefs){\n            _loop(pathRef);\n        }\n        if (rangeRef) {\n            rangeRef.unref();\n        }\n    });\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar wrapNodes = function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                match = matchPath(editor, at);\n            } else if (editor.isInline(element)) {\n                match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (split && Range.isRange(at)) {\n            var [start, end] = Range.edges(at);\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                voids\n            });\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                voids\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        var roots = Array.from(Editor.nodes(editor, {\n            at,\n            match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),\n            mode: \"lowest\",\n            voids\n        }));\n        for (var [, rootPath] of roots){\n            var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n            if (!a) {\n                continue;\n            }\n            var matches = Array.from(Editor.nodes(editor, {\n                at: a,\n                match,\n                mode,\n                voids\n            }));\n            if (matches.length > 0) {\n                var _ret = function() {\n                    var [first] = matches;\n                    var last = matches[matches.length - 1];\n                    var [, firstPath] = first;\n                    var [, lastPath] = last;\n                    if (firstPath.length === 0 && lastPath.length === 0) {\n                        // if there's no matching parent - usually means the node is an editor - don't do anything\n                        return \"continue\";\n                    }\n                    var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                    var range = Editor.range(editor, firstPath, lastPath);\n                    var commonNodeEntry = Editor.node(editor, commonPath);\n                    var [commonNode] = commonNodeEntry;\n                    var depth = commonPath.length + 1;\n                    var wrapperPath = Path.next(lastPath.slice(0, depth));\n                    var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n                        children: []\n                    });\n                    Transforms.insertNodes(editor, wrapper, {\n                        at: wrapperPath,\n                        voids\n                    });\n                    Transforms.moveNodes(editor, {\n                        at: range,\n                        match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),\n                        to: wrapperPath.concat(0),\n                        voids\n                    });\n                }();\n                if (_ret === \"continue\") continue;\n            }\n        }\n    });\n};\n/**\r\n * Create a new Slate `Editor` object.\r\n */ var createEditor = ()=>{\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isElementReadOnly: ()=>false,\n        isInline: ()=>false,\n        isSelectable: ()=>true,\n        isVoid: ()=>false,\n        markableVoid: ()=>false,\n        onChange: ()=>{},\n        // Core\n        apply: function apply$1() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return apply(editor, ...args);\n        },\n        // Editor\n        addMark: function addMark$1() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                args[_key2] = arguments[_key2];\n            }\n            return addMark(editor, ...args);\n        },\n        deleteBackward: function deleteBackward$1() {\n            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                args[_key3] = arguments[_key3];\n            }\n            return deleteBackward(editor, ...args);\n        },\n        deleteForward: function deleteForward$1() {\n            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                args[_key4] = arguments[_key4];\n            }\n            return deleteForward(editor, ...args);\n        },\n        deleteFragment: function deleteFragment$1() {\n            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                args[_key5] = arguments[_key5];\n            }\n            return deleteFragment(editor, ...args);\n        },\n        getFragment: function getFragment$1() {\n            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){\n                args[_key6] = arguments[_key6];\n            }\n            return getFragment(editor, ...args);\n        },\n        insertBreak: function insertBreak$1() {\n            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){\n                args[_key7] = arguments[_key7];\n            }\n            return insertBreak(editor, ...args);\n        },\n        insertSoftBreak: function insertSoftBreak$1() {\n            for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){\n                args[_key8] = arguments[_key8];\n            }\n            return insertSoftBreak(editor, ...args);\n        },\n        insertFragment: function insertFragment$1() {\n            for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){\n                args[_key9] = arguments[_key9];\n            }\n            return insertFragment(editor, ...args);\n        },\n        insertNode: function insertNode$1() {\n            for(var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){\n                args[_key10] = arguments[_key10];\n            }\n            return insertNode(editor, ...args);\n        },\n        insertText: function insertText$1() {\n            for(var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++){\n                args[_key11] = arguments[_key11];\n            }\n            return insertText(editor, ...args);\n        },\n        normalizeNode: function normalizeNode$1() {\n            for(var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++){\n                args[_key12] = arguments[_key12];\n            }\n            return normalizeNode(editor, ...args);\n        },\n        removeMark: function removeMark$1() {\n            for(var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++){\n                args[_key13] = arguments[_key13];\n            }\n            return removeMark(editor, ...args);\n        },\n        getDirtyPaths: function getDirtyPaths$1() {\n            for(var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++){\n                args[_key14] = arguments[_key14];\n            }\n            return getDirtyPaths(editor, ...args);\n        },\n        shouldNormalize: function shouldNormalize$1() {\n            for(var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++){\n                args[_key15] = arguments[_key15];\n            }\n            return shouldNormalize(editor, ...args);\n        },\n        // Editor interface\n        above: function above$1() {\n            for(var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++){\n                args[_key16] = arguments[_key16];\n            }\n            return above(editor, ...args);\n        },\n        after: function after$1() {\n            for(var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++){\n                args[_key17] = arguments[_key17];\n            }\n            return after(editor, ...args);\n        },\n        before: function before$1() {\n            for(var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++){\n                args[_key18] = arguments[_key18];\n            }\n            return before(editor, ...args);\n        },\n        collapse: function collapse$1() {\n            for(var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++){\n                args[_key19] = arguments[_key19];\n            }\n            return collapse(editor, ...args);\n        },\n        delete: function _delete() {\n            for(var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++){\n                args[_key20] = arguments[_key20];\n            }\n            return deleteText(editor, ...args);\n        },\n        deselect: function deselect$1() {\n            for(var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++){\n                args[_key21] = arguments[_key21];\n            }\n            return deselect(editor, ...args);\n        },\n        edges: function edges$1() {\n            for(var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++){\n                args[_key22] = arguments[_key22];\n            }\n            return edges(editor, ...args);\n        },\n        elementReadOnly: function elementReadOnly$1() {\n            for(var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++){\n                args[_key23] = arguments[_key23];\n            }\n            return elementReadOnly(editor, ...args);\n        },\n        end: function end$1() {\n            for(var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++){\n                args[_key24] = arguments[_key24];\n            }\n            return end(editor, ...args);\n        },\n        first: function first$1() {\n            for(var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++){\n                args[_key25] = arguments[_key25];\n            }\n            return first(editor, ...args);\n        },\n        fragment: function fragment$1() {\n            for(var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++){\n                args[_key26] = arguments[_key26];\n            }\n            return fragment(editor, ...args);\n        },\n        getMarks: function getMarks() {\n            for(var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++){\n                args[_key27] = arguments[_key27];\n            }\n            return marks(editor, ...args);\n        },\n        hasBlocks: function hasBlocks$1() {\n            for(var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++){\n                args[_key28] = arguments[_key28];\n            }\n            return hasBlocks(editor, ...args);\n        },\n        hasInlines: function hasInlines$1() {\n            for(var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++){\n                args[_key29] = arguments[_key29];\n            }\n            return hasInlines(editor, ...args);\n        },\n        hasPath: function hasPath$1() {\n            for(var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++){\n                args[_key30] = arguments[_key30];\n            }\n            return hasPath(editor, ...args);\n        },\n        hasTexts: function hasTexts$1() {\n            for(var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++){\n                args[_key31] = arguments[_key31];\n            }\n            return hasTexts(editor, ...args);\n        },\n        insertNodes: function insertNodes$1() {\n            for(var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++){\n                args[_key32] = arguments[_key32];\n            }\n            return insertNodes(editor, ...args);\n        },\n        isBlock: function isBlock$1() {\n            for(var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++){\n                args[_key33] = arguments[_key33];\n            }\n            return isBlock(editor, ...args);\n        },\n        isEdge: function isEdge$1() {\n            for(var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++){\n                args[_key34] = arguments[_key34];\n            }\n            return isEdge(editor, ...args);\n        },\n        isEmpty: function isEmpty$1() {\n            for(var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++){\n                args[_key35] = arguments[_key35];\n            }\n            return isEmpty(editor, ...args);\n        },\n        isEnd: function isEnd$1() {\n            for(var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++){\n                args[_key36] = arguments[_key36];\n            }\n            return isEnd(editor, ...args);\n        },\n        isNormalizing: function isNormalizing$1() {\n            for(var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++){\n                args[_key37] = arguments[_key37];\n            }\n            return isNormalizing(editor, ...args);\n        },\n        isStart: function isStart$1() {\n            for(var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++){\n                args[_key38] = arguments[_key38];\n            }\n            return isStart(editor, ...args);\n        },\n        last: function last$1() {\n            for(var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++){\n                args[_key39] = arguments[_key39];\n            }\n            return last(editor, ...args);\n        },\n        leaf: function leaf$1() {\n            for(var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++){\n                args[_key40] = arguments[_key40];\n            }\n            return leaf(editor, ...args);\n        },\n        levels: function levels$1() {\n            for(var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++){\n                args[_key41] = arguments[_key41];\n            }\n            return levels(editor, ...args);\n        },\n        liftNodes: function liftNodes$1() {\n            for(var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++){\n                args[_key42] = arguments[_key42];\n            }\n            return liftNodes(editor, ...args);\n        },\n        mergeNodes: function mergeNodes$1() {\n            for(var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++){\n                args[_key43] = arguments[_key43];\n            }\n            return mergeNodes(editor, ...args);\n        },\n        move: function move$1() {\n            for(var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++){\n                args[_key44] = arguments[_key44];\n            }\n            return move(editor, ...args);\n        },\n        moveNodes: function moveNodes$1() {\n            for(var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++){\n                args[_key45] = arguments[_key45];\n            }\n            return moveNodes(editor, ...args);\n        },\n        next: function next$1() {\n            for(var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++){\n                args[_key46] = arguments[_key46];\n            }\n            return next(editor, ...args);\n        },\n        node: function node$1() {\n            for(var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++){\n                args[_key47] = arguments[_key47];\n            }\n            return node(editor, ...args);\n        },\n        nodes: function nodes$1() {\n            for(var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++){\n                args[_key48] = arguments[_key48];\n            }\n            return nodes(editor, ...args);\n        },\n        normalize: function normalize$1() {\n            for(var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++){\n                args[_key49] = arguments[_key49];\n            }\n            return normalize(editor, ...args);\n        },\n        parent: function parent$1() {\n            for(var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++){\n                args[_key50] = arguments[_key50];\n            }\n            return parent(editor, ...args);\n        },\n        path: function path$1() {\n            for(var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++){\n                args[_key51] = arguments[_key51];\n            }\n            return path(editor, ...args);\n        },\n        pathRef: function pathRef$1() {\n            for(var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++){\n                args[_key52] = arguments[_key52];\n            }\n            return pathRef(editor, ...args);\n        },\n        pathRefs: function pathRefs$1() {\n            for(var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++){\n                args[_key53] = arguments[_key53];\n            }\n            return pathRefs(editor, ...args);\n        },\n        point: function point$1() {\n            for(var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++){\n                args[_key54] = arguments[_key54];\n            }\n            return point(editor, ...args);\n        },\n        pointRef: function pointRef$1() {\n            for(var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++){\n                args[_key55] = arguments[_key55];\n            }\n            return pointRef(editor, ...args);\n        },\n        pointRefs: function pointRefs$1() {\n            for(var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++){\n                args[_key56] = arguments[_key56];\n            }\n            return pointRefs(editor, ...args);\n        },\n        positions: function positions$1() {\n            for(var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++){\n                args[_key57] = arguments[_key57];\n            }\n            return positions(editor, ...args);\n        },\n        previous: function previous$1() {\n            for(var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++){\n                args[_key58] = arguments[_key58];\n            }\n            return previous(editor, ...args);\n        },\n        range: function range$1() {\n            for(var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++){\n                args[_key59] = arguments[_key59];\n            }\n            return range(editor, ...args);\n        },\n        rangeRef: function rangeRef$1() {\n            for(var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++){\n                args[_key60] = arguments[_key60];\n            }\n            return rangeRef(editor, ...args);\n        },\n        rangeRefs: function rangeRefs$1() {\n            for(var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++){\n                args[_key61] = arguments[_key61];\n            }\n            return rangeRefs(editor, ...args);\n        },\n        removeNodes: function removeNodes$1() {\n            for(var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++){\n                args[_key62] = arguments[_key62];\n            }\n            return removeNodes(editor, ...args);\n        },\n        select: function select$1() {\n            for(var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++){\n                args[_key63] = arguments[_key63];\n            }\n            return select(editor, ...args);\n        },\n        setNodes: function setNodes$1() {\n            for(var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++){\n                args[_key64] = arguments[_key64];\n            }\n            return setNodes(editor, ...args);\n        },\n        setNormalizing: function setNormalizing$1() {\n            for(var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++){\n                args[_key65] = arguments[_key65];\n            }\n            return setNormalizing(editor, ...args);\n        },\n        setPoint: function setPoint$1() {\n            for(var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++){\n                args[_key66] = arguments[_key66];\n            }\n            return setPoint(editor, ...args);\n        },\n        setSelection: function setSelection$1() {\n            for(var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++){\n                args[_key67] = arguments[_key67];\n            }\n            return setSelection(editor, ...args);\n        },\n        splitNodes: function splitNodes$1() {\n            for(var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++){\n                args[_key68] = arguments[_key68];\n            }\n            return splitNodes(editor, ...args);\n        },\n        start: function start$1() {\n            for(var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++){\n                args[_key69] = arguments[_key69];\n            }\n            return start(editor, ...args);\n        },\n        string: function string$1() {\n            for(var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++){\n                args[_key70] = arguments[_key70];\n            }\n            return string(editor, ...args);\n        },\n        unhangRange: function unhangRange$1() {\n            for(var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++){\n                args[_key71] = arguments[_key71];\n            }\n            return unhangRange(editor, ...args);\n        },\n        unsetNodes: function unsetNodes$1() {\n            for(var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++){\n                args[_key72] = arguments[_key72];\n            }\n            return unsetNodes(editor, ...args);\n        },\n        unwrapNodes: function unwrapNodes$1() {\n            for(var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++){\n                args[_key73] = arguments[_key73];\n            }\n            return unwrapNodes(editor, ...args);\n        },\n        void: function _void() {\n            for(var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++){\n                args[_key74] = arguments[_key74];\n            }\n            return getVoid(editor, ...args);\n        },\n        withoutNormalizing: function withoutNormalizing$1() {\n            for(var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++){\n                args[_key75] = arguments[_key75];\n            }\n            return withoutNormalizing(editor, ...args);\n        },\n        wrapNodes: function wrapNodes$1() {\n            for(var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++){\n                args[_key76] = arguments[_key76];\n            }\n            return wrapNodes(editor, ...args);\n        }\n    };\n    return editor;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNtQjtBQUVuRSxJQUFJSyxVQUFVO0lBQ1pDLFdBQVVDLEdBQUcsRUFBRUMsRUFBRTtRQUNmLElBQUksRUFDRkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR0g7UUFFSixJQUFJRSxXQUFXLE1BQU07WUFDbkI7UUFDRjtRQUVBLElBQUlFLE9BQU9DLEtBQUtOLFNBQVMsQ0FBQ0csU0FBU0QsSUFBSTtZQUNyQ0U7UUFDRjtRQUNBSCxJQUFJRSxPQUFPLEdBQUdFO1FBRWQsSUFBSUEsUUFBUSxNQUFNO1lBQ2hCSixJQUFJTSxLQUFLO1FBQ1g7SUFDRjtBQUVGO0FBRUEsSUFBSUMsV0FBVztJQUNiUixXQUFVQyxHQUFHLEVBQUVDLEVBQUU7UUFDZixJQUFJLEVBQ0ZDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdIO1FBRUosSUFBSUUsV0FBVyxNQUFNO1lBQ25CO1FBQ0Y7UUFFQSxJQUFJTSxRQUFRQyxNQUFNVixTQUFTLENBQUNHLFNBQVNELElBQUk7WUFDdkNFO1FBQ0Y7UUFDQUgsSUFBSUUsT0FBTyxHQUFHTTtRQUVkLElBQUlBLFNBQVMsTUFBTTtZQUNqQlIsSUFBSU0sS0FBSztRQUNYO0lBQ0Y7QUFFRjtBQUVBLElBQUlJLFdBQVc7SUFDYlgsV0FBVUMsR0FBRyxFQUFFQyxFQUFFO1FBQ2YsSUFBSSxFQUNGQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHSDtRQUVKLElBQUlFLFdBQVcsTUFBTTtZQUNuQjtRQUNGO1FBRUEsSUFBSUUsT0FBT08sTUFBTVosU0FBUyxDQUFDRyxTQUFTRCxJQUFJO1lBQ3RDRTtRQUNGO1FBQ0FILElBQUlFLE9BQU8sR0FBR0U7UUFFZCxJ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eC5lcy5qcz83ZjRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IHsgY3JlYXRlRHJhZnQsIGZpbmlzaERyYWZ0LCBpc0RyYWZ0LCBwcm9kdWNlIH0gZnJvbSAnaW1tZXInO1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBSYW5nZVJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFJhbmdlLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGggPSB7XG4gIGFuY2VzdG9ycyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG5cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgY29tcGFyZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSA8IGFub3RoZXJbaV0pIHJldHVybiAtMTtcbiAgICAgIGlmIChwYXRoW2ldID4gYW5vdGhlcltpXSkgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgZW5kc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2ID4gYnY7XG4gIH0sXG5cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICBlbmRzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2IDwgYnY7XG4gIH0sXG5cbiAgZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoKG4sIGkpID0+IG4gPT09IGFub3RoZXJbaV0pO1xuICB9LFxuXG4gIGhhc1ByZXZpb3VzKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID4gMDtcbiAgfSxcblxuICBpc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgaXNDaGlsZChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCArIDEgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIGlzUGFyZW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggKyAxID09PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgaXNQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyk7XG4gIH0sXG5cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0ICsgMSk7XG4gIH0sXG5cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgcGFyZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBwYXRoIG9mIHRoZSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0uXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH0sXG5cbiAgcHJldmlvdXMocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gcHJldmlvdXMgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSBmaXJzdCBjaGlsZCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgLSAxKTtcbiAgfSxcblxuICByZWxhdGl2ZShwYXRoLCBhbmNlc3Rvcikge1xuICAgIGlmICghUGF0aC5pc0FuY2VzdG9yKGFuY2VzdG9yLCBwYXRoKSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgYW5jZXN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSByZWxhdGl2ZSBwYXRoIG9mIFtcIi5jb25jYXQocGF0aCwgXCJdIGluc2lkZSBhbmNlc3RvciBbXCIpLmNvbmNhdChhbmNlc3RvciwgXCJdLCBiZWNhdXNlIGl0IGlzIG5vdCBhYm92ZSBvciBlcXVhbCB0byB0aGUgcGF0aC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKGFuY2VzdG9yLmxlbmd0aCk7XG4gIH0sXG5cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsOyAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7IC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AyLFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBfcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wNCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyRlKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRlKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkZShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJGUoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBhcHBseVRvRHJhZnQgPSAoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKSA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChpbmRleCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gXFxcImluc2VydF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbcG9pbnQsIGtleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoKTtcblxuICAgICAgICB2YXIgYmVmb3JlID0gX25vZGUudGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBhZnRlciA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcblxuICAgICAgICBfbm9kZS50ZXh0ID0gYmVmb3JlICsgdGV4dCArIGFmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50LCBfa2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX25vZGUyID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXYgPSBOb2RlLmdldChlZGl0b3IsIHByZXZQYXRoKTtcblxuICAgICAgICB2YXIgX3BhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgX2luZGV4ID0gX3BhdGgyW19wYXRoMi5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGUyKSAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTIudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghVGV4dC5pc1RleHQoX25vZGUyKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LmNoaWxkcmVuLnB1c2goLi4uX25vZGUyLmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJmYWNlczogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25vZGUyKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQyLCBfa2V5Ml0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5Ml0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Miwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgYSBwYXRoIFtcIi5jb25jYXQoX3BhdGgzLCBcIl0gdG8gbmV3IHBhdGggW1wiKS5jb25jYXQobmV3UGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIGluc2lkZSBpdHNlbGYuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTMgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTsgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAvLyB0aGUgc2FtZSBzbmFwc2hvdCBpbiB0aW1lLCB0aGVyZSdzIGEgbWlzbWF0Y2guIEFmdGVyIGVpdGhlclxuICAgICAgICAvLyByZW1vdmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBzZWNvbmQgc3RlcCdzIHBhdGggY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgIC8vIHRyYW5zZm9ybSBgb3AucGF0aGAgdG8gYXNjZXJ0YWluIHdoYXQgdGhlIGBuZXdQYXRoYCB3b3VsZCBiZSBhZnRlclxuICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBhcHBsaWVkLlxuXG4gICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcblxuICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlMyk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQzLCBfa2V5M10gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5M10gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Mywgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG5cbiAgICAgICAgX3BhcmVudDMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDMsIDEpOyAvLyBUcmFuc2Zvcm0gYWxsIG9mIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgLy8gbm9kZSB0aGF0IHdhcyByZW1vdmVkIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByYW5nZSBvciByZW1vdmUgaXQuXG5cblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDQsIF9rZXk0XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ0LCBvcCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTRdID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBfcHJldiA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV4dCA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwcmVmZXJOZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV4dFsxXSwgX3BhdGg0KSkge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9ICFQYXRoLmhhc1ByZXZpb3VzKG5leHRbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gUGF0aC5jb21tb24oX3ByZXZbMV0sIF9wYXRoNCkubGVuZ3RoIDwgUGF0aC5jb21tb24obmV4dFsxXSwgX3BhdGg0KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmICFwcmVmZXJOZXh0KSB7XG4gICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gX3ByZXZbMV07XG4gICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSBfcHJldlswXS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gbmV4dFsxXTtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNSxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGU0ID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGg1KTtcblxuICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNC50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuXG4gICAgICAgIHZhciBfYWZ0ZXIgPSBfbm9kZTQudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcblxuICAgICAgICBfbm9kZTQudGV4dCA9IF9iZWZvcmUgKyBfYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ1LCBfa2V5NV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NSwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNixcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNSA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg2KTtcblxuICAgICAgICBmb3IgKHZhciBfa2V5NiBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKF9rZXk2ID09PSAnY2hpbGRyZW4nIHx8IF9rZXk2ID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTYsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNbX2tleTZdO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTZdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbm9kZTVbX2tleTZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHByb3BlcnRpZXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVmaW5lZCwgYnV0IGFyZSBub3cgbWlzc2luZywgbXVzdCBiZSBkZWxldGVkXG5cblxuICAgICAgICBmb3IgKHZhciBfa2V5NyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9rZXk3KSkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5N107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkZSh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9rZXk4IGluIF9uZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlID0gX25ld1Byb3BlcnRpZXNbX2tleThdO1xuXG4gICAgICAgICAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk4ID09PSAnYW5jaG9yJyB8fCBfa2V5OCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTgsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltfa2V5OF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleThdID0gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg3LFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld05vZGU7XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNikpIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTIgPSBfbm9kZTYudGV4dC5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNi50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LmNoaWxkcmVuID0gX2JlZm9yZTM7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NiwgX2tleTldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDYsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGNyZWF0ZURyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgY3JlYXRlRHJhZnQoZWRpdG9yLnNlbGVjdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uID0gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGlzRHJhZnQoc2VsZWN0aW9uKSA/IGZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgfSxcblxuICBsaWZ0Tm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmxpZnROb2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICBtZXJnZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tZXJnZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuXG4gIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuXG4gIHJlbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5yZW1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcblxuICBzcGxpdE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5zcGxpdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuXG4gIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci51bnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcblxuICB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW53cmFwTm9kZXMob3B0aW9ucyk7XG4gIH0sXG5cbiAgd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci53cmFwTm9kZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNlbGVjdGlvblRyYW5zZm9ybXMgPSB7XG4gIGNvbGxhcHNlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5jb2xsYXBzZShvcHRpb25zKTtcbiAgfSxcblxuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVzZWxlY3QoKTtcbiAgfSxcblxuICBtb3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tb3ZlKG9wdGlvbnMpO1xuICB9LFxuXG4gIHNlbGVjdChlZGl0b3IsIHRhcmdldCkge1xuICAgIGVkaXRvci5zZWxlY3QodGFyZ2V0KTtcbiAgfSxcblxuICBzZXRQb2ludChlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldFBvaW50KHByb3BzLCBvcHRpb25zKTtcbiAgfSxcblxuICBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICAgIGVkaXRvci5zZXRTZWxlY3Rpb24ocHJvcHMpO1xuICB9XG5cbn07XG5cbi8qXHJcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXHJcblxuICBXZSBkb24ndCBuZWVkIGdlbmVyYWwgcHVycG9zZSBkZWVwIGVxdWFsaXR5O1xyXG4gIFNsYXRlIG9ubHkgc3VwcG9ydHMgcGxhaW4gdmFsdWVzLCBBcnJheXMsIGFuZCBuZXN0ZWQgb2JqZWN0cy5cclxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cclxuXG4gIFNsYXRlIG9iamVjdHMgYXJlIGRlc2lnbmVkIHRvIGJlIHNlcmlhbGlzZWQsIHNvXHJcbiAgbWlzc2luZyBrZXlzIGFyZSBkZWxpYmVyYXRlbHkgbm9ybWFsaXNlZCB0byB1bmRlZmluZWQuXHJcbiAqL1xuXG52YXIgaXNEZWVwRXF1YWwgPSAobm9kZSwgYW5vdGhlcikgPT4ge1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIHZhciBhID0gbm9kZVtrZXldO1xuICAgIHZhciBiID0gYW5vdGhlcltrZXldO1xuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbChhLCBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYSAhPT0gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKlxyXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXHJcbiAgICB3ZSBhcmUgb25seSBsb29raW5nIGZvciBrZXlzIHRoYXQgYXJlIG1pc3NpbmcuXHJcbiAgICBBcyBhYm92ZSwgdW5kZWZpbmVkIGtleXMgYXJlIG5vcm1hbGlzZWQgdG8gbWlzc2luZy5cclxuICAqL1xuXG5cbiAgZm9yICh2YXIgX2tleSBpbiBhbm90aGVyKSB7XG4gICAgaWYgKG5vZGVbX2tleV0gPT09IHVuZGVmaW5lZCAmJiBhbm90aGVyW19rZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyRkKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkZChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJGQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBSYW5nZSA9IHtcbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgZW5kKHJhbmdlKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG5cbiAgaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQ0KTtcblxuICAgIHZhciBbczEsIGUxXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgW3MyLCBlMl0gPSBSYW5nZS5lZGdlcyhhbm90aGVyKTtcbiAgICB2YXIgc3RhcnQgPSBQb2ludC5pc0JlZm9yZShzMSwgczIpID8gczIgOiBzMTtcbiAgICB2YXIgZW5kID0gUG9pbnQuaXNCZWZvcmUoZTEsIGUyKSA/IGUxIDogZTI7XG5cbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRkKHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuXG4gIGlzQmFja3dhcmQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG5cbiAgaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcblxuICBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAqcG9pbnRzKHJhbmdlKSB7XG4gICAgeWllbGQgW3JhbmdlLmFuY2hvciwgJ2FuY2hvciddO1xuICAgIHlpZWxkIFtyYW5nZS5mb2N1cywgJ2ZvY3VzJ107XG4gIH0sXG5cbiAgc3RhcnQocmFuZ2UpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG5cbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShyYW5nZSwgciA9PiB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cblxufTtcblxuLyoqXHJcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcclxuICovXG5cbnZhciBpc0VsZW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmICFFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBFbGVtZW50ID0ge1xuICBpc0FuY2VzdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbik7XG4gIH0sXG5cbiAgaXNFbGVtZW50LFxuXG4gIGlzRWxlbWVudExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IEVsZW1lbnQuaXNFbGVtZW50KHZhbCkpO1xuICB9LFxuXG4gIGlzRWxlbWVudFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgaXNFbGVtZW50VHlwZTogZnVuY3Rpb24gaXNFbGVtZW50VHlwZSh2YWx1ZSwgZWxlbWVudFZhbCkge1xuICAgIHZhciBlbGVtZW50S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndHlwZSc7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSkgJiYgdmFsdWVbZWxlbWVudEtleV0gPT09IGVsZW1lbnRWYWw7XG4gIH0sXG5cbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gICAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcbnZhciBJU19OT0RFX0xJU1RfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBOb2RlID0ge1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgKmFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgcCBvZiBQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgdmFyIG4gPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHApO1xuICAgICAgdmFyIGVudHJ5ID0gW24sIHBdO1xuICAgICAgeWllbGQgZW50cnk7XG4gICAgfVxuICB9LFxuXG4gIGNoaWxkKHJvb3QsIGluZGV4KSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBjaGlsZCBvZiBhIHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHZhciBjID0gcm9vdC5jaGlsZHJlbltpbmRleF07XG5cbiAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGNoaWxkIGF0IGluZGV4IGBcIi5jb25jYXQoaW5kZXgsIFwiYCBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9LFxuXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAqZGVzY2VuZGFudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYG5vZGVgIGlzIG5vdCBhIGBFZGl0b3JgLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cuXG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDMpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgZmlyc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5bMF07XG4gICAgICAgIHAucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICBnZXQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkZXNjZW5kYW50IGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgaGFzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICBpc05vZGVMaXN0KHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjYWNoZWRSZXN1bHQgPSBJU19OT0RFX0xJU1RfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlTGlzdCA9IHZhbHVlLmV2ZXJ5KHZhbCA9PiBOb2RlLmlzTm9kZSh2YWwpKTtcbiAgICBJU19OT0RFX0xJU1RfQ0FDSEUuc2V0KHZhbHVlLCBpc05vZGVMaXN0KTtcbiAgICByZXR1cm4gaXNOb2RlTGlzdDtcbiAgfSxcblxuICBsYXN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcblxuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAqdGV4dHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyRjKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkYyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIE9wZXJhdGlvbiA9IHtcbiAgaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcblxuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgaXNUZXh0T3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3RleHQnKTtcbiAgfSxcblxuICBpbnZlcnNlKG9wKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5wcmV2aW91cyhvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9ID0gb3A7IC8vIFBFUkY6IGluIHRoaXMgY2FzZSB0aGUgbW92ZSBvcGVyYXRpb24gaXMgYSBuby1vcCBhbnl3YXlzLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgbW92ZSBoYXBwZW5zIGNvbXBsZXRlbHkgd2l0aGluIGEgc2luZ2xlIHBhcmVudCB0aGUgcGF0aCBhbmRcbiAgICAgICAgICAvLyBuZXdQYXRoIGFyZSBzdGFibGUgd2l0aCByZXNwZWN0IHRvIGVhY2ggb3RoZXIuXG5cblxuICAgICAgICAgIGlmIChQYXRoLmlzU2libGluZyhwYXRoLCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICAgICAgbmV3UGF0aDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgbW92ZSBkb2VzIG5vdCBoYXBwZW4gd2l0aGluIGEgc2luZ2xlIHBhcmVudCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciB0aGUgbW92ZSB0byBpbXBhY3QgdGhlIHRydWUgcGF0aCB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWQuIFdlIGhhdmUgdG8gYWRqdXN0IGZvciB0aGlzXG4gICAgICAgICAgLy8gYW5kIGZpbmQgdGhlIG9yaWdpbmFsIHBhdGguIFdlIGNhbiBhY2NvbXBsaXNoIHRoaXMgKG9ubHkgaW4gbm9uLXNpYmxpbmcpXG4gICAgICAgICAgLy8gbW92ZXMgYnkgbG9va2luZyBhdCB0aGUgaW1wYWN0IG9mIHRoZSBtb3ZlIG9wZXJhdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgICAgIC8vIGFmdGVyIHRoZSBvcmlnaW5hbCBtb3ZlIHBhdGguXG5cblxuICAgICAgICAgIHZhciBpbnZlcnNlUGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICB2YXIgaW52ZXJzZU5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShQYXRoLm5leHQocGF0aCksIG9wKTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoOiBpbnZlcnNlTmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcblxuICAgICAgICAgIGlmIChfcHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgubmV4dChvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xudmFyIGlzRWRpdG9yID0gdmFsdWUgPT4ge1xuICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWRJc0VkaXRvcjtcbiAgfVxuXG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNFbGVtZW50UmVhZE9ubHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1NlbGVjdGFibGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gIHJldHVybiBpc0VkaXRvcjtcbn07XG5cbnZhciBFZGl0b3IgPSB7XG4gIGFib3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWJvdmUob3B0aW9ucyk7XG4gIH0sXG5cbiAgYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgICBlZGl0b3IuYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfSxcblxuICBhZnRlcihlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5hZnRlcihhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgYmVmb3JlKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmJlZm9yZShhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgZGVsZXRlQmFja3dhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH0sXG5cbiAgZGVsZXRlRm9yd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGb3J3YXJkKHVuaXQpO1xuICB9LFxuXG4gIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChvcHRpb25zKTtcbiAgfSxcblxuICBlZGdlcyhlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5lZGdlcyhhdCk7XG4gIH0sXG5cbiAgZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZWRpdG9yLmVsZW1lbnRSZWFkT25seShvcHRpb25zKTtcbiAgfSxcblxuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZW5kKGF0KTtcbiAgfSxcblxuICBmaXJzdChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5maXJzdChhdCk7XG4gIH0sXG5cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZnJhZ21lbnQoYXQpO1xuICB9LFxuXG4gIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0Jsb2NrcyhlbGVtZW50KTtcbiAgfSxcblxuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzSW5saW5lcyhlbGVtZW50KTtcbiAgfSxcblxuICBoYXNQYXRoKGVkaXRvciwgcGF0aCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzUGF0aChwYXRoKTtcbiAgfSxcblxuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1RleHRzKGVsZW1lbnQpO1xuICB9LFxuXG4gIGluc2VydEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICB9LFxuXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG5cbiAgaW5zZXJ0U29mdEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoKTtcbiAgfSxcblxuICBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIGVkaXRvci5pbnNlcnRUZXh0KHRleHQpO1xuICB9LFxuXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNCbG9jayh2YWx1ZSk7XG4gIH0sXG5cbiAgaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VkZ2UocG9pbnQsIGF0KTtcbiAgfSxcblxuICBpc0VkaXRvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG5cbiAgaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlbGVtZW50KTtcbiAgfSxcblxuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eShlbGVtZW50KTtcbiAgfSxcblxuICBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbmQocG9pbnQsIGF0KTtcbiAgfSxcblxuICBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgaXNOb3JtYWxpemluZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzTm9ybWFsaXppbmcoKTtcbiAgfSxcblxuICBpc1NlbGVjdGFibGUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNTZWxlY3RhYmxlKHZhbHVlKTtcbiAgfSxcblxuICBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1N0YXJ0KHBvaW50LCBhdCk7XG4gIH0sXG5cbiAgaXNWb2lkKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVm9pZCh2YWx1ZSk7XG4gIH0sXG5cbiAgbGFzdChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYXN0KGF0KTtcbiAgfSxcblxuICBsZWFmKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxlYWYoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGxldmVscyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxldmVscyhvcHRpb25zKTtcbiAgfSxcblxuICBtYXJrcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmdldE1hcmtzKCk7XG4gIH0sXG5cbiAgbmV4dChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5leHQob3B0aW9ucyk7XG4gIH0sXG5cbiAgbm9kZShlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5ub2RlKGF0LCBvcHRpb25zKTtcbiAgfSxcblxuICBub2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5vZGVzKG9wdGlvbnMpO1xuICB9LFxuXG4gIG5vcm1hbGl6ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iubm9ybWFsaXplKG9wdGlvbnMpO1xuICB9LFxuXG4gIHBhcmVudChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXJlbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGF0aChhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGhSZWYocGF0aCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoUmVmcygpO1xuICB9LFxuXG4gIHBvaW50KGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50KGF0LCBvcHRpb25zKTtcbiAgfSxcblxuICBwb2ludFJlZihlZGl0b3IsIHBvaW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludFJlZihwb2ludCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnRSZWZzKCk7XG4gIH0sXG5cbiAgcG9zaXRpb25zKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9zaXRpb25zKG9wdGlvbnMpO1xuICB9LFxuXG4gIHByZXZpb3VzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucHJldmlvdXMob3B0aW9ucyk7XG4gIH0sXG5cbiAgcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlKGF0LCB0byk7XG4gIH0sXG5cbiAgcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucmFuZ2VSZWYocmFuZ2UsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmcygpO1xuICB9LFxuXG4gIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgICBlZGl0b3IucmVtb3ZlTWFyayhrZXkpO1xuICB9LFxuXG4gIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgaXNOb3JtYWxpemluZykge1xuICAgIGVkaXRvci5zZXROb3JtYWxpemluZyhpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdGFydChhdCk7XG4gIH0sXG5cbiAgc3RyaW5nKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnN0cmluZyhhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IudW5oYW5nUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHZvaWQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci52b2lkKG9wdGlvbnMpO1xuICB9LFxuXG4gIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZuKSB7XG4gICAgZWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhmbik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICBpc1NwYW4odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHZhbHVlLmV2ZXJ5KFBhdGguaXNQYXRoKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyRiKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkYihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFBvaW50ID0ge1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICBlcXVhbHMocG9pbnQsIGFub3RoZXIpIHtcbiAgICAvLyBQRVJGOiBlbnN1cmUgdGhlIG9mZnNldHMgYXJlIGVxdWFsIGZpcnN0IHNpbmNlIHRoZXkgYXJlIGNoZWFwZXIgdG8gY2hlY2suXG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gYW5vdGhlci5vZmZzZXQgJiYgUGF0aC5lcXVhbHMocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcbiAgfSxcblxuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocG9pbnQsIHAgPT4ge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHA7XG5cbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcblxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQyID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyRhKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRhKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkYShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJGEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUZXh0ID0ge1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQyKTtcblxuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG5cbiAgaXNUZXh0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJztcbiAgfSxcblxuICBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBUZXh0LmlzVGV4dCh2YWwpKTtcbiAgfSxcblxuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGRlY29yYXRpb25zKG5vZGUsIGRlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJGEoe30sIG5vZGUpXTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBsZWFmIG9mIGxlYXZlcykge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9ID0gbGVhZi50ZXh0O1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7IC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG5cbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG59O1xuXG4vKipcclxuICogR2V0IHRoZSBkZWZhdWx0IGxvY2F0aW9uIHRvIGluc2VydCBjb250ZW50IGludG8gdGhlIGVkaXRvci5cclxuICogQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXHJcbiAqIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXHJcbiAqIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxyXG4gKi9cblxudmFyIGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbiA9IGVkaXRvciA9PiB7XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb247XG4gIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzBdO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cblxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cblxuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cblxuICBmb3IgKHZhciBjaGFyIG9mIGNvZGVwb2ludHMpIHtcbiAgICB2YXIgY29kZSA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoY2hhciwgY29kZSk7XG4gICAgW2xlZnQsIHJpZ2h0XSA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcblxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBkaXN0YW5jZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRpc3RhbmNlICs9IGNoYXIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuICAgIHZhciBbY2hhciwgcmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cclxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cblxudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IChzdHIsIGRpc3QsIGlzUlRMKSA9PiB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cblxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICBpZiAoU1BBQ0UudGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDaGFtZWxlb25zIGNvdW50IGFzIHdvcmQgY2hhcmFjdGVycyBhcyBsb25nIGFzIHRoZXkncmUgaW4gYSB3b3JkLCBzb1xuICAvLyByZWN1cnNlIHRvIHNlZSBpZiB0aGUgbmV4dCBvbmUgaXMgYSB3b3JkIGNoYXJhY3RlciBvciBub3QuXG5cblxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoY2hhcikpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgW25leHRDaGFyLCBuZXh0UmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqL1xuXG5cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcblxuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGxvdyBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxuXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcblxudmFyIENvZGVwb2ludFR5cGU7XG5cbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcblxudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcblxudmFyIGdldENvZGVwb2ludFR5cGUgPSAoY2hhciwgY29kZSkgPT4ge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuXG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuXG4gIGlmIChjb2RlID09PSAweDIwMGQpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuWldKO1xuICB9XG5cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cblxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLCAvLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLCAvLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLCAvLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sIC8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSwgLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcblxuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KHIgPT4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKSkgPT09IC0xO1xufVxuXG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcblxudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcblxudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcblxudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBzdHIgPT4ge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG52YXIgVGV4dFRyYW5zZm9ybXMgPSB7XG4gIGRlbGV0ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuZGVsZXRlKG9wdGlvbnMpO1xuICB9LFxuXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcilcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkgfHwgRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gYXQ7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHRleHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG52YXIgYXBwbHkgPSAoZWRpdG9yLCBvcCkgPT4ge1xuICBmb3IgKHZhciByZWYgb2YgRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpIHtcbiAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgfVxuXG4gIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgfVxuXG4gIGZvciAodmFyIF9yZWYyIG9mIEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSkge1xuICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICB9XG5cbiAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICB2YXIgZGlydHlQYXRocztcbiAgdmFyIGRpcnR5UGF0aEtleXM7XG5cbiAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG5cbiAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBkaXJ0eVBhdGhLZXlzLmFkZChrZXkpO1xuICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgZGlydHlQYXRocyA9IFtdO1xuICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgYWRkKG5ld1BhdGgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgfVxuXG4gIHZhciBuZXdEaXJ0eVBhdGhzID0gZWRpdG9yLmdldERpcnR5UGF0aHMob3ApO1xuXG4gIGZvciAodmFyIF9wYXRoIG9mIG5ld0RpcnR5UGF0aHMpIHtcbiAgICBhZGQoX3BhdGgpO1xuICB9XG5cbiAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgZGlydHlQYXRocyk7XG4gIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gIGVkaXRvci5vcGVyYXRpb25zLnB1c2gob3ApO1xuICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvciwge1xuICAgIG9wZXJhdGlvbjogb3BcbiAgfSk7IC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cbiAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXHJcbiAqL1xuXG52YXIgZ2V0RGlydHlQYXRocyA9IChlZGl0b3IsIG9wKSA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aCk7XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIF9wYXRoLmNvbmNhdChwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4ubGV2ZWxzLCAuLi5kZXNjZW5kYW50c107XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgcmV0dXJuIFsuLi5hbmNlc3RvcnMsIHByZXZpb3VzUGF0aF07XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGFuY2VzdG9yIG9mIFBhdGguYW5jZXN0b3JzKF9wYXRoMykpIHtcbiAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgb2xkQW5jZXN0b3JzLnB1c2gocCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpIHtcbiAgICAgICAgICB2YXIgX3AgPSBQYXRoLnRyYW5zZm9ybShfYW5jZXN0b3IsIG9wKTtcblxuICAgICAgICAgIG5ld0FuY2VzdG9ycy5wdXNoKF9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXdBbmNlc3RvcnNbbmV3QW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSBuZXdQYXRoW25ld1BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgIHJldHVybiBbLi4ub2xkQW5jZXN0b3JzLCAuLi5uZXdBbmNlc3RvcnMsIHJlc3VsdFBhdGhdO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9hbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDQpO1xuXG4gICAgICAgIHJldHVybiBbLi4uX2FuY2VzdG9yc107XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDVcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg1KTtcblxuICAgICAgICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQoX3BhdGg1KTtcbiAgICAgICAgcmV0dXJuIFsuLi5fbGV2ZWxzLCBuZXh0UGF0aF07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRGcmFnbWVudCA9IGVkaXRvciA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG5cbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG5cbnZhciBub3JtYWxpemVOb2RlID0gKGVkaXRvciwgZW50cnkpID0+IHtcbiAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5OyAvLyBUaGVyZSBhcmUgbm8gY29yZSBub3JtYWxpemF0aW9ucyBmb3IgdGV4dCBub2Rlcy5cblxuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuXG5cbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGNoaWxkID0ge1xuICAgICAgdGV4dDogJydcbiAgICB9O1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgYXQ6IHBhdGguY29uY2F0KDApLFxuICAgICAgdm9pZHM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuXG5cbiAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7IC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuXG4gIHZhciBuID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgdmFyIF9jaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW25dO1xuICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpOyAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBibG9jayBub2Rlcy4gU2ltaWxhcmx5LCBvbmx5IGFsbG93IGlubGluZSBub2RlcyBpblxuICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgIC8vIHRleHQuXG5cbiAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG4tLTtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdWxkTm9ybWFsaXplID0gKGVkaXRvciwgX3JlZikgPT4ge1xuICB2YXIge1xuICAgIGl0ZXJhdGlvbixcbiAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aFxuICB9ID0gX3JlZjtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuXG4gIGlmIChpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBsZXRlbHkgbm9ybWFsaXplIHRoZSBlZGl0b3IgYWZ0ZXIgXCIuY29uY2F0KG1heEl0ZXJhdGlvbnMsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXCIpKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFib3ZlID0gZnVuY3Rpb24gYWJvdmUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlLFxuICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2hcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gIHZhciByZXZlcnNlID0gbW9kZSA9PT0gJ2xvd2VzdCc7XG5cbiAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgYXQ6IHBhdGgsXG4gICAgdm9pZHMsXG4gICAgbWF0Y2gsXG4gICAgcmV2ZXJzZVxuICB9KSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChuKSkgY29udGludWU7XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgYXQuYW5jaG9yLnBhdGgpICYmIFBhdGguaXNBbmNlc3RvcihwLCBhdC5mb2N1cy5wYXRoKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDgob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBhZGRNYXJrID0gKGVkaXRvciwga2V5LCB2YWx1ZSkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgfVxuXG4gICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGFuY2hvciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIHZhciByYW5nZSA9IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbiAgdmFyIHtcbiAgICBkaXN0YW5jZSA9IDFcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBkID0gMDtcbiAgdmFyIHRhcmdldDtcblxuICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBhdDogcmFuZ2VcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuXG4gICAgZCsrO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIGJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGFuY2hvciA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xuICB2YXIgcmFuZ2UgPSB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZCA9IDA7XG4gIHZhciB0YXJnZXQ7XG5cbiAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuXG4gICAgZCsrO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBkZWxldGVCYWNrd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXQsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWxldGVGb3J3YXJkID0gKGVkaXRvciwgdW5pdCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgdW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRnJhZ21lbnQgPSBmdW5jdGlvbiBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgdmFyIHtcbiAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCdcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZWRnZXMgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gW0VkaXRvci5zdGFydChlZGl0b3IsIGF0KSwgRWRpdG9yLmVuZChlZGl0b3IsIGF0KV07XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBlbGVtZW50UmVhZE9ubHkgPSBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkNShfb2JqZWN0U3ByZWFkJDUoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG4pXG4gIH0pKTtcbn07XG5cbnZhciBlbmQgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbn07XG5cbnZhciBmaXJzdCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG4gIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGZyYWdtZW50ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHJhbmdlKTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIGdldFZvaWQgPSBmdW5jdGlvbiBnZXRWb2lkKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbilcbiAgfSkpO1xufTtcblxudmFyIGhhc0Jsb2NrcyA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc0lubGluZXMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG59O1xuXG52YXIgaGFzUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgaGFzVGV4dHMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KG4gPT4gVGV4dC5pc1RleHQobikpO1xufTtcblxudmFyIGluc2VydEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbnZhciBpbnNlcnROb2RlID0gKGVkaXRvciwgbm9kZSwgb3B0aW9ucykgPT4ge1xuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwgb3B0aW9ucyk7XG59O1xuXG52YXIgaW5zZXJ0U29mdEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIGluc2VydFRleHQgPSBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uLFxuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG5cbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChtYXJrcykge1xuICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDMoe1xuICAgICAgICB0ZXh0XG4gICAgICB9LCBtYXJrcyk7XG5cbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGF0OiBvcHRpb25zLmF0LFxuICAgICAgICB2b2lkczogb3B0aW9ucy52b2lkc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cbn07XG5cbnZhciBpc0Jsb2NrID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xufTtcblxudmFyIGlzRWRnZSA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG59O1xuXG52YXIgaXNFbXB0eSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gZWxlbWVudDtcbiAgdmFyIFtmaXJzdF0gPSBjaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xufTtcblxudmFyIGlzRW5kID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xufTtcblxudmFyIGlzTm9ybWFsaXppbmcgPSBlZGl0b3IgPT4ge1xuICB2YXIgaXNOb3JtYWxpemluZyA9IE5PUk1BTElaSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG59O1xuXG52YXIgaXNTdGFydCA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgaWYgKHBvaW50Lm9mZnNldCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xufTtcblxudmFyIGxhc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgbGVhZiA9IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiogbGV2ZWxzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIG1hdGNoXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICB9XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsZXZlbHMgPSBbXTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSkge1xuICAgIGlmICghbWF0Y2gobiwgcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG5cbiAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJldmVyc2UpIHtcbiAgICBsZXZlbHMucmV2ZXJzZSgpO1xuICB9XG5cbiAgeWllbGQqIGxldmVscztcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJ0ZXh0XCJdO1xudmFyIG1hcmtzID0gZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgbWFya3MsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtYXJrcykge1xuICAgIHJldHVybiBtYXJrcztcbiAgfVxuXG4gIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgW19ub2RlXSA9IG1hdGNoO1xuXG4gICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUsIF9leGNsdWRlZCQxKTtcblxuICAgICAgcmV0dXJuIF9yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIHtcbiAgICBhbmNob3JcbiAgfSA9IHNlbGVjdGlvbjtcbiAgdmFyIHtcbiAgICBwYXRoXG4gIH0gPSBhbmNob3I7XG4gIHZhciBbbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHBhdGgpO1xuXG4gIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuICAgIHZhciBtYXJrZWRWb2lkID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICB9KTtcblxuICAgIGlmICghbWFya2VkVm9pZCkge1xuICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgICB9KTtcblxuICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcbiAgICAgICAgdmFyIFssIGJsb2NrUGF0aF0gPSBibG9jaztcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgbm9kZSA9IHByZXZOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQxKTtcblxuICByZXR1cm4gcmVzdDtcbn07XG5cbnZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIG1hdGNoLFxuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgdmFyIHNwYW4gPSBbcG9pbnRBZnRlckxvY2F0aW9uLnBhdGgsIHRvXTtcblxuICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICB9XG5cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIFtuZXh0XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogc3BhbixcbiAgICBtYXRjaCxcbiAgICBtb2RlLFxuICAgIHZvaWRzXG4gIH0pO1xuICByZXR1cm4gbmV4dDtcbn07XG5cbnZhciBub2RlID0gZnVuY3Rpb24gbm9kZShlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gW25vZGUsIHBhdGhdO1xufTtcblxuZnVuY3Rpb24qIG5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1vZGUgPSAnYWxsJyxcbiAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgdm9pZHMgPSBmYWxzZSxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgbWF0Y2hcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZnJvbTtcbiAgdmFyIHRvO1xuXG4gIGlmIChTcGFuLmlzU3BhbihhdCkpIHtcbiAgICBmcm9tID0gYXRbMF07XG4gICAgdG8gPSBhdFsxXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgfVxuXG4gIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgcmV2ZXJzZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgdmFyIFtub2RlXSA9IF9yZWY7XG4gICAgICBpZiAoIUVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXZvaWRzICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChpZ25vcmVOb25TZWxlY3RhYmxlICYmICFFZGl0b3IuaXNTZWxlY3RhYmxlKGVkaXRvciwgbm9kZSkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBtYXRjaGVzID0gW107XG4gIHZhciBoaXQ7XG5cbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgaWYgKGlnbm9yZU5vblNlbGVjdGFibGUgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIUVkaXRvci5pc1NlbGVjdGFibGUoZWRpdG9yLCBub2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzTG93ZXIgPSBoaXQgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGhpdFsxXSkgPT09IDA7IC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cblxuICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgIC8vIGhpdCwgdGhlbiB3ZSd2ZSBmb3VuZCBhIGJyYW5jaCB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBhIG1hdGNoLCB3aGljaFxuICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuXG5cbiAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICB2YXIgZW1pdCA9IG1vZGUgPT09ICdsb3dlc3QnID8gaGl0IDogW25vZGUsIHBhdGhdO1xuXG4gICAgaWYgKGVtaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gIH0gLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuXG5cbiAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIG1hdGNoZXMucHVzaChoaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBoaXQ7XG4gICAgfVxuICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICBpZiAodW5pdmVyc2FsKSB7XG4gICAgeWllbGQqIG1hdGNoZXM7XG4gIH1cbn1cblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGZvcmNlID0gZmFsc2UsXG4gICAgb3BlcmF0aW9uXG4gIH0gPSBvcHRpb25zO1xuXG4gIHZhciBnZXREaXJ0eVBhdGhzID0gZWRpdG9yID0+IHtcbiAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIH07XG5cbiAgdmFyIGdldERpcnR5UGF0aEtleXMgPSBlZGl0b3IgPT4ge1xuICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICB9O1xuXG4gIHZhciBwb3BEaXJ0eVBhdGggPSBlZGl0b3IgPT4ge1xuICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcikuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgaWYgKCFFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZvcmNlKSB7XG4gICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0pO1xuICAgIHZhciBhbGxQYXRoS2V5cyA9IG5ldyBTZXQoYWxsUGF0aHMubWFwKHAgPT4gcC5qb2luKCcsJykpKTtcbiAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgfVxuXG4gIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAvKlxyXG4gICAgICBGaXggZGlydHkgZWxlbWVudHMgd2l0aCBubyBjaGlsZHJlbi5cclxuICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxyXG4gICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxyXG4gICAgKi9cbiAgICBmb3IgKHZhciBkaXJ0eVBhdGggb2YgZ2V0RGlydHlQYXRocyhlZGl0b3IpKSB7XG4gICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZGlydHlQYXRoKTtcbiAgICAgICAgdmFyIFtub2RlLCBfXSA9IGVudHJ5O1xuICAgICAgICAvKlxyXG4gICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXHJcbiAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgIEFzIGxvbmcgYXMgdGhlIG5vcm1hbGl6ZXIgb25seSBpbnNlcnRzIGNoaWxkIG5vZGVzIGZvciB0aGlzIGNhc2UgaXQgaXMgc2FmZSB0byBkbyBpbiBhbnkgb3JkZXI7XHJcbiAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cclxuICAgICAgICAqL1xuXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKGVudHJ5LCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgd2hpbGUgKGRpcnR5UGF0aHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICBkaXJ0eVBhdGhzLFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICBvcGVyYXRpb25cbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9kaXJ0eVBhdGggPSBwb3BEaXJ0eVBhdGgoZWRpdG9yKTsgLy8gSWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuXG5cbiAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuXG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSwge1xuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgICBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcGFyZW50ID0gZnVuY3Rpb24gcGFyZW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICByZXR1cm4gZW50cnk7XG59O1xuXG52YXIgcGF0aFJlZiA9IGZ1bmN0aW9uIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwYXRoLFxuICAgIGFmZmluaXR5LFxuXG4gICAgdW5yZWYoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcmVmO1xuICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICBwYXRoUmVmcy5kZWxldGUocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBhdGhSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cblxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciBwYXRoID0gZnVuY3Rpb24gcGF0aChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBkZXB0aCxcbiAgICBlZGdlXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGF0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgYXQgPSBhdC5wYXRoO1xuICB9XG5cbiAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgfVxuXG4gIHJldHVybiBhdDtcbn07XG5cbnZhciBwb2ludFJlZiA9IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgIGFmZmluaXR5LFxuXG4gICAgdW5yZWYoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcmVmO1xuICAgICAgdmFyIHBvaW50UmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICAgIHBvaW50UmVmcy5kZWxldGUocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwb2ludFJlZnMgPSBlZGl0b3IgPT4ge1xuICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcG9pbnQgPSBmdW5jdGlvbiBwb2ludChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBlZGdlID0gJ3N0YXJ0J1xuICB9ID0gb3B0aW9ucztcblxuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgdmFyIHBhdGg7XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgIHBhdGggPSBmaXJzdFBhdGg7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBlZGdlID09PSAnZW5kJyA/IG5vZGUudGV4dC5sZW5ndGggOiAwXG4gICAgfTtcbiAgfVxuXG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgfVxuXG4gIHJldHVybiBhdDtcbn07XG5cbmZ1bmN0aW9uKiBwb3NpdGlvbnMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICB2b2lkcyA9IGZhbHNlLFxuICAgIGlnbm9yZU5vblNlbGVjdGFibGUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxyXG4gICAqIEFsZ29yaXRobSBub3RlczpcclxuICAgKlxyXG4gICAqIEVhY2ggc3RlcCBgZGlzdGFuY2VgIGlzIGR5bmFtaWMgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIHRleHRcclxuICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcclxuICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXHJcbiAgICogdHdvIGxldmVscyBpbiBzdGVwLXN5bmM6XHJcbiAgICpcclxuICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXHJcbiAgICogdGhyb3VnaCB1c2luZyB0aGUgY291bnRlcnMgYGxlYWZUZXh0T2Zmc2V0YCBhbmQgYGxlYWZUZXh0UmVtYWluaW5nYC5cclxuICAgKlxyXG4gICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXHJcbiAgICogYnkgYGRpc3RhbmNlYCBldmVyeSB0aW1lIGl0IGlzIGFkdmFuY2VkLlxyXG4gICAqXHJcbiAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxyXG4gICAqIGEgYmxvY2sgbm9kZSBhbHdheXMgYXBwZWFycyBiZWZvcmUgYWxsIG9mIGl0cyBsZWFmIG5vZGVzLlxyXG4gICAqL1xuXG5cbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gIHZhciBibG9ja1RleHQgPSAnJztcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cblxuICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICB2YXIgbGVhZlRleHRPZmZzZXQgPSAwOyAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vZGVzIGluIHJhbmdlLCBncmFiYmluZyBlbnRpcmUgdGV4dHVhbCBjb250ZW50XG4gIC8vIG9mIGJsb2NrIG5vZGVzIGluIGJsb2NrVGV4dCwgYW5kIHRleHQgbm9kZXMgaW4gbGVhZlRleHQuXG4gIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgLy8gZW5jb3VudGVyIHRoZSBibG9jayBub2RlLCB0aGVuIGFsbCBvZiBpdHMgdGV4dCBub2Rlcywgc28gd2hlbiBpdGVyYXRpbmdcbiAgLy8gdGhyb3VnaCB0aGUgYmxvY2tUZXh0IGFuZCBsZWFmVGV4dCB3ZSBqdXN0IG5lZWQgdG8gcmVtZW1iZXIgYSB3aW5kb3cgb2ZcbiAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQsXG4gICAgcmV2ZXJzZSxcbiAgICB2b2lkcyxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlXG4gIH0pKSB7XG4gICAgLypcclxuICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xyXG4gICAgICovXG4gICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgLy8geWllbGQgdGhlaXIgZmlyc3QgcG9pbnQuIElmIHRoZSBgdm9pZHNgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgIGlmICghdm9pZHMgJiYgKGVkaXRvci5pc1ZvaWQobm9kZSkgfHwgZWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KG5vZGUpKSkge1xuICAgICAgICB5aWVsZCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgLy8gY29udHJpYnV0ZSB0byBgYmxvY2tUZXh0YCBvciBgbGVhZlRleHRgIC0gdGhlaXIgcGFyZW50IGFuZFxuICAgICAgLy8gY2hpbGRyZW4gZG8uXG5cblxuICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7IC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuXG4gICAgICBpZiAoRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAvLyAgICAgYGJsb2NrVGV4dD0nJHtibG9ja1RleHR9JyAtIGArXG4gICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgIC8vIHN0YXJ0L2VuZCBlZGdlIGNhc2VzIHdoZXJlIGJsb2NrIGV4dGVuZHMgYmV5b25kIHJhbmdlLlxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgYmxvY2tSYW5nZSkgLy8gaW50ZXJzZWN0XG4gICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgcyA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBzdGFydC5wYXRoKSA/IHN0YXJ0IDogRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgIGZvY3VzOiBlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qXHJcbiAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXHJcbiAgICAgKiBwb3NpdGlvbnMgZXZlcnkgYGRpc3RhbmNlYCBvZmZzZXQgYWNjb3JkaW5nIHRvIGB1bml0YC5cclxuICAgICAqL1xuXG5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7IC8vIFByb29mIHRoYXQgd2UgYWx3YXlzIGV4aGF1c3QgdGV4dCBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgbGVhZiB0ZXh0IG5vZGVgLCBwYXRoKVxuICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cblxuICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSByZXZlcnNlID8gZmlyc3Qub2Zmc2V0IDogbm9kZS50ZXh0Lmxlbmd0aCAtIGZpcnN0Lm9mZnNldDtcbiAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuXG5cbiAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICB9IC8vIFlpZWxkIHBvc2l0aW9ucyBldmVyeSAoZHluYW1pY2FsbHkgY2FsY3VsYXRlZCkgYGRpc3RhbmNlYCBvZmZzZXQuXG5cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAvLyBhbmQgaWYgYmxvY2tUZXh0IGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGFub3RoZXIgYmxvY2sgbm9kZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICBpZiAoYmxvY2tUZXh0ID09PSAnJykgYnJlYWs7XG4gICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTsgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cblxuICAgICAgICAgIGJsb2NrVGV4dCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShibG9ja1RleHQsIGRpc3RhbmNlLCByZXZlcnNlKVsxXTtcbiAgICAgICAgfSAvLyBBZHZhbmNlIGBsZWFmVGV4dGAgYnkgdGhlIGN1cnJlbnQgYGRpc3RhbmNlYC5cblxuXG4gICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IGxlYWZUZXh0UmVtYWluaW5nIC0gZGlzdGFuY2U7IC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgIC8vIGFuZCBzZXQgZGlzdGFuY2UgdG8gdGhlIG92ZXJmbG93IGFtb3VudCwgc28gd2UnbGwgKG1heWJlKVxuICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG5cbiAgICAgICAgaWYgKGxlYWZUZXh0UmVtYWluaW5nIDwgMCkge1xuICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIFN1Y2Nlc3NmdWxseSB3YWxrZWQgYGRpc3RhbmNlYCBvZmZzZXRzIHRocm91Z2ggYGxlYWZUZXh0YFxuICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG5cblxuICAgICAgICBkaXN0YW5jZSA9IDA7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAvLyBIZWxwZXI6XG4gIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cblxuXG4gIGZ1bmN0aW9uIGNhbGNEaXN0YW5jZSh0ZXh0LCB1bml0LCByZXZlcnNlKSB7XG4gICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAnd29yZCcpIHtcbiAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG59XG5cbnZhciBwcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgbWF0Y2gsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9pbnRCZWZvcmVMb2NhdGlvbiA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzXG4gIH0pO1xuXG4gIGlmICghcG9pbnRCZWZvcmVMb2NhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBbLCB0b10gPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSk7IC8vIFRoZSBzZWFyY2ggbG9jYXRpb24gaXMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBwYXRoIG9mXG4gIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuXG4gIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICB9XG5cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIFtwcmV2aW91c10gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICBhdDogc3BhbixcbiAgICBtYXRjaCxcbiAgICBtb2RlLFxuICAgIHZvaWRzXG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG52YXIgcmFuZ2VSZWYgPSBmdW5jdGlvbiByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiByYW5nZSxcbiAgICBhZmZpbml0eSxcblxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICByYW5nZVJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcmFuZ2VSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuXG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHJhbmdlID0gKGVkaXRvciwgYXQsIHRvKSA9PiB7XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICByZXR1cm4gYXQ7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgdG8gfHwgYXQpO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgcmVtb3ZlTWFyayA9IChlZGl0b3IsIGtleSkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgfVxuXG4gICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDIoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KTtcblxuICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzZXROb3JtYWxpemluZyA9IChlZGl0b3IsIGlzTm9ybWFsaXppbmcpID0+IHtcbiAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgaXNOb3JtYWxpemluZyk7XG59O1xuXG52YXIgc3RhcnQgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gIHZhciB0ZXh0ID0gJyc7XG5cbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogcmFuZ2UsXG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgIHZvaWRzXG4gIH0pKSB7XG4gICAgdmFyIHQgPSBub2RlLnRleHQ7XG5cbiAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgfVxuXG4gICAgdGV4dCArPSB0O1xuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG52YXIgdW5oYW5nUmFuZ2UgPSBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpOyAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cblxuICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpIHx8IFBhdGguaGFzUHJldmlvdXMoZW5kLnBhdGgpKSB7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIGF0OiBlbmQsXG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICB2b2lkc1xuICB9KTtcbiAgdmFyIGJsb2NrUGF0aCA9IGVuZEJsb2NrID8gZW5kQmxvY2tbMV0gOiBbXTtcbiAgdmFyIGZpcnN0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgc3RhcnQpO1xuICB2YXIgYmVmb3JlID0ge1xuICAgIGFuY2hvcjogZmlyc3QsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xuICB2YXIgc2tpcCA9IHRydWU7XG5cbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogYmVmb3JlLFxuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICByZXZlcnNlOiB0cnVlLFxuICAgIHZvaWRzXG4gIH0pKSB7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgZW5kID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxudmFyIHdpdGhvdXROb3JtYWxpemluZyA9IChlZGl0b3IsIGZuKSA9PiB7XG4gIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIGZhbHNlKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgdmFsdWUpO1xuICB9XG5cbiAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpO1xufTtcblxudmFyIGRlbGV0ZVRleHQgPSBmdW5jdGlvbiBkZWxldGVUZXh0KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIF9FZGl0b3Ikdm9pZCwgX0VkaXRvciR2b2lkMjtcblxuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICB2YXIgWywgdm9pZFBhdGhdID0gZnVydGhlc3RWb2lkO1xuICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIGF0ID0ge1xuICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgZm9jdXM6IHRhcmdldFxuICAgICAgICB9O1xuICAgICAgICBoYW5naW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgIHZhciBlbmRPZkRvYyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgIGlmICghUG9pbnQuZXF1YWxzKF9lbmQsIGVuZE9mRG9jKSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogc3RhcnQsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogZW5kLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgdmFyIGlzU2luZ2xlVGV4dCA9IFBhdGguZXF1YWxzKHN0YXJ0LnBhdGgsIGVuZC5wYXRoKTtcbiAgICB2YXIgc3RhcnROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQgIT09IHZvaWQgMCA/IF9FZGl0b3Ikdm9pZCA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICB2YXIgZW5kTm9uRWRpdGFibGUgPSB2b2lkcyA/IG51bGwgOiAoX0VkaXRvciR2b2lkMiA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQyICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQyIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTsgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG5cbiAgICBpZiAoc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG5cbiAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgIHN0YXJ0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfSAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4gICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG5cblxuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGxhc3RQYXRoO1xuXG4gICAgZm9yICh2YXIgZW50cnkgb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgbGFzdFBhdGgpID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICBsYXN0UGF0aCA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgdmFyIHJlbW92ZWRUZXh0ID0gJyc7XG5cbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIF9wb2ludCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoXG4gICAgICB9ID0gX3BvaW50O1xuICAgICAgdmFyIHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgIHZhciB0ZXh0ID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHAsXG4gICAgICB2b2lkc1xuICAgIH0pKTtcblxuICAgIGlmICghZW5kTm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgW19ub2RlMl0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICB9ID0gX3BvaW50MjtcblxuICAgICAgdmFyIF9vZmZzZXQgPSBpc1NpbmdsZVRleHQgPyBzdGFydC5vZmZzZXQgOiAwO1xuXG4gICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoMixcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gX3RleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9IC8vIEZvciBUaGFpIHNjcmlwdCwgZGVsZXRpbmcgTiBjaGFyYWN0ZXIocykgYmFja3dhcmQgc2hvdWxkIGRlbGV0ZVxuICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cblxuXG4gICAgaWYgKGlzQ29sbGFwc2VkICYmIHJldmVyc2UgJiYgdW5pdCA9PT0gJ2NoYXJhY3RlcicgJiYgcmVtb3ZlZFRleHQubGVuZ3RoID4gMSAmJiByZW1vdmVkVGV4dC5tYXRjaCgvW1xcdTBFMDAtXFx1MEU3Rl0rLykpIHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0VW5yZWYgPSBzdGFydFJlZi51bnJlZigpO1xuICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcblxuICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIH1cblxuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcblxuICAgIGlmIChpbmxpbmVFbGVtZW50TWF0Y2gpIHtcbiAgICAgIHZhciBbLCBfaW5saW5lUGF0aF0gPSBpbmxpbmVFbGVtZW50TWF0Y2g7XG5cbiAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGJsb2NrUGF0aF0gPSBibG9ja01hdGNoO1xuICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICB2YXIgbWF0Y2hlciA9IF9yZWYgPT4ge1xuICAgICAgdmFyIFtuLCBwXSA9IF9yZWY7XG4gICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG5cbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lcmdlRW5kICYmIFBhdGguaXNBbmNlc3RvcihwLCBsYXN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBlbnRyeSBvZiBOb2RlLm5vZGVzKHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIHtcbiAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICB9KSkge1xuICAgICAgaWYgKG1hdGNoZXIoZW50cnkpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgdmFyIGVuZHMgPSBbXTtcbiAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIFtub2RlXSBvZiBtYXRjaGVzKSB7XG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICBoYXNCbG9ja3MgPSB0cnVlO1xuICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgIHN0YXJ0cy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IGhhc0Jsb2NrcyA/IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgc3RhcnRzLCB7XG4gICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcblxuICAgIGlmIChpc0Jsb2NrRW1wdHkgJiYgIXN0YXJ0cy5sZW5ndGggJiYgbWlkZGxlcy5sZW5ndGggJiYgIWVuZHMubGVuZ3RoKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtaWRkbGVzLCB7XG4gICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlbmRzLCB7XG4gICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYXQpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKGVuZFJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobWlkZGxlcy5sZW5ndGggPiAwICYmIG1pZGRsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhzdGFydFJlZi5jdXJyZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFJlZi51bnJlZigpO1xuICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgIGVuZFJlZi51bnJlZigpO1xuICB9KTtcbn07XG5cbnZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgZWRnZSA9ICdhbmNob3InXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBlbmQpO1xuICB9XG59O1xuXG52YXIgZGVzZWxlY3QgPSBlZGl0b3IgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgbW92ZSA9IGZ1bmN0aW9uIG1vdmUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBkaXN0YW5jZSA9IDEsXG4gICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgIHJldmVyc2UgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBlZGdlID0gbnVsbFxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuXG4gIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gIH1cblxuICB2YXIge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIgb3B0cyA9IHtcbiAgICBkaXN0YW5jZSxcbiAgICB1bml0LFxuICAgIGlnbm9yZU5vblNlbGVjdGFibGU6IHRydWVcbiAgfTtcbiAgdmFyIHByb3BzID0ge307XG5cbiAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG5cbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgIH1cbiAgfVxuXG4gIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgIHZhciBfcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGZvY3VzLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGZvY3VzLCBvcHRzKTtcblxuICAgIGlmIChfcG9pbnQpIHtcbiAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgIH1cbiAgfVxuXG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xufTtcblxudmFyIHNlbGVjdCA9IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gIH1cblxuICBlZGl0b3IuYXBwbHkoe1xuICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgbmV3UHJvcGVydGllczogdGFyZ2V0XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiBzZXRQb2ludChlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBlZGdlID0gJ2JvdGgnXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICB9XG5cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuXG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgIFtlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJ106IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvaW50KSwgcHJvcHMpXG4gIH0pO1xufTtcblxudmFyIHNldFNlbGVjdGlvbiA9IChlZGl0b3IsIHByb3BzKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciBvbGRQcm9wcyA9IHt9O1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICBpZiAoayA9PT0gJ2FuY2hvcicgJiYgcHJvcHMuYW5jaG9yICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5hbmNob3IsIHNlbGVjdGlvbi5hbmNob3IpIHx8IGsgPT09ICdmb2N1cycgJiYgcHJvcHMuZm9jdXMgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmZvY3VzLCBzZWxlY3Rpb24uZm9jdXMpIHx8IGsgIT09ICdhbmNob3InICYmIGsgIT09ICdmb2N1cycgJiYgcHJvcHNba10gIT09IHNlbGVjdGlvbltrXSkge1xuICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpbnNlcnROb2RlcyA9IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBzZWxlY3RcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFtub2RlXSA9IG5vZGVzO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKTtcbiAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdCA9PSBudWxsKSB7XG4gICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtlbnRyeV0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdC5wYXRoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdmFyIFssIG1hdGNoUGF0aF0gPSBlbnRyeTtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIG1hdGNoUGF0aCk7XG4gICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIG1hdGNoUGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KGF0KTtcbiAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcGFyZW50UGF0aFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIHZhciBfcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcblxuICAgICAgaW5kZXgrKztcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgfSk7XG4gICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgfVxuXG4gICAgYXQgPSBQYXRoLnByZXZpb3VzKGF0KTtcblxuICAgIGlmIChzZWxlY3QpIHtcbiAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGxpZnROb2RlcyA9IGZ1bmN0aW9uIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudE5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpO1xuICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gcGFyZW50LmNoaWxkcmVuO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhcmVudFBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgdmFyIF90b1BhdGgyID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuXG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogX3RvUGF0aDIsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIG1lcmdlTm9kZXMgPSBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG5cbiAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgW25vZGUsIHBhdGhdID0gY3VycmVudDtcbiAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICB2YXIgaXNQcmV2aW91c1NpYmxpbmcgPSBQYXRoLmlzU2libGluZyhwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSksIF9yZWYgPT4ge1xuICAgICAgdmFyIFtuXSA9IF9yZWY7XG4gICAgICByZXR1cm4gbjtcbiAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIG1hdGNoOiBuID0+IGxldmVscy5pbmNsdWRlcyhuKSAmJiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBuKVxuICAgIH0pO1xuICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICB2YXIgcHJvcGVydGllcztcbiAgICB2YXIgcG9zaXRpb247IC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dChwcmV2Tm9kZSkpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG5cbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVjYXVzZSBpdCBpcyBub3QgdGhlIHNhbWUga2luZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgIH0gLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH0gLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cblxuXG4gICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH0gLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbiAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpICYmIEVkaXRvci5pc0VtcHR5KGVkaXRvciwgcHJldk5vZGUpIHx8IFRleHQuaXNUZXh0KHByZXZOb2RlKSAmJiBwcmV2Tm9kZS50ZXh0ID09PSAnJyAmJiBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIG1vdmVOb2RlcyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgdG8sXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cblxuICAgIHZhciB0b1JlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgdG8pO1xuICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9SZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlTm9kZXMgPSBmdW5jdGlvbiByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cblxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGRlcHRocyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKGRlcHRocywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBzZXROb2RlcyA9IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGNvbXBhcmUsXG4gICAgICBtZXJnZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQgaW4gYSBub24tZW1wdHkgbm9kZSBhbmQgJ3NwbGl0JyBpcyB0cnVlLCB0aGVyZSdzIG5vdGhpbmcgdG9cbiAgICAgICAgLy8gc2V0IHRoYXQgd29uJ3QgZ2V0IG5vcm1hbGl6ZWQgYXdheVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICB2YXIgZW5kQXRFbmRPZk5vZGUgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBlbmQsIGVuZC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbXBhcmUpIHtcbiAgICAgIGNvbXBhcmUgPSAocHJvcCwgbm9kZVByb3ApID0+IHByb3AgIT09IG5vZGVQcm9wO1xuICAgIH1cblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICB2YXIgbmV3UHJvcGVydGllcyA9IHt9OyAvLyBZb3UgY2FuJ3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIGVkaXRvciBub2RlLlxuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGsgPT09ICdjaGlsZHJlbicgfHwgayA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShwcm9wc1trXSwgbm9kZVtrXSkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107IC8vIE9taXQgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG5ldyBwcm9wZXJ0aWVzIGxpc3RcblxuICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3NldF9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXHJcbiAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgcG9pbnQgYnkgZGVsZXRpbmcgaXQncyBjb250ZW50LlxyXG4gKi9cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgc3BsaXROb2RlcyA9IGZ1bmN0aW9uIHNwbGl0Tm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGhlaWdodCA9IDAsXG4gICAgICBhbHdheXMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICB9IC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIHBhdGggPSBhdDtcbiAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICBtYXRjaCA9IG4gPT4gbiA9PT0gcGFyZW50O1xuXG4gICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICBhbHdheXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgdmFyIGFmdGVyUmVmO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIG51ZGdlID0gMDtcblxuICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudCh2b2lkTm9kZSkgJiYgZWRpdG9yLmlzSW5saW5lKHZvaWROb2RlKSkge1xuICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHZvaWRQYXRoKTtcblxuICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZnRlclBhdGggPSBQYXRoLm5leHQodm9pZFBhdGgpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nSGVpZ2h0ID0gYXQucGF0aC5sZW5ndGggLSB2b2lkUGF0aC5sZW5ndGg7XG4gICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuICAgICAgdmFyIFssIGhpZ2hlc3RQYXRoXSA9IGhpZ2hlc3Q7XG4gICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcblxuICAgICAgZm9yICh2YXIgW25vZGUsIF9wYXRoXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfcGF0aC5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgubGVuZ3RoID09PSAwIHx8ICF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfcG9pbnQgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aCk7XG5cbiAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aCkpIHtcbiAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBOb2RlLmV4dHJhY3RQcm9wcyhub2RlKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uID0gX3BhdGhbX3BhdGgubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdmFyIF9hZnRlclJlZjtcblxuICAgICAgYmVmb3JlUmVmLnVucmVmKCk7XG4gICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciB1bnNldE5vZGVzID0gZnVuY3Rpb24gdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgcHJvcHMgPSBbcHJvcHNdO1xuICB9XG5cbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgIG9ialtrZXldID0gbnVsbDtcbiAgfVxuXG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xufTtcblxudmFyIHVud3JhcE5vZGVzID0gZnVuY3Rpb24gdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSAvLyB1bndyYXBOb2RlIHdpbGwgY2FsbCBsaWZ0Tm9kZSB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IHNwbGl0dGluZyB0aGUgbm9kZSB3aGVuIG5lc3RlZC5cbiAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgIC8vIHRoYXQgd3JhcCB0YXJnZXQgbm9kZS4gU28gd2UgcmV2ZXJzZSB0aGUgb3JkZXIuXG4gICAgKS5yZXZlcnNlKCk7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmIChzcGxpdCAmJiByYW5nZVJlZikge1xuICAgICAgICByYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZVJlZi5jdXJyZW50LCByYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIF9sb29wKHBhdGhSZWYpO1xuICAgIH1cblxuICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHdyYXBOb2RlcyA9IGZ1bmN0aW9uIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hQYXRoKGVkaXRvciwgYXQpO1xuICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290cyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgWywgcm9vdFBhdGhdIG9mIHJvb3RzKSB7XG4gICAgICB2YXIgYSA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gUmFuZ2UuaW50ZXJzZWN0aW9uKGF0LCBFZGl0b3IucmFuZ2UoZWRpdG9yLCByb290UGF0aCkpIDogYXQ7XG5cbiAgICAgIGlmICghYSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGEsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBbZmlyc3RdID0gbWF0Y2hlcztcbiAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IGZpcnN0O1xuICAgICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBsYXN0O1xuXG4gICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIG1hdGNoaW5nIHBhcmVudCAtIHVzdWFsbHkgbWVhbnMgdGhlIG5vZGUgaXMgYW4gZWRpdG9yIC0gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmVxdWFscyhmaXJzdFBhdGgsIGxhc3RQYXRoKSA/IFBhdGgucGFyZW50KGZpcnN0UGF0aCkgOiBQYXRoLmNvbW1vbihmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICB2YXIgW2NvbW1vbk5vZGVdID0gY29tbW9uTm9kZUVudHJ5O1xuICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgIHZhciB3cmFwcGVyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgIGF0OiB3cmFwcGVyUGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgIHRvOiB3cmFwcGVyUGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzRWxlbWVudFJlYWRPbmx5OiAoKSA9PiBmYWxzZSxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNTZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxuICAgIGlzVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgbWFya2FibGVWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgLy8gQ29yZVxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcHBseShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgLy8gRWRpdG9yXG4gICAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZE1hcmsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUJhY2t3YXJkOiBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZXRlRm9yd2FyZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbiBnZXRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnRCcmVhayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnRTb2Z0QnJlYWsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc2VydEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTBdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnROb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTFdID0gYXJndW1lbnRzW19rZXkxMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnRUZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBmdW5jdGlvbiBub3JtYWxpemVOb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMiksIF9rZXkxMiA9IDA7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTJdID0gYXJndW1lbnRzW19rZXkxMl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtYWxpemVOb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMyksIF9rZXkxMyA9IDA7IF9rZXkxMyA8IF9sZW4xMzsgX2tleTEzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTNdID0gYXJndW1lbnRzW19rZXkxM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmVNYXJrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXREaXJ0eVBhdGhzOiBmdW5jdGlvbiBnZXREaXJ0eVBhdGhzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNCksIF9rZXkxNCA9IDA7IF9rZXkxNCA8IF9sZW4xNDsgX2tleTE0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTRdID0gYXJndW1lbnRzW19rZXkxNF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXREaXJ0eVBhdGhzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzaG91bGROb3JtYWxpemU6IGZ1bmN0aW9uIHNob3VsZE5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTUpLCBfa2V5MTUgPSAwOyBfa2V5MTUgPCBfbGVuMTU7IF9rZXkxNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE1XSA9IGFyZ3VtZW50c1tfa2V5MTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkTm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3IgaW50ZXJmYWNlXG4gICAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNiksIF9rZXkxNiA9IDA7IF9rZXkxNiA8IF9sZW4xNjsgX2tleTE2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhYm92ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNyksIF9rZXkxNyA9IDA7IF9rZXkxNyA8IF9sZW4xNzsgX2tleTE3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTddID0gYXJndW1lbnRzW19rZXkxN107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZnRlcihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE4KSwgX2tleTE4ID0gMDsgX2tleTE4IDwgX2xlbjE4OyBfa2V5MTgrKykge1xuICAgICAgICBhcmdzW19rZXkxOF0gPSBhcmd1bWVudHNbX2tleTE4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJlZm9yZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOSksIF9rZXkxOSA9IDA7IF9rZXkxOSA8IF9sZW4xOTsgX2tleTE5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTldID0gYXJndW1lbnRzW19rZXkxOV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsYXBzZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjApLCBfa2V5MjAgPSAwOyBfa2V5MjAgPCBfbGVuMjA7IF9rZXkyMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIwXSA9IGFyZ3VtZW50c1tfa2V5MjBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZXRlVGV4dChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMSksIF9rZXkyMSA9IDA7IF9rZXkyMSA8IF9sZW4yMTsgX2tleTIxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjFdID0gYXJndW1lbnRzW19rZXkyMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNlbGVjdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMiksIF9rZXkyMiA9IDA7IF9rZXkyMiA8IF9sZW4yMjsgX2tleTIyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjJdID0gYXJndW1lbnRzW19rZXkyMl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIzKSwgX2tleTIzID0gMDsgX2tleTIzIDwgX2xlbjIzOyBfa2V5MjMrKykge1xuICAgICAgICBhcmdzW19rZXkyM10gPSBhcmd1bWVudHNbX2tleTIzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRSZWFkT25seShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI0KSwgX2tleTI0ID0gMDsgX2tleTI0IDwgX2xlbjI0OyBfa2V5MjQrKykge1xuICAgICAgICBhcmdzW19rZXkyNF0gPSBhcmd1bWVudHNbX2tleTI0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNSksIF9rZXkyNSA9IDA7IF9rZXkyNSA8IF9sZW4yNTsgX2tleTI1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjVdID0gYXJndW1lbnRzW19rZXkyNV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXJzdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNiksIF9rZXkyNiA9IDA7IF9rZXkyNiA8IF9sZW4yNjsgX2tleTI2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjZdID0gYXJndW1lbnRzW19rZXkyNl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0TWFya3M6IGZ1bmN0aW9uIGdldE1hcmtzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjcpLCBfa2V5MjcgPSAwOyBfa2V5MjcgPCBfbGVuMjc7IF9rZXkyNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI3XSA9IGFyZ3VtZW50c1tfa2V5MjddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3MoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc0Jsb2NrczogZnVuY3Rpb24gaGFzQmxvY2tzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOCksIF9rZXkyOCA9IDA7IF9rZXkyOCA8IF9sZW4yODsgX2tleTI4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjhdID0gYXJndW1lbnRzW19rZXkyOF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNCbG9ja3MoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI5KSwgX2tleTI5ID0gMDsgX2tleTI5IDwgX2xlbjI5OyBfa2V5MjkrKykge1xuICAgICAgICBhcmdzW19rZXkyOV0gPSBhcmd1bWVudHNbX2tleTI5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc0lubGluZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMwKSwgX2tleTMwID0gMDsgX2tleTMwIDwgX2xlbjMwOyBfa2V5MzArKykge1xuICAgICAgICBhcmdzW19rZXkzMF0gPSBhcmd1bWVudHNbX2tleTMwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc1BhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc1RleHRzOiBmdW5jdGlvbiBoYXNUZXh0cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzEpLCBfa2V5MzEgPSAwOyBfa2V5MzEgPCBfbGVuMzE7IF9rZXkzMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMxXSA9IGFyZ3VtZW50c1tfa2V5MzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzVGV4dHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydE5vZGVzOiBmdW5jdGlvbiBpbnNlcnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzIpLCBfa2V5MzIgPSAwOyBfa2V5MzIgPCBfbGVuMzI7IF9rZXkzMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMyXSA9IGFyZ3VtZW50c1tfa2V5MzJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2skMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMzKSwgX2tleTMzID0gMDsgX2tleTMzIDwgX2xlbjMzOyBfa2V5MzMrKykge1xuICAgICAgICBhcmdzW19rZXkzM10gPSBhcmd1bWVudHNbX2tleTMzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzQmxvY2soZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNCksIF9rZXkzNCA9IDA7IF9rZXkzNCA8IF9sZW4zNDsgX2tleTM0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzRdID0gYXJndW1lbnRzW19rZXkzNF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0VkZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM1KSwgX2tleTM1ID0gMDsgX2tleTM1IDwgX2xlbjM1OyBfa2V5MzUrKykge1xuICAgICAgICBhcmdzW19rZXkzNV0gPSBhcmd1bWVudHNbX2tleTM1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRW1wdHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRW5kOiBmdW5jdGlvbiBpc0VuZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzYpLCBfa2V5MzYgPSAwOyBfa2V5MzYgPCBfbGVuMzY7IF9rZXkzNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM2XSA9IGFyZ3VtZW50c1tfa2V5MzZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFbmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzTm9ybWFsaXppbmc6IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM3KSwgX2tleTM3ID0gMDsgX2tleTM3IDwgX2xlbjM3OyBfa2V5MzcrKykge1xuICAgICAgICBhcmdzW19rZXkzN10gPSBhcmd1bWVudHNbX2tleTM3XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzTm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM4KSwgX2tleTM4ID0gMDsgX2tleTM4IDwgX2xlbjM4OyBfa2V5MzgrKykge1xuICAgICAgICBhcmdzW19rZXkzOF0gPSBhcmd1bWVudHNbX2tleTM4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzU3RhcnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM5KSwgX2tleTM5ID0gMDsgX2tleTM5IDwgX2xlbjM5OyBfa2V5MzkrKykge1xuICAgICAgICBhcmdzW19rZXkzOV0gPSBhcmd1bWVudHNbX2tleTM5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxlYWY6IGZ1bmN0aW9uIGxlYWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQwKSwgX2tleTQwID0gMDsgX2tleTQwIDwgX2xlbjQwOyBfa2V5NDArKykge1xuICAgICAgICBhcmdzW19rZXk0MF0gPSBhcmd1bWVudHNbX2tleTQwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlYWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MSksIF9rZXk0MSA9IDA7IF9rZXk0MSA8IF9sZW40MTsgX2tleTQxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDFdID0gYXJndW1lbnRzW19rZXk0MV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXZlbHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxpZnROb2RlczogZnVuY3Rpb24gbGlmdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MiksIF9rZXk0MiA9IDA7IF9rZXk0MiA8IF9sZW40MjsgX2tleTQyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDJdID0gYXJndW1lbnRzW19rZXk0Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaWZ0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1lcmdlTm9kZXM6IGZ1bmN0aW9uIG1lcmdlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQzKSwgX2tleTQzID0gMDsgX2tleTQzIDwgX2xlbjQzOyBfa2V5NDMrKykge1xuICAgICAgICBhcmdzW19rZXk0M10gPSBhcmd1bWVudHNbX2tleTQzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ0KSwgX2tleTQ0ID0gMDsgX2tleTQ0IDwgX2xlbjQ0OyBfa2V5NDQrKykge1xuICAgICAgICBhcmdzW19rZXk0NF0gPSBhcmd1bWVudHNbX2tleTQ0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1vdmVOb2RlczogZnVuY3Rpb24gbW92ZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NSksIF9rZXk0NSA9IDA7IF9rZXk0NSA8IF9sZW40NTsgX2tleTQ1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDVdID0gYXJndW1lbnRzW19rZXk0NV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3ZlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ2KSwgX2tleTQ2ID0gMDsgX2tleTQ2IDwgX2xlbjQ2OyBfa2V5NDYrKykge1xuICAgICAgICBhcmdzW19rZXk0Nl0gPSBhcmd1bWVudHNbX2tleTQ2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ3KSwgX2tleTQ3ID0gMDsgX2tleTQ3IDwgX2xlbjQ3OyBfa2V5NDcrKykge1xuICAgICAgICBhcmdzW19rZXk0N10gPSBhcmd1bWVudHNbX2tleTQ3XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vZGVzOiBmdW5jdGlvbiBub2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDgpLCBfa2V5NDggPSAwOyBfa2V5NDggPCBfbGVuNDg7IF9rZXk0OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ4XSA9IGFyZ3VtZW50c1tfa2V5NDhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OSksIF9rZXk0OSA9IDA7IF9rZXk0OSA8IF9sZW40OTsgX2tleTQ5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDldID0gYXJndW1lbnRzW19rZXk0OV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtYWxpemUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MCksIF9rZXk1MCA9IDA7IF9rZXk1MCA8IF9sZW41MDsgX2tleTUwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTBdID0gYXJndW1lbnRzW19rZXk1MF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUxKSwgX2tleTUxID0gMDsgX2tleTUxIDwgX2xlbjUxOyBfa2V5NTErKykge1xuICAgICAgICBhcmdzW19rZXk1MV0gPSBhcmd1bWVudHNbX2tleTUxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUyKSwgX2tleTUyID0gMDsgX2tleTUyIDwgX2xlbjUyOyBfa2V5NTIrKykge1xuICAgICAgICBhcmdzW19rZXk1Ml0gPSBhcmd1bWVudHNbX2tleTUyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGhSZWZzOiBmdW5jdGlvbiBwYXRoUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTMpLCBfa2V5NTMgPSAwOyBfa2V5NTMgPCBfbGVuNTM7IF9rZXk1MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUzXSA9IGFyZ3VtZW50c1tfa2V5NTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aFJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTQpLCBfa2V5NTQgPSAwOyBfa2V5NTQgPCBfbGVuNTQ7IF9rZXk1NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU0XSA9IGFyZ3VtZW50c1tfa2V5NTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50UmVmOiBmdW5jdGlvbiBwb2ludFJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTUpLCBfa2V5NTUgPSAwOyBfa2V5NTUgPCBfbGVuNTU7IF9rZXk1NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU1XSA9IGFyZ3VtZW50c1tfa2V5NTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnRSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50UmVmczogZnVuY3Rpb24gcG9pbnRSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NiksIF9rZXk1NiA9IDA7IF9rZXk1NiA8IF9sZW41NjsgX2tleTU2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTZdID0gYXJndW1lbnRzW19rZXk1Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludFJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NyksIF9rZXk1NyA9IDA7IF9rZXk1NyA8IF9sZW41NzsgX2tleTU3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTddID0gYXJndW1lbnRzW19rZXk1N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTgpLCBfa2V5NTggPSAwOyBfa2V5NTggPCBfbGVuNTg7IF9rZXk1OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU4XSA9IGFyZ3VtZW50c1tfa2V5NThdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlOiBmdW5jdGlvbiByYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTkpLCBfa2V5NTkgPSAwOyBfa2V5NTkgPCBfbGVuNTk7IF9rZXk1OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU5XSA9IGFyZ3VtZW50c1tfa2V5NTldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmOiBmdW5jdGlvbiByYW5nZVJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjApLCBfa2V5NjAgPSAwOyBfa2V5NjAgPCBfbGVuNjA7IF9rZXk2MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYwXSA9IGFyZ3VtZW50c1tfa2V5NjBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2VSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MSksIF9rZXk2MSA9IDA7IF9rZXk2MSA8IF9sZW42MTsgX2tleTYxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjFdID0gYXJndW1lbnRzW19rZXk2MV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZVJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGVzOiBmdW5jdGlvbiByZW1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjIpLCBfa2V5NjIgPSAwOyBfa2V5NjIgPCBfbGVuNjI7IF9rZXk2MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYyXSA9IGFyZ3VtZW50c1tfa2V5NjJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MyksIF9rZXk2MyA9IDA7IF9rZXk2MyA8IF9sZW42MzsgX2tleTYzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjNdID0gYXJndW1lbnRzW19rZXk2M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjQpLCBfa2V5NjQgPSAwOyBfa2V5NjQgPCBfbGVuNjQ7IF9rZXk2NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY0XSA9IGFyZ3VtZW50c1tfa2V5NjRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjUpLCBfa2V5NjUgPSAwOyBfa2V5NjUgPCBfbGVuNjU7IF9rZXk2NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY1XSA9IGFyZ3VtZW50c1tfa2V5NjVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiBzZXRQb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjYpLCBfa2V5NjYgPSAwOyBfa2V5NjYgPCBfbGVuNjY7IF9rZXk2NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY2XSA9IGFyZ3VtZW50c1tfa2V5NjZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0UG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NyksIF9rZXk2NyA9IDA7IF9rZXk2NyA8IF9sZW42NzsgX2tleTY3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjddID0gYXJndW1lbnRzW19rZXk2N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRTZWxlY3Rpb24oZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY4KSwgX2tleTY4ID0gMDsgX2tleTY4IDwgX2xlbjY4OyBfa2V5NjgrKykge1xuICAgICAgICBhcmdzW19rZXk2OF0gPSBhcmd1bWVudHNbX2tleTY4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwbGl0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjkpLCBfa2V5NjkgPSAwOyBfa2V5NjkgPCBfbGVuNjk7IF9rZXk2OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY5XSA9IGFyZ3VtZW50c1tfa2V5NjldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MCksIF9rZXk3MCA9IDA7IF9rZXk3MCA8IF9sZW43MDsgX2tleTcwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzBdID0gYXJndW1lbnRzW19rZXk3MF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJpbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzEpLCBfa2V5NzEgPSAwOyBfa2V5NzEgPCBfbGVuNzE7IF9rZXk3MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcxXSA9IGFyZ3VtZW50c1tfa2V5NzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5oYW5nUmFuZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcyKSwgX2tleTcyID0gMDsgX2tleTcyIDwgX2xlbjcyOyBfa2V5NzIrKykge1xuICAgICAgICBhcmdzW19rZXk3Ml0gPSBhcmd1bWVudHNbX2tleTcyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuc2V0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjczID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzMpLCBfa2V5NzMgPSAwOyBfa2V5NzMgPCBfbGVuNzM7IF9rZXk3MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTczXSA9IGFyZ3VtZW50c1tfa2V5NzNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW53cmFwTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHZvaWQ6IGZ1bmN0aW9uIF92b2lkKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzQpLCBfa2V5NzQgPSAwOyBfa2V5NzQgPCBfbGVuNzQ7IF9rZXk3NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc0XSA9IGFyZ3VtZW50c1tfa2V5NzRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0Vm9pZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd2l0aG91dE5vcm1hbGl6aW5nOiBmdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc1KSwgX2tleTc1ID0gMDsgX2tleTc1IDwgX2xlbjc1OyBfa2V5NzUrKykge1xuICAgICAgICBhcmdzW19rZXk3NV0gPSBhcmd1bWVudHNbX2tleTc1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd3JhcE5vZGVzOiBmdW5jdGlvbiB3cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc2KSwgX2tleTc2ID0gMDsgX2tleTc2IDwgX2xlbjc2OyBfa2V5NzYrKykge1xuICAgICAgICBhcmdzW19rZXk3Nl0gPSBhcmd1bWVudHNbX2tleTc2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyYXBOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmV4cG9ydCB7IEVkaXRvciwgRWxlbWVudCwgTG9jYXRpb24sIE5vZGUsIE9wZXJhdGlvbiwgUGF0aCwgUGF0aFJlZiwgUG9pbnQsIFBvaW50UmVmLCBSYW5nZSwgUmFuZ2VSZWYsIFNjcnViYmVyLCBTcGFuLCBUZXh0LCBUcmFuc2Zvcm1zLCBhYm92ZSwgYWRkTWFyaywgYWZ0ZXIsIGFwcGx5LCBiZWZvcmUsIGNvbGxhcHNlLCBjcmVhdGVFZGl0b3IsIGRlbGV0ZUJhY2t3YXJkLCBkZWxldGVGb3J3YXJkLCBkZWxldGVGcmFnbWVudCwgZGVsZXRlVGV4dCwgZGVzZWxlY3QsIGVkZ2VzLCBlbGVtZW50UmVhZE9ubHksIGVuZCwgZmlyc3QsIGZyYWdtZW50LCBnZXREaXJ0eVBhdGhzLCBnZXRGcmFnbWVudCwgZ2V0Vm9pZCwgaGFzQmxvY2tzLCBoYXNJbmxpbmVzLCBoYXNQYXRoLCBoYXNUZXh0cywgaW5zZXJ0QnJlYWssIGluc2VydEZyYWdtZW50LCBpbnNlcnROb2RlLCBpbnNlcnROb2RlcywgaW5zZXJ0U29mdEJyZWFrLCBpbnNlcnRUZXh0LCBpc0Jsb2NrLCBpc0VkZ2UsIGlzRWRpdG9yLCBpc0VtcHR5LCBpc0VuZCwgaXNOb3JtYWxpemluZywgaXNTdGFydCwgbGFzdCwgbGVhZiwgbGV2ZWxzLCBsaWZ0Tm9kZXMsIG1hcmtzLCBtZXJnZU5vZGVzLCBtb3ZlLCBtb3ZlTm9kZXMsIG5leHQsIG5vZGUsIG5vZGVzLCBub3JtYWxpemUsIG5vcm1hbGl6ZU5vZGUsIHBhcmVudCwgcGF0aCwgcGF0aFJlZiwgcGF0aFJlZnMsIHBvaW50LCBwb2ludFJlZiwgcG9pbnRSZWZzLCBwb3NpdGlvbnMsIHByZXZpb3VzLCByYW5nZSwgcmFuZ2VSZWYsIHJhbmdlUmVmcywgcmVtb3ZlTWFyaywgcmVtb3ZlTm9kZXMsIHNlbGVjdCwgc2V0Tm9kZXMsIHNldE5vcm1hbGl6aW5nLCBzZXRQb2ludCwgc2V0U2VsZWN0aW9uLCBzaG91bGROb3JtYWxpemUsIHNwbGl0Tm9kZXMsIHN0YXJ0LCBzdHJpbmcsIHVuaGFuZ1JhbmdlLCB1bnNldE5vZGVzLCB1bndyYXBOb2Rlcywgd2l0aG91dE5vcm1hbGl6aW5nLCB3cmFwTm9kZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiaXNEcmFmdCIsInByb2R1Y2UiLCJQYXRoUmVmIiwidHJhbnNmb3JtIiwicmVmIiwib3AiLCJjdXJyZW50IiwiYWZmaW5pdHkiLCJwYXRoIiwiUGF0aCIsInVucmVmIiwiUG9pbnRSZWYiLCJwb2ludCIsIlBvaW50IiwiUmFuZ2VSZWYiLCJSYW5nZSIsIkRJUlRZX1BBVEhTIiwiV2Vha01hcCIsIkRJUlRZX1BBVEhfS0VZUyIsIkZMVVNISU5HIiwiTk9STUFMSVpJTkciLCJQQVRIX1JFRlMiLCJQT0lOVF9SRUZTIiwiUkFOR0VfUkVGUyIsImFuY2VzdG9ycyIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyZXZlcnNlIiwicGF0aHMiLCJsZXZlbHMiLCJzbGljZSIsImNvbW1vbiIsImFub3RoZXIiLCJpIiwiYXYiLCJidiIsInB1c2giLCJjb21wYXJlIiwibWluIiwiTWF0aCIsImVuZHNBZnRlciIsImFzIiwiYnMiLCJlcXVhbHMiLCJlbmRzQXQiLCJlbmRzQmVmb3JlIiwiZXZlcnkiLCJuIiwiaGFzUHJldmlvdXMiLCJpc0FmdGVyIiwiaXNBbmNlc3RvciIsImlzQmVmb3JlIiwiaXNDaGlsZCIsImlzQ29tbW9uIiwiaXNEZXNjZW5kYW50IiwiaXNQYXJlbnQiLCJpc1BhdGgiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImlzU2libGluZyIsImFsIiwiYmwiLCJsaXN0IiwibmV4dCIsIkVycm9yIiwiY29uY2F0IiwibGFzdCIsIm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgiLCJvcGVyYXRpb24iLCJ0eXBlIiwicGFyZW50IiwicHJldmlvdXMiLCJyZWxhdGl2ZSIsImFuY2VzdG9yIiwicCIsIl9vcCIsIl9vcDIiLCJwb3NpdGlvbiIsIl9vcDMiLCJfcG9zaXRpb24iLCJfb3A0IiwibmV3UGF0aCIsIm9ucCIsImNvcHkiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMkZSIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQkZSIsInRhcmdldCIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImFwcGx5VG9EcmFmdCIsImVkaXRvciIsInNlbGVjdGlvbiIsIm5vZGUiLCJOb2RlIiwiaW5kZXgiLCJjaGlsZHJlbiIsInNwbGljZSIsInBvaW50cyIsIl9wYXRoIiwib2Zmc2V0IiwidGV4dCIsIl9ub2RlIiwibGVhZiIsImJlZm9yZSIsImFmdGVyIiwiX3BvaW50IiwiX2tleSIsIl9wYXRoMiIsIl9ub2RlMiIsImdldCIsInByZXZQYXRoIiwicHJldiIsIl9wYXJlbnQiLCJfaW5kZXgiLCJUZXh0IiwiaXNUZXh0IiwiU2NydWJiZXIiLCJzdHJpbmdpZnkiLCJfcG9pbnQyIiwiX2tleTIiLCJfcGF0aDMiLCJfbm9kZTMiLCJfcGFyZW50MiIsIl9pbmRleDIiLCJ0cnVlUGF0aCIsIm5ld1BhcmVudCIsIm5ld0luZGV4IiwiX3BvaW50MyIsIl9rZXkzIiwiX3BhdGg0IiwiX2luZGV4MyIsIl9wYXJlbnQzIiwiX3BvaW50NCIsIl9rZXk0IiwicmVzdWx0IiwiX3ByZXYiLCJ0ZXh0cyIsInByZWZlck5leHQiLCJfcGF0aDUiLCJfb2Zmc2V0IiwiX3RleHQiLCJfbm9kZTQiLCJfYmVmb3JlIiwiX2FmdGVyIiwiX3BvaW50NSIsIl9rZXk1IiwiX3BhdGg2IiwicHJvcGVydGllcyIsIm5ld1Byb3BlcnRpZXMiLCJfbm9kZTUiLCJfa2V5NiIsIl9rZXk3IiwiaGFzT3duUHJvcGVydHkiLCJfbmV3UHJvcGVydGllcyIsImlzUmFuZ2UiLCJfa2V5OCIsIl92YWx1ZSIsIl9wYXRoNyIsIl9wcm9wZXJ0aWVzIiwiX25vZGU2IiwiX3BhcmVudDQiLCJfaW5kZXg0IiwibmV3Tm9kZSIsIl9iZWZvcmUyIiwiX2FmdGVyMiIsIl9iZWZvcmUzIiwiX2FmdGVyMyIsIl9wb2ludDYiLCJfa2V5OSIsIkdlbmVyYWxUcmFuc2Zvcm1zIiwiTm9kZVRyYW5zZm9ybXMiLCJpbnNlcnROb2RlcyIsIm5vZGVzIiwibGlmdE5vZGVzIiwibWVyZ2VOb2RlcyIsIm1vdmVOb2RlcyIsInJlbW92ZU5vZGVzIiwic2V0Tm9kZXMiLCJwcm9wcyIsInNwbGl0Tm9kZXMiLCJ1bnNldE5vZGVzIiwidW53cmFwTm9kZXMiLCJ3cmFwTm9kZXMiLCJlbGVtZW50IiwiU2VsZWN0aW9uVHJhbnNmb3JtcyIsImNvbGxhcHNlIiwiZGVzZWxlY3QiLCJtb3ZlIiwic2VsZWN0Iiwic2V0UG9pbnQiLCJzZXRTZWxlY3Rpb24iLCJpc0RlZXBFcXVhbCIsImEiLCJiIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIl9leGNsdWRlZCQ0Iiwib3duS2V5cyRkIiwiX29iamVjdFNwcmVhZCRkIiwiZWRnZXMiLCJyYW5nZSIsImFuY2hvciIsImZvY3VzIiwiaXNCYWNrd2FyZCIsImVuZCIsImluY2x1ZGVzIiwicnMiLCJyZSIsInRzIiwidGUiLCJzdGFydCIsImlzQWZ0ZXJTdGFydCIsImlzQmVmb3JlRW5kIiwiaXNQb2ludCIsImludGVyc2VjdGlvbiIsInJlc3QiLCJzMSIsImUxIiwiczIiLCJlMiIsImlzQ29sbGFwc2VkIiwiaXNFeHBhbmRlZCIsImlzRm9yd2FyZCIsInIiLCJhZmZpbml0eUFuY2hvciIsImFmZmluaXR5Rm9jdXMiLCJpc0VsZW1lbnQiLCJpc05vZGVMaXN0IiwiRWRpdG9yIiwiaXNFZGl0b3IiLCJFbGVtZW50IiwiaXNFbGVtZW50TGlzdCIsInZhbCIsImlzRWxlbWVudFByb3BzIiwiaXNFbGVtZW50VHlwZSIsImVsZW1lbnRWYWwiLCJlbGVtZW50S2V5IiwibWF0Y2hlcyIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiQzIiwiSVNfTk9ERV9MSVNUX0NBQ0hFIiwicm9vdCIsImVudHJ5IiwiY2hpbGQiLCJjIiwiY2hpbGRQYXRoIiwiZGVzY2VuZGFudCIsImRlc2NlbmRhbnRzIiwiZWxlbWVudHMiLCJleHRyYWN0UHJvcHMiLCJmaXJzdCIsImZyYWdtZW50IiwibmV3Um9vdCIsIm5vZGVFbnRyaWVzIiwicGFzcyIsIl9yZWYiLCJfbGVhZiIsImhhcyIsImlzTm9kZSIsImNhY2hlZFJlc3VsdCIsInNldCIsImlzVGV4dFByb3BzIiwiZnJvbSIsInRvIiwidmlzaXRlZCIsIlNldCIsImFkZCIsIm5leHRJbmRleCIsIl9uZXdQYXRoIiwicGFyZW50UGF0aCIsInN0cmluZyIsIm1hcCIsImpvaW4iLCJvd25LZXlzJGMiLCJfb2JqZWN0U3ByZWFkJGMiLCJPcGVyYXRpb24iLCJpc05vZGVPcGVyYXRpb24iLCJpc09wZXJhdGlvbiIsImVuZHNXaXRoIiwiaXNPcGVyYXRpb25MaXN0IiwiaXNTZWxlY3Rpb25PcGVyYXRpb24iLCJpc1RleHRPcGVyYXRpb24iLCJpbnZlcnNlIiwiaW52ZXJzZVBhdGgiLCJpbnZlcnNlTmV3UGF0aCIsIklTX0VESVRPUl9DQUNIRSIsImNhY2hlZElzRWRpdG9yIiwiYWRkTWFyayIsImRlbGV0ZUZyYWdtZW50IiwiaW5zZXJ0QnJlYWsiLCJpbnNlcnRTb2Z0QnJlYWsiLCJpbnNlcnRGcmFnbWVudCIsImluc2VydE5vZGUiLCJpbnNlcnRUZXh0IiwiaXNFbGVtZW50UmVhZE9ubHkiLCJpc0lubGluZSIsImlzU2VsZWN0YWJsZSIsImlzVm9pZCIsIm5vcm1hbGl6ZU5vZGUiLCJvbkNoYW5nZSIsInJlbW92ZU1hcmsiLCJnZXREaXJ0eVBhdGhzIiwibWFya3MiLCJvcGVyYXRpb25zIiwiYWJvdmUiLCJhdCIsImRlbGV0ZUJhY2t3YXJkIiwidW5pdCIsImRlbGV0ZUZvcndhcmQiLCJlbGVtZW50UmVhZE9ubHkiLCJoYXNCbG9ja3MiLCJoYXNJbmxpbmVzIiwiaGFzUGF0aCIsImhhc1RleHRzIiwiaXNCbG9jayIsImlzRWRnZSIsImlzRW1wdHkiLCJpc0VuZCIsImlzTm9ybWFsaXppbmciLCJpc1N0YXJ0IiwiZ2V0TWFya3MiLCJub3JtYWxpemUiLCJwYXRoUmVmIiwicGF0aFJlZnMiLCJwb2ludFJlZiIsInBvaW50UmVmcyIsInBvc2l0aW9ucyIsInJhbmdlUmVmIiwicmFuZ2VSZWZzIiwic2V0Tm9ybWFsaXppbmciLCJ1bmhhbmdSYW5nZSIsInZvaWQiLCJ3aXRob3V0Tm9ybWFsaXppbmciLCJmbiIsIkxvY2F0aW9uIiwiaXNMb2NhdGlvbiIsIlNwYW4iLCJpc1NwYW4iLCJvd25LZXlzJGIiLCJfb2JqZWN0U3ByZWFkJGIiLCJfc2NydWJiZXIiLCJzZXRTY3J1YmJlciIsInNjcnViYmVyIiwiSlNPTiIsIl9leGNsdWRlZCQyIiwiX2V4Y2x1ZGVkMiQyIiwib3duS2V5cyRhIiwiX29iamVjdFNwcmVhZCRhIiwibG9vc2UiLCJvbWl0VGV4dCIsImlzVGV4dExpc3QiLCJkZWNvcmF0aW9ucyIsImxlYXZlcyIsImRlYyIsImxlYWZFbmQiLCJkZWNvcmF0aW9uU3RhcnQiLCJkZWNvcmF0aW9uRW5kIiwibGVhZlN0YXJ0IiwiYXNzaWduIiwibWlkZGxlIiwib2ZmIiwiX29mZiIsImdldERlZmF1bHRJbnNlcnRMb2NhdGlvbiIsIm1hdGNoUGF0aCIsImdldENoYXJhY3RlckRpc3RhbmNlIiwic3RyIiwiaXNSVEwiLCJpc0xUUiIsImNvZGVwb2ludHMiLCJjb2RlcG9pbnRzSXRlcmF0b3JSVEwiLCJsZWZ0IiwiQ29kZXBvaW50VHlwZSIsIk5vbmUiLCJyaWdodCIsImRpc3RhbmNlIiwiZ2IxMSIsImdiMTJPcjEzIiwiY2hhciIsImNvZGUiLCJjb2RlUG9pbnRBdCIsImdldENvZGVwb2ludFR5cGUiLCJpbnRlcnNlY3RzIiwiWldKIiwiRXh0UGljdCIsImVuZHNXaXRoRW1vamlaV0oiLCJzdWJzdHJpbmciLCJSSSIsImVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMiLCJpc0JvdW5kYXJ5UGFpciIsIlNQQUNFIiwiUFVOQ1RVQVRJT04iLCJDSEFNRUxFT04iLCJnZXRXb3JkRGlzdGFuY2UiLCJkaXN0Iiwic3RhcnRlZCIsImNoYXJEaXN0IiwicmVtYWluaW5nIiwic3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlIiwiaXNXb3JkQ2hhcmFjdGVyIiwidGVzdCIsIm5leHRDaGFyIiwibmV4dFJlbWFpbmluZyIsImNoYXIxIiwiY2hhckF0IiwiaXNMb3dTdXJyb2dhdGUiLCJjaGFyQ29kZUF0IiwiY2hhcjIiLCJpc0hpZ2hTdXJyb2dhdGUiLCJjaGFyQ29kZSIsInJlRXh0ZW5kIiwicmVQcmVwZW5kIiwicmVTcGFjaW5nTWFyayIsInJlTCIsInJlViIsInJlVCIsInJlTFYiLCJyZUxWVCIsInJlRXh0UGljdCIsIkFueSIsInNlYXJjaCIsIkV4dGVuZCIsIlByZXBlbmQiLCJTcGFjaW5nTWFyayIsIkwiLCJWIiwiVCIsIkxWIiwiTFZUIiwieCIsInkiLCJOb25Cb3VuZGFyeVBhaXJzIiwiZmluZEluZGV4IiwiZW5kaW5nRW1vamlaV0oiLCJlbmRpbmdSSXMiLCJtYXRjaCIsIm51bVJJcyIsIlRleHRUcmFuc2Zvcm1zIiwiZGVsZXRlIiwidm9pZHMiLCJzdGFydFJlZiIsImVuZFJlZiIsIlRyYW5zZm9ybXMiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJvd25LZXlzJDkiLCJfb2JqZWN0U3ByZWFkJDkiLCJfcmVmMiIsIm9sZERpcnR5UGF0aHMiLCJvbGREaXJ0eVBhdGhLZXlzIiwiZGlydHlQYXRocyIsImRpcnR5UGF0aEtleXMiLCJuZXdEaXJ0eVBhdGhzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicHJldmlvdXNQYXRoIiwib2xkQW5jZXN0b3JzIiwibmV3QW5jZXN0b3JzIiwiX2FuY2VzdG9yIiwiX3AiLCJyZXN1bHRQYXRoIiwiX2FuY2VzdG9ycyIsIl9sZXZlbHMiLCJuZXh0UGF0aCIsImdldEZyYWdtZW50Iiwic2hvdWxkSGF2ZUlubGluZXMiLCJjdXJyZW50Tm9kZSIsIl9jaGlsZCIsImlzTGFzdCIsImlzSW5saW5lT3JUZXh0IiwibmV3Q2hpbGQiLCJfbmV3Q2hpbGQiLCJzaG91bGROb3JtYWxpemUiLCJpdGVyYXRpb24iLCJpbml0aWFsRGlydHlQYXRoc0xlbmd0aCIsIm1heEl0ZXJhdGlvbnMiLCJtb2RlIiwib3duS2V5cyQ4IiwiX29iamVjdFNwcmVhZCQ4IiwicGFyZW50Tm9kZSIsIm1hcmthYmxlVm9pZCIsImV4cGFuZGVkU2VsZWN0aW9uIiwibWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCIsInNlbGVjdGVkTm9kZSIsInNlbGVjdGVkUGF0aCIsInNwbGl0Iiwib3duS2V5cyQ3IiwiX29iamVjdFNwcmVhZCQ3IiwiZWRnZSIsImQiLCJvd25LZXlzJDYiLCJfb2JqZWN0U3ByZWFkJDYiLCJkaXJlY3Rpb24iLCJvd25LZXlzJDUiLCJfb2JqZWN0U3ByZWFkJDUiLCJvd25LZXlzJDQiLCJfb2JqZWN0U3ByZWFkJDQiLCJnZXRWb2lkIiwic29tZSIsImFsd2F5cyIsIm93bktleXMkMyIsIl9vYmplY3RTcHJlYWQkMyIsIl9leGNsdWRlZCQxIiwiX2V4Y2x1ZGVkMiQxIiwiX3Jlc3QiLCJtYXJrZWRWb2lkIiwiYmxvY2siLCJwcmV2Tm9kZSIsImJsb2NrUGF0aCIsInBvaW50QWZ0ZXJMb2NhdGlvbiIsInNwYW4iLCJ1bml2ZXJzYWwiLCJpZ25vcmVOb25TZWxlY3RhYmxlIiwiaGl0IiwiaXNMb3dlciIsImVtaXQiLCJmb3JjZSIsImdldERpcnR5UGF0aEtleXMiLCJwb3BEaXJ0eVBhdGgiLCJwb3AiLCJhbGxQYXRocyIsImFsbFBhdGhLZXlzIiwiZGlydHlQYXRoIiwiXyIsIl9kaXJ0eVBhdGgiLCJfZW50cnkiLCJyZWZzIiwiZGVwdGgiLCJmaXJzdFBhdGgiLCJsYXN0UGF0aCIsImlzTmV3QmxvY2siLCJibG9ja1RleHQiLCJsZWFmVGV4dFJlbWFpbmluZyIsImxlYWZUZXh0T2Zmc2V0IiwiZSIsInMiLCJpc0ZpcnN0IiwiY2FsY0Rpc3RhbmNlIiwicG9pbnRCZWZvcmVMb2NhdGlvbiIsIm93bktleXMkMiIsIl9vYmplY3RTcHJlYWQkMiIsInQiLCJlbmRCbG9jayIsInNraXAiLCJkZWxldGVUZXh0IiwiX0VkaXRvciR2b2lkIiwiX0VkaXRvciR2b2lkMiIsImhhbmdpbmciLCJmdXJ0aGVzdFZvaWQiLCJ2b2lkUGF0aCIsIm9wdHMiLCJfZW5kIiwiZW5kT2ZEb2MiLCJzdGFydEJsb2NrIiwiaXNBY3Jvc3NCbG9ja3MiLCJpc1NpbmdsZVRleHQiLCJzdGFydE5vbkVkaXRhYmxlIiwiZW5kTm9uRWRpdGFibGUiLCJyZW1vdmVkVGV4dCIsInN0YXJ0VW5yZWYiLCJlbmRVbnJlZiIsImlubGluZUVsZW1lbnRNYXRjaCIsIl9pbmxpbmVQYXRoIiwiYmxvY2tNYXRjaCIsImlzQmxvY2tTdGFydCIsImlzQmxvY2tFbmQiLCJpc0Jsb2NrRW1wdHkiLCJtZXJnZVN0YXJ0IiwibWVyZ2VFbmQiLCJtYXRjaGVyIiwiaXNSb290Iiwic3RhcnRzIiwibWlkZGxlcyIsImVuZHMiLCJzdGFydGluZyIsImlubGluZU1hdGNoIiwiaW5saW5lUGF0aCIsImlzSW5saW5lU3RhcnQiLCJpc0lubGluZUVuZCIsIm1pZGRsZVJlZiIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJrIiwiaXNBdEVuZCIsInBhcmVudE5vZGVFbnRyeSIsInRvUGF0aCIsIl90b1BhdGgiLCJzcGxpdFBhdGgiLCJfdG9QYXRoMiIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJoYXNTaW5nbGVDaGlsZE5lc3QiLCJjb21tb25QYXRoIiwiaXNQcmV2aW91c1NpYmxpbmciLCJlbXB0eUFuY2VzdG9yIiwiZW1wdHlSZWYiLCJ0b1JlZiIsInRhcmdldHMiLCJkZXB0aHMiLCJtZXJnZSIsInNwbGl0TW9kZSIsImVuZEF0RW5kT2ZOb2RlIiwic3RhcnRBdFN0YXJ0T2ZOb2RlIiwicHJvcCIsIm5vZGVQcm9wIiwiaGFzQ2hhbmdlcyIsImRlbGV0ZVJhbmdlIiwiaGVpZ2h0IiwiYmVmb3JlUmVmIiwiYWZ0ZXJSZWYiLCJoaWdoZXN0Iiwidm9pZE1hdGNoIiwibnVkZ2UiLCJ2b2lkTm9kZSIsImFmdGVyUGF0aCIsInNpYmxpbmdIZWlnaHQiLCJoaWdoZXN0UGF0aCIsImxvd2VzdFBhdGgiLCJfYWZ0ZXJSZWYiLCJfbG9vcCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwicm9vdHMiLCJyb290UGF0aCIsIl9yZXQiLCJjb21tb25Ob2RlRW50cnkiLCJjb21tb25Ob2RlIiwid3JhcHBlclBhdGgiLCJ3cmFwcGVyIiwiY3JlYXRlRWRpdG9yIiwiYXBwbHkkMSIsIl9sZW4iLCJhcmdzIiwiYWRkTWFyayQxIiwiX2xlbjIiLCJkZWxldGVCYWNrd2FyZCQxIiwiX2xlbjMiLCJkZWxldGVGb3J3YXJkJDEiLCJfbGVuNCIsImRlbGV0ZUZyYWdtZW50JDEiLCJfbGVuNSIsImdldEZyYWdtZW50JDEiLCJfbGVuNiIsImluc2VydEJyZWFrJDEiLCJfbGVuNyIsImluc2VydFNvZnRCcmVhayQxIiwiX2xlbjgiLCJpbnNlcnRGcmFnbWVudCQxIiwiX2xlbjkiLCJpbnNlcnROb2RlJDEiLCJfbGVuMTAiLCJfa2V5MTAiLCJpbnNlcnRUZXh0JDEiLCJfbGVuMTEiLCJfa2V5MTEiLCJub3JtYWxpemVOb2RlJDEiLCJfbGVuMTIiLCJfa2V5MTIiLCJyZW1vdmVNYXJrJDEiLCJfbGVuMTMiLCJfa2V5MTMiLCJnZXREaXJ0eVBhdGhzJDEiLCJfbGVuMTQiLCJfa2V5MTQiLCJzaG91bGROb3JtYWxpemUkMSIsIl9sZW4xNSIsIl9rZXkxNSIsImFib3ZlJDEiLCJfbGVuMTYiLCJfa2V5MTYiLCJhZnRlciQxIiwiX2xlbjE3IiwiX2tleTE3IiwiYmVmb3JlJDEiLCJfbGVuMTgiLCJfa2V5MTgiLCJjb2xsYXBzZSQxIiwiX2xlbjE5IiwiX2tleTE5IiwiX2RlbGV0ZSIsIl9sZW4yMCIsIl9rZXkyMCIsImRlc2VsZWN0JDEiLCJfbGVuMjEiLCJfa2V5MjEiLCJlZGdlcyQxIiwiX2xlbjIyIiwiX2tleTIyIiwiZWxlbWVudFJlYWRPbmx5JDEiLCJfbGVuMjMiLCJfa2V5MjMiLCJlbmQkMSIsIl9sZW4yNCIsIl9rZXkyNCIsImZpcnN0JDEiLCJfbGVuMjUiLCJfa2V5MjUiLCJmcmFnbWVudCQxIiwiX2xlbjI2IiwiX2tleTI2IiwiX2xlbjI3IiwiX2tleTI3IiwiaGFzQmxvY2tzJDEiLCJfbGVuMjgiLCJfa2V5MjgiLCJoYXNJbmxpbmVzJDEiLCJfbGVuMjkiLCJfa2V5MjkiLCJoYXNQYXRoJDEiLCJfbGVuMzAiLCJfa2V5MzAiLCJoYXNUZXh0cyQxIiwiX2xlbjMxIiwiX2tleTMxIiwiaW5zZXJ0Tm9kZXMkMSIsIl9sZW4zMiIsIl9rZXkzMiIsImlzQmxvY2skMSIsIl9sZW4zMyIsIl9rZXkzMyIsImlzRWRnZSQxIiwiX2xlbjM0IiwiX2tleTM0IiwiaXNFbXB0eSQxIiwiX2xlbjM1IiwiX2tleTM1IiwiaXNFbmQkMSIsIl9sZW4zNiIsIl9rZXkzNiIsImlzTm9ybWFsaXppbmckMSIsIl9sZW4zNyIsIl9rZXkzNyIsImlzU3RhcnQkMSIsIl9sZW4zOCIsIl9rZXkzOCIsImxhc3QkMSIsIl9sZW4zOSIsIl9rZXkzOSIsImxlYWYkMSIsIl9sZW40MCIsIl9rZXk0MCIsImxldmVscyQxIiwiX2xlbjQxIiwiX2tleTQxIiwibGlmdE5vZGVzJDEiLCJfbGVuNDIiLCJfa2V5NDIiLCJtZXJnZU5vZGVzJDEiLCJfbGVuNDMiLCJfa2V5NDMiLCJtb3ZlJDEiLCJfbGVuNDQiLCJfa2V5NDQiLCJtb3ZlTm9kZXMkMSIsIl9sZW40NSIsIl9rZXk0NSIsIm5leHQkMSIsIl9sZW40NiIsIl9rZXk0NiIsIm5vZGUkMSIsIl9sZW40NyIsIl9rZXk0NyIsIm5vZGVzJDEiLCJfbGVuNDgiLCJfa2V5NDgiLCJub3JtYWxpemUkMSIsIl9sZW40OSIsIl9rZXk0OSIsInBhcmVudCQxIiwiX2xlbjUwIiwiX2tleTUwIiwicGF0aCQxIiwiX2xlbjUxIiwiX2tleTUxIiwicGF0aFJlZiQxIiwiX2xlbjUyIiwiX2tleTUyIiwicGF0aFJlZnMkMSIsIl9sZW41MyIsIl9rZXk1MyIsInBvaW50JDEiLCJfbGVuNTQiLCJfa2V5NTQiLCJwb2ludFJlZiQxIiwiX2xlbjU1IiwiX2tleTU1IiwicG9pbnRSZWZzJDEiLCJfbGVuNTYiLCJfa2V5NTYiLCJwb3NpdGlvbnMkMSIsIl9sZW41NyIsIl9rZXk1NyIsInByZXZpb3VzJDEiLCJfbGVuNTgiLCJfa2V5NTgiLCJyYW5nZSQxIiwiX2xlbjU5IiwiX2tleTU5IiwicmFuZ2VSZWYkMSIsIl9sZW42MCIsIl9rZXk2MCIsInJhbmdlUmVmcyQxIiwiX2xlbjYxIiwiX2tleTYxIiwicmVtb3ZlTm9kZXMkMSIsIl9sZW42MiIsIl9rZXk2MiIsInNlbGVjdCQxIiwiX2xlbjYzIiwiX2tleTYzIiwic2V0Tm9kZXMkMSIsIl9sZW42NCIsIl9rZXk2NCIsInNldE5vcm1hbGl6aW5nJDEiLCJfbGVuNjUiLCJfa2V5NjUiLCJzZXRQb2ludCQxIiwiX2xlbjY2IiwiX2tleTY2Iiwic2V0U2VsZWN0aW9uJDEiLCJfbGVuNjciLCJfa2V5NjciLCJzcGxpdE5vZGVzJDEiLCJfbGVuNjgiLCJfa2V5NjgiLCJzdGFydCQxIiwiX2xlbjY5IiwiX2tleTY5Iiwic3RyaW5nJDEiLCJfbGVuNzAiLCJfa2V5NzAiLCJ1bmhhbmdSYW5nZSQxIiwiX2xlbjcxIiwiX2tleTcxIiwidW5zZXROb2RlcyQxIiwiX2xlbjcyIiwiX2tleTcyIiwidW53cmFwTm9kZXMkMSIsIl9sZW43MyIsIl9rZXk3MyIsIl92b2lkIiwiX2xlbjc0IiwiX2tleTc0Iiwid2l0aG91dE5vcm1hbGl6aW5nJDEiLCJfbGVuNzUiLCJfa2V5NzUiLCJ3cmFwTm9kZXMkMSIsIl9sZW43NiIsIl9rZXk3NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.es.js\n");

/***/ })

};
;