"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/url-parse";
exports.ids = ["vendor-chunks/url-parse"];
exports.modules = {

/***/ "(ssr)/./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar required = __webpack_require__(/*! requires-port */ \"(ssr)/./node_modules/requires-port/index.js\"), qs = __webpack_require__(/*! querystringify */ \"(ssr)/./node_modules/querystringify/index.js\"), controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/, CRHTLF = /[\\n\\r\\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//, port = /:\\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */ function trimLeft(str) {\n    return (str ? str : \"\").toString().replace(controlOrWhitespace, \"\");\n}\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */ var rules = [\n    [\n        \"#\",\n        \"hash\"\n    ],\n    [\n        \"?\",\n        \"query\"\n    ],\n    function sanitize(address, url) {\n        return isSpecial(url.protocol) ? address.replace(/\\\\/g, \"/\") : address;\n    },\n    [\n        \"/\",\n        \"pathname\"\n    ],\n    [\n        \"@\",\n        \"auth\",\n        1\n    ],\n    [\n        NaN,\n        \"host\",\n        undefined,\n        1,\n        1\n    ],\n    [\n        /:(\\d*)$/,\n        \"port\",\n        undefined,\n        1\n    ],\n    [\n        NaN,\n        \"hostname\",\n        undefined,\n        1,\n        1\n    ] // Set left over.\n];\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */ var ignore = {\n    hash: 1,\n    query: 1\n};\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */ function lolcation(loc) {\n    var globalVar;\n    if (false) {}\n    else if (typeof global !== \"undefined\") globalVar = global;\n    else if (typeof self !== \"undefined\") globalVar = self;\n    else globalVar = {};\n    var location = globalVar.location || {};\n    loc = loc || location;\n    var finaldestination = {}, type = typeof loc, key;\n    if (\"blob:\" === loc.protocol) {\n        finaldestination = new Url(unescape(loc.pathname), {});\n    } else if (\"string\" === type) {\n        finaldestination = new Url(loc, {});\n        for(key in ignore)delete finaldestination[key];\n    } else if (\"object\" === type) {\n        for(key in loc){\n            if (key in ignore) continue;\n            finaldestination[key] = loc[key];\n        }\n        if (finaldestination.slashes === undefined) {\n            finaldestination.slashes = slashes.test(loc.href);\n        }\n    }\n    return finaldestination;\n}\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */ function isSpecial(scheme) {\n    return scheme === \"file:\" || scheme === \"ftp:\" || scheme === \"http:\" || scheme === \"https:\" || scheme === \"ws:\" || scheme === \"wss:\";\n}\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */ /**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */ function extractProtocol(address, location) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    location = location || {};\n    var match = protocolre.exec(address);\n    var protocol = match[1] ? match[1].toLowerCase() : \"\";\n    var forwardSlashes = !!match[2];\n    var otherSlashes = !!match[3];\n    var slashesCount = 0;\n    var rest;\n    if (forwardSlashes) {\n        if (otherSlashes) {\n            rest = match[2] + match[3] + match[4];\n            slashesCount = match[2].length + match[3].length;\n        } else {\n            rest = match[2] + match[4];\n            slashesCount = match[2].length;\n        }\n    } else {\n        if (otherSlashes) {\n            rest = match[3] + match[4];\n            slashesCount = match[3].length;\n        } else {\n            rest = match[4];\n        }\n    }\n    if (protocol === \"file:\") {\n        if (slashesCount >= 2) {\n            rest = rest.slice(2);\n        }\n    } else if (isSpecial(protocol)) {\n        rest = match[4];\n    } else if (protocol) {\n        if (forwardSlashes) {\n            rest = rest.slice(2);\n        }\n    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n        rest = match[4];\n    }\n    return {\n        protocol: protocol,\n        slashes: forwardSlashes || isSpecial(protocol),\n        slashesCount: slashesCount,\n        rest: rest\n    };\n}\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */ function resolve(relative, base) {\n    if (relative === \"\") return base;\n    var path = (base || \"/\").split(\"/\").slice(0, -1).concat(relative.split(\"/\")), i = path.length, last = path[i - 1], unshift = false, up = 0;\n    while(i--){\n        if (path[i] === \".\") {\n            path.splice(i, 1);\n        } else if (path[i] === \"..\") {\n            path.splice(i, 1);\n            up++;\n        } else if (up) {\n            if (i === 0) unshift = true;\n            path.splice(i, 1);\n            up--;\n        }\n    }\n    if (unshift) path.unshift(\"\");\n    if (last === \".\" || last === \"..\") path.push(\"\");\n    return path.join(\"/\");\n}\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */ function Url(address, location, parser) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    if (!(this instanceof Url)) {\n        return new Url(address, location, parser);\n    }\n    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;\n    //\n    // The following if statements allows this module two have compatibility with\n    // 2 different API:\n    //\n    // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n    //    where the boolean indicates that the query string should also be parsed.\n    //\n    // 2. The `URL` interface of the browser which accepts a URL, object as\n    //    arguments. The supplied object will be used as default values / fall-back\n    //    for relative paths.\n    //\n    if (\"object\" !== type && \"string\" !== type) {\n        parser = location;\n        location = null;\n    }\n    if (parser && \"function\" !== typeof parser) parser = qs.parse;\n    location = lolcation(location);\n    //\n    // Extract protocol information before running the instructions.\n    //\n    extracted = extractProtocol(address || \"\", location);\n    relative = !extracted.protocol && !extracted.slashes;\n    url.slashes = extracted.slashes || relative && location.slashes;\n    url.protocol = extracted.protocol || location.protocol || \"\";\n    address = extracted.rest;\n    //\n    // When the authority component is absent the URL starts with a path\n    // component.\n    //\n    if (extracted.protocol === \"file:\" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n        instructions[3] = [\n            /(.*)/,\n            \"pathname\"\n        ];\n    }\n    for(; i < instructions.length; i++){\n        instruction = instructions[i];\n        if (typeof instruction === \"function\") {\n            address = instruction(address, url);\n            continue;\n        }\n        parse = instruction[0];\n        key = instruction[1];\n        if (parse !== parse) {\n            url[key] = address;\n        } else if (\"string\" === typeof parse) {\n            index = parse === \"@\" ? address.lastIndexOf(parse) : address.indexOf(parse);\n            if (~index) {\n                if (\"number\" === typeof instruction[2]) {\n                    url[key] = address.slice(0, index);\n                    address = address.slice(index + instruction[2]);\n                } else {\n                    url[key] = address.slice(index);\n                    address = address.slice(0, index);\n                }\n            }\n        } else if (index = parse.exec(address)) {\n            url[key] = index[1];\n            address = address.slice(0, index.index);\n        }\n        url[key] = url[key] || (relative && instruction[3] ? location[key] || \"\" : \"\");\n        //\n        // Hostname, host and protocol should be lowercased so they can be used to\n        // create a proper `origin`.\n        //\n        if (instruction[4]) url[key] = url[key].toLowerCase();\n    }\n    //\n    // Also parse the supplied query string in to an object. If we're supplied\n    // with a custom parser as function use that instead of the default build-in\n    // parser.\n    //\n    if (parser) url.query = parser(url.query);\n    //\n    // If the URL is relative, resolve the pathname against the base URL.\n    //\n    if (relative && location.slashes && url.pathname.charAt(0) !== \"/\" && (url.pathname !== \"\" || location.pathname !== \"\")) {\n        url.pathname = resolve(url.pathname, location.pathname);\n    }\n    //\n    // Default to a / for pathname if none exists. This normalizes the URL\n    // to always have a /\n    //\n    if (url.pathname.charAt(0) !== \"/\" && isSpecial(url.protocol)) {\n        url.pathname = \"/\" + url.pathname;\n    }\n    //\n    // We should not add port numbers if they are already the default port number\n    // for a given protocol. As the host also contains the port number we're going\n    // override it with the hostname which contains no port number.\n    //\n    if (!required(url.port, url.protocol)) {\n        url.host = url.hostname;\n        url.port = \"\";\n    }\n    //\n    // Parse down the `auth` for the username and password.\n    //\n    url.username = url.password = \"\";\n    if (url.auth) {\n        index = url.auth.indexOf(\":\");\n        if (~index) {\n            url.username = url.auth.slice(0, index);\n            url.username = encodeURIComponent(decodeURIComponent(url.username));\n            url.password = url.auth.slice(index + 1);\n            url.password = encodeURIComponent(decodeURIComponent(url.password));\n        } else {\n            url.username = encodeURIComponent(decodeURIComponent(url.auth));\n        }\n        url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    }\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    //\n    // The href is just the compiled result.\n    //\n    url.href = url.toString();\n}\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */ function set(part, value, fn) {\n    var url = this;\n    switch(part){\n        case \"query\":\n            if (\"string\" === typeof value && value.length) {\n                value = (fn || qs.parse)(value);\n            }\n            url[part] = value;\n            break;\n        case \"port\":\n            url[part] = value;\n            if (!required(value, url.protocol)) {\n                url.host = url.hostname;\n                url[part] = \"\";\n            } else if (value) {\n                url.host = url.hostname + \":\" + value;\n            }\n            break;\n        case \"hostname\":\n            url[part] = value;\n            if (url.port) value += \":\" + url.port;\n            url.host = value;\n            break;\n        case \"host\":\n            url[part] = value;\n            if (port.test(value)) {\n                value = value.split(\":\");\n                url.port = value.pop();\n                url.hostname = value.join(\":\");\n            } else {\n                url.hostname = value;\n                url.port = \"\";\n            }\n            break;\n        case \"protocol\":\n            url.protocol = value.toLowerCase();\n            url.slashes = !fn;\n            break;\n        case \"pathname\":\n        case \"hash\":\n            if (value) {\n                var char = part === \"pathname\" ? \"/\" : \"#\";\n                url[part] = value.charAt(0) !== char ? char + value : value;\n            } else {\n                url[part] = value;\n            }\n            break;\n        case \"username\":\n        case \"password\":\n            url[part] = encodeURIComponent(value);\n            break;\n        case \"auth\":\n            var index = value.indexOf(\":\");\n            if (~index) {\n                url.username = value.slice(0, index);\n                url.username = encodeURIComponent(decodeURIComponent(url.username));\n                url.password = value.slice(index + 1);\n                url.password = encodeURIComponent(decodeURIComponent(url.password));\n            } else {\n                url.username = encodeURIComponent(decodeURIComponent(value));\n            }\n    }\n    for(var i = 0; i < rules.length; i++){\n        var ins = rules[i];\n        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n    }\n    url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    url.href = url.toString();\n    return url;\n}\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */ function toString(stringify) {\n    if (!stringify || \"function\" !== typeof stringify) stringify = qs.stringify;\n    var query, url = this, host = url.host, protocol = url.protocol;\n    if (protocol && protocol.charAt(protocol.length - 1) !== \":\") protocol += \":\";\n    var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? \"//\" : \"\");\n    if (url.username) {\n        result += url.username;\n        if (url.password) result += \":\" + url.password;\n        result += \"@\";\n    } else if (url.password) {\n        result += \":\" + url.password;\n        result += \"@\";\n    } else if (url.protocol !== \"file:\" && isSpecial(url.protocol) && !host && url.pathname !== \"/\") {\n        //\n        // Add back the empty userinfo, otherwise the original invalid URL\n        // might be transformed into a valid one with `url.pathname` as host.\n        //\n        result += \"@\";\n    }\n    //\n    // Trailing colon is removed from `url.host` when it is parsed. If it still\n    // ends with a colon, then add back the trailing colon that was removed. This\n    // prevents an invalid URL from being transformed into a valid one.\n    //\n    if (host[host.length - 1] === \":\" || port.test(url.hostname) && !url.port) {\n        host += \":\";\n    }\n    result += host + url.pathname;\n    query = \"object\" === typeof url.query ? stringify(url.query) : url.query;\n    if (query) result += \"?\" !== query.charAt(0) ? \"?\" + query : query;\n    if (url.hash) result += url.hash;\n    return result;\n}\nUrl.prototype = {\n    set: set,\n    toString: toString\n};\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\nmodule.exports = Url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsV0FBV0MsbUJBQU9BLENBQUMscUVBQ25CQyxLQUFLRCxtQkFBT0EsQ0FBQyx1RUFDYkUsc0JBQXNCLDhFQUN0QkMsU0FBUyxhQUNUQyxVQUFVLGlDQUNWQyxPQUFPLFNBQ1BDLGFBQWEsb0RBQ2JDLHFCQUFxQjtBQUV6Qjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsU0FBU0MsR0FBRztJQUNuQixPQUFPLENBQUNBLE1BQU1BLE1BQU0sRUFBQyxFQUFHQyxRQUFRLEdBQUdDLE9BQU8sQ0FBQ1QscUJBQXFCO0FBQ2xFO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxJQUFJVSxRQUFRO0lBQ1Y7UUFBQztRQUFLO0tBQU87SUFDYjtRQUFDO1FBQUs7S0FBUTtJQUNkLFNBQVNDLFNBQVNDLE9BQU8sRUFBRUMsR0FBRztRQUM1QixPQUFPQyxVQUFVRCxJQUFJRSxRQUFRLElBQUlILFFBQVFILE9BQU8sQ0FBQyxPQUFPLE9BQU9HO0lBQ2pFO0lBQ0E7UUFBQztRQUFLO0tBQVc7SUFDakI7UUFBQztRQUFLO1FBQVE7S0FBRTtJQUNoQjtRQUFDSTtRQUFLO1FBQVFDO1FBQVc7UUFBRztLQUFFO0lBQzlCO1FBQUM7UUFBVztRQUFRQTtRQUFXO0tBQUU7SUFDakM7UUFBQ0Q7UUFBSztRQUFZQztRQUFXO1FBQUc7S0FBRSxDQUFJLGlCQUFpQjtDQUN4RDtBQUVEOzs7Ozs7O0NBT0MsR0FDRCxJQUFJQyxTQUFTO0lBQUVDLE1BQU07SUFBR0MsT0FBTztBQUFFO0FBRWpDOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0MsVUFBVUMsR0FBRztJQUNwQixJQUFJQztJQUVKLElBQUksS0FBa0IsRUFBYUEsRUFBbUJDO1NBQ2pELElBQUksT0FBT0MsV0FBVyxhQUFhRixZQUFZRTtTQUMvQyxJQUFJLE9BQU9DLFNBQVMsYUFBYUgsWUFBWUc7U0FDN0NILFlBQVksQ0FBQztJ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SUFDRixJQUFJaEIsSUFBSSxDQUFDQSxLQUFLeEIsTUFBTSxHQUFHLEVBQUUsS0FBSyxPQUFRMUMsS0FBSytCLElBQUksQ0FBQ3JCLElBQUl5RCxRQUFRLEtBQUssQ0FBQ3pELElBQUlWLElBQUksRUFBRztRQUMzRWtFLFFBQVE7SUFDVjtJQUVBZ0IsVUFBVWhCLE9BQU94RCxJQUFJb0IsUUFBUTtJQUU3QmIsUUFBUSxhQUFhLE9BQU9QLElBQUlPLEtBQUssR0FBR2dFLFVBQVV2RSxJQUFJTyxLQUFLLElBQUlQLElBQUlPLEtBQUs7SUFDeEUsSUFBSUEsT0FBT2lFLFVBQVUsUUFBUWpFLE1BQU1nRCxNQUFNLENBQUMsS0FBSyxNQUFLaEQsUUFBUUE7SUFFNUQsSUFBSVAsSUFBSU0sSUFBSSxFQUFFa0UsVUFBVXhFLElBQUlNLElBQUk7SUFFaEMsT0FBT2tFO0FBQ1Q7QUFFQXRELElBQUl1RCxTQUFTLEdBQUc7SUFBRVQsS0FBS0E7SUFBS3JFLFVBQVVBO0FBQVM7QUFFL0MsRUFBRTtBQUNGLGdGQUFnRjtBQUNoRixxQkFBcUI7QUFDckIsRUFBRTtBQUNGdUIsSUFBSU0sZUFBZSxHQUFHQTtBQUN0Qk4sSUFBSUosUUFBUSxHQUFHTjtBQUNmVSxJQUFJekIsUUFBUSxHQUFHQTtBQUNmeUIsSUFBSWhDLEVBQUUsR0FBR0E7QUFFVHdGLE9BQU9DLE9BQU8sR0FBR3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlnbWEvLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzPzRiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBjb250cm9sT3JXaGl0ZXNwYWNlID0gL15bXFx4MDAtXFx4MjBcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0rL1xuICAsIENSSFRMRiA9IC9bXFxuXFxyXFx0XS9nXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvL1xuICAsIHBvcnQgPSAvOlxcZCskL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxcXC9dKyk/KFtcXFNcXHNdKikvaVxuICAsIHdpbmRvd3NEcml2ZUxldHRlciA9IC9eW2EtekEtWl06LztcblxuLyoqXG4gKiBSZW1vdmUgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB3aGl0ZXNwYWNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgbmV3IHN0cmluZyByZXByZXNlbnRpbmcgYHN0cmAgc3RyaXBwZWQgb2YgY29udHJvbFxuICogICAgIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UgZnJvbSBpdHMgYmVnaW5uaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGNvbnRyb2xPcldoaXRlc3BhY2UsICcnKTtcbn1cblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcywgdXJsKSB7ICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgPyBhZGRyZXNzLnJlcGxhY2UoL1xcXFwvZywgJy8nKSA6IGFkZHJlc3M7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCopJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgcHJvdG9jb2wgc2NoZW1lIG9mIHRoZSBVUkxcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTcGVjaWFsKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSA9PT0gJ2ZpbGU6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2Z0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cHM6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzOicgfHxcbiAgICBzY2hlbWUgPT09ICd3c3M6J1xuICApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzLCBsb2NhdGlvbikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoQ1JIVExGLCAnJyk7XG4gIGxvY2F0aW9uID0gbG9jYXRpb24gfHwge307XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuICB2YXIgcHJvdG9jb2wgPSBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgdmFyIGZvcndhcmRTbGFzaGVzID0gISFtYXRjaFsyXTtcbiAgdmFyIG90aGVyU2xhc2hlcyA9ICEhbWF0Y2hbM107XG4gIHZhciBzbGFzaGVzQ291bnQgPSAwO1xuICB2YXIgcmVzdDtcblxuICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoICsgbWF0Y2hbM10ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgcmVzdCA9IG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFs0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgIGlmIChzbGFzaGVzQ291bnQgPj0gMikge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3BlY2lhbChwcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH0gZWxzZSBpZiAocHJvdG9jb2wpIHtcbiAgICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzbGFzaGVzQ291bnQgPj0gMiAmJiBpc1NwZWNpYWwobG9jYXRpb24ucHJvdG9jb2wpKSB7XG4gICAgcmVzdCA9IG1hdGNoWzRdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogZm9yd2FyZFNsYXNoZXMgfHwgaXNTcGVjaWFsKHByb3RvY29sKSxcbiAgICBzbGFzaGVzQ291bnQ6IHNsYXNoZXNDb3VudCxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJywgbG9jYXRpb24pO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKFxuICAgIGV4dHJhY3RlZC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAoXG4gICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50ICE9PSAyIHx8IHdpbmRvd3NEcml2ZUxldHRlci50ZXN0KGFkZHJlc3MpKSB8fFxuICAgICghZXh0cmFjdGVkLnNsYXNoZXMgJiZcbiAgICAgIChleHRyYWN0ZWQucHJvdG9jb2wgfHxcbiAgICAgICAgZXh0cmFjdGVkLnNsYXNoZXNDb3VudCA8IDIgfHxcbiAgICAgICAgIWlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSlcbiAgKSB7XG4gICAgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG4gIH1cblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MsIHVybCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaW5kZXggPSBwYXJzZSA9PT0gJ0AnXG4gICAgICAgID8gYWRkcmVzcy5sYXN0SW5kZXhPZihwYXJzZSlcbiAgICAgICAgOiBhZGRyZXNzLmluZGV4T2YocGFyc2UpO1xuXG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIERlZmF1bHQgdG8gYSAvIGZvciBwYXRobmFtZSBpZiBub25lIGV4aXN0cy4gVGhpcyBub3JtYWxpemVzIHRoZSBVUkxcbiAgLy8gdG8gYWx3YXlzIGhhdmUgYSAvXG4gIC8vXG4gIGlmICh1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcblxuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbmRleCA9IHVybC5hdXRoLmluZGV4T2YoJzonKTtcblxuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgIHVybC51c2VybmFtZSA9IHVybC5hdXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSk7XG5cbiAgICAgIHVybC5wYXNzd29yZCA9IHVybC5hdXRoLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICB1cmwucGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5wYXNzd29yZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLmF1dGgpKTtcbiAgICB9XG5cbiAgICB1cmwuYXV0aCA9IHVybC5wYXNzd29yZCA/IHVybC51c2VybmFtZSArJzonKyB1cmwucGFzc3dvcmQgOiB1cmwudXNlcm5hbWU7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmIChwb3J0LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1c2VybmFtZSc6XG4gICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgdXJsW3BhcnRdID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0aCc6XG4gICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC51c2VybmFtZSkpO1xuXG4gICAgICAgIHVybC5wYXNzd29yZCA9IHZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLmF1dGggPSB1cmwucGFzc3dvcmQgPyB1cmwudXNlcm5hbWUgKyc6JysgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBob3N0ID0gdXJsLmhvc3RcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPVxuICAgIHByb3RvY29sICtcbiAgICAoKHVybC5wcm90b2NvbCAmJiB1cmwuc2xhc2hlcykgfHwgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9IGVsc2UgaWYgKHVybC5wYXNzd29yZCkge1xuICAgIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9IGVsc2UgaWYgKFxuICAgIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmXG4gICAgIWhvc3QgJiZcbiAgICB1cmwucGF0aG5hbWUgIT09ICcvJ1xuICApIHtcbiAgICAvL1xuICAgIC8vIEFkZCBiYWNrIHRoZSBlbXB0eSB1c2VyaW5mbywgb3RoZXJ3aXNlIHRoZSBvcmlnaW5hbCBpbnZhbGlkIFVSTFxuICAgIC8vIG1pZ2h0IGJlIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBvbmUgd2l0aCBgdXJsLnBhdGhuYW1lYCBhcyBob3N0LlxuICAgIC8vXG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIC8vXG4gIC8vIFRyYWlsaW5nIGNvbG9uIGlzIHJlbW92ZWQgZnJvbSBgdXJsLmhvc3RgIHdoZW4gaXQgaXMgcGFyc2VkLiBJZiBpdCBzdGlsbFxuICAvLyBlbmRzIHdpdGggYSBjb2xvbiwgdGhlbiBhZGQgYmFjayB0aGUgdHJhaWxpbmcgY29sb24gdGhhdCB3YXMgcmVtb3ZlZC4gVGhpc1xuICAvLyBwcmV2ZW50cyBhbiBpbnZhbGlkIFVSTCBmcm9tIGJlaW5nIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBvbmUuXG4gIC8vXG4gIGlmIChob3N0W2hvc3QubGVuZ3RoIC0gMV0gPT09ICc6JyB8fCAocG9ydC50ZXN0KHVybC5ob3N0bmFtZSkgJiYgIXVybC5wb3J0KSkge1xuICAgIGhvc3QgKz0gJzonO1xuICB9XG5cbiAgcmVzdWx0ICs9IGhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIl0sIm5hbWVzIjpbInJlcXVpcmVkIiwicmVxdWlyZSIsInFzIiwiY29udHJvbE9yV2hpdGVzcGFjZSIsIkNSSFRMRiIsInNsYXNoZXMiLCJwb3J0IiwicHJvdG9jb2xyZSIsIndpbmRvd3NEcml2ZUxldHRlciIsInRyaW1MZWZ0Iiwic3RyIiwidG9TdHJpbmciLCJyZXBsYWNlIiwicnVsZXMiLCJzYW5pdGl6ZSIsImFkZHJlc3MiLCJ1cmwiLCJpc1NwZWNpYWwiLCJwcm90b2NvbCIsIk5hTiIsInVuZGVmaW5lZCIsImlnbm9yZSIsImhhc2giLCJxdWVyeSIsImxvbGNhdGlvbiIsImxvYyIsImdsb2JhbFZhciIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJsb2NhdGlvbiIsImZpbmFsZGVzdGluYXRpb24iLCJ0eXBlIiwia2V5IiwiVXJsIiwidW5lc2NhcGUiLCJwYXRobmFtZSIsInRlc3QiLCJocmVmIiwic2NoZW1lIiwiZXh0cmFjdFByb3RvY29sIiwibWF0Y2giLCJleGVjIiwidG9Mb3dlckNhc2UiLCJmb3J3YXJkU2xhc2hlcyIsIm90aGVyU2xhc2hlcyIsInNsYXNoZXNDb3VudCIsInJlc3QiLCJsZW5ndGgiLCJzbGljZSIsInJlc29sdmUiLCJyZWxhdGl2ZSIsImJhc2UiLCJwYXRoIiwic3BsaXQiLCJjb25jYXQiLCJpIiwibGFzdCIsInVuc2hpZnQiLCJ1cCIsInNwbGljZSIsInB1c2giLCJqb2luIiwicGFyc2VyIiwiZXh0cmFjdGVkIiwicGFyc2UiLCJpbnN0cnVjdGlvbiIsImluZGV4IiwiaW5zdHJ1Y3Rpb25zIiwibGFzdEluZGV4T2YiLCJpbmRleE9mIiwiY2hhckF0IiwiaG9zdCIsImhvc3RuYW1lIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJvcmlnaW4iLCJzZXQiLCJwYXJ0IiwidmFsdWUiLCJmbiIsInBvcCIsImNoYXIiLCJpbnMiLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/url-parse/index.js\n");

/***/ })

};
;