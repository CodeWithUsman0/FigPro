"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-react";
exports.ids = ["vendor-chunks/slate-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-react/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/slate-react/dist/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"(ssr)/./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/./node_modules/scroll-into-view-if-needed/es/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\r\n * A React context for sharing the editor object.\r\n */ var EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlateStatic = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\nvar REACT_MAJOR_VERSION = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split(\".\")[0], 10);\nvar IS_IOS = typeof navigator !== \"undefined\" && \"undefined\" !== \"undefined\" && 0 && 0;\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== \"undefined\" && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== \"undefined\" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== \"undefined\" && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== \"undefined\" && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== \"undefined\" && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== \"undefined\" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!( false && 0); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== \"undefined\" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === \"function\";\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */ var NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */ var EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */ var IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */ var EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */ var EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */ var EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */ var PLACEHOLDER_SYMBOL = Symbol(\"placeholder\");\nvar MARK_PLACEHOLDER_SYMBOL = Symbol(\"mark-placeholder\");\n/**\r\n * Types.\r\n */ var DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */ var getDefaultView = (value)=>{\n    return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */ var isDOMComment = (value)=>{\n    return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMElement = (value)=>{\n    return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */ var isDOMNode = (value)=>{\n    var window1 = getDefaultView(value);\n    return !!window1 && value instanceof window1.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */ var isDOMSelection = (value)=>{\n    var window1 = value && value.anchorNode && getDefaultView(value.anchorNode);\n    return !!window1 && value instanceof window1.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMText = (value)=>{\n    return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */ var isPlainTextOnlyPaste = (event)=>{\n    return event.clipboardData && event.clipboardData.getData(\"text/plain\") !== \"\" && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */ var normalizeDOMPoint = (domPoint)=>{\n    var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n    // including comment nodes, so try to find the right text child node.\n    if (isDOMElement(node) && node.childNodes.length) {\n        var isLast = offset === node.childNodes.length;\n        var index = isLast ? offset - 1 : offset;\n        [node, index] = getEditableChildAndIndex(node, index, isLast ? \"backward\" : \"forward\"); // If the editable child found is in front of input offset, we instead seek to its end\n        isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n        // can be either text nodes, or other void DOM nodes.\n        while(isDOMElement(node) && node.childNodes.length){\n            var i = isLast ? node.childNodes.length - 1 : 0;\n            node = getEditableChild(node, i, isLast ? \"backward\" : \"forward\");\n        } // Determine the new offset inside the text node.\n        offset = isLast && node.textContent != null ? node.textContent.length : 0;\n    } // Return the node and offset.\n    return [\n        node,\n        offset\n    ];\n};\n/**\r\n * Determines whether the active element is nested within a shadowRoot\r\n */ var hasShadowRoot = (node)=>{\n    var parent = node && node.parentNode;\n    while(parent){\n        if (parent.toString() === \"[object ShadowRoot]\") {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChildAndIndex = (parent, index, direction)=>{\n    var { childNodes } = parent;\n    var child = childNodes[index];\n    var i = index;\n    var triedForward = false;\n    var triedBackward = false; // While the child is a comment node, or an element node with no children,\n    // keep iterating to find a sibling non-void, non-comment node.\n    while(isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute(\"contenteditable\") === \"false\"){\n        if (triedForward && triedBackward) {\n            break;\n        }\n        if (i >= childNodes.length) {\n            triedForward = true;\n            i = index - 1;\n            direction = \"backward\";\n            continue;\n        }\n        if (i < 0) {\n            triedBackward = true;\n            i = index + 1;\n            direction = \"forward\";\n            continue;\n        }\n        child = childNodes[i];\n        index = i;\n        i += direction === \"forward\" ? 1 : -1;\n    }\n    return [\n        child,\n        index\n    ];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChild = (parent, index, direction)=>{\n    var [child] = getEditableChildAndIndex(parent, index, direction);\n    return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */ var getPlainText = (domNode)=>{\n    var text = \"\";\n    if (isDOMText(domNode) && domNode.nodeValue) {\n        return domNode.nodeValue;\n    }\n    if (isDOMElement(domNode)) {\n        for (var childNode of Array.from(domNode.childNodes)){\n            text += getPlainText(childNode);\n        }\n        var display = getComputedStyle(domNode).getPropertyValue(\"display\");\n        if (display === \"block\" || display === \"list\" || domNode.tagName === \"BR\") {\n            text += \"\\n\";\n        }\n    }\n    return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */ var catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = (dataTransfer)=>{\n    var htmlData = dataTransfer.getData(\"text/html\");\n    var [, fragment] = htmlData.match(catchSlateFragment) || [];\n    return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */ var isTrackedMutation = (editor, mutation, batch)=>{\n    var { target } = mutation;\n    if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n        return false;\n    }\n    var { document: document1 } = ReactEditor.getWindow(editor);\n    if (document1.contains(target)) {\n        return ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    }\n    var parentMutation = batch.find((_ref)=>{\n        var { addedNodes, removedNodes } = _ref;\n        for (var node of addedNodes){\n            if (node === target || node.contains(target)) {\n                return true;\n            }\n        }\n        for (var _node of removedNodes){\n            if (_node === target || _node.contains(target)) {\n                return true;\n            }\n        }\n    });\n    if (!parentMutation || parentMutation === mutation) {\n        return false;\n    } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n    return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\r\n * An auto-incrementing identifier for keys.\r\n */ var n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */ class Key {\n    constructor(){\n        this.id = \"\".concat(n++);\n    }\n}\nvar ReactEditor = {\n    androidPendingDiffs: (editor)=>EDITOR_TO_PENDING_DIFFS.get(editor),\n    androidScheduleFlush: (editor)=>{\n        var _EDITOR_TO_SCHEDULE_F;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n    },\n    blur: (editor)=>{\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, false);\n        if (root.activeElement === el) {\n            el.blur();\n        }\n    },\n    deselect: (editor)=>{\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (domSelection && domSelection.rangeCount > 0) {\n            domSelection.removeAllRanges();\n        }\n        if (selection) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n        }\n    },\n    findDocumentOrShadowRoot: (editor)=>{\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = el.getRootNode();\n        if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n            return root;\n        }\n        return el.ownerDocument;\n    },\n    findEventRange: (editor, event)=>{\n        if (\"nativeEvent\" in event) {\n            event = event.nativeEvent;\n        }\n        var { clientX: x, clientY: y, target } = event;\n        if (x == null || y == null) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        }\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n        // next or previous node, depending on which side the `x` and `y`\n        // coordinates are closest to.\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n            var rect = target.getBoundingClientRect();\n            var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n            var edge = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.point(editor, path, {\n                edge: isPrev ? \"start\" : \"end\"\n            });\n            var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, edge);\n            if (point) {\n                var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point);\n                return _range;\n            }\n        } // Else resolve a range from the caret position where the drop occured.\n        var domRange;\n        var { document: document1 } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n        if (document1.caretRangeFromPoint) {\n            domRange = document1.caretRangeFromPoint(x, y);\n        } else {\n            var position = document1.caretPositionFromPoint(x, y);\n            if (position) {\n                domRange = document1.createRange();\n                domRange.setStart(position.offsetNode, position.offset);\n                domRange.setEnd(position.offsetNode, position.offset);\n            }\n        }\n        if (!domRange) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        } // Resolve a Slate range from the DOM range.\n        var range = ReactEditor.toSlateRange(editor, domRange, {\n            exactMatch: false,\n            suppressThrow: false\n        });\n        return range;\n    },\n    findKey: (editor, node)=>{\n        var key = NODE_TO_KEY.get(node);\n        if (!key) {\n            key = new Key();\n            NODE_TO_KEY.set(node, key);\n        }\n        return key;\n    },\n    findPath: (editor, node)=>{\n        var path = [];\n        var child = node;\n        while(true){\n            var parent = NODE_TO_PARENT.get(child);\n            if (parent == null) {\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(child)) {\n                    return path;\n                } else {\n                    break;\n                }\n            }\n            var i = NODE_TO_INDEX.get(child);\n            if (i == null) {\n                break;\n            }\n            path.unshift(i);\n            child = parent;\n        }\n        throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n    },\n    focus: (editor)=>{\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, true);\n        if (root.activeElement !== el) {\n            el.focus({\n                preventScroll: true\n            });\n        }\n    },\n    getWindow: (editor)=>{\n        var window1 = EDITOR_TO_WINDOW.get(editor);\n        if (!window1) {\n            throw new Error(\"Unable to find a host window element for this editor\");\n        }\n        return window1;\n    },\n    hasDOMNode: function hasDOMNode(editor, target) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { editable = false } = options;\n        var editorEl = ReactEditor.toDOMNode(editor, editor);\n        var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n        // target is originating from an internal \"restricted\" element (e.g. a\n        // stepper arrow on a number input). (2018/05/04)\n        // https://github.com/ianstormtaylor/slate/issues/1819\n        try {\n            targetEl = isDOMElement(target) ? target : target.parentElement;\n        } catch (err) {\n            if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n                throw err;\n            }\n        }\n        if (!targetEl) {\n            return false;\n        }\n        return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === \"boolean\" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n        targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute(\"data-slate-zero-width\"));\n    },\n    hasEditableTarget: (editor, target)=>isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        }),\n    hasRange: (editor, range)=>{\n        var { anchor, focus } = range;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, focus.path);\n    },\n    hasSelectableTarget: (editor, target)=>ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target),\n    hasTarget: (editor, target)=>isDOMNode(target) && ReactEditor.hasDOMNode(editor, target),\n    insertData: (editor, data)=>{\n        editor.insertData(data);\n    },\n    insertFragmentData: (editor, data)=>editor.insertFragmentData(data),\n    insertTextData: (editor, data)=>editor.insertTextData(data),\n    isComposing: (editor)=>{\n        return !!IS_COMPOSING.get(editor);\n    },\n    isFocused: (editor)=>!!IS_FOCUSED.get(editor),\n    isReadOnly: (editor)=>!!IS_READ_ONLY.get(editor),\n    isTargetInsideNonReadonlyVoid: (editor, target)=>{\n        if (IS_READ_ONLY.get(editor)) return false;\n        var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, slateNode);\n    },\n    setFragmentData: (editor, data, originEvent)=>editor.setFragmentData(data, originEvent),\n    toDOMNode: (editor, node)=>{\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        var domNode = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n        if (!domNode) {\n            throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n        }\n        return domNode;\n    },\n    toDOMPoint: (editor, point)=>{\n        var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(editor, point.path);\n        var el = ReactEditor.toDOMNode(editor, node);\n        var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n        // width spacing character will result in an incorrect offset of 1\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: point\n        })) {\n            point = {\n                path: point.path,\n                offset: 0\n            };\n        } // For each leaf, we need to isolate its content, which means filtering\n        // to its direct text and zero-width spans. (We have to filter out any\n        // other siblings that may have been rendered alongside them.)\n        var selector = \"[data-slate-string], [data-slate-zero-width]\";\n        var texts = Array.from(el.querySelectorAll(selector));\n        var start = 0;\n        for(var i = 0; i < texts.length; i++){\n            var text = texts[i];\n            var domNode = text.childNodes[0];\n            if (domNode == null || domNode.textContent == null) {\n                continue;\n            }\n            var { length } = domNode.textContent;\n            var attr = text.getAttribute(\"data-slate-length\");\n            var trueLength = attr == null ? length : parseInt(attr, 10);\n            var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n            // composed text is displayed with the correct marks.\n            var nextText = texts[i + 1];\n            if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute(\"data-slate-mark-placeholder\")) {\n                var _nextText$textContent;\n                var domText = nextText.childNodes[0];\n                domPoint = [\n                    // dom text element, chrome will put the selection behind the actual dom\n                    // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n                    // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n                    // which will cause issues when scrolling to it.\n                    domText instanceof DOMText ? domText : nextText,\n                    (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0\n                ];\n                break;\n            }\n            if (point.offset <= end) {\n                var offset = Math.min(length, Math.max(0, point.offset - start));\n                domPoint = [\n                    domNode,\n                    offset\n                ];\n                break;\n            }\n            start = end;\n        }\n        if (!domPoint) {\n            throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(point)));\n        }\n        return domPoint;\n    },\n    toDOMRange: (editor, range)=>{\n        var { anchor, focus } = range;\n        var isBackward = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(range);\n        var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n        var domFocus = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n        var window1 = ReactEditor.getWindow(editor);\n        var domRange = window1.document.createRange();\n        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n        var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n        // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n        // adjust the offset accordingly.\n        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n        var isStartAtZeroWidth = !!startEl.getAttribute(\"data-slate-zero-width\");\n        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n        var isEndAtZeroWidth = !!endEl.getAttribute(\"data-slate-zero-width\");\n        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n        return domRange;\n    },\n    toSlateNode: (editor, domNode)=>{\n        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n        if (domEl && !domEl.hasAttribute(\"data-slate-node\")) {\n            domEl = domEl.closest(\"[data-slate-node]\");\n        }\n        var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n        if (!node) {\n            throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n        }\n        return node;\n    },\n    toSlatePoint: (editor, domPoint, options)=>{\n        var { exactMatch, suppressThrow } = options;\n        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n        var parentNode = nearestNode.parentNode;\n        var textNode = null;\n        var offset = 0;\n        if (parentNode) {\n            var _domNode$textContent, _domNode$textContent2;\n            var editorEl = ReactEditor.toDOMNode(editor, editor);\n            var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n            // within this editor, and not a void node within some parent editor. This can happen\n            // if this editor is within a void node of another editor (\"nested editors\", like in\n            // the \"Editable Voids\" example on the docs site).\n            var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n            var leafNode = parentNode.closest(\"[data-slate-leaf]\");\n            var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n            // can determine what the offset relative to the text node is.\n            if (leafNode) {\n                textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                if (textNode) {\n                    var window1 = ReactEditor.getWindow(editor);\n                    var range = window1.document.createRange();\n                    range.setStart(textNode, 0);\n                    range.setEnd(nearestNode, nearestOffset);\n                    var contents = range.cloneContents();\n                    var removals = [\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[data-slate-zero-width]\")),\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[contenteditable=false]\"))\n                    ];\n                    removals.forEach((el)=>{\n                        // COMPAT: While composing at the start of a text node, some keyboards put\n                        // the text content inside the zero width space.\n                        if (IS_ANDROID && !exactMatch && el.hasAttribute(\"data-slate-zero-width\") && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n                            if (el.textContent.startsWith(\"\\uFEFF\")) {\n                                el.textContent = el.textContent.slice(1);\n                            }\n                            return;\n                        }\n                        el.parentNode.removeChild(el);\n                    }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n                    // convert \\n into \\r\\n. The bug causes a loop when slate-react\n                    // attempts to reposition its cursor to match the native position. Use\n                    // textContent.length instead.\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n                    offset = contents.textContent.length;\n                    domNode = textNode;\n                }\n            } else if (voidNode) {\n                // For void nodes, the element with the offset key will be a cousin, not an\n                // ancestor, so find it by going down from the nearest void parent and taking the\n                // first one that isn't inside a nested editor.\n                var leafNodes = voidNode.querySelectorAll(\"[data-slate-leaf]\");\n                for(var index = 0; index < leafNodes.length; index++){\n                    var current = leafNodes[index];\n                    if (ReactEditor.hasDOMNode(editor, current)) {\n                        leafNode = current;\n                        break;\n                    }\n                } // COMPAT: In read-only editors the leaf is not rendered.\n                if (!leafNode) {\n                    offset = 1;\n                } else {\n                    textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                    domNode = leafNode;\n                    offset = domNode.textContent.length;\n                    domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el)=>{\n                        offset -= el.textContent.length;\n                    });\n                }\n            }\n            if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n            // and we don't add it for line-breaks.\n            IS_ANDROID && domNode.getAttribute(\"data-slate-zero-width\") === \"z\" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute(\"data-slate-zero-width\") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith(\"\\n\\n\"))) {\n                offset--;\n            }\n        }\n        if (IS_ANDROID && !textNode && !exactMatch) {\n            var node = parentNode.hasAttribute(\"data-slate-node\") ? parentNode : parentNode.closest(\"[data-slate-node]\");\n            if (node && ReactEditor.hasDOMNode(editor, node, {\n                editable: true\n            })) {\n                var _slateNode = ReactEditor.toSlateNode(editor, node);\n                var { path: _path, offset: _offset } = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n                if (!node.querySelector(\"[data-slate-leaf]\")) {\n                    _offset = nearestOffset;\n                }\n                return {\n                    path: _path,\n                    offset: _offset\n                };\n            }\n        }\n        if (!textNode) {\n            if (suppressThrow) {\n                return null;\n            }\n            throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n        } // COMPAT: If someone is clicking from one Slate editor into another,\n        // the select event fires twice, once for the old editor's `element`\n        // first, and then afterwards for the correct `element`. (2017/03/03)\n        var slateNode = ReactEditor.toSlateNode(editor, textNode);\n        var path = ReactEditor.findPath(editor, slateNode);\n        return {\n            path,\n            offset\n        };\n    },\n    toSlateRange: (editor, domRange, options)=>{\n        var { exactMatch, suppressThrow } = options;\n        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n        var anchorNode;\n        var anchorOffset;\n        var focusNode;\n        var focusOffset;\n        var isCollapsed;\n        if (el) {\n            if (isDOMSelection(domRange)) {\n                // COMPAT: In firefox the normal seletion way does not work\n                // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n                if (IS_FIREFOX && domRange.rangeCount > 1) {\n                    focusNode = domRange.focusNode; // Focus node works fine\n                    var firstRange = domRange.getRangeAt(0);\n                    var lastRange = domRange.getRangeAt(domRange.rangeCount - 1); // Here we are in the contenteditable mode of a table in firefox\n                    if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n                        // HTMLElement, becouse Element is a slate element\n                        function getLastChildren(element) {\n                            if (element.childElementCount > 0) {\n                                return getLastChildren(element.children[0]);\n                            } else {\n                                return element;\n                            }\n                        }\n                        var firstNodeRow = firstRange.startContainer;\n                        var lastNodeRow = lastRange.startContainer; // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n                        var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n                        var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]); // Zero, as we allways take the right one as the anchor point\n                        focusOffset = 0;\n                        if (lastNode.childNodes.length > 0) {\n                            anchorNode = lastNode.childNodes[0];\n                        } else {\n                            anchorNode = lastNode;\n                        }\n                        if (firstNode.childNodes.length > 0) {\n                            focusNode = firstNode.childNodes[0];\n                        } else {\n                            focusNode = firstNode;\n                        }\n                        if (lastNode instanceof HTMLElement) {\n                            anchorOffset = lastNode.innerHTML.length;\n                        } else {\n                            // Fallback option\n                            anchorOffset = 0;\n                        }\n                    } else {\n                        // This is the read only mode of a firefox table\n                        // Right to left\n                        if (firstRange.startContainer === focusNode) {\n                            anchorNode = lastRange.endContainer;\n                            anchorOffset = lastRange.endOffset;\n                            focusOffset = firstRange.startOffset;\n                        } else {\n                            // Left to right\n                            anchorNode = firstRange.startContainer;\n                            anchorOffset = firstRange.endOffset;\n                            focusOffset = lastRange.startOffset;\n                        }\n                    }\n                } else {\n                    anchorNode = domRange.anchorNode;\n                    anchorOffset = domRange.anchorOffset;\n                    focusNode = domRange.focusNode;\n                    focusOffset = domRange.focusOffset;\n                } // COMPAT: There's a bug in chrome that always returns `true` for\n                // `isCollapsed` for a Selection that comes from a ShadowRoot.\n                // (2020/08/08)\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n                // IsCollapsed might not work in firefox, but this will\n                if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n                    isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n                } else {\n                    isCollapsed = domRange.isCollapsed;\n                }\n            } else {\n                anchorNode = domRange.startContainer;\n                anchorOffset = domRange.startOffset;\n                focusNode = domRange.endContainer;\n                focusOffset = domRange.endOffset;\n                isCollapsed = domRange.collapsed;\n            }\n        }\n        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n            throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n        } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n        // inside a `contenteditable=\"false\"` DOM node following the word, which\n        // will cause `toSlatePoint` to throw an error. (2023/03/07)\n        if (\"getAttribute\" in focusNode && focusNode.getAttribute(\"contenteditable\") === \"false\" && focusNode.getAttribute(\"data-slate-void\") !== \"true\") {\n            var _anchorNode$textConte;\n            focusNode = anchorNode;\n            focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n        }\n        var anchor = ReactEditor.toSlatePoint(editor, [\n            anchorNode,\n            anchorOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!anchor) {\n            return null;\n        }\n        var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [\n            focusNode,\n            focusOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!focus) {\n            return null;\n        }\n        var range = {\n            anchor: anchor,\n            focus: focus\n        }; // if the selection is a hanging range that ends in a void\n        // and the DOM focus is an Element\n        // (meaning that the selection ends before the element)\n        // unhang the range to avoid mistakenly including the void\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range.focus,\n            mode: \"highest\"\n        })) {\n            range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.unhangRange(editor, range, {\n                voids: true\n            });\n        }\n        return range;\n    }\n};\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */ function verifyDiffState(editor, textDiff) {\n    var { path, diff } = textDiff;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return false;\n    }\n    var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n        return false;\n    }\n    if (diff.start !== node.text.length || diff.text.length === 0) {\n        return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n    }\n    var nextPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, nextPath)) {\n        return false;\n    }\n    var nextNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, nextPath);\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n    for(var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        diffs[_key - 1] = arguments[_key];\n    }\n    return diffs.reduce((text, diff)=>text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n    var length = Math.min(str.length, another.length);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(i) !== another.charAt(i)) {\n            return i;\n        }\n    }\n    return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n    var length = Math.min(str.length, another.length, max);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n            return i;\n        }\n    }\n    return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */ function normalizeStringDiff(targetText, diff) {\n    var { start, end, text } = diff;\n    var removedText = targetText.slice(start, end);\n    var prefixLength = longestCommonPrefixLength(removedText, text);\n    var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n    var suffixLength = longestCommonSuffixLength(removedText, text, max);\n    var normalized = {\n        start: start + prefixLength,\n        end: end - suffixLength,\n        text: text.slice(prefixLength, text.length - suffixLength)\n    };\n    if (normalized.start === normalized.end && normalized.text.length === 0) {\n        return null;\n    }\n    return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */ function mergeStringDiffs(targetText, a, b) {\n    var start = Math.min(a.start, b.start);\n    var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n    var applied = applyStringDiff(targetText, a, b);\n    var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n    var text = applied.slice(start, sliceEnd);\n    var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n    return normalizeStringDiff(targetText, {\n        start,\n        end,\n        text\n    });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */ function targetRange(textDiff) {\n    var { path, diff } = textDiff;\n    return {\n        anchor: {\n            path,\n            offset: diff.start\n        },\n        focus: {\n            path,\n            offset: diff.end\n        }\n    };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */ function normalizePoint(editor, point) {\n    var { path, offset } = point;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return null;\n    }\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(leaf)) {\n        return null;\n    }\n    var parentBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n        at: path\n    });\n    if (!parentBlock) {\n        return null;\n    }\n    while(offset > leaf.text.length){\n        var entry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n        });\n        if (!entry || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.isDescendant(entry[1], parentBlock[1])) {\n            return null;\n        }\n        offset -= leaf.text.length;\n        leaf = entry[0];\n        path = entry[1];\n    }\n    return {\n        path,\n        offset\n    };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */ function normalizeRange(editor, range) {\n    var anchor = normalizePoint(editor, range.anchor);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = normalizePoint(editor, range.focus);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformPendingPoint(editor, point, op) {\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n    var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref)=>{\n        var { path } = _ref;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(path, point.path);\n    });\n    if (!textDiff || point.offset <= textDiff.diff.start) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(point, op, {\n            affinity: \"backward\"\n        });\n    }\n    var { diff } = textDiff; // Point references location inside the diff => transform the point based on the location\n    // the diff will be applied to and add the offset inside the diff.\n    if (point.offset <= diff.start + diff.text.length) {\n        var _anchor = {\n            path: point.path,\n            offset: diff.start\n        };\n        var _transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(_anchor, op, {\n            affinity: \"backward\"\n        });\n        if (!_transformed) {\n            return null;\n        }\n        return {\n            path: _transformed.path,\n            offset: _transformed.offset + point.offset - diff.start\n        };\n    } // Point references location after the diff\n    var anchor = {\n        path: point.path,\n        offset: point.offset - diff.text.length + diff.end - diff.start\n    };\n    var transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(anchor, op, {\n        affinity: \"backward\"\n    });\n    if (!transformed) {\n        return null;\n    }\n    if (op.type === \"split_node\" && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n        return transformed;\n    }\n    return {\n        path: transformed.path,\n        offset: transformed.offset + diff.text.length - diff.end + diff.start\n    };\n}\nfunction transformPendingRange(editor, range, op) {\n    var anchor = transformPendingPoint(editor, range.anchor, op);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = transformPendingPoint(editor, range.focus, op);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformTextDiff(textDiff, op) {\n    var { path, diff, id } = textDiff;\n    switch(op.type){\n        case \"insert_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset <= diff.start) {\n                    return {\n                        diff: {\n                            start: op.text.length + diff.start,\n                            end: op.text.length + diff.end,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end + op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"remove_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset + op.text.length <= diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start - op.text.length,\n                            end: diff.end - op.text.length,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end - op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"split_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.position >= diff.end) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                            affinity: \"backward\"\n                        })\n                    };\n                }\n                if (op.position > diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start,\n                            end: Math.min(op.position, diff.end),\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start - op.position,\n                        end: diff.end - op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                        affinity: \"forward\"\n                    })\n                };\n            }\n        case \"merge_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path)) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start + op.position,\n                        end: diff.end + op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                };\n            }\n    }\n    var newPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op);\n    if (!newPath) {\n        return null;\n    }\n    return {\n        diff,\n        path: newPath,\n        id\n    };\n}\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\nvar isDataTransfer = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === \"DataTransfer\";\nfunction createAndroidInputManager(_ref) {\n    var { editor, scheduleOnDOMSelectionChange, onDOMSelectionChange } = _ref;\n    var flushing = false;\n    var compositionEndTimeoutId = null;\n    var flushTimeoutId = null;\n    var actionTimeoutId = null;\n    var idCounter = 0;\n    var insertPositionHint = false;\n    var applyPendingSelection = ()=>{\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        if (pendingSelection) {\n            var { selection } = editor;\n            var normalized = normalizeRange(editor, pendingSelection);\n            if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n            }\n        }\n    };\n    var performAction = ()=>{\n        var action = EDITOR_TO_PENDING_ACTION.get(editor);\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        if (!action) {\n            return;\n        }\n        if (action.at) {\n            var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n            if (!target) {\n                return;\n            }\n            var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n            }\n        }\n        action.run();\n    };\n    var flush = ()=>{\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        if (actionTimeoutId) {\n            clearTimeout(actionTimeoutId);\n            actionTimeoutId = null;\n        }\n        if (!hasPendingDiffs() && !hasPendingAction()) {\n            applyPendingSelection();\n            return;\n        }\n        if (!flushing) {\n            flushing = true;\n            setTimeout(()=>flushing = false);\n        }\n        if (hasPendingAction()) {\n            flushing = \"action\";\n        }\n        var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n            affinity: \"forward\"\n        });\n        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n        debug(\"flush\", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n        var scheduleSelectionChange = hasPendingDiffs();\n        var diff;\n        while(diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]){\n            var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n            var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n            if (pendingMarks !== undefined) {\n                EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n                editor.marks = pendingMarks;\n            }\n            if (pendingMarks && insertPositionHint === false) {\n                insertPositionHint = null;\n            }\n            var range = targetRange(diff);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n            }\n            if (diff.diff.text) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n            } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            } // Remove diff only after we have applied it to account for it when transforming\n            // pending ranges.\n            EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2)=>{\n                var { id } = _ref2;\n                return id !== diff.id;\n            }));\n            if (!verifyDiffState(editor, diff)) {\n                scheduleSelectionChange = false;\n                EDITOR_TO_PENDING_ACTION.delete(editor);\n                EDITOR_TO_USER_MARKS.delete(editor);\n                flushing = \"action\"; // Ensure we don't restore the pending user (dom) selection\n                // since the document and dom state do not match.\n                EDITOR_TO_PENDING_SELECTION.delete(editor);\n                scheduleOnDOMSelectionChange.cancel();\n                onDOMSelectionChange.cancel();\n                selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n            }\n        }\n        var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n        if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n        }\n        if (hasPendingAction()) {\n            performAction();\n            return;\n        } // COMPAT: The selectionChange event is fired after the action is performed,\n        // so we have to manually schedule it to ensure we don't 'throw away' the selection\n        // while rendering if we have pending changes.\n        if (scheduleSelectionChange) {\n            scheduleOnDOMSelectionChange();\n        }\n        scheduleOnDOMSelectionChange.flush();\n        onDOMSelectionChange.flush();\n        applyPendingSelection();\n        var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        if (userMarks !== undefined) {\n            editor.marks = userMarks;\n            editor.onChange();\n        }\n    };\n    var handleCompositionEnd = (_event)=>{\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n        }\n        compositionEndTimeoutId = setTimeout(()=>{\n            IS_COMPOSING.set(editor, false);\n            flush();\n        }, RESOLVE_DELAY);\n    };\n    var handleCompositionStart = (_event)=>{\n        IS_COMPOSING.set(editor, true);\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n            compositionEndTimeoutId = null;\n        }\n    };\n    var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n        var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n        if (!placeholderElement) {\n            return;\n        }\n        if (hasPendingDiffs() || forceHide) {\n            placeholderElement.style.display = \"none\";\n            return;\n        }\n        placeholderElement.style.removeProperty(\"display\");\n    };\n    var storeDiff = (path, diff)=>{\n        var _EDITOR_TO_PENDING_DI3;\n        var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n        EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n        var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n        var idx = pendingDiffs.findIndex((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n        if (idx < 0) {\n            var normalized = normalizeStringDiff(target.text, diff);\n            if (normalized) {\n                pendingDiffs.push({\n                    path,\n                    diff,\n                    id: idCounter++\n                });\n            }\n            updatePlaceholderVisibility();\n            return;\n        }\n        var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n        if (!merged) {\n            pendingDiffs.splice(idx, 1);\n            updatePlaceholderVisibility();\n            return;\n        }\n        pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n            diff: merged\n        });\n    };\n    var scheduleAction = function scheduleAction(run) {\n        var { at } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        insertPositionHint = false;\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        if (hasPendingAction()) {\n            flush();\n        }\n        EDITOR_TO_PENDING_ACTION.set(editor, {\n            at,\n            run\n        }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n        // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n        // in this case and thus never actually perform the action.\n        actionTimeoutId = setTimeout(flush);\n    };\n    var handleDOMBeforeInput = (event)=>{\n        var _targetRange2;\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { inputType: type } = event;\n        var targetRange = null;\n        var data = event.dataTransfer || event.data || undefined;\n        if (insertPositionHint !== false && type !== \"insertText\" && type !== \"insertCompositionText\") {\n            insertPositionHint = false;\n        }\n        var [nativeTargetRange] = event.getTargetRanges();\n        if (nativeTargetRange) {\n            targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        } // COMPAT: SelectionChange event is fired after the action is performed, so we\n        // have to manually get the selection here to ensure it's up-to-date.\n        var window1 = ReactEditor.getWindow(editor);\n        var domSelection = window1.getSelection();\n        if (!targetRange && domSelection) {\n            nativeTargetRange = domSelection;\n            targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        }\n        targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n        if (!targetRange) {\n            return;\n        } // By default, the input manager tries to store text diffs so that we can\n        // defer flushing them at a later point in time. We don't want to flush\n        // for every input event as this can be expensive. However, there are some\n        // scenarios where we cannot safely store the text diff and must instead\n        // schedule an action to let Slate normalize the editor state.\n        var canStoreDiff = true;\n        if (type.startsWith(\"delete\")) {\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n                if (_leaf.text.length === _start.offset && _end.offset === 0) {\n                    var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n                        at: _start.path,\n                        match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n                    });\n                    if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n                        targetRange = {\n                            anchor: _end,\n                            focus: _end\n                        };\n                    }\n                }\n            }\n            var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n            var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n            var diff = {\n                text: \"\",\n                start: start.offset,\n                end: end.offset\n            };\n            var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n            var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n            var diffs = relevantPendingDiffs ? [\n                relevantPendingDiffs.diff,\n                diff\n            ] : [\n                diff\n            ];\n            var text = applyStringDiff(leaf.text, ...diffs);\n            if (text.length === 0) {\n                // Text leaf will be removed, so we need to schedule an\n                // action to remove it so that Slate can normalize instead\n                // of storing as a diff\n                canStoreDiff = false;\n            }\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                    var point = {\n                        path: targetRange.anchor.path,\n                        offset: start.offset\n                    };\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n                    handleUserSelect(range);\n                    return storeDiff(targetRange.anchor.path, {\n                        text: \"\",\n                        end: end.offset,\n                        start: start.offset\n                    });\n                }\n                return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                        direction\n                    }), {\n                    at: targetRange\n                });\n            }\n        }\n        switch(type){\n            case \"deleteByComposition\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContent\":\n            case \"deleteContentForward\":\n                {\n                    var { anchor } = targetRange;\n                    if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n                        var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n                        if (anchor.offset < targetNode.text.length) {\n                            return storeDiff(anchor.path, {\n                                text: \"\",\n                                start: anchor.offset,\n                                end: anchor.offset + 1\n                            });\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContentBackward\":\n                {\n                    var _nativeTargetRange;\n                    var { anchor: _anchor } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n                    // we are most likely deleting a zero-width placeholder and thus should perform it\n                    // as an action to ensure correct behavior (mostly happens with mark placeholders)\n                    var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n                    if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n                        return storeDiff(_anchor.path, {\n                            text: \"\",\n                            start: _anchor.offset - 1,\n                            end: _anchor.offset\n                        });\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteEntireSoftLine\":\n                {\n                    return scheduleAction(()=>{\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                    }, {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"insertLineBreak\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertParagraph\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertCompositionText\":\n            case \"deleteCompositionText\":\n            case \"insertFromComposition\":\n            case \"insertFromDrop\":\n            case \"insertFromPaste\":\n            case \"insertFromYank\":\n            case \"insertReplacementText\":\n            case \"insertText\":\n                {\n                    if (isDataTransfer(data)) {\n                        return scheduleAction(()=>ReactEditor.insertData(editor, data), {\n                            at: targetRange\n                        });\n                    }\n                    var _text = data !== null && data !== void 0 ? data : \"\"; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n                    // the placeholder itself and thus includes the zero-width space inside edit events.\n                    if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n                        _text = _text.replace(\"\\uFEFF\", \"\");\n                    } // Pastes from the Android clipboard will generate `insertText` events.\n                    // If the copied text contains any newlines, Android will append an\n                    // extra newline to the end of the copied text.\n                    if (type === \"insertText\" && /.*\\n.*\\n$/.test(_text)) {\n                        _text = _text.slice(0, -1);\n                    } // If the text includes a newline, split it at newlines and paste each component\n                    // string, with soft breaks in between each.\n                    if (_text.includes(\"\\n\")) {\n                        return scheduleAction(()=>{\n                            var parts = _text.split(\"\\n\");\n                            parts.forEach((line, i)=>{\n                                if (line) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                                }\n                                if (i !== parts.length - 1) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                                }\n                            });\n                        }, {\n                            at: targetRange\n                        });\n                    }\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                        var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                        var _diff = {\n                            start: _start2.offset,\n                            end: _end2.offset,\n                            text: _text\n                        }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n                        // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n                        // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n                        // text events are fired with the correct target ranges, only the final 'insertComposition'\n                        // isn't, so we can adjust the target range start offset if we are confident this is the\n                        // swiftkey insert causing the issue.\n                        if (_text && insertPositionHint && type === \"insertCompositionText\") {\n                            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n                            var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n                            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                                _diff.start -= 1;\n                                insertPositionHint = null;\n                                scheduleFlush();\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else if (type === \"insertText\") {\n                            if (insertPositionHint === null) {\n                                insertPositionHint = _diff;\n                            } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                                    text: insertPositionHint.text + _text\n                                });\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else {\n                            insertPositionHint = false;\n                        }\n                        if (canStoreDiff) {\n                            storeDiff(_start2.path, _diff);\n                            return;\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n                        at: targetRange\n                    });\n                }\n        }\n    };\n    var hasPendingAction = ()=>{\n        return !!EDITOR_TO_PENDING_ACTION.get(editor);\n    };\n    var hasPendingDiffs = ()=>{\n        var _EDITOR_TO_PENDING_DI4;\n        return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n    };\n    var hasPendingChanges = ()=>{\n        return hasPendingAction() || hasPendingDiffs();\n    };\n    var isFlushing = ()=>{\n        return flushing;\n    };\n    var handleUserSelect = (range)=>{\n        EDITOR_TO_PENDING_SELECTION.set(editor, range);\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { selection } = editor;\n        if (!range) {\n            return;\n        }\n        var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n        var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n        if (pathChanged && insertPositionHint || parentPathChanged) {\n            insertPositionHint = false;\n        }\n        if (pathChanged || hasPendingDiffs()) {\n            flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n        }\n    };\n    var handleInput = ()=>{\n        if (hasPendingAction() || !hasPendingDiffs()) {\n            flush();\n        }\n    };\n    var handleKeyDown = (_)=>{\n        // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n        // directly next to a non-contenteditable element (= the placeholder).\n        // The only event fired soon enough for us to allow hiding the placeholder\n        // without swiftkey picking it up is the keydown event, so we have to hide it\n        // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n        if (!hasPendingDiffs()) {\n            updatePlaceholderVisibility(true);\n            setTimeout(updatePlaceholderVisibility);\n        }\n    };\n    var scheduleFlush = ()=>{\n        if (!hasPendingAction()) {\n            actionTimeoutId = setTimeout(flush);\n        }\n    };\n    var handleDomMutations = (mutations)=>{\n        if (hasPendingDiffs() || hasPendingAction()) {\n            return;\n        }\n        if (mutations.some((mutation)=>isTrackedMutation(editor, mutation, mutations))) {\n            var _EDITOR_TO_FORCE_REND;\n            // Cause a re-render to restore the dom state if we encounter tracked mutations without\n            // a corresponding pending action.\n            (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n        }\n    };\n    return {\n        flush,\n        scheduleFlush,\n        hasPendingDiffs,\n        hasPendingAction,\n        hasPendingChanges,\n        isFlushing,\n        handleUserSelect,\n        handleCompositionEnd,\n        handleCompositionStart,\n        handleDOMBeforeInput,\n        handleKeyDown,\n        handleDomMutations,\n        handleInput\n    };\n}\nfunction useIsMounted() {\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef.current;\n}\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */ var useIsomorphicLayoutEffect = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\nfunction useMutationObserver(node, callback, options) {\n    var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>new MutationObserver(callback));\n    useIsomorphicLayoutEffect(()=>{\n        // Discard mutations caused during render phase. This works due to react calling\n        // useLayoutEffect synchronously after the render phase before the next tick.\n        mutationObserver.takeRecords();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        mutationObserver.observe(node.current, options);\n        return ()=>mutationObserver.disconnect();\n    }, [\n        mutationObserver,\n        node,\n        options\n    ]);\n}\nvar _excluded$3 = [\n    \"node\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar MUTATION_OBSERVER_CONFIG$1 = {\n    subtree: true,\n    childList: true,\n    characterData: true\n};\nvar useAndroidInputManager = !IS_ANDROID ? ()=>null : (_ref)=>{\n    var { node } = _ref, options = _objectWithoutProperties(_ref, _excluded$3);\n    if (!IS_ANDROID) {\n        return null;\n    }\n    var editor = useSlateStatic();\n    var isMounted = useIsMounted();\n    var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>createAndroidInputManager(_objectSpread$2({\n            editor\n        }, options)));\n    useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n    EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n    if (isMounted) {\n        inputManager.flush();\n    }\n    return inputManager;\n};\nvar _excluded$2 = [\n    \"anchor\",\n    \"focus\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nvar shallowCompare = (obj1, obj2)=>Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other)=>{\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded$2);\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n    return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isElementDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i];\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isTextDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i]; // compare only offsets because paths doesn't matter for text\n        if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Leaf content strings.\r\n */ var String = (props)=>{\n    var { isLast, leaf, parent, text } = props;\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, text);\n    var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n    var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.isVoid(parent)) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n        });\n    } // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (leaf.text === \"\" && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isLineBreak: true,\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (leaf.text === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    if (isLast && leaf.text.slice(-1) === \"\\n\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n            isTrailing: true,\n            text: leaf.text\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n        text: leaf.text\n    });\n};\n/**\r\n * Leaf strings with text in them.\r\n */ var TextString = (props)=>{\n    var { text, isTrailing = false } = props;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var getTextContent = ()=>{\n        return \"\".concat(text !== null && text !== void 0 ? text : \"\").concat(isTrailing ? \"\\n\" : \"\");\n    };\n    var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent); // This is the actual text rendering boundary where we interface with the DOM\n    // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n    // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n    // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n    // exactly if and only if its current content does not match our current virtual DOM.\n    // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n    // eg makes native spellcheck opt out from checking the text node.\n    // useLayoutEffect: updating our span before browser paint\n    useIsomorphicLayoutEffect(()=>{\n        // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n        var textWithTrailing = getTextContent();\n        if (ref.current && ref.current.textContent !== textWithTrailing) {\n            ref.current.textContent = textWithTrailing;\n        } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n    }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n    // We defer to the layout effect above to update the `textContent` of the span element when needed.\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n        ref: ref\n    }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-string\": true,\n        ref: ref\n    }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */ var ZeroWidthString = (props)=>{\n    var { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props;\n    var attributes = {\n        \"data-slate-zero-width\": isLineBreak ? \"n\" : \"z\",\n        \"data-slate-length\": length\n    };\n    if (isMarkPlaceholder) {\n        attributes[\"data-slate-mark-placeholder\"] = true;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n    if (placeholderResizeObserver.current) {\n        placeholderResizeObserver.current.disconnect();\n        if (releaseObserver) {\n            placeholderResizeObserver.current = null;\n        }\n    }\n}\nfunction clearTimeoutRef(timeoutRef) {\n    if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n    }\n}\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */ var Leaf = (props)=>{\n    var { leaf, isLast, text, parent, renderPlaceholder, renderLeaf = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, Object.assign({}, props)) } = props;\n    var editor = useSlateStatic();\n    var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var [showPlaceholder, setShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var showPlaceholderTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var callbackPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((placeholderEl)=>{\n        disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n        if (placeholderEl == null) {\n            var _leaf$onPlaceholderRe;\n            EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n            (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 ? void 0 : _leaf$onPlaceholderRe.call(leaf, null);\n        } else {\n            EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n            if (!placeholderResizeObserver.current) {\n                // Create a new observer and observe the placeholder element.\n                var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__.ResizeObserver;\n                placeholderResizeObserver.current = new ResizeObserver$1(()=>{\n                    var _leaf$onPlaceholderRe2;\n                    (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 ? void 0 : _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n                });\n            }\n            placeholderResizeObserver.current.observe(placeholderEl);\n            placeholderRef.current = placeholderEl;\n        }\n    }, [\n        placeholderRef,\n        leaf,\n        editor\n    ]);\n    var children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String, {\n        isLast: isLast,\n        leaf: leaf,\n        parent: parent,\n        text: text\n    });\n    var leafIsPlaceholder = leaf[PLACEHOLDER_SYMBOL];\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (leafIsPlaceholder) {\n            if (!showPlaceholderTimeoutRef.current) {\n                // Delay the placeholder so it will not render in a selection\n                showPlaceholderTimeoutRef.current = setTimeout(()=>{\n                    setShowPlaceholder(true);\n                    showPlaceholderTimeoutRef.current = null;\n                }, 300);\n            }\n        } else {\n            clearTimeoutRef(showPlaceholderTimeoutRef);\n            setShowPlaceholder(false);\n        }\n        return ()=>clearTimeoutRef(showPlaceholderTimeoutRef);\n    }, [\n        leafIsPlaceholder,\n        setShowPlaceholder\n    ]);\n    if (leafIsPlaceholder && showPlaceholder) {\n        var placeholderProps = {\n            children: leaf.placeholder,\n            attributes: {\n                \"data-slate-placeholder\": true,\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    pointerEvents: \"none\",\n                    width: \"100%\",\n                    maxWidth: \"100%\",\n                    display: \"block\",\n                    opacity: \"0.333\",\n                    userSelect: \"none\",\n                    textDecoration: \"none\",\n                    // Fixes https://github.com/udecode/plate/issues/2315\n                    WebkitUserModify: IS_WEBKIT ? \"inherit\" : undefined\n                },\n                contentEditable: false,\n                ref: callbackPlaceholderRef\n            }\n        };\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n    } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n    var attributes = {\n        \"data-slate-leaf\": true\n    };\n    return renderLeaf({\n        attributes,\n        children,\n        leaf,\n        text\n    });\n};\nvar MemoizedLeaf = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = (props)=>{\n    var { attributes, children } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children);\n};\n/**\r\n * Text.\r\n */ var Text = (props)=>{\n    var { decorations, isLast, parent, renderPlaceholder, renderLeaf, text } = props;\n    var editor = useSlateStatic();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n    var key = ReactEditor.findKey(editor, text);\n    var children = [];\n    for(var i = 0; i < leaves.length; i++){\n        var leaf = leaves[i];\n        children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n            isLast: isLast && i === leaves.length - 1,\n            key: \"\".concat(key.id, \"-\").concat(i),\n            renderPlaceholder: renderPlaceholder,\n            leaf: leaf,\n            text: text,\n            parent: parent,\n            renderLeaf: renderLeaf\n        }));\n    } // Update element-related weak maps with the DOM element ref.\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((span)=>{\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (span) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n            NODE_TO_ELEMENT.set(text, span);\n            ELEMENT_TO_NODE.set(span, text);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(text);\n            if (ref.current) {\n                ELEMENT_TO_NODE.delete(ref.current);\n            }\n        }\n        ref.current = span;\n    }, [\n        ref,\n        editor,\n        key,\n        text\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-node\": \"text\",\n        ref: callbackRef\n    }, children);\n};\nvar MemoizedText = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n/**\r\n * Element.\r\n */ var Element = (props)=>{\n    var { decorations, element, renderElement = (p)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, Object.assign({}, p)), renderPlaceholder, renderLeaf, selection } = props;\n    var editor = useSlateStatic();\n    var readOnly = useReadOnly();\n    var isInline = editor.isInline(element);\n    var key = ReactEditor.findKey(editor, element);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((ref)=>{\n        // Update element-related weak maps with the DOM element ref.\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (ref) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n            NODE_TO_ELEMENT.set(element, ref);\n            ELEMENT_TO_NODE.set(ref, element);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(element);\n        }\n    }, [\n        editor,\n        key,\n        element\n    ]);\n    var children = useChildren({\n        decorations,\n        node: element,\n        renderElement,\n        renderPlaceholder,\n        renderLeaf,\n        selection\n    }); // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n        \"data-slate-node\": \"element\",\n        ref\n    };\n    if (isInline) {\n        attributes[\"data-slate-inline\"] = true;\n    } // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n        var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n        var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n        if (dir === \"rtl\") {\n            attributes.dir = dir;\n        }\n    } // If it's a void node, wrap the children in extra void-specific elements.\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n        attributes[\"data-slate-void\"] = true;\n        if (!readOnly && isInline) {\n            attributes.contentEditable = false;\n        }\n        var Tag = isInline ? \"span\" : \"div\";\n        var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n            \"data-slate-spacer\": true,\n            style: {\n                height: \"0\",\n                color: \"transparent\",\n                outline: \"none\",\n                position: \"absolute\"\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n            renderPlaceholder: renderPlaceholder,\n            decorations: [],\n            isLast: false,\n            parent: element,\n            text: _text\n        }));\n        NODE_TO_INDEX.set(_text, 0);\n        NODE_TO_PARENT.set(_text, element);\n    }\n    return renderElement({\n        attributes,\n        children,\n        element\n    });\n};\nvar MemoizedElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next)=>{\n    return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */ var DefaultElement = (props)=>{\n    var { attributes, children, element } = props;\n    var editor = useSlateStatic();\n    var Tag = editor.isInline(element) ? \"span\" : \"div\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, Object.assign({}, attributes, {\n        style: {\n            position: \"relative\"\n        }\n    }), children);\n};\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */ var DecorateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(()=>[]);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */ var useDecorate = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */ var SelectedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */ var useSelected = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n/**\r\n * Children.\r\n */ var useChildren = (props)=>{\n    var { decorations, node, renderElement, renderPlaceholder, renderLeaf, selection } = props;\n    var decorate = useDecorate();\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, node);\n    var children = [];\n    var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n    for(var i = 0; i < node.children.length; i++){\n        var p = path.concat(i);\n        var n = node.children[i];\n        var key = ReactEditor.findKey(editor, n);\n        var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n        var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n        var ds = decorate([\n            n,\n            p\n        ]);\n        for (var dec of decorations){\n            var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n            if (d) {\n                ds.push(d);\n            }\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n                key: \"provider-\".concat(key.id),\n                value: !!sel\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n                decorations: ds,\n                element: n,\n                key: key.id,\n                renderElement: renderElement,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                selection: sel\n            })));\n        } else {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n                decorations: ds,\n                key: key.id,\n                isLast: isLeafBlock && i === node.children.length - 1,\n                parent: node,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                text: n\n            }));\n        }\n        NODE_TO_INDEX.set(n, i);\n        NODE_TO_PARENT.set(n, node);\n    }\n    return children;\n};\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */ var ReadOnlyContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */ var useReadOnly = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\nvar SlateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlate = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    var { editor } = context;\n    return editor;\n};\nvar useSlateWithV = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    return context;\n};\nfunction useTrackUserInput() {\n    var editor = useSlateStatic();\n    var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (receivedUserInput.current) {\n            return;\n        }\n        receivedUserInput.current = true;\n        var window1 = ReactEditor.getWindow(editor);\n        window1.cancelAnimationFrame(animationFrameIdRef.current);\n        animationFrameIdRef.current = window1.requestAnimationFrame(()=>{\n            receivedUserInput.current = false;\n        });\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>()=>cancelAnimationFrame(animationFrameIdRef.current), []);\n    return {\n        receivedUserInput,\n        onUserInput\n    };\n}\nvar TRIPLE_CLICK = 3;\n/**\r\n * Hotkey mappings for each platform.\r\n */ var HOTKEYS = {\n    bold: \"mod+b\",\n    compose: [\n        \"down\",\n        \"left\",\n        \"right\",\n        \"up\",\n        \"backspace\",\n        \"enter\"\n    ],\n    moveBackward: \"left\",\n    moveForward: \"right\",\n    moveWordBackward: \"ctrl+left\",\n    moveWordForward: \"ctrl+right\",\n    deleteBackward: \"shift?+backspace\",\n    deleteForward: \"shift?+delete\",\n    extendBackward: \"shift+left\",\n    extendForward: \"shift+right\",\n    italic: \"mod+i\",\n    insertSoftBreak: \"shift+enter\",\n    splitBlock: \"enter\",\n    undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS = {\n    moveLineBackward: \"opt+up\",\n    moveLineForward: \"opt+down\",\n    moveWordBackward: \"opt+left\",\n    moveWordForward: \"opt+right\",\n    deleteBackward: [\n        \"ctrl+backspace\",\n        \"ctrl+h\"\n    ],\n    deleteForward: [\n        \"ctrl+delete\",\n        \"ctrl+d\"\n    ],\n    deleteLineBackward: \"cmd+shift?+backspace\",\n    deleteLineForward: [\n        \"cmd+shift?+delete\",\n        \"ctrl+k\"\n    ],\n    deleteWordBackward: \"opt+shift?+backspace\",\n    deleteWordForward: \"opt+shift?+delete\",\n    extendLineBackward: \"opt+shift+up\",\n    extendLineForward: \"opt+shift+down\",\n    redo: \"cmd+shift+z\",\n    transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n    deleteWordBackward: \"ctrl+shift?+backspace\",\n    deleteWordForward: \"ctrl+shift?+delete\",\n    redo: [\n        \"ctrl+y\",\n        \"ctrl+shift+z\"\n    ]\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */ var create = (key)=>{\n    var generic = HOTKEYS[key];\n    var apple = APPLE_HOTKEYS[key];\n    var windows = WINDOWS_HOTKEYS[key];\n    var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(generic);\n    var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(apple);\n    var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(windows);\n    return (event)=>{\n        if (isGeneric && isGeneric(event)) return true;\n        if (IS_APPLE && isApple && isApple(event)) return true;\n        if (!IS_APPLE && isWindows && isWindows(event)) return true;\n        return false;\n    };\n};\n/**\r\n * Hotkeys.\r\n */ var Hotkeys = {\n    isBold: create(\"bold\"),\n    isCompose: create(\"compose\"),\n    isMoveBackward: create(\"moveBackward\"),\n    isMoveForward: create(\"moveForward\"),\n    isDeleteBackward: create(\"deleteBackward\"),\n    isDeleteForward: create(\"deleteForward\"),\n    isDeleteLineBackward: create(\"deleteLineBackward\"),\n    isDeleteLineForward: create(\"deleteLineForward\"),\n    isDeleteWordBackward: create(\"deleteWordBackward\"),\n    isDeleteWordForward: create(\"deleteWordForward\"),\n    isExtendBackward: create(\"extendBackward\"),\n    isExtendForward: create(\"extendForward\"),\n    isExtendLineBackward: create(\"extendLineBackward\"),\n    isExtendLineForward: create(\"extendLineForward\"),\n    isItalic: create(\"italic\"),\n    isMoveLineBackward: create(\"moveLineBackward\"),\n    isMoveLineForward: create(\"moveLineForward\"),\n    isMoveWordBackward: create(\"moveWordBackward\"),\n    isMoveWordForward: create(\"moveWordForward\"),\n    isRedo: create(\"redo\"),\n    isSoftBreak: create(\"insertSoftBreak\"),\n    isSplitBlock: create(\"splitBlock\"),\n    isTransposeCharacter: create(\"transposeCharacter\"),\n    isUndo: create(\"undo\")\n};\nvar createRestoreDomManager = (editor, receivedUserInput)=>{\n    var bufferedMutations = [];\n    var clear = ()=>{\n        bufferedMutations = [];\n    };\n    var registerMutations = (mutations)=>{\n        if (!receivedUserInput.current) {\n            return;\n        }\n        var trackedMutations = mutations.filter((mutation)=>isTrackedMutation(editor, mutation, mutations));\n        bufferedMutations.push(...trackedMutations);\n    };\n    function restoreDOM() {\n        if (bufferedMutations.length > 0) {\n            bufferedMutations.reverse().forEach((mutation)=>{\n                if (mutation.type === \"characterData\") {\n                    // We don't want to restore the DOM for characterData mutations\n                    // because this interrupts the composition.\n                    return;\n                }\n                mutation.removedNodes.forEach((node)=>{\n                    mutation.target.insertBefore(node, mutation.nextSibling);\n                });\n                mutation.addedNodes.forEach((node)=>{\n                    mutation.target.removeChild(node);\n                });\n            }); // Clear buffered mutations to ensure we don't undo them twice\n            clear();\n        }\n    }\n    return {\n        registerMutations,\n        restoreDOM,\n        clear\n    };\n};\nvar MUTATION_OBSERVER_CONFIG = {\n    subtree: true,\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n    constructor(){\n        super(...arguments);\n        this.context = null;\n        this.manager = null;\n        this.mutationObserver = null;\n    }\n    observe() {\n        var _this$mutationObserve;\n        var { node } = this.props;\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n    }\n    componentDidMount() {\n        var { receivedUserInput } = this.props;\n        var editor = this.context;\n        this.manager = createRestoreDomManager(editor, receivedUserInput);\n        this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n        this.observe();\n    }\n    getSnapshotBeforeUpdate() {\n        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n            var _this$manager;\n            (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n        }\n        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n        return null;\n    }\n    componentDidUpdate() {\n        var _this$manager3;\n        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n        this.observe();\n    }\n    componentWillUnmount() {\n        var _this$mutationObserve4;\n        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n    }\n    render() {\n        return this.props.children;\n    }\n}\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref)=>{\n    var { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\nvar _excluded$1 = [\n    \"autoFocus\",\n    \"decorate\",\n    \"onDOMBeforeInput\",\n    \"placeholder\",\n    \"readOnly\",\n    \"renderElement\",\n    \"renderLeaf\",\n    \"renderPlaceholder\",\n    \"scrollSelectionIntoView\",\n    \"style\",\n    \"as\",\n    \"disableDefaultStyles\"\n], _excluded2 = [\n    \"text\"\n];\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Children = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\r\n * Editable.\r\n */ var Editable = (props)=>{\n    var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, Object.assign({}, props)), []);\n    var { autoFocus, decorate = defaultDecorate, onDOMBeforeInput: propsOnDOMBeforeInput, placeholder, readOnly = false, renderElement, renderLeaf, renderPlaceholder = defaultRenderPlaceholder, scrollSelectionIntoView = defaultScrollSelectionIntoView, style: userStyle = {}, as: Component = \"div\", disableDefaultStyles = false } = props, attributes = _objectWithoutProperties(props, _excluded$1);\n    var editor = useSlate(); // Rerender editor when composition status changed\n    var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    var [placeholderHeight, setPlaceholderHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    var { onUserInput, receivedUserInput } = useTrackUserInput();\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n    IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n    var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>({\n            isDraggingInternally: false,\n            isUpdatingSelection: false,\n            latestElement: null,\n            hasMarkPlaceholder: false\n        }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n    // needs to be manually focused.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (ref.current && autoFocus) {\n            ref.current.focus();\n        }\n    }, [\n        autoFocus\n    ]);\n    /**\r\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\r\n   *\r\n   * It is defined as a reference to simplify hook dependencies and clarify that\r\n   * it needs to be initialized.\r\n   */ var androidInputManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(); // Listen on the native `selectionchange` event to be able to update any time\n    // the selection changes. This is required because React's `onSelect` is leaky\n    // and non-standard so it doesn't fire until after a selection has been\n    // released. This causes issues in situations where another change happens\n    // while a selection is being dragged.\n    var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(()=>{\n            var androidInputManager = androidInputManagerRef.current;\n            if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n                var root = ReactEditor.findDocumentOrShadowRoot(editor);\n                var { activeElement } = root;\n                var el = ReactEditor.toDOMNode(editor, editor);\n                var domSelection = root.getSelection();\n                if (activeElement === el) {\n                    state.latestElement = activeElement;\n                    IS_FOCUSED.set(editor, true);\n                } else {\n                    IS_FOCUSED.delete(editor);\n                }\n                if (!domSelection) {\n                    return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n                }\n                var { anchorNode, focusNode } = domSelection;\n                var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n                var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n                if (anchorNodeSelectable && focusNodeSelectable) {\n                    var range = ReactEditor.toSlateRange(editor, domSelection, {\n                        exactMatch: false,\n                        suppressThrow: true\n                    });\n                    if (range) {\n                        if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                        } else {\n                            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n                        }\n                    }\n                } // Deselect the editor if the dom selection is not selectable in readonly mode\n                if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n                }\n            }\n        }, 100), [\n        editor,\n        readOnly,\n        state\n    ]);\n    var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [\n        onDOMSelectionChange\n    ]);\n    androidInputManagerRef.current = useAndroidInputManager({\n        node: ref,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    });\n    useIsomorphicLayoutEffect(()=>{\n        var _androidInputManagerR, _androidInputManagerR2;\n        // Update element-related weak maps with the DOM element ref.\n        var window1;\n        if (ref.current && (window1 = getDefaultView(ref.current))) {\n            EDITOR_TO_WINDOW.set(editor, window1);\n            EDITOR_TO_ELEMENT.set(editor, ref.current);\n            NODE_TO_ELEMENT.set(editor, ref.current);\n            ELEMENT_TO_NODE.set(ref.current, editor);\n        } else {\n            NODE_TO_ELEMENT.delete(editor);\n        } // Make sure the DOM selection state is in sync.\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n            return;\n        }\n        var setDomSelection = (forceChange)=>{\n            var hasDomSelection = domSelection.type !== \"None\"; // If the DOM selection is properly unset, we're done.\n            if (!selection && !hasDomSelection) {\n                return;\n            } // Get anchorNode and focusNode\n            var focusNode = domSelection.focusNode;\n            var anchorNode; // COMPAT: In firefox the normal seletion way does not work\n            // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n            if (IS_FIREFOX && domSelection.rangeCount > 1) {\n                var firstRange = domSelection.getRangeAt(0);\n                var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1); // Right to left\n                if (firstRange.startContainer === focusNode) {\n                    anchorNode = lastRange.endContainer;\n                } else {\n                    // Left to right\n                    anchorNode = firstRange.startContainer;\n                }\n            } else {\n                anchorNode = domSelection.anchorNode;\n            } // verify that the dom selection is in the editor\n            var editorElement = EDITOR_TO_ELEMENT.get(editor);\n            var hasDomSelectionInEditor = false;\n            if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n                hasDomSelectionInEditor = true;\n            } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n            if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n                var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: true,\n                    // domSelection is not necessarily a valid Slate range\n                    // (e.g. when clicking on contentEditable:false element)\n                    suppressThrow: true\n                });\n                if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n                    var _anchorNode, _anchorNode$parentEle;\n                    if (!state.hasMarkPlaceholder) {\n                        return;\n                    } // Ensure selection is inside the mark placeholder\n                    if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode$parentEle = _anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute(\"data-slate-mark-placeholder\")) {\n                        return;\n                    }\n                }\n            } // when <Editable/> is being controlled through external value\n            // then its children might just change - DOM responds to it on its own\n            // but Slate's value is not being updated through any operation\n            // and thus it doesn't transform selection on its own\n            if (selection && !ReactEditor.hasRange(editor, selection)) {\n                editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                return;\n            } // Otherwise the DOM selection is out of sync, so update it.\n            state.isUpdatingSelection = true;\n            var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n            if (newDomRange) {\n                if (ReactEditor.isComposing(editor) && !IS_ANDROID) {\n                    domSelection.collapseToEnd();\n                } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n                    domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n                } else {\n                    domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n                }\n                scrollSelectionIntoView(editor, newDomRange);\n            } else {\n                domSelection.removeAllRanges();\n            }\n            return newDomRange;\n        }; // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n        if (domSelection.rangeCount <= 1) {\n            setDomSelection();\n        }\n        var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === \"action\";\n        if (!IS_ANDROID || !ensureSelection) {\n            setTimeout(()=>{\n                state.isUpdatingSelection = false;\n            });\n            return;\n        }\n        var timeoutId = null;\n        var animationFrameId = requestAnimationFrame(()=>{\n            if (ensureSelection) {\n                var ensureDomSelection = (forceChange)=>{\n                    try {\n                        var el = ReactEditor.toDOMNode(editor, editor);\n                        el.focus();\n                        setDomSelection(forceChange);\n                    } catch (e) {}\n                }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n                // This essentially would make setting the slate selection during an update meaningless, so we force it\n                // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n                // visible flicker.\n                ensureDomSelection();\n                timeoutId = setTimeout(()=>{\n                    // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n                    // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n                    // the animation frame to ensure it displays the correct state.\n                    ensureDomSelection(true);\n                    state.isUpdatingSelection = false;\n                });\n            }\n        });\n        return ()=>{\n            cancelAnimationFrame(animationFrameId);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n        };\n    }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n    // is required because React's `beforeinput` is fake and never really attaches\n    // to the real event sadly. (2019/11/01)\n    // https://github.com/facebook/react/issues/11211\n    var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n        onUserInput();\n        if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n            var _EDITOR_TO_USER_SELEC;\n            // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n            if (androidInputManagerRef.current) {\n                return androidInputManagerRef.current.handleDOMBeforeInput(event);\n            } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n            // triggering a `beforeinput` expecting the change to be applied to the immediately before\n            // set selection.\n            scheduleOnDOMSelectionChange.flush();\n            onDOMSelectionChange.flush();\n            var { selection } = editor;\n            var { inputType: type } = event;\n            var data = event.dataTransfer || event.data || undefined;\n            var isCompositionChange = type === \"insertCompositionText\" || type === \"deleteCompositionText\"; // COMPAT: use composition change events as a hint to where we should insert\n            // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n            if (isCompositionChange && ReactEditor.isComposing(editor)) {\n                return;\n            }\n            var native = false;\n            if (type === \"insertText\" && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n            // Long-press events (hold a + press 4 = ä) to choose a special character otherwise\n            // causes duplicate inserts.\n            event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n            // When there is an inline element, e.g. a link, and you select\n            // right after it (the start of the next node).\n            selection.anchor.offset !== 0) {\n                var _node$parentElement, _window$getComputedSt;\n                native = true; // Skip native if there are marks, as\n                // `insertText` will insert a node, not just text.\n                if (editor.marks) {\n                    native = false;\n                } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n                // Therefore we don't allow native events to insert text at the end of anchor nodes.\n                var { anchor } = selection;\n                var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n                var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest(\"a\");\n                var window1 = ReactEditor.getWindow(editor);\n                if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n                    var _lastText$textContent;\n                    // Find the last text node inside the anchor.\n                    var lastText = window1 === null || window1 === void 0 ? void 0 : window1.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n                    if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n                        native = false;\n                    }\n                } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n                // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n                if (native && node.parentElement && (window1 === null || window1 === void 0 ? void 0 : (_window$getComputedSt = window1.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === \"pre\") {\n                    var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        at: anchor.path,\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n                    });\n                    if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes(\"\t\")) {\n                        native = false;\n                    }\n                }\n            } // COMPAT: For the deleting forward/backward input types we don't want\n            // to change the selection because it is the range that will be deleted,\n            // and those commands determine that for themselves.\n            if (!type.startsWith(\"delete\") || type.startsWith(\"deleteBy\")) {\n                var [targetRange] = event.getTargetRanges();\n                if (targetRange) {\n                    var range = ReactEditor.toSlateRange(editor, targetRange, {\n                        exactMatch: false,\n                        suppressThrow: false\n                    });\n                    if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, range)) {\n                        native = false;\n                        var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                        if (selectionRef) {\n                            EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n                        }\n                    }\n                }\n            } // Composition change types occur while a user is composing text and can't be\n            // cancelled. Let them through and wait for the composition to end.\n            if (isCompositionChange) {\n                return;\n            }\n            if (!native) {\n                event.preventDefault();\n            } // COMPAT: If the selection is expanded, even if the command seems like\n            // a delete forward/backward command it should delete the selection.\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith(\"delete\")) {\n                var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                    direction\n                });\n                return;\n            }\n            switch(type){\n                case \"deleteByComposition\":\n                case \"deleteByCut\":\n                case \"deleteByDrag\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        break;\n                    }\n                case \"deleteContent\":\n                case \"deleteContentForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        break;\n                    }\n                case \"deleteContentBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        break;\n                    }\n                case \"deleteEntireSoftLine\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteWordBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"deleteWordForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"insertLineBreak\":\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                    break;\n                case \"insertParagraph\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        break;\n                    }\n                case \"insertFromComposition\":\n                case \"insertFromDrop\":\n                case \"insertFromPaste\":\n                case \"insertFromYank\":\n                case \"insertReplacementText\":\n                case \"insertText\":\n                    {\n                        if (type === \"insertFromComposition\") {\n                            // COMPAT: in Safari, `compositionend` is dispatched after the\n                            // `beforeinput` for \"insertFromComposition\". But if we wait for it\n                            // then we will abort because we're still composing and the selection\n                            // won't be updated properly.\n                            // https://www.w3.org/TR/input-events-2/\n                            if (ReactEditor.isComposing(editor)) {\n                                setIsComposing(false);\n                                IS_COMPOSING.set(editor, false);\n                            }\n                        } // use a weak comparison instead of 'instanceof' to allow\n                        // programmatic access of paste events coming from external windows\n                        // like cypress where cy.window does not work realibly\n                        if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n                            ReactEditor.insertData(editor, data);\n                        } else if (typeof data === \"string\") {\n                            // Only insertText operations use the native functionality, for now.\n                            // Potentially expand to single character deletes, as well.\n                            if (native) {\n                                deferredOperations.current.push(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n                            } else {\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n                            }\n                        }\n                        break;\n                    }\n            } // Restore the actual user section if nothing manually set it.\n            var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n            EDITOR_TO_USER_SELECTION.delete(editor);\n            if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n            }\n        }\n    }, [\n        editor,\n        onDOMSelectionChange,\n        onUserInput,\n        propsOnDOMBeforeInput,\n        readOnly,\n        scheduleOnDOMSelectionChange\n    ]);\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((node)=>{\n        if (node == null) {\n            onDOMSelectionChange.cancel();\n            scheduleOnDOMSelectionChange.cancel();\n            EDITOR_TO_ELEMENT.delete(editor);\n            NODE_TO_ELEMENT.delete(editor);\n            if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                ref.current.removeEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        } else {\n            // Attach a native DOM event handler for `beforeinput` events, because React's\n            // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n            // real `beforeinput` events sadly... (2019/11/04)\n            // https://github.com/facebook/react/issues/11211\n            if (HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                node.addEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        }\n        ref.current = node;\n    }, [\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange,\n        editor,\n        onDOMBeforeInput\n    ]); // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n    // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n    // fire for any change to the selection inside the editor. (2019/11/04)\n    // https://github.com/facebook/react/issues/5785\n    useIsomorphicLayoutEffect(()=>{\n        var window1 = ReactEditor.getWindow(editor);\n        window1.document.addEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        return ()=>{\n            window1.document.removeEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        };\n    }, [\n        scheduleOnDOMSelectionChange\n    ]);\n    var decorations = decorate([\n        editor,\n        []\n    ]);\n    var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === \"\" && !isComposing;\n    var placeHolderResizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((placeholderEl)=>{\n        if (placeholderEl && showPlaceholder) {\n            var _placeholderEl$getBou;\n            setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n        } else {\n            setPlaceholderHeight(undefined);\n        }\n    }, [\n        showPlaceholder\n    ]);\n    if (showPlaceholder) {\n        var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n        decorations.push({\n            [PLACEHOLDER_SYMBOL]: true,\n            placeholder,\n            onPlaceholderResize: placeHolderResizeHandler,\n            anchor: start,\n            focus: start\n        });\n    }\n    var { marks } = editor;\n    state.hasMarkPlaceholder = false;\n    if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n        var { anchor } = editor.selection;\n        var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n        var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n            loose: true\n        })) {\n            state.hasMarkPlaceholder = true;\n            var unset = Object.fromEntries(Object.keys(rest).map((mark)=>[\n                    mark,\n                    null\n                ]));\n            decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n                [MARK_PLACEHOLDER_SYMBOL]: true\n            }, unset), marks), {}, {\n                anchor,\n                focus: anchor\n            }));\n        }\n    } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n    // before we receive the composition end event.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setTimeout(()=>{\n            var { selection } = editor;\n            if (selection) {\n                var { anchor: _anchor } = selection;\n                var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n                // here which only compares marks anyway.\n                if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n                    loose: true\n                })) {\n                    EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n                    return;\n                }\n            }\n            EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        });\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n        value: readOnly\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n        value: decorate\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n        node: ref,\n        receivedUserInput: receivedUserInput\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, Object.assign({\n        role: readOnly ? undefined : \"textbox\",\n        \"aria-multiline\": readOnly ? undefined : true\n    }, attributes, {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n        // have to use hacks to make these replacement-based features work.\n        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n        // mismatch warning app moves to browser. Pass-through consumer props when\n        // not CAN_USE_DOM (SSR) and default to falsy value\n        spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n        autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : \"false\",\n        autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : \"false\",\n        \"data-slate-editor\": true,\n        \"data-slate-node\": \"value\",\n        // explicitly set this\n        contentEditable: !readOnly,\n        // in some cases, a decoration needs access to the range / selection to decorate a text node,\n        // then you will select the whole text node when you select part the of text\n        // this magic zIndex=\"-1\" will fix it\n        zindex: -1,\n        suppressContentEditableWarning: true,\n        ref: callbackRef,\n        style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n            // Allow positioning relative to the editable element.\n            position: \"relative\",\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: \"pre-wrap\",\n            // Allow words to break if they are too long.\n            wordWrap: \"break-word\"\n        }, placeholderHeight ? {\n            minHeight: placeholderHeight\n        } : {})), userStyle),\n        onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n            // fall back to React's leaky polyfill instead just for it. It\n            // only works for the `insertText` input type.\n            if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n                event.preventDefault();\n                if (!ReactEditor.isComposing(editor)) {\n                    var _text2 = event.data;\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n                }\n            }\n        }, [\n            attributes.onBeforeInput,\n            editor,\n            readOnly\n        ]),\n        onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (isEventHandled(event, attributes.onInput)) {\n                return;\n            }\n            if (androidInputManagerRef.current) {\n                androidInputManagerRef.current.handleInput();\n                return;\n            } // Flush native operations, as native events will have propogated\n            // and we can correctly compare DOM text values in components\n            // to stop rendering, so that browser functions like autocorrect\n            // and spellcheck work as expected.\n            for (var op of deferredOperations.current){\n                op();\n            }\n            deferredOperations.current = [];\n        }, [\n            attributes.onInput\n        ]),\n        onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n                return;\n            } // COMPAT: If the current `activeElement` is still the previous\n            // one, this is due to the window being blurred when the tab\n            // itself becomes unfocused, so we want to abort early to allow to\n            // editor to stay focused when the tab becomes focused again.\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            if (state.latestElement === root.activeElement) {\n                return;\n            }\n            var { relatedTarget } = event;\n            var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n            // to the editor from an embedded editable element (eg. an <input>\n            // element inside a void node).\n            if (relatedTarget === el) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving from\n            // the editor to inside a void node's spacer element.\n            if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute(\"data-slate-spacer\")) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving to a\n            // non- editable section of an element that isn't a void node (eg.\n            // a list item of the check list example).\n            if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n                var node = ReactEditor.toSlateNode(editor, relatedTarget);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n                    return;\n                }\n            } // COMPAT: Safari doesn't always remove the selection even if the content-\n            // editable element no longer has focus. Refer to:\n            // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n            if (IS_WEBKIT) {\n                var domSelection = root.getSelection();\n                domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n            }\n            IS_FOCUSED.delete(editor);\n        }, [\n            readOnly,\n            state.isUpdatingSelection,\n            state.latestElement,\n            editor,\n            attributes.onBlur\n        ]),\n        onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n                // because onClick handlers can change the document before we get here.\n                // Therefore we must check that this path actually exists,\n                // and that it still refers to the same node.\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n                    return;\n                }\n                if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n                    var blockPath = path;\n                    if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n                        var _block$;\n                        var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                            match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n                            at: path\n                        });\n                        blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n                    }\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    return;\n                }\n                if (readOnly) {\n                    return;\n                }\n                var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n                var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n                var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: _start\n                });\n                var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: end\n                });\n                if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n                    var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n                }\n            }\n        }, [\n            editor,\n            attributes.onClick,\n            readOnly\n        ]),\n        onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                var _androidInputManagerR3;\n                if (ReactEditor.isComposing(editor)) {\n                    setIsComposing(false);\n                    IS_COMPOSING.set(editor, false);\n                }\n                (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 ? void 0 : _androidInputManagerR3.handleCompositionEnd(event);\n                if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n                    return;\n                } // COMPAT: In Chrome, `beforeinput` events for compositions\n                // aren't correct and never fire the \"insertFromComposition\"\n                // type that we need. So instead, insert whenever a composition\n                // ends since it will already have been committed to the DOM.\n                if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n                    var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n                    EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n                    if (placeholderMarks !== undefined) {\n                        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n                        editor.marks = placeholderMarks;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n                    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n                    EDITOR_TO_USER_MARKS.delete(editor);\n                    if (userMarks !== undefined) {\n                        editor.marks = userMarks;\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionEnd,\n            editor\n        ]),\n        onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n                if (!ReactEditor.isComposing(editor)) {\n                    setIsComposing(true);\n                    IS_COMPOSING.set(editor, true);\n                }\n            }\n        }, [\n            attributes.onCompositionUpdate,\n            editor\n        ]),\n        onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                var _androidInputManagerR4;\n                (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 ? void 0 : _androidInputManagerR4.handleCompositionStart(event);\n                if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n                    return;\n                }\n                setIsComposing(true);\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        return;\n                    }\n                    var inline = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, n),\n                        mode: \"highest\"\n                    });\n                    if (inline) {\n                        var [, inlinePath] = inline;\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, selection.anchor, inlinePath)) {\n                            var point = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, inlinePath);\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setSelection(editor, {\n                                anchor: point,\n                                focus: point\n                            });\n                        }\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionStart,\n            editor\n        ]),\n        onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"copy\");\n            }\n        }, [\n            attributes.onCopy,\n            editor\n        ]),\n        onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"cut\");\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                    } else {\n                        var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onCut\n        ]),\n        onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n                // Only when the target is void, call `preventDefault` to signal\n                // that drops are allowed. Editable content is droppable by\n                // default, and calling `preventDefault` hides the cursor.\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                    event.preventDefault();\n                }\n            }\n        }, [\n            attributes.onDragOver,\n            editor\n        ]),\n        onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node);\n                var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: path,\n                    voids: true\n                }); // If starting a drag on a void node, make sure it is selected\n                // so that it shows up in the selection's fragment.\n                if (voidMatch) {\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                }\n                state.isDraggingInternally = true;\n                ReactEditor.setFragmentData(editor, event.dataTransfer, \"drag\");\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onDragStart,\n            state\n        ]),\n        onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n                event.preventDefault(); // Keep a reference to the dragged range before updating selection\n                var draggedRange = editor.selection; // Find the range where the drop happened\n                var range = ReactEditor.findEventRange(editor, event);\n                var data = event.dataTransfer;\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                if (state.isDraggingInternally) {\n                    if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                        at: range,\n                        voids: true\n                    })) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                            at: draggedRange\n                        });\n                    }\n                }\n                ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n                // that the current editor does not have focus.\n                if (!ReactEditor.isFocused(editor)) {\n                    ReactEditor.focus(editor);\n                }\n            }\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            editor,\n            attributes.onDrop,\n            state\n        ]),\n        onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n                attributes.onDragEnd(event);\n            } // When dropping on a different droppable element than the current editor,\n            // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n            // Note: `onDragEnd` is only called when `onDrop` is not called\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            state,\n            attributes,\n            editor\n        ]),\n        onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n                var el = ReactEditor.toDOMNode(editor, editor);\n                var root = ReactEditor.findDocumentOrShadowRoot(editor);\n                state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n                // can go to them. In Firefox, this must be prevented because it\n                // results in issues with keyboard navigation. (2017/03/30)\n                if (IS_FIREFOX && event.target !== el) {\n                    el.focus();\n                    return;\n                }\n                IS_FOCUSED.set(editor, true);\n            }\n        }, [\n            readOnly,\n            state,\n            editor,\n            attributes.onFocus\n        ]),\n        onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n                var _androidInputManagerR5;\n                (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 ? void 0 : _androidInputManagerR5.handleKeyDown(event);\n                var { nativeEvent } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n                // so we sometimes might end up stuck in a composition state even though we\n                // aren't composing any more.\n                if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n                    IS_COMPOSING.set(editor, false);\n                    setIsComposing(false);\n                }\n                if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n                    return;\n                }\n                var { selection } = editor;\n                var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n                var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === \"rtl\"; // COMPAT: Since we prevent the default behavior on\n                // `beforeinput` events, the browser doesn't think there's ever\n                // any history stack to undo or redo, so we have to manage these\n                // hotkeys ourselves. (2019/11/06)\n                if (Hotkeys.isRedo(nativeEvent)) {\n                    event.preventDefault();\n                    var maybeHistoryEditor = editor;\n                    if (typeof maybeHistoryEditor.redo === \"function\") {\n                        maybeHistoryEditor.redo();\n                    }\n                    return;\n                }\n                if (Hotkeys.isUndo(nativeEvent)) {\n                    event.preventDefault();\n                    var _maybeHistoryEditor = editor;\n                    if (typeof _maybeHistoryEditor.undo === \"function\") {\n                        _maybeHistoryEditor.undo();\n                    }\n                    return;\n                } // COMPAT: Certain browsers don't handle the selection updates\n                // properly. In Chrome, the selection isn't properly extended.\n                // And in Firefox, the selection isn't properly collapsed.\n                // (2017/10/17)\n                if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\"\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\"\n                    });\n                    return;\n                } // COMPAT: If a void node is selected, or a zero-width text node\n                // adjacent to an inline is selected, we need to handle these\n                // hotkeys manually because browsers won't be able to skip over\n                // the void node with the zero-width space not being an empty\n                // string.\n                if (Hotkeys.isMoveBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: !isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"start\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"end\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: !isRTL\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: isRTL\n                    });\n                    return;\n                } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to guessing at the input intention for hotkeys.\n                // COMPAT: In iOS, some of these hotkeys are handled in the\n                if (!HAS_BEFORE_INPUT_SUPPORT) {\n                    // We don't have a core behavior for these, but they change the\n                    // DOM if we don't prevent them, so we have to.\n                    if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n                        event.preventDefault();\n                        return;\n                    }\n                    if (Hotkeys.isSoftBreak(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isSplitBlock(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                } else {\n                    if (IS_CHROME || IS_WEBKIT) {\n                        // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                        // an event when deleting backwards in a selected void inline node\n                        if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                            var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                            if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                                event.preventDefault();\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                    unit: \"block\"\n                                });\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onKeyDown\n        ]),\n        onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's `onPaste` here instead.\n                // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                // COMPAT: Safari InputEvents generated by pasting won't include\n                // application/x-slate-fragment items, so use the\n                // ClipboardEvent here. (2023/03/15)\n                if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {\n                    event.preventDefault();\n                    ReactEditor.insertData(editor, event.clipboardData);\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onPaste\n        ])\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n        decorations: decorations,\n        node: editor,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: editor.selection\n    })))));\n};\n/**\r\n * The default placeholder element\r\n */ var DefaultPlaceholder = (_ref)=>{\n    var { attributes, children } = _ref;\n    return(/*#__PURE__*/ // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null)));\n};\n/**\r\n * A default memoized decorate function.\r\n */ var defaultDecorate = ()=>[];\n/**\r\n * A default implement to scroll dom range into view.\r\n */ var defaultScrollSelectionIntoView = (editor, domRange)=>{\n    // This was affecting the selection of multiple blocks and dragging behavior,\n    // so enabled only if the selection has been collapsed.\n    if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n        var leafEl = domRange.startContainer.parentElement;\n        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n        (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n            scrollMode: \"if-needed\"\n        }); // @ts-expect-error an unorthodox delete D:\n        delete leafEl.getBoundingClientRect;\n    }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */ var isEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if the event's target is an input element\r\n */ var isDOMEventTargetInput = (event)=>{\n    return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */ var isDOMEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.defaultPrevented;\n};\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */ var FocusedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */ var useFocused = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\nfunction isError(error) {\n    return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */ var SlateSelectorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b)=>a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */ function useSlateSelector(selector) {\n    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n    if (!context) {\n        throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n    }\n    var { getSlate, addEventListener } = context;\n    var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(()=>null);\n    var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var selectedState;\n    try {\n        if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n            selectedState = selector(getSlate());\n        } else {\n            selectedState = latestSelectedState.current;\n        }\n    } catch (err) {\n        if (latestSubscriptionCallbackError.current && isError(err)) {\n            err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n    }\n    useIsomorphicLayoutEffect(()=>{\n        latestSelector.current = selector;\n        latestSelectedState.current = selectedState;\n        latestSubscriptionCallbackError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(()=>{\n        function checkForUpdates() {\n            try {\n                var newSelectedState = latestSelector.current(getSlate());\n                if (equalityFn(newSelectedState, latestSelectedState.current)) {\n                    return;\n                }\n                latestSelectedState.current = newSelectedState;\n            } catch (err) {\n                // we ignore all errors here, since when the component\n                // is re-rendered, the selectors are called again, and\n                // will throw again, if neither props nor store state\n                // changed\n                latestSubscriptionCallbackError.current = err;\n            }\n            forceRender();\n        }\n        var unsubscribe = addEventListener(checkForUpdates);\n        checkForUpdates();\n        return ()=>unsubscribe();\n    }, [\n        addEventListener,\n        getSlate\n    ]);\n    return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */ function useSelectorContext(editor) {\n    var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n    var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n        editor\n    }).current;\n    var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((editor)=>{\n        slateRef.editor = editor;\n        eventListeners.forEach((listener)=>listener(editor));\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>{\n        return {\n            getSlate: ()=>slateRef.editor,\n            addEventListener: (callback)=>{\n                eventListeners.push(callback);\n                return ()=>{\n                    eventListeners.splice(eventListeners.indexOf(callback), 1);\n                };\n            }\n        };\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    return {\n        selectorContext,\n        onChange\n    };\n}\nvar _excluded = [\n    \"editor\",\n    \"children\",\n    \"onChange\",\n    \"initialValue\"\n];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */ var Slate = (props)=>{\n    var { editor, children, onChange, initialValue } = props, rest = _objectWithoutProperties(props, _excluded);\n    var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(()=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(initialValue)) {\n            throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(initialValue)));\n        }\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n            throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n        }\n        editor.children = initialValue;\n        Object.assign(editor, rest);\n        return {\n            v: 0,\n            editor\n        };\n    });\n    var { selectorContext, onChange: handleSelectorChange } = useSelectorContext(editor);\n    var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (onChange) {\n            onChange(editor.children);\n        }\n        setContext((prevContext)=>({\n                v: prevContext.v + 1,\n                editor\n            }));\n        handleSelectorChange(editor);\n    }, [\n        editor,\n        handleSelectorChange,\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n        return ()=>{\n            EDITOR_TO_ON_CHANGE.set(editor, ()=>{});\n        };\n    }, [\n        editor,\n        onContextChange\n    ]);\n    var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setIsFocused(ReactEditor.isFocused(editor));\n    }, [\n        editor\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        var fn = ()=>setIsFocused(ReactEditor.isFocused(editor));\n        if (REACT_MAJOR_VERSION >= 17) {\n            // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n            // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n            // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n            document.addEventListener(\"focusin\", fn);\n            document.addEventListener(\"focusout\", fn);\n            return ()=>{\n                document.removeEventListener(\"focusin\", fn);\n                document.removeEventListener(\"focusout\", fn);\n            };\n        } else {\n            document.addEventListener(\"focus\", fn, true);\n            document.addEventListener(\"blur\", fn, true);\n            return ()=>{\n                document.removeEventListener(\"focus\", fn, true);\n                document.removeEventListener(\"blur\", fn, true);\n            };\n        }\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n        value: selectorContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n        value: context\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n        value: context.editor\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n        value: isFocused\n    }, children))));\n};\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */ var useEditor = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */ var useSlateSelection = ()=>{\n    return useSlateSelector((editor)=>editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b)=>{\n    if (!a && !b) return true;\n    if (!a || !b) return false;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n/**\r\n * Utilities for single-line deletion\r\n */ var doRectsIntersect = (rect, compareRect)=>{\n    var middle = (compareRect.top + compareRect.bottom) / 2;\n    return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2)=>{\n    var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n    var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n    return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */ var findCurrentLineRange = (editor, parentRange)=>{\n    var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Range.end(parentRange));\n    var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n        at: parentRange\n    }));\n    var left = 0;\n    var right = positions.length;\n    var middle = Math.floor(right / 2);\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left], parentRangeBoundary);\n    }\n    if (positions.length < 2) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n    }\n    while(middle !== positions.length && middle !== left){\n        if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n            right = middle;\n        } else {\n            left = middle;\n        }\n        middle = Math.floor((left + right) / 2);\n    }\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */ var withReact = function withReact(editor) {\n    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x-slate-fragment\";\n    var e = editor;\n    var { apply, onChange, deleteBackward, addMark, removeMark } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n    // avoid collisions between editors in the DOM that share the same value.\n    EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n    e.addMark = (key, value)=>{\n        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        addMark(key, value);\n    };\n    e.removeMark = (key)=>{\n        var _EDITOR_TO_PENDING_DI2;\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        removeMark(key);\n    };\n    e.deleteBackward = (unit)=>{\n        if (unit !== \"line\") {\n            return deleteBackward(unit);\n        }\n        if (e.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(e.selection)) {\n            var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(e, {\n                match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(e, n),\n                at: e.selection\n            });\n            if (parentBlockEntry) {\n                var [, parentBlockPath] = parentBlockEntry;\n                var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(e, parentBlockPath, e.selection.anchor);\n                var currentLineRange = findCurrentLineRange(e, parentElementRange);\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(currentLineRange)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(e, {\n                        at: currentLineRange\n                    });\n                }\n            }\n        }\n    }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n    // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n    e.apply = (op)=>{\n        var matches = [];\n        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n            var transformed = pendingDiffs.map((textDiff)=>transformTextDiff(textDiff, op)).filter(Boolean);\n            EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n        }\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n        if (pendingSelection) {\n            EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n        }\n        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n            var at = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n            EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n                at\n            }) : null);\n        }\n        switch(op.type){\n            case \"insert_text\":\n            case \"remove_text\":\n            case \"set_node\":\n            case \"split_node\":\n                {\n                    matches.push(...getMatches(e, op.path));\n                    break;\n                }\n            case \"set_selection\":\n                {\n                    var _EDITOR_TO_USER_SELEC;\n                    // Selection was manually set, don't restore the user selection after the change.\n                    (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n                    EDITOR_TO_USER_SELECTION.delete(e);\n                    break;\n                }\n            case \"insert_node\":\n            case \"remove_node\":\n                {\n                    matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path)));\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var prevPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(op.path);\n                    matches.push(...getMatches(e, prevPath));\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var commonPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.common(slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.newPath));\n                    matches.push(...getMatches(e, commonPath));\n                    break;\n                }\n        }\n        apply(op);\n        for (var [path, key] of matches){\n            var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(e, path);\n            NODE_TO_KEY.set(node, key);\n        }\n    };\n    e.setFragmentData = (data)=>{\n        var { selection } = e;\n        if (!selection) {\n            return;\n        }\n        var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(selection);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: start.path\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: end.path\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && !startVoid) {\n            return;\n        } // Create a fake selection so that we can add a Base64-encoded copy of the\n        // fragment to the HTML, to decode on future pastes.\n        var domRange = ReactEditor.toDOMRange(e, selection);\n        var contents = domRange.cloneContents();\n        var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n        contents.childNodes.forEach((node)=>{\n            if (node.textContent && node.textContent.trim() !== \"\") {\n                attach = node;\n            }\n        }); // COMPAT: If the end node is a void node, we need to move the end of the\n        // range from the void node's spacer span, to the end of the void node's\n        // content, since the spacer is before void's content in the DOM.\n        if (endVoid) {\n            var [voidNode] = endVoid;\n            var r = domRange.cloneRange();\n            var domNode = ReactEditor.toDOMNode(e, voidNode);\n            r.setEndAfter(domNode);\n            contents = r.cloneContents();\n        } // COMPAT: If the start node is a void node, we need to attach the encoded\n        // fragment to the void node's content node instead of the spacer, because\n        // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n        // most browsers. (2018/04/27)\n        if (startVoid) {\n            attach = contents.querySelector(\"[data-slate-spacer]\");\n        } // Remove any zero-width space spans from the cloned DOM so that they don't\n        // show up elsewhere when pasted.\n        Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw)=>{\n            var isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n            zw.textContent = isNewline ? \"\\n\" : \"\";\n        }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n        // in the HTML, and can be used for intra-Slate pasting. If it's a text\n        // node, wrap it in a `<span>` so we have something to set an attribute on.\n        if (isDOMText(attach)) {\n            var span = attach.ownerDocument.createElement(\"span\"); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n            // then leading and trailing spaces will be ignored. (2017/09/21)\n            span.style.whiteSpace = \"pre\";\n            span.appendChild(attach);\n            contents.appendChild(span);\n            attach = span;\n        }\n        var fragment = e.getFragment();\n        var string = JSON.stringify(fragment);\n        var encoded = window.btoa(encodeURIComponent(string));\n        attach.setAttribute(\"data-slate-fragment\", encoded);\n        data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n        var div = contents.ownerDocument.createElement(\"div\");\n        div.appendChild(contents);\n        div.setAttribute(\"hidden\", \"true\");\n        contents.ownerDocument.body.appendChild(div);\n        data.setData(\"text/html\", div.innerHTML);\n        data.setData(\"text/plain\", getPlainText(div));\n        contents.ownerDocument.body.removeChild(div);\n        return data;\n    };\n    e.insertData = (data)=>{\n        if (!e.insertFragmentData(data)) {\n            e.insertTextData(data);\n        }\n    };\n    e.insertFragmentData = (data)=>{\n        /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */ var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n        if (fragment) {\n            var decoded = decodeURIComponent(window.atob(fragment));\n            var parsed = JSON.parse(decoded);\n            e.insertFragment(parsed);\n            return true;\n        }\n        return false;\n    };\n    e.insertTextData = (data)=>{\n        var text = data.getData(\"text/plain\");\n        if (text) {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var split = false;\n            for (var line of lines){\n                if (split) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(e, {\n                        always: true\n                    });\n                }\n                e.insertText(line);\n                split = true;\n            }\n            return true;\n        }\n        return false;\n    };\n    e.onChange = (options)=>{\n        // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n        // that the children and selection can get out of sync for one render\n        // pass. So we have to use this unstable API to ensure it batches them.\n        // (2019/12/03)\n        // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n        var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? (react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates) : (callback)=>callback();\n        maybeBatchUpdates(()=>{\n            var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n            if (onContextChange) {\n                onContextChange();\n            }\n            onChange(options);\n        });\n    };\n    return e;\n};\nvar getMatches = (e, path)=>{\n    var matches = [];\n    for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.levels(e, {\n        at: path\n    })){\n        var key = ReactEditor.findKey(e, n);\n        matches.push([\n            p,\n            key\n        ]);\n    }\n    return matches;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQytIO0FBQzlHO0FBQzZEO0FBQzVEO0FBQ3BCO0FBQ0o7QUFFakMsU0FBUytCLGdCQUFnQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFDdEMsSUFBSUQsT0FBT0QsS0FBSztRQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BHLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBRUEsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLDhCQUE4QkMsTUFBTSxFQUFFQyxRQUFRO0lBQ3JELElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUUsU0FBUyxDQUFDO0lBQ2QsSUFBSUMsYUFBYVQsT0FBT1UsSUFBSSxDQUFDSjtJQUM3QixJQUFJUixLQUFLYTtJQUVULElBQUtBLElBQUksR0FBR0EsSUFBSUYsV0FBV0csTUFBTSxFQUFFRCxJQUFLO1FBQ3RDYixNQUFNVyxVQUFVLENBQUNFLEVBQUU7UUFDbkIsSUFBSUosU0FBU00sT0FBTyxDQUFDZixRQUFRLEdBQUc7UUFDaENVLE1BQU0sQ0FBQ1YsSUFBSSxHQUFHUSxNQUFNLENBQUNSLElBQUk7SUFDM0I7SUFFQSxPQUFPVTtBQUNUO0FBRUEsU0FBU00seUJBQXlCUixNQUFNLEVBQUVDLFFBQVE7SUFDaEQsSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJRSxTQUFTSCw4QkFBOEJDLFFBQVFDO0lBQ25ELElBQUlULEtBQUthO0lBRVQsSUFBSVgsT0FBT2UscUJBQXFCLEVBQUU7UUFDaEMsSUFBSUMsbUJBQW1CaEIsT0FBT2UscUJBQXFCLENBQUNUO1FBRXBE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QUFPO29CQUNUN0MsNkNBQVVBLENBQUN5NkIsVUFBVSxDQUFDbEwsR0FBRzt3QkFDdkJtTCxRQUFRO29CQUNWO2dCQUNGO2dCQUVBbkwsRUFBRWpVLFVBQVUsQ0FBQzZDO2dCQUNidGIsUUFBUTtZQUNWO1lBRUEsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNUO0lBRUEwc0IsRUFBRTNULFFBQVEsR0FBR3ROLENBQUFBO1FBQ1gsc0VBQXNFO1FBQ3RFLHFFQUFxRTtRQUNyRSx1RUFBdUU7UUFDdkUsZUFBZTtRQUNmLHdFQUF3RTtRQUN4RSxJQUFJcXNCLG9CQUFvQmo0QixzQkFBc0IsS0FBSzdCLDBFQUFnQyxHQUFHOGUsQ0FBQUEsV0FBWUE7UUFDbEdnYixrQkFBa0I7WUFDaEIsSUFBSWpFLGtCQUFrQnR4QixvQkFBb0JxRixHQUFHLENBQUM4a0I7WUFFOUMsSUFBSW1ILGlCQUFpQjtnQkFDbkJBO1lBQ0Y7WUFFQTlhLFNBQVN0TjtRQUNYO0lBQ0Y7SUFFQSxPQUFPaWhCO0FBQ1Q7QUFFQSxJQUFJcUosYUFBYSxDQUFDckosR0FBR3BqQjtJQUNuQixJQUFJNUMsVUFBVSxFQUFFO0lBRWhCLEtBQUssSUFBSSxDQUFDWSxHQUFHNGEsRUFBRSxJQUFJNWtCLHlDQUFNQSxDQUFDMDZCLE1BQU0sQ0FBQ3RMLEdBQUc7UUFDbENsZixJQUFJbEU7SUFDTixHQUFJO1FBQ0YsSUFBSW5MLE1BQU13SSxZQUFZd0UsT0FBTyxDQUFDdWhCLEdBQUdwbEI7UUFDakNaLFFBQVF1UCxJQUFJLENBQUM7WUFBQ2lNO1lBQUcvakI7U0FBSTtJQUN2QjtJQUVBLE9BQU91STtBQUNUO0FBRW1PLENBQ25PLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RpZ21hLy4vbm9kZV9tb2R1bGVzL3NsYXRlLXJlYWN0L2Rpc3QvaW5kZXguZXMuanM/NGUyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJ2RpcmVjdGlvbic7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlLCBtZW1vLCBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgQ29tcG9uZW50LCB1c2VSZWR1Y2VyLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNjcm9sbEludG9WaWV3IGZyb20gJ3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkJztcbmltcG9ydCB7IFRyYW5zZm9ybXMsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBFZGl0b3IsIFNjcnViYmVyLCBSYW5nZSwgUGF0aCwgUG9pbnQsIE5vZGUsIFRleHQgYXMgVGV4dCQxIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcic7XG5pbXBvcnQgeyBpc0hvdGtleSB9IGZyb20gJ2lzLWhvdGtleSc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBlZGl0b3Igb2JqZWN0LlxyXG4gKi9cblxudmFyIEVkaXRvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZVNsYXRlU3RhdGljID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTdGF0aWNgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG52YXIgUkVBQ1RfTUFKT1JfVkVSU0lPTiA9IHBhcnNlSW50KFJlYWN0LnZlcnNpb24uc3BsaXQoJy4nKVswXSwgMTApO1xudmFyIElTX0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgSVNfQVBQTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvTWFjIE9TIFgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0ZJUkVGT1ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfV0VCS0lUID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FwcGxlV2ViS2l0KD8hLipDaHJvbWUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG5cbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gTmF0aXZlIGBiZWZvcmVJbnB1dGAgZXZlbnRzIGRvbid0IHdvcmsgd2VsbCB3aXRoIHJlYWN0IG9uIENocm9tZSA3NVxuLy8gYW5kIG9sZGVyLCBDaHJvbWUgNzYrIGNhbiB1c2UgYGJlZm9yZUlucHV0YCB0aG91Z2guXG5cbnZhciBJU19DSFJPTUVfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC03XVswLTVdfFswLTZdWzAtOV0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZID0gSVNfQU5EUk9JRCAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTVdP1xcZCkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cblxudmFyIElTX0ZJUkVGT1hfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3hcXC8oPzpbMC03XVswLTldfFswLThdWzAtNl0pKD86XFwuKSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFVDIG1vYmlsZSBicm93c2VyXG5cbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFdlY2hhdCBicm93c2VyIChub3QgaW5jbHVkaW5nIG1hYyB3ZWNoYXQpXG5cbnZhciBJU19XRUNIQVRCUk9XU0VSID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvLipNYWNXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGF2b2lkIGxvb2tiZWhpbmQgKGJ1Z2d5IGluIHNhZmFyaSA8IDE2LjQpXG4vLyBDaGVjayBpZiBET00gaXMgYXZhaWxhYmxlIGFzIFJlYWN0IGRvZXMgaW50ZXJuYWxseS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcblxudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7IC8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxuXG52YXIgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gKCFJU19DSFJPTUVfTEVHQUNZIHx8ICFJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kpICYmICFJU19FREdFX0xFR0FDWSAmJiAvLyBnbG9iYWxUaGlzIGlzIHVuZGVmaW5lZCBpbiBvbGRlciBicm93c2Vyc1xudHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSW5wdXRFdmVudCAmJiAvLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG4vKipcclxuICogVHdvIHdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHJlYnVpbGQgYSBwYXRoIGdpdmVuIGEgbm9kZS4gVGhleSBhcmUgcG9wdWxhdGVkXHJcbiAqIGF0IHJlbmRlciB0aW1lIHN1Y2ggdGhhdCBhZnRlciBhIHJlbmRlciBvY2N1cnMgd2UgY2FuIGFsd2F5cyBiYWNrdHJhY2suXHJcbiAqL1xudmFyIE5PREVfVE9fSU5ERVggPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fUEFSRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyB0byBnbyBiZXR3ZWVuIFNsYXRlIG5vZGVzIGFuZCBET00gbm9kZXMuIFRoZXNlXHJcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19XSU5ET1cgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRUxFTUVOVF9UT19OT0RFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fS0VZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cclxuICovXG5cbnZhciBJU19SRUFEX09OTFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0ZPQ1VTRUQgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0NPTVBPU0lORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cclxuICovXG5cbnZhciBFRElUT1JfVE9fT05fQ0hBTkdFID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgZm9yIHNhdmluZyBwZW5kaW5nIHN0YXRlIG9uIGNvbXBvc2l0aW9uIHN0YWdlLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQW5kcm9pZCBpbnB1dCBoYW5kbGluZyBzcGVjaWZpYyB3ZWFrLW1hcHNcclxuICovXG5cbnZhciBFRElUT1JfVE9fUEVORElOR19ESUZGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19GT1JDRV9SRU5ERVIgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFN5bWJvbHMuXHJcbiAqL1xuXG52YXIgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdwbGFjZWhvbGRlcicpO1xudmFyIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdtYXJrLXBsYWNlaG9sZGVyJyk7XG5cbi8qKlxyXG4gKiBUeXBlcy5cclxuICovXG52YXIgRE9NVGV4dCA9IGdsb2JhbFRoaXMuVGV4dDtcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBob3N0IHdpbmRvdyBvZiBhIERPTSBub2RlXHJcbiAqL1xuXG52YXIgZ2V0RGVmYXVsdFZpZXcgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5vd25lckRvY3VtZW50ICYmIHZhbHVlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbnVsbDtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhIGNvbW1lbnQgbm9kZS5cclxuICovXG5cbnZhciBpc0RPTUNvbW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSA4O1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cclxuICovXG5cbnZhciBpc0RPTUVsZW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01Ob2RlID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gZ2V0RGVmYXVsdFZpZXcodmFsdWUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBzZWxlY3Rpb24uXHJcbiAqL1xuXG52YXIgaXNET01TZWxlY3Rpb24gPSB2YWx1ZSA9PiB7XG4gIHZhciB3aW5kb3cgPSB2YWx1ZSAmJiB2YWx1ZS5hbmNob3JOb2RlICYmIGdldERlZmF1bHRWaWV3KHZhbHVlLmFuY2hvck5vZGUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuU2VsZWN0aW9uO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cclxuICovXG5cbnZhciBpc0RPTVRleHQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufTtcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBhIHBhc3RlIGV2ZW50IGlzIGEgcGxhaW50ZXh0LW9ubHkgZXZlbnQuXHJcbiAqL1xuXG52YXIgaXNQbGFpblRleHRPbmx5UGFzdGUgPSBldmVudCA9PiB7XG4gIHJldHVybiBldmVudC5jbGlwYm9hcmREYXRhICYmIGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpICE9PSAnJyAmJiBldmVudC5jbGlwYm9hcmREYXRhLnR5cGVzLmxlbmd0aCA9PT0gMTtcbn07XG4vKipcclxuICogTm9ybWFsaXplIGEgRE9NIHBvaW50IHNvIHRoYXQgaXQgYWx3YXlzIHJlZmVycyB0byBhIHRleHQgbm9kZS5cclxuICovXG5cbnZhciBub3JtYWxpemVET01Qb2ludCA9IGRvbVBvaW50ID0+IHtcbiAgdmFyIFtub2RlLCBvZmZzZXRdID0gZG9tUG9pbnQ7IC8vIElmIGl0J3MgYW4gZWxlbWVudCBub2RlLCBpdHMgb2Zmc2V0IHJlZmVycyB0byB0aGUgaW5kZXggb2YgaXRzIGNoaWxkcmVuXG4gIC8vIGluY2x1ZGluZyBjb21tZW50IG5vZGVzLCBzbyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgdGV4dCBjaGlsZCBub2RlLlxuXG4gIGlmIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBpc0xhc3QgPSBvZmZzZXQgPT09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gaXNMYXN0ID8gb2Zmc2V0IC0gMSA6IG9mZnNldDtcbiAgICBbbm9kZSwgaW5kZXhdID0gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KG5vZGUsIGluZGV4LCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTsgLy8gSWYgdGhlIGVkaXRhYmxlIGNoaWxkIGZvdW5kIGlzIGluIGZyb250IG9mIGlucHV0IG9mZnNldCwgd2UgaW5zdGVhZCBzZWVrIHRvIGl0cyBlbmRcblxuICAgIGlzTGFzdCA9IGluZGV4IDwgb2Zmc2V0OyAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRyYXZlcnNlIHVudGlsIHdlIGhhdmUgYSBsZWFmIG5vZGUuIExlYWYgbm9kZXNcbiAgICAvLyBjYW4gYmUgZWl0aGVyIHRleHQgbm9kZXMsIG9yIG90aGVyIHZvaWQgRE9NIG5vZGVzLlxuXG4gICAgd2hpbGUgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgaSA9IGlzTGFzdCA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxIDogMDtcbiAgICAgIG5vZGUgPSBnZXRFZGl0YWJsZUNoaWxkKG5vZGUsIGksIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuICAgIH0gLy8gRGV0ZXJtaW5lIHRoZSBuZXcgb2Zmc2V0IGluc2lkZSB0aGUgdGV4dCBub2RlLlxuXG5cbiAgICBvZmZzZXQgPSBpc0xhc3QgJiYgbm9kZS50ZXh0Q29udGVudCAhPSBudWxsID8gbm9kZS50ZXh0Q29udGVudC5sZW5ndGggOiAwO1xuICB9IC8vIFJldHVybiB0aGUgbm9kZSBhbmQgb2Zmc2V0LlxuXG5cbiAgcmV0dXJuIFtub2RlLCBvZmZzZXRdO1xufTtcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5lc3RlZCB3aXRoaW4gYSBzaGFkb3dSb290XHJcbiAqL1xuXG52YXIgaGFzU2hhZG93Um9vdCA9IG5vZGUgPT4ge1xuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTsgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpbmRleCA9IGk7XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuXG4gIHJldHVybiBbY2hpbGQsIGluZGV4XTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xyXG4gKiBgZGlyZWN0aW9uYC5cclxuICovXG5cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIgW2NoaWxkXSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuLyoqXHJcbiAqIEdldCBhIHBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBvZiBhIG5vZGUsIGFjY291bnRpbmcgZm9yIGJsb2NrXHJcbiAqIGVsZW1lbnRzIHdoaWNoIGdldCBhIG5ld2xpbmUgYXBwZW5kZWQuXHJcbiAqXHJcbiAqIFRoZSBkb21Ob2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cclxuICovXG5cbnZhciBnZXRQbGFpblRleHQgPSBkb21Ob2RlID0+IHtcbiAgdmFyIHRleHQgPSAnJztcblxuICBpZiAoaXNET01UZXh0KGRvbU5vZGUpICYmIGRvbU5vZGUubm9kZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUubm9kZVZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIGNoaWxkTm9kZSBvZiBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2RlcykpIHtcbiAgICAgIHRleHQgKz0gZ2V0UGxhaW5UZXh0KGNoaWxkTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcblxuICAgIGlmIChkaXNwbGF5ID09PSAnYmxvY2snIHx8IGRpc3BsYXkgPT09ICdsaXN0JyB8fCBkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuLyoqXHJcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcclxuICovXG5cbnZhciBjYXRjaFNsYXRlRnJhZ21lbnQgPSAvZGF0YS1zbGF0ZS1mcmFnbWVudD1cIiguKz8pXCIvbTtcbnZhciBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgdmFyIGh0bWxEYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICB2YXIgWywgZnJhZ21lbnRdID0gaHRtbERhdGEubWF0Y2goY2F0Y2hTbGF0ZUZyYWdtZW50KSB8fCBbXTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IChlZGl0b3IsIG11dGF0aW9uLCBiYXRjaCkgPT4ge1xuICB2YXIge1xuICAgIHRhcmdldFxuICB9ID0gbXV0YXRpb247XG5cbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuXG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGFyZW50TXV0YXRpb24gPSBiYXRjaC5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBhZGRlZE5vZGVzLFxuICAgICAgcmVtb3ZlZE5vZGVzXG4gICAgfSA9IF9yZWY7XG5cbiAgICBmb3IgKHZhciBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9ub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgICAgaWYgKF9ub2RlID09PSB0YXJnZXQgfHwgX25vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuXG5cbiAgcmV0dXJuIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgcGFyZW50TXV0YXRpb24sIGJhdGNoKTtcbn07XG5cbi8qKlxyXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxyXG4gKi9cbnZhciBuID0gMDtcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgYSBrZXkgc3RyaW5nLiBXZSB1c2UgYSBmdWxsIGNsYXNzIGhlcmUgYmVjYXVzZSB3ZVxyXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cclxuICovXG5cbmNsYXNzIEtleSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBcIlwiLmNvbmNhdChuKyspO1xuICB9XG5cbn1cblxudmFyIFJlYWN0RWRpdG9yID0ge1xuICBhbmRyb2lkUGVuZGluZ0RpZmZzOiBlZGl0b3IgPT4gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvciksXG4gIGFuZHJvaWRTY2hlZHVsZUZsdXNoOiBlZGl0b3IgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1NDSEVEVUxFX0Y7XG5cbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICB9LFxuICBibHVyOiBlZGl0b3IgPT4ge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIGZhbHNlKTtcblxuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuICBkZXNlbGVjdDogZWRpdG9yID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuICBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Q6IGVkaXRvciA9PiB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG5cbiAgICBpZiAoKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkgJiYgcm9vdC5nZXRTZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQ7XG4gIH0sXG4gIGZpbmRFdmVudFJhbmdlOiAoZWRpdG9yLCBldmVudCkgPT4ge1xuICAgIGlmICgnbmF0aXZlRXZlbnQnIGluIGV2ZW50KSB7XG4gICAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBjbGllbnRYOiB4LFxuICAgICAgY2xpZW50WTogeSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcblxuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTsgLy8gSWYgdGhlIGRyb3AgdGFyZ2V0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSBpdCBpbnRvIGVpdGhlciB0aGVcbiAgICAvLyBuZXh0IG9yIHByZXZpb3VzIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHRoZSBgeGAgYW5kIGB5YFxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBjbG9zZXN0IHRvLlxuXG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBpc1ByZXYgPSBlZGl0b3IuaXNJbmxpbmUobm9kZSkgPyB4IC0gcmVjdC5sZWZ0IDwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAtIHggOiB5IC0gcmVjdC50b3AgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC0geTtcbiAgICAgIHZhciBlZGdlID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCwge1xuICAgICAgICBlZGdlOiBpc1ByZXYgPyAnc3RhcnQnIDogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50ID0gaXNQcmV2ID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGVkZ2UpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZWRnZSk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgX3JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQpO1xuXG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfSAvLyBFbHNlIHJlc29sdmUgYSByYW5nZSBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuXG5cbiAgICB2YXIgZG9tUmFuZ2U7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpOyAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGBjYXJldFJhbmdlRnJvbVBvaW50YCBkb2Vzbid0IGV4aXN0LiAoMjAxNi8wNy8yNSlcblxuICAgIGlmIChkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGRvbVJhbmdlLnNldFN0YXJ0KHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICAgIGRvbVJhbmdlLnNldEVuZChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZG9tUmFuZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfSAvLyBSZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSB0aGUgRE9NIHJhbmdlLlxuXG5cbiAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwge1xuICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfSxcbiAgZmluZEtleTogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZmluZFBhdGg6IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBjaGlsZCA9IG5vZGU7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IE5PREVfVE9fUEFSRU5ULmdldChjaGlsZCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gTk9ERV9UT19JTkRFWC5nZXQoY2hpbGQpO1xuXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgcGF0aCBmb3IgU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICB9LFxuICBmb2N1czogZWRpdG9yID0+IHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICBlbC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0V2luZG93OiBlZGl0b3IgPT4ge1xuICAgIHZhciB3aW5kb3cgPSBFRElUT1JfVE9fV0lORE9XLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYSBob3N0IHdpbmRvdyBlbGVtZW50IGZvciB0aGlzIGVkaXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3c7XG4gIH0sXG4gIGhhc0RPTU5vZGU6IGZ1bmN0aW9uIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkaXRhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWRpdG9yRWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciB0YXJnZXRFbDsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG5cbiAgICB0cnkge1xuICAgICAgdGFyZ2V0RWwgPSBpc0RPTUVsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwibm9kZVR5cGVcIicpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID8gdHJ1ZSA6IHR5cGVvZiB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nICYmIC8vIGlzQ29udGVudEVkaXRhYmxlIGV4aXN0cyBvbmx5IG9uIEhUTUxFbGVtZW50LCBhbmQgb24gb3RoZXIgbm9kZXMgaXQgd2lsbCBiZSB1bmRlZmluZWRcbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIGxvZ2ljIHRoYXQgbGV0cyB5b3Uga25vdyB5b3UgZ290IHRoZSByaWdodCBlZGl0b3Iuc2VsZWN0aW9uIGluc3RlYWQgb2YgbnVsbCB3aGVuIGVkaXRvciBpcyBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiKHJlYWRPbmx5KVxuICAgIHRhcmdldEVsLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpID09PSBlZGl0b3JFbCB8fCAhIXRhcmdldEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpO1xuICB9LFxuICBoYXNFZGl0YWJsZVRhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgZWRpdGFibGU6IHRydWVcbiAgfSksXG4gIGhhc1JhbmdlOiAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBhbmNob3IucGF0aCkgJiYgRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBmb2N1cy5wYXRoKTtcbiAgfSxcbiAgaGFzU2VsZWN0YWJsZVRhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCB0YXJnZXQpLFxuICBoYXNUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gaXNET01Ob2RlKHRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCksXG4gIGluc2VydERhdGE6IChlZGl0b3IsIGRhdGEpID0+IHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpLFxuICBpbnNlcnRUZXh0RGF0YTogKGVkaXRvciwgZGF0YSkgPT4gZWRpdG9yLmluc2VydFRleHREYXRhKGRhdGEpLFxuICBpc0NvbXBvc2luZzogZWRpdG9yID0+IHtcbiAgICByZXR1cm4gISFJU19DT01QT1NJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGlzRm9jdXNlZDogZWRpdG9yID0+ICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKSxcbiAgaXNSZWFkT25seTogZWRpdG9yID0+ICEhSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpLFxuICBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZDogKGVkaXRvciwgdGFyZ2V0KSA9PiB7XG4gICAgaWYgKElTX1JFQURfT05MWS5nZXQoZWRpdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzbGF0ZU5vZGUgPSBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCB0YXJnZXQpICYmIFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChzbGF0ZU5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuICBzZXRGcmFnbWVudERhdGE6IChlZGl0b3IsIGRhdGEsIG9yaWdpbkV2ZW50KSA9PiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEsIG9yaWdpbkV2ZW50KSxcbiAgdG9ET01Ob2RlOiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIHZhciBkb21Ob2RlID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZ2V0KFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBub2RlKSk7XG5cbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIG5vZGUgZnJvbSBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG4gIHRvRE9NUG9pbnQ6IChlZGl0b3IsIHBvaW50KSA9PiB7XG4gICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCk7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50OyAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG5cbiAgICBpZiAoRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcG9pbnRcbiAgICB9KSkge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9IC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG5cblxuICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtc2xhdGUtc3RyaW5nXSwgW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIjtcbiAgICB2YXIgdGV4dHMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHQgPSB0ZXh0c1tpXTtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuXG4gICAgICBpZiAoZG9tTm9kZSA9PSBudWxsIHx8IGRvbU5vZGUudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIHZhciBhdHRyID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbGVuZ3RoJyk7XG4gICAgICB2YXIgdHJ1ZUxlbmd0aCA9IGF0dHIgPT0gbnVsbCA/IGxlbmd0aCA6IHBhcnNlSW50KGF0dHIsIDEwKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCArIHRydWVMZW5ndGg7IC8vIFByZWZlciBwdXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyIHRvIGVuc3VyZVxuICAgICAgLy8gY29tcG9zZWQgdGV4dCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgY29ycmVjdCBtYXJrcy5cblxuICAgICAgdmFyIG5leHRUZXh0ID0gdGV4dHNbaSArIDFdO1xuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID09PSBlbmQgJiYgbmV4dFRleHQgIT09IG51bGwgJiYgbmV4dFRleHQgIT09IHZvaWQgMCAmJiBuZXh0VGV4dC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHZhciBfbmV4dFRleHQkdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgdmFyIGRvbVRleHQgPSBuZXh0VGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBkb21Qb2ludCA9IFsvLyBDT01QQVQ6IElmIHdlIGRvbid0IGV4cGxpY2l0eSBzZXQgdGhlIGRvbSBwb2ludCB0byBiZSBvbiB0aGUgYWN0dWFsXG4gICAgICAgIC8vIGRvbSB0ZXh0IGVsZW1lbnQsIGNocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uIGJlaGluZCB0aGUgYWN0dWFsIGRvbVxuICAgICAgICAvLyB0ZXh0IGVsZW1lbnQsIGNhdXNpbmcgZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgY2FsbHMgb24gYSBjb2xsYXBzZWRcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHJldHVybiBpbmNvcnJlY3QgemVybyB2YWx1ZXMgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzNTQzOClcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMgd2hlbiBzY3JvbGxpbmcgdG8gaXQuXG4gICAgICAgIGRvbVRleHQgaW5zdGFuY2VvZiBET01UZXh0ID8gZG9tVGV4dCA6IG5leHRUZXh0LCAoX25leHRUZXh0JHRleHRDb250ZW50ID0gbmV4dFRleHQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgPyAxIDogMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDw9IGVuZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBNYXRoLm1heCgwLCBwb2ludC5vZmZzZXQgLSBzdGFydCkpO1xuICAgICAgICBkb21Qb2ludCA9IFtkb21Ob2RlLCBvZmZzZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFkb21Qb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gcG9pbnQgZnJvbSBTbGF0ZSBwb2ludDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG4gIHRvRE9NUmFuZ2U6IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHZhciBpc0JhY2t3YXJkID0gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gICAgdmFyIGRvbUFuY2hvciA9IFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBhbmNob3IpO1xuICAgIHZhciBkb21Gb2N1cyA9IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSA/IGRvbUFuY2hvciA6IFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBmb2N1cyk7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21SYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciBbc3RhcnROb2RlLCBzdGFydE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tRm9jdXMgOiBkb21BbmNob3I7XG4gICAgdmFyIFtlbmROb2RlLCBlbmRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUFuY2hvciA6IGRvbUZvY3VzOyAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cblxuICAgIHZhciBzdGFydEVsID0gaXNET01FbGVtZW50KHN0YXJ0Tm9kZSkgPyBzdGFydE5vZGUgOiBzdGFydE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNTdGFydEF0WmVyb1dpZHRoID0gISFzdGFydEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgdmFyIGVuZEVsID0gaXNET01FbGVtZW50KGVuZE5vZGUpID8gZW5kTm9kZSA6IGVuZE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNFbmRBdFplcm9XaWR0aCA9ICEhZW5kRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIGlzU3RhcnRBdFplcm9XaWR0aCA/IDEgOiBzdGFydE9mZnNldCk7XG4gICAgZG9tUmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGlzRW5kQXRaZXJvV2lkdGggPyAxIDogZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gZG9tUmFuZ2U7XG4gIH0sXG4gIHRvU2xhdGVOb2RlOiAoZWRpdG9yLCBkb21Ob2RlKSA9PiB7XG4gICAgdmFyIGRvbUVsID0gaXNET01FbGVtZW50KGRvbU5vZGUpID8gZG9tTm9kZSA6IGRvbU5vZGUucGFyZW50RWxlbWVudDtcblxuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBkb21FbCA/IEVMRU1FTlRfVE9fTk9ERS5nZXQoZG9tRWwpIDogbnVsbDtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBub2RlIGZyb20gRE9NIG5vZGU6IFwiLmNvbmNhdChkb21FbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICB0b1NsYXRlUG9pbnQ6IChlZGl0b3IsIGRvbVBvaW50LCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldF0gPSBleGFjdE1hdGNoID8gZG9tUG9pbnQgOiBub3JtYWxpemVET01Qb2ludChkb21Qb2ludCk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBuZWFyZXN0Tm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgdmFyIF9kb21Ob2RlJHRleHRDb250ZW50LCBfZG9tTm9kZSR0ZXh0Q29udGVudDI7XG5cbiAgICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgcG90ZW50aWFsVm9pZE5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLXZvaWQ9XCJ0cnVlXCJdJyk7IC8vIE5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb3Nlc3Qgdm9pZCBub2RlIGlzIGFjdHVhbGx5IGEgdm9pZCBub2RlXG4gICAgICAvLyB3aXRoaW4gdGhpcyBlZGl0b3IsIGFuZCBub3QgYSB2b2lkIG5vZGUgd2l0aGluIHNvbWUgcGFyZW50IGVkaXRvci4gVGhpcyBjYW4gaGFwcGVuXG4gICAgICAvLyBpZiB0aGlzIGVkaXRvciBpcyB3aXRoaW4gYSB2b2lkIG5vZGUgb2YgYW5vdGhlciBlZGl0b3IgKFwibmVzdGVkIGVkaXRvcnNcIiwgbGlrZSBpblxuICAgICAgLy8gdGhlIFwiRWRpdGFibGUgVm9pZHNcIiBleGFtcGxlIG9uIHRoZSBkb2NzIHNpdGUpLlxuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7IC8vIENhbGN1bGF0ZSBob3cgZmFyIGludG8gdGhlIHRleHQgbm9kZSB0aGUgYG5lYXJlc3ROb2RlYCBpcywgc28gdGhhdCB3ZVxuICAgICAgLy8gY2FuIGRldGVybWluZSB3aGF0IHRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHRleHQgbm9kZSBpcy5cblxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcblxuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgICAgICAgdmFyIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgIHZhciByZW1vdmFscyA9IFsuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKSwgLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZT1mYWxzZV0nKSldO1xuICAgICAgICAgIHJlbW92YWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBjb21wb3NpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlLCBzb21lIGtleWJvYXJkcyBwdXRcbiAgICAgICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgaW5zaWRlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlLlxuICAgICAgICAgICAgaWYgKElTX0FORFJPSUQgJiYgIWV4YWN0TWF0Y2ggJiYgZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSAmJiBlbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIGVsLnRleHRDb250ZXh0ICE9PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSkge1xuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pOyAvLyBDT01QQVQ6IEVkZ2UgaGFzIGEgYnVnIHdoZXJlIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZygpIHdpbGxcbiAgICAgICAgICAvLyBjb252ZXJ0IFxcbiBpbnRvIFxcclxcbi4gVGhlIGJ1ZyBjYXVzZXMgYSBsb29wIHdoZW4gc2xhdGUtcmVhY3RcbiAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZXBvc2l0aW9uIGl0cyBjdXJzb3IgdG8gbWF0Y2ggdGhlIG5hdGl2ZSBwb3NpdGlvbi4gVXNlXG4gICAgICAgICAgLy8gdGV4dENvbnRlbnQubGVuZ3RoIGluc3RlYWQuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAyOTExMTYvXG5cbiAgICAgICAgICBvZmZzZXQgPSBjb250ZW50cy50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZSA9IHRleHROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZvaWROb2RlKSB7XG4gICAgICAgIC8vIEZvciB2b2lkIG5vZGVzLCB0aGUgZWxlbWVudCB3aXRoIHRoZSBvZmZzZXQga2V5IHdpbGwgYmUgYSBjb3VzaW4sIG5vdCBhblxuICAgICAgICAvLyBhbmNlc3Rvciwgc28gZmluZCBpdCBieSBnb2luZyBkb3duIGZyb20gdGhlIG5lYXJlc3Qgdm9pZCBwYXJlbnQgYW5kIHRha2luZyB0aGVcbiAgICAgICAgLy8gZmlyc3Qgb25lIHRoYXQgaXNuJ3QgaW5zaWRlIGEgbmVzdGVkIGVkaXRvci5cbiAgICAgICAgdmFyIGxlYWZOb2RlcyA9IHZvaWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlYWZOb2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGxlYWZOb2Rlc1tpbmRleF07XG5cbiAgICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsZWFmTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiByZWFkLW9ubHkgZWRpdG9ycyB0aGUgbGVhZiBpcyBub3QgcmVuZGVyZWQuXG5cblxuICAgICAgICBpZiAoIWxlYWZOb2RlKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIG9mZnNldCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJiAvLyBDT01QQVQ6IEFuZHJvaWQgSU1FcyBtaWdodCByZW1vdmUgdGhlIHplcm8gd2lkdGggc3BhY2Ugd2hpbGUgY29tcG9zaW5nLFxuICAgICAgLy8gYW5kIHdlIGRvbid0IGFkZCBpdCBmb3IgbGluZS1icmVha3MuXG4gICAgICBJU19BTkRST0lEICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ3onICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpICYmIChwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgfHwgSVNfRklSRUZPWCAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQyID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyLmVuZHNXaXRoKCdcXG5cXG4nKSkpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKElTX0FORFJPSUQgJiYgIXRleHROb2RlICYmICFleGFjdE1hdGNoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSA/IHBhcmVudE5vZGUgOiBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGVdJyk7XG5cbiAgICAgIGlmIChub2RlICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgX3NsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgbm9kZSk7XG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfSA9IEVkaXRvci5zdGFydChlZGl0b3IsIFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX3NsYXRlTm9kZSkpO1xuXG4gICAgICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpKSB7XG4gICAgICAgICAgX29mZnNldCA9IG5lYXJlc3RPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgIGlmIChzdXBwcmVzc1Rocm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHBvaW50IGZyb20gRE9NIHBvaW50OiBcIi5jb25jYXQoZG9tUG9pbnQpKTtcbiAgICB9IC8vIENPTVBBVDogSWYgc29tZW9uZSBpcyBjbGlja2luZyBmcm9tIG9uZSBTbGF0ZSBlZGl0b3IgaW50byBhbm90aGVyLFxuICAgIC8vIHRoZSBzZWxlY3QgZXZlbnQgZmlyZXMgdHdpY2UsIG9uY2UgZm9yIHRoZSBvbGQgZWRpdG9yJ3MgYGVsZW1lbnRgXG4gICAgLy8gZmlyc3QsIGFuZCB0aGVuIGFmdGVyd2FyZHMgZm9yIHRoZSBjb3JyZWN0IGBlbGVtZW50YC4gKDIwMTcvMDMvMDMpXG5cblxuICAgIHZhciBzbGF0ZU5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRleHROb2RlKTtcbiAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH0sXG4gIHRvU2xhdGVSYW5nZTogKGVkaXRvciwgZG9tUmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWwgPSBpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkgPyBkb21SYW5nZS5hbmNob3JOb2RlIDogZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgdmFyIGFuY2hvck5vZGU7XG4gICAgdmFyIGFuY2hvck9mZnNldDtcbiAgICB2YXIgZm9jdXNOb2RlO1xuICAgIHZhciBmb2N1c09mZnNldDtcbiAgICB2YXIgaXNDb2xsYXBzZWQ7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tUmFuZ2UucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7IC8vIEZvY3VzIG5vZGUgd29ya3MgZmluZVxuXG4gICAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KGRvbVJhbmdlLnJhbmdlQ291bnQgLSAxKTsgLy8gSGVyZSB3ZSBhcmUgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9mIGEgdGFibGUgaW4gZmlyZWZveFxuXG4gICAgICAgICAgaWYgKGZvY3VzTm9kZSBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSFRNTEVsZW1lbnQsIGJlY291c2UgRWxlbWVudCBpcyBhIHNsYXRlIGVsZW1lbnRcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldExhc3RDaGlsZHJlbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZVJvdyA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGVSb3cgPSBsYXN0UmFuZ2Uuc3RhcnRDb250YWluZXI7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGZhaWwgYXMgXCJUaGUgSFRNTEVsZW1lbnQgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW55IEhUTUwgZWxlbWVudC5cIlxuXG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGZpcnN0Tm9kZVJvdy5jaGlsZHJlbltmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4obGFzdE5vZGVSb3cuY2hpbGRyZW5bbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7IC8vIFplcm8sIGFzIHdlIGFsbHdheXMgdGFrZSB0aGUgcmlnaHQgb25lIGFzIHRoZSBhbmNob3IgcG9pbnRcblxuICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBpZiAobGFzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3ROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE5vZGUuaW5uZXJIVE1MLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9wdGlvblxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZWFkIG9ubHkgbW9kZSBvZiBhIGZpcmVmb3ggdGFibGVcbiAgICAgICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3RSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZmlyc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZpcnN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLmFuY2hvck5vZGU7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IC8vIENPTVBBVDogVGhlcmUncyBhIGJ1ZyBpbiBjaHJvbWUgdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICAgIC8vIGBpc0NvbGxhcHNlZGAgZm9yIGEgU2VsZWN0aW9uIHRoYXQgY29tZXMgZnJvbSBhIFNoYWRvd1Jvb3QuXG4gICAgICAgIC8vICgyMDIwLzA4LzA4KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbiAgICAgICAgLy8gSXNDb2xsYXBzZWQgbWlnaHQgbm90IHdvcmsgaW4gZmlyZWZveCwgYnV0IHRoaXMgd2lsbFxuXG5cbiAgICAgICAgaWYgKElTX0NIUk9NRSAmJiBoYXNTaGFkb3dSb290KGFuY2hvck5vZGUpIHx8IElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmFuY2hvck5vZGUgPT09IGRvbVJhbmdlLmZvY3VzTm9kZSAmJiBkb21SYW5nZS5hbmNob3JPZmZzZXQgPT09IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfSAvLyBDT01QQVQ6IFRyaXBsZS1jbGlja2luZyBhIHdvcmQgaW4gY2hyb21lIHdpbGwgc29tZXRpbWVzIHBsYWNlIHRoZSBmb2N1c1xuICAgIC8vIGluc2lkZSBhIGBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiYCBET00gbm9kZSBmb2xsb3dpbmcgdGhlIHdvcmQsIHdoaWNoXG4gICAgLy8gd2lsbCBjYXVzZSBgdG9TbGF0ZVBvaW50YCB0byB0aHJvdyBhbiBlcnJvci4gKDIwMjMvMDMvMDcpXG5cblxuICAgIGlmICgnZ2V0QXR0cmlidXRlJyBpbiBmb2N1c05vZGUgJiYgZm9jdXNOb2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScgJiYgZm9jdXNOb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS12b2lkJykgIT09ICd0cnVlJykge1xuICAgICAgdmFyIF9hbmNob3JOb2RlJHRleHRDb250ZTtcblxuICAgICAgZm9jdXNOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gKChfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPSBhbmNob3JOb2RlLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbmNob3JOb2RlJHRleHRDb250ZS5sZW5ndGgpIHx8IDA7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmb2N1cyA9IGlzQ29sbGFwc2VkID8gYW5jaG9yIDogUmVhY3RFZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFmb2N1cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9OyAvLyBpZiB0aGUgc2VsZWN0aW9uIGlzIGEgaGFuZ2luZyByYW5nZSB0aGF0IGVuZHMgaW4gYSB2b2lkXG4gICAgLy8gYW5kIHRoZSBET00gZm9jdXMgaXMgYW4gRWxlbWVudFxuICAgIC8vIChtZWFuaW5nIHRoYXQgdGhlIHNlbGVjdGlvbiBlbmRzIGJlZm9yZSB0aGUgZWxlbWVudClcbiAgICAvLyB1bmhhbmcgdGhlIHJhbmdlIHRvIGF2b2lkIG1pc3Rha2VubHkgaW5jbHVkaW5nIHRoZSB2b2lkXG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChyYW5nZSkgJiYgUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSAmJiBpc0RPTUVsZW1lbnQoZm9jdXNOb2RlKSAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZS5mb2N1cyxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSB7XG4gICAgICByYW5nZSA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCB7XG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgdGV4dCBkaWZmIHdhcyBhcHBsaWVkIGluIGEgd2F5IHdlIGNhbiBwZXJmb3JtIHRoZSBwZW5kaW5nIGFjdGlvbiBvbiAvXHJcbiAqIHJlY292ZXIgdGhlIHBlbmRpbmcgc2VsZWN0aW9uLlxyXG4gKi9cblxuZnVuY3Rpb24gdmVyaWZ5RGlmZlN0YXRlKGVkaXRvciwgdGV4dERpZmYpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmO1xuXG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICBpZiAoIVRleHQkMS5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZGlmZi5zdGFydCAhPT0gbm9kZS50ZXh0Lmxlbmd0aCB8fCBkaWZmLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dC5zbGljZShkaWZmLnN0YXJ0LCBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkgPT09IGRpZmYudGV4dDtcbiAgfVxuXG4gIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgbmV4dFBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5leHROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBuZXh0UGF0aCk7XG4gIHJldHVybiBUZXh0JDEuaXNUZXh0KG5leHROb2RlKSAmJiBuZXh0Tm9kZS50ZXh0LnN0YXJ0c1dpdGgoZGlmZi50ZXh0KTtcbn1cbmZ1bmN0aW9uIGFwcGx5U3RyaW5nRGlmZih0ZXh0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkaWZmcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZGlmZnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZSgodGV4dCwgZGlmZikgPT4gdGV4dC5zbGljZSgwLCBkaWZmLnN0YXJ0KSArIGRpZmYudGV4dCArIHRleHQuc2xpY2UoZGlmZi5lbmQpLCB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChzdHIsIGFub3RoZXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgIT09IGFub3RoZXIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHN0ciwgYW5vdGhlciwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCwgbWF4KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIGkgLSAxKSAhPT0gYW5vdGhlci5jaGFyQXQoYW5vdGhlci5sZW5ndGggLSBpIC0gMSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZW5ndGg7XG59XG4vKipcclxuICogUmVtb3ZlIHJlZHVuZGFudCBjaGFuZ2VzIGZyb20gdGhlIGRpZmYgc28gdGhhdCBpdCBzcGFucyB0aGUgbWluaW1hbCBwb3NzaWJsZSByYW5nZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIGRpZmYpIHtcbiAgdmFyIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9ID0gZGlmZjtcbiAgdmFyIHJlbW92ZWRUZXh0ID0gdGFyZ2V0VGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHByZWZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQpO1xuICB2YXIgbWF4ID0gTWF0aC5taW4ocmVtb3ZlZFRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCk7XG4gIHZhciBzdWZmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0LCBtYXgpO1xuICB2YXIgbm9ybWFsaXplZCA9IHtcbiAgICBzdGFydDogc3RhcnQgKyBwcmVmaXhMZW5ndGgsXG4gICAgZW5kOiBlbmQgLSBzdWZmaXhMZW5ndGgsXG4gICAgdGV4dDogdGV4dC5zbGljZShwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gc3VmZml4TGVuZ3RoKVxuICB9O1xuXG4gIGlmIChub3JtYWxpemVkLnN0YXJ0ID09PSBub3JtYWxpemVkLmVuZCAmJiBub3JtYWxpemVkLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgZGlmZiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYXBwbHlpbmcgYiBhZnRlciBhIHNwYW5uaW5nIHRoZSByYW5nZSBvZlxyXG4gKiBib3RoIGNoYW5nZXNcclxuICovXG5cbmZ1bmN0aW9uIG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0VGV4dCwgYSwgYikge1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgdmFyIG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCwgYi5lbmQpIC0gYi5zdGFydCk7XG4gIHZhciBhcHBsaWVkID0gYXBwbHlTdHJpbmdEaWZmKHRhcmdldFRleHQsIGEsIGIpO1xuICB2YXIgc2xpY2VFbmQgPSBNYXRoLm1heChiLnN0YXJ0ICsgYi50ZXh0Lmxlbmd0aCwgYS5zdGFydCArIGEudGV4dC5sZW5ndGggKyAoYS5zdGFydCArIGEudGV4dC5sZW5ndGggPiBiLnN0YXJ0ID8gYi50ZXh0Lmxlbmd0aCA6IDApIC0gb3ZlcmxhcCk7XG4gIHZhciB0ZXh0ID0gYXBwbGllZC5zbGljZShzdGFydCwgc2xpY2VFbmQpO1xuICB2YXIgZW5kID0gTWF0aC5tYXgoYS5lbmQsIGIuZW5kIC0gYS50ZXh0Lmxlbmd0aCArIChhLmVuZCAtIGEuc3RhcnQpKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0pO1xufVxuLyoqXHJcbiAqIEdldCB0aGUgc2xhdGUgcmFuZ2UgdGhlIHRleHQgZGlmZiBzcGFucy5cclxuICovXG5cbmZ1bmN0aW9uIHRhcmdldFJhbmdlKHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLmVuZFxuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBwb2ludCcgYS5rLmEgYSBwb2ludCBiYXNlZCBvbiB0aGUgZG9tIHN0YXRlIGJlZm9yZSBhcHBseWluZ1xyXG4gKiB0aGUgcGVuZGluZyBkaWZmcy4gU2luY2UgdGhlIHBlbmRpbmcgZGlmZnMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIHdpdGggZGlmZmVyZW50XHJcbiAqIG1hcmtzIHdlIGhhdmUgdG8gJ3dhbGsnIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gdG8gZW5zdXJlIHdlIHN0aWxsXHJcbiAqIGhhdmUgYSB2YWxpZCBwb2ludCBpbnNpZGUgdGhlIGRvY3VtZW50XHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVQb2ludChlZGl0b3IsIHBvaW50KSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfSA9IHBvaW50O1xuXG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxlYWYgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gIGlmICghVGV4dCQxLmlzVGV4dChsZWFmKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcmVudEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICBhdDogcGF0aFxuICB9KTtcblxuICBpZiAoIXBhcmVudEJsb2NrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3aGlsZSAob2Zmc2V0ID4gbGVhZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IEVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtYXRjaDogVGV4dCQxLmlzVGV4dFxuICAgIH0pO1xuXG4gICAgaWYgKCFlbnRyeSB8fCAhUGF0aC5pc0Rlc2NlbmRhbnQoZW50cnlbMV0sIHBhcmVudEJsb2NrWzFdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgb2Zmc2V0IC09IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgbGVhZiA9IGVudHJ5WzBdO1xuICAgIHBhdGggPSBlbnRyeVsxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfTtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBzZWxlY3Rpb24nIHRvIGVuc3VyZSBpdCdzIHZhbGlkIGluIHRoZSBjdXJyZW50IGRvY3VtZW50IHN0YXRlLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgYW5jaG9yID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IpO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZvY3VzID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cyk7XG5cbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHBvaW50LCBvcCkge1xuICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gIHZhciB0ZXh0RGlmZiA9IHBlbmRpbmdEaWZmcyA9PT0gbnVsbCB8fCBwZW5kaW5nRGlmZnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdEaWZmcy5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKHBhdGgsIHBvaW50LnBhdGgpO1xuICB9KTtcblxuICBpZiAoIXRleHREaWZmIHx8IHBvaW50Lm9mZnNldCA8PSB0ZXh0RGlmZi5kaWZmLnN0YXJ0KSB7XG4gICAgcmV0dXJuIFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cblxuICB2YXIge1xuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmOyAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGluc2lkZSB0aGUgZGlmZiA9PiB0cmFuc2Zvcm0gdGhlIHBvaW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAvLyB0aGUgZGlmZiB3aWxsIGJlIGFwcGxpZWQgdG8gYW5kIGFkZCB0aGUgb2Zmc2V0IGluc2lkZSB0aGUgZGlmZi5cblxuICBpZiAocG9pbnQub2Zmc2V0IDw9IGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIF9hbmNob3IgPSB7XG4gICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfTtcblxuICAgIHZhciBfdHJhbnNmb3JtZWQgPSBQb2ludC50cmFuc2Zvcm0oX2FuY2hvciwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG5cbiAgICBpZiAoIV90cmFuc2Zvcm1lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IF90cmFuc2Zvcm1lZC5wYXRoLFxuICAgICAgb2Zmc2V0OiBfdHJhbnNmb3JtZWQub2Zmc2V0ICsgcG9pbnQub2Zmc2V0IC0gZGlmZi5zdGFydFxuICAgIH07XG4gIH0gLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBhZnRlciB0aGUgZGlmZlxuXG5cbiAgdmFyIGFuY2hvciA9IHtcbiAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgIG9mZnNldDogcG9pbnQub2Zmc2V0IC0gZGlmZi50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kIC0gZGlmZi5zdGFydFxuICB9O1xuICB2YXIgdHJhbnNmb3JtZWQgPSBQb2ludC50cmFuc2Zvcm0oYW5jaG9yLCBvcCwge1xuICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gIH0pO1xuXG4gIGlmICghdHJhbnNmb3JtZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChvcC50eXBlID09PSAnc3BsaXRfbm9kZScgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcG9pbnQucGF0aCkgJiYgYW5jaG9yLm9mZnNldCA8IG9wLnBvc2l0aW9uICYmIGRpZmYuc3RhcnQgPCBvcC5wb3NpdGlvbikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogdHJhbnNmb3JtZWQucGF0aCxcbiAgICBvZmZzZXQ6IHRyYW5zZm9ybWVkLm9mZnNldCArIGRpZmYudGV4dC5sZW5ndGggLSBkaWZmLmVuZCArIGRpZmYuc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcCkge1xuICB2YXIgYW5jaG9yID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yLCBvcCk7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cblxuICB2YXIgZm9jdXMgPSB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cywgb3ApO1xuXG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmYsXG4gICAgaWRcbiAgfSA9IHRleHREaWZmO1xuXG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3Aub2Zmc2V0IDw9IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogb3AudGV4dC5sZW5ndGggKyBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5lbmQsXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoIDw9IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5wb3NpdGlvbiA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLnBvc2l0aW9uID4gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IE1hdGgubWluKG9wLnBvc2l0aW9uLCBkaWZmLmVuZCksXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0ICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG5cbiAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG5cbiAgaWYgKCFuZXdQYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZmYsXG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8vIFdoZW4gdXNpbmcga2V5Ym9hcmQgRW5nbGlzaCBhc3NvY2lhdGlvbiBmdW5jdGlvbiwgY29ucG9zaXRpb25FbmQgdHJpZ2dlcmVkIHRvbyBmYXN0LCByZXN1bHRpbmcgaW4gYWZ0ZXIgYGluc2VydFRleHRgIHN0aWxsIG1haW50YWluIGFzc29jaWF0aW9uIHN0YXRlLlxuXG52YXIgUkVTT0xWRV9ERUxBWSA9IDI1OyAvLyBUaW1lIHdpdGggbm8gdXNlciBpbnRlcmFjdGlvbiBiZWZvcmUgdGhlIGN1cnJlbnQgdXNlciBhY3Rpb24gaXMgY29uc2lkZXJlZCBhcyBkb25lLlxuXG52YXIgRkxVU0hfREVMQVkgPSAyMDA7IC8vIFJlcGxhY2Ugd2l0aCBgY29uc3QgZGVidWcgPSBjb25zb2xlLmxvZ2AgdG8gZGVidWdcblxudmFyIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTsgLy8gVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEgRGF0YVRyYW5zZmVyXG5cblxudmFyIGlzRGF0YVRyYW5zZmVyID0gdmFsdWUgPT4gKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2Zlcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIoX3JlZikge1xuICB2YXIge1xuICAgIGVkaXRvcixcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLFxuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0gPSBfcmVmO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgdmFyIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGFjdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICB2YXIgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG5cbiAgdmFyIGFwcGx5UGVuZGluZ1NlbGVjdGlvbiA9ICgpID0+IHtcbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYW5nZShlZGl0b3IsIHBlbmRpbmdTZWxlY3Rpb24pO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAmJiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKG5vcm1hbGl6ZWQsIHNlbGVjdGlvbikpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZXJmb3JtQWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBhY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLmF0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9pbnQuaXNQb2ludChhY3Rpb24uYXQpID8gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBhY3Rpb24uYXQpIDogbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBhY3Rpb24uYXQpO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGFyZ2V0UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCBfdGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb24ucnVuKCk7XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gKCkgPT4ge1xuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoYWN0aW9uVGltZW91dElkKTtcbiAgICAgIGFjdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSAmJiAhaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGZsdXNoaW5nID0gZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGZsdXNoaW5nID0gJ2FjdGlvbic7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvblJlZiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgIH0pO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLnNldChlZGl0b3IsIGVkaXRvci5tYXJrcyk7XG4gICAgZGVidWcoJ2ZsdXNoJywgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpLCBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSk7XG4gICAgdmFyIHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlID0gaGFzUGVuZGluZ0RpZmZzKCk7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoZGlmZiA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfRElbMF0pIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREksIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICAgIHZhciBwZW5kaW5nTWFya3MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcik7XG5cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICAgIH1cblxuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHRhcmdldFJhbmdlKGRpZmYpO1xuXG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmLmRpZmYudGV4dCkge1xuICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRpZmYuZGlmZi50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgfSAvLyBSZW1vdmUgZGlmZiBvbmx5IGFmdGVyIHdlIGhhdmUgYXBwbGllZCBpdCB0byBhY2NvdW50IGZvciBpdCB3aGVuIHRyYW5zZm9ybWluZ1xuICAgICAgLy8gcGVuZGluZyByYW5nZXMuXG5cblxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJMi5maWx0ZXIoX3JlZjIgPT4ge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBkaWZmLmlkO1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAoIXZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIGRpZmYpKSB7XG4gICAgICAgIHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIGZsdXNoaW5nID0gJ2FjdGlvbic7IC8vIEVuc3VyZSB3ZSBkb24ndCByZXN0b3JlIHRoZSBwZW5kaW5nIHVzZXIgKGRvbSkgc2VsZWN0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBkb2N1bWVudCBhbmQgZG9tIHN0YXRlIGRvIG5vdCBtYXRjaC5cblxuICAgICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBzZWxlY3Rpb25SZWYgPT09IG51bGwgfHwgc2VsZWN0aW9uUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb25SZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uUmVmID09PSBudWxsIHx8IHNlbGVjdGlvblJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uUmVmLnVucmVmKCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uICYmICFFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGVkaXRvcikgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCBlZGl0b3Iuc2VsZWN0aW9uKSkpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBwZXJmb3JtQWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDT01QQVQ6IFRoZSBzZWxlY3Rpb25DaGFuZ2UgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGFjdGlvbiBpcyBwZXJmb3JtZWQsXG4gICAgLy8gc28gd2UgaGF2ZSB0byBtYW51YWxseSBzY2hlZHVsZSBpdCB0byBlbnN1cmUgd2UgZG9uJ3QgJ3Rocm93IGF3YXknIHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aGlsZSByZW5kZXJpbmcgaWYgd2UgaGF2ZSBwZW5kaW5nIGNoYW5nZXMuXG5cblxuICAgIGlmIChzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgIHZhciB1c2VyTWFya3MgPSBFRElUT1JfVE9fVVNFUl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcblxuICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVDb21wb3NpdGlvbkVuZCA9IF9ldmVudCA9PiB7XG4gICAgaWYgKGNvbXBvc2l0aW9uRW5kVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpO1xuICAgIH1cblxuICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgZmx1c2goKTtcbiAgICB9LCBSRVNPTFZFX0RFTEFZKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25TdGFydCA9IF9ldmVudCA9PiB7XG4gICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIHRydWUpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uRW5kVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpO1xuICAgICAgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5ID0gZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCkge1xuICAgIHZhciBmb3JjZUhpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwbGFjZWhvbGRlckVsZW1lbnQgPSBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdEaWZmcygpIHx8IGZvcmNlSGlkZSkge1xuICAgICAgcGxhY2Vob2xkZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGxhY2Vob2xkZXJFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdkaXNwbGF5Jyk7XG4gIH07XG5cbiAgdmFyIHN0b3JlRGlmZiA9IChwYXRoLCBkaWZmKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTM7XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTMgIT09IHZvaWQgMCA/IF9FRElUT1JfVE9fUEVORElOR19ESTMgOiBbXTtcbiAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZWRpdG9yLCBwZW5kaW5nRGlmZnMpO1xuICAgIHZhciB0YXJnZXQgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgICB2YXIgaWR4ID0gcGVuZGluZ0RpZmZzLmZpbmRJbmRleChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0LnRleHQsIGRpZmYpO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBwZW5kaW5nRGlmZnMucHVzaCh7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIGlkOiBpZENvdW50ZXIrK1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0LnRleHQsIHBlbmRpbmdEaWZmc1tpZHhdLmRpZmYsIGRpZmYpO1xuXG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIHBlbmRpbmdEaWZmcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlbmRpbmdEaWZmc1tpZHhdID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgcGVuZGluZ0RpZmZzW2lkeF0pLCB7fSwge1xuICAgICAgZGlmZjogbWVyZ2VkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHNjaGVkdWxlQWN0aW9uID0gZnVuY3Rpb24gc2NoZWR1bGVBY3Rpb24ocnVuKSB7XG4gICAgdmFyIHtcbiAgICAgIGF0XG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaCgpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJ1blxuICAgIH0pOyAvLyBDT01QQVQ6IFdoZW4gZGVsZXRpbmcgYmVmb3JlIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IGNocm9tZSBvbmx5IGZpcmVzIGEgYmVmb3JlaW5wdXQsXG4gICAgLy8gKG5vIGlucHV0KSBhbmQgZG9lc24ndCBwZXJmb3JtIGFueSBkb20gbXV0YXRpb25zLiBXaXRob3V0IGEgZmx1c2ggdGltZW91dCB3ZSB3b3VsZCBuZXZlciBmbHVzaFxuICAgIC8vIGluIHRoaXMgY2FzZSBhbmQgdGh1cyBuZXZlciBhY3R1YWxseSBwZXJmb3JtIHRoZSBhY3Rpb24uXG5cbiAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlRE9NQmVmb3JlSW5wdXQgPSBldmVudCA9PiB7XG4gICAgdmFyIF90YXJnZXRSYW5nZTI7XG5cbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGlucHV0VHlwZTogdHlwZVxuICAgIH0gPSBldmVudDtcbiAgICB2YXIgdGFyZ2V0UmFuZ2UgPSBudWxsO1xuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyIHx8IGV2ZW50LmRhdGEgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGluc2VydFBvc2l0aW9uSGludCAhPT0gZmFsc2UgJiYgdHlwZSAhPT0gJ2luc2VydFRleHQnICYmIHR5cGUgIT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgW25hdGl2ZVRhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuXG4gICAgaWYgKG5hdGl2ZVRhcmdldFJhbmdlKSB7XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIG5hdGl2ZVRhcmdldFJhbmdlLCB7XG4gICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIENPTVBBVDogU2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLCBzbyB3ZVxuICAgIC8vIGhhdmUgdG8gbWFudWFsbHkgZ2V0IHRoZSBzZWxlY3Rpb24gaGVyZSB0byBlbnN1cmUgaXQncyB1cC10by1kYXRlLlxuXG5cbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghdGFyZ2V0UmFuZ2UgJiYgZG9tU2VsZWN0aW9uKSB7XG4gICAgICBuYXRpdmVUYXJnZXRSYW5nZSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHRhcmdldFJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0YXJnZXRSYW5nZSA9IChfdGFyZ2V0UmFuZ2UyID0gdGFyZ2V0UmFuZ2UpICE9PSBudWxsICYmIF90YXJnZXRSYW5nZTIgIT09IHZvaWQgMCA/IF90YXJnZXRSYW5nZTIgOiBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgaWYgKCF0YXJnZXRSYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQnkgZGVmYXVsdCwgdGhlIGlucHV0IG1hbmFnZXIgdHJpZXMgdG8gc3RvcmUgdGV4dCBkaWZmcyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIGRlZmVyIGZsdXNoaW5nIHRoZW0gYXQgYSBsYXRlciBwb2ludCBpbiB0aW1lLiBXZSBkb24ndCB3YW50IHRvIGZsdXNoXG4gICAgLy8gZm9yIGV2ZXJ5IGlucHV0IGV2ZW50IGFzIHRoaXMgY2FuIGJlIGV4cGVuc2l2ZS4gSG93ZXZlciwgdGhlcmUgYXJlIHNvbWVcbiAgICAvLyBzY2VuYXJpb3Mgd2hlcmUgd2UgY2Fubm90IHNhZmVseSBzdG9yZSB0aGUgdGV4dCBkaWZmIGFuZCBtdXN0IGluc3RlYWRcbiAgICAvLyBzY2hlZHVsZSBhbiBhY3Rpb24gdG8gbGV0IFNsYXRlIG5vcm1hbGl6ZSB0aGUgZWRpdG9yIHN0YXRlLlxuXG5cbiAgICB2YXIgY2FuU3RvcmVEaWZmID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgdmFyIFtfc3RhcnQsIF9lbmRdID0gUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpO1xuXG4gICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIF9zdGFydC5wYXRoKTtcblxuICAgICAgICBpZiAoX2xlYWYudGV4dC5sZW5ndGggPT09IF9zdGFydC5vZmZzZXQgJiYgX2VuZC5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IEVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IF9zdGFydC5wYXRoLFxuICAgICAgICAgICAgbWF0Y2g6IFRleHQkMS5pc1RleHRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChuZXh0ICYmIFBhdGguZXF1YWxzKG5leHRbMV0sIF9lbmQucGF0aCkpIHtcbiAgICAgICAgICAgIHRhcmdldFJhbmdlID0ge1xuICAgICAgICAgICAgICBhbmNob3I6IF9lbmQsXG4gICAgICAgICAgICAgIGZvY3VzOiBfZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpO1xuICAgICAgdmFyIFtsZWFmLCBwYXRoXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgc3RhcnQucGF0aCk7XG4gICAgICB2YXIgZGlmZiA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIHN0YXJ0OiBzdGFydC5vZmZzZXQsXG4gICAgICAgIGVuZDogZW5kLm9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciByZWxldmFudFBlbmRpbmdEaWZmcyA9IHBlbmRpbmdEaWZmcyA9PT0gbnVsbCB8fCBwZW5kaW5nRGlmZnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdEaWZmcy5maW5kKGNoYW5nZSA9PiBQYXRoLmVxdWFscyhjaGFuZ2UucGF0aCwgcGF0aCkpO1xuICAgICAgdmFyIGRpZmZzID0gcmVsZXZhbnRQZW5kaW5nRGlmZnMgPyBbcmVsZXZhbnRQZW5kaW5nRGlmZnMuZGlmZiwgZGlmZl0gOiBbZGlmZl07XG4gICAgICB2YXIgdGV4dCA9IGFwcGx5U3RyaW5nRGlmZihsZWFmLnRleHQsIC4uLmRpZmZzKTtcblxuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRleHQgbGVhZiB3aWxsIGJlIHJlbW92ZWQsIHNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW5cbiAgICAgICAgLy8gYWN0aW9uIHRvIHJlbW92ZSBpdCBzbyB0aGF0IFNsYXRlIGNhbiBub3JtYWxpemUgaW5zdGVhZFxuICAgICAgICAvLyBvZiBzdG9yaW5nIGFzIGEgZGlmZlxuICAgICAgICBjYW5TdG9yZURpZmYgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogdGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0Lm9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQsIHBvaW50KTtcbiAgICAgICAgICBoYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIGVuZDogZW5kLm9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBhbmNob3JcbiAgICAgICAgICB9ID0gdGFyZ2V0UmFuZ2U7XG5cbiAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3Iub2Zmc2V0IDwgdGFyZ2V0Tm9kZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKGFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuY2hvci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBhbmNob3Iub2Zmc2V0ICsgMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbmF0aXZlVGFyZ2V0UmFuZ2U7XG5cbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlOyAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgbmF0aXZlIGFuZCBzbGF0ZSBzZWxlY3Rpb24gYmVpbmcgY29sbGFwc2VkXG4gICAgICAgICAgLy8gd2UgYXJlIG1vc3QgbGlrZWx5IGRlbGV0aW5nIGEgemVyby13aWR0aCBwbGFjZWhvbGRlciBhbmQgdGh1cyBzaG91bGQgcGVyZm9ybSBpdFxuICAgICAgICAgIC8vIGFzIGFuIGFjdGlvbiB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvciAobW9zdGx5IGhhcHBlbnMgd2l0aCBtYXJrIHBsYWNlaG9sZGVycylcblxuICAgICAgICAgIHZhciBuYXRpdmVDb2xsYXBzZWQgPSBpc0RPTVNlbGVjdGlvbihuYXRpdmVUYXJnZXRSYW5nZSkgPyBuYXRpdmVUYXJnZXRSYW5nZS5pc0NvbGxhcHNlZCA6ICEhKChfbmF0aXZlVGFyZ2V0UmFuZ2UgPSBuYXRpdmVUYXJnZXRSYW5nZSkgIT09IG51bGwgJiYgX25hdGl2ZVRhcmdldFJhbmdlICE9PSB2b2lkIDAgJiYgX25hdGl2ZVRhcmdldFJhbmdlLmNvbGxhcHNlZCk7XG5cbiAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIG5hdGl2ZUNvbGxhcHNlZCAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkgJiYgX2FuY2hvci5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKF9hbmNob3IucGF0aCwge1xuICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgc3RhcnQ6IF9hbmNob3Iub2Zmc2V0IC0gMSxcbiAgICAgICAgICAgICAgZW5kOiBfYW5jaG9yLm9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVFbnRpcmVTb2Z0TGluZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVXb3JkRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydENvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdkZWxldGVDb21wb3NpdGlvblRleHQnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNEYXRhVHJhbnNmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSksIHtcbiAgICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RleHQgPSBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiAnJzsgLy8gQ09NUEFUOiBJZiB3ZSBhcmUgd3JpdGluZyBpbnNpZGUgYSBwbGFjZWhvbGRlciwgdGhlIGltZSBpbnNlcnRzIHRoZSB0ZXh0IGluc2lkZVxuICAgICAgICAgIC8vIHRoZSBwbGFjZWhvbGRlciBpdHNlbGYgYW5kIHRodXMgaW5jbHVkZXMgdGhlIHplcm8td2lkdGggc3BhY2UgaW5zaWRlIGVkaXQgZXZlbnRzLlxuXG5cbiAgICAgICAgICBpZiAoRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnJlcGxhY2UoJ1xcdUZFRkYnLCAnJyk7XG4gICAgICAgICAgfSAvLyBQYXN0ZXMgZnJvbSB0aGUgQW5kcm9pZCBjbGlwYm9hcmQgd2lsbCBnZW5lcmF0ZSBgaW5zZXJ0VGV4dGAgZXZlbnRzLlxuICAgICAgICAgIC8vIElmIHRoZSBjb3BpZWQgdGV4dCBjb250YWlucyBhbnkgbmV3bGluZXMsIEFuZHJvaWQgd2lsbCBhcHBlbmQgYW5cbiAgICAgICAgICAvLyBleHRyYSBuZXdsaW5lIHRvIHRoZSBlbmQgb2YgdGhlIGNvcGllZCB0ZXh0LlxuXG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnICYmIC8uKlxcbi4qXFxuJC8udGVzdChfdGV4dCkpIHtcbiAgICAgICAgICAgIF90ZXh0ID0gX3RleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHRleHQgaW5jbHVkZXMgYSBuZXdsaW5lLCBzcGxpdCBpdCBhdCBuZXdsaW5lcyBhbmQgcGFzdGUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAvLyBzdHJpbmcsIHdpdGggc29mdCBicmVha3MgaW4gYmV0d2VlbiBlYWNoLlxuXG5cbiAgICAgICAgICBpZiAoX3RleHQuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBfdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgcGFydHMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgW19zdGFydDIsIF9lbmQyXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgICAgICAgIHZhciBfZGlmZiA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IF9zdGFydDIub2Zmc2V0LFxuICAgICAgICAgICAgICBlbmQ6IF9lbmQyLm9mZnNldCxcbiAgICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICAgIH07IC8vIENPTVBBVDogU3dpZnRrZXkgaGFzIGEgd2VpcmQgYnVnIHdoZXJlIHRoZSB0YXJnZXQgcmFuZ2Ugb2YgdGhlIDJuZCB3b3JkXG4gICAgICAgICAgICAvLyBpbnNlcnRlZCBhZnRlciBhIG1hcmsgcGxhY2Vob2xkZXIgaXMgaW5zZXJ0ZWQgd2l0aCBhbiBhbmNob3Igb2Zmc2V0IG9mZiBieSAxLlxuICAgICAgICAgICAgLy8gU28gd3JpdGluZyAnc29tZSB0ZXh0JyB3aWxsIHJlc3VsdCBpbiAnc29tZSB0dGV4dCcuIEx1Y2tpbHkgYWxsICdub3JtYWwnIGluc2VydFxuICAgICAgICAgICAgLy8gdGV4dCBldmVudHMgYXJlIGZpcmVkIHdpdGggdGhlIGNvcnJlY3QgdGFyZ2V0IHJhbmdlcywgb25seSB0aGUgZmluYWwgJ2luc2VydENvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgLy8gaXNuJ3QsIHNvIHdlIGNhbiBhZGp1c3QgdGhlIHRhcmdldCByYW5nZSBzdGFydCBvZmZzZXQgaWYgd2UgYXJlIGNvbmZpZGVudCB0aGlzIGlzIHRoZVxuICAgICAgICAgICAgLy8gc3dpZnRrZXkgaW5zZXJ0IGNhdXNpbmcgdGhlIGlzc3VlLlxuXG4gICAgICAgICAgICBpZiAoX3RleHQgJiYgaW5zZXJ0UG9zaXRpb25IaW50ICYmIHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICAgICAgICAgIHZhciBoaW50UG9zaXRpb24gPSBpbnNlcnRQb3NpdGlvbkhpbnQuc3RhcnQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5zZWFyY2goL1xcU3wkLyk7XG5cbiAgICAgICAgICAgICAgdmFyIGRpZmZQb3NpdGlvbiA9IF9kaWZmLnN0YXJ0ICsgX2RpZmYudGV4dC5zZWFyY2goL1xcU3wkLyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZQb3NpdGlvbiA9PT0gaGludFBvc2l0aW9uICsgMSAmJiBfZGlmZi5lbmQgPT09IGluc2VydFBvc2l0aW9uSGludC5zdGFydCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9kaWZmLnN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnKSB7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfZGlmZjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIGluc2VydFBvc2l0aW9uSGludC5lbmQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGggPT09IF9zdGFydDIub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgaW5zZXJ0UG9zaXRpb25IaW50KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGluc2VydFBvc2l0aW9uSGludC50ZXh0ICsgX3RleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYpIHtcbiAgICAgICAgICAgICAgc3RvcmVEaWZmKF9zdGFydDIucGF0aCwgX2RpZmYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgX3RleHQpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0FjdGlvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gISFFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gIH07XG5cbiAgdmFyIGhhc1BlbmRpbmdEaWZmcyA9ICgpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJNDtcblxuICAgIHJldHVybiAhISgoX0VESVRPUl9UT19QRU5ESU5HX0RJNCA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk0ICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJNC5sZW5ndGgpO1xuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nQ2hhbmdlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gaGFzUGVuZGluZ0FjdGlvbigpIHx8IGhhc1BlbmRpbmdEaWZmcygpO1xuICB9O1xuXG4gIHZhciBpc0ZsdXNoaW5nID0gKCkgPT4ge1xuICAgIHJldHVybiBmbHVzaGluZztcbiAgfTtcblxuICB2YXIgaGFuZGxlVXNlclNlbGVjdCA9IHJhbmdlID0+IHtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uc2V0KGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuXG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aCwgcmFuZ2UuYW5jaG9yLnBhdGgpO1xuICAgIHZhciBwYXJlbnRQYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAtMSksIHJhbmdlLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSk7XG5cbiAgICBpZiAocGF0aENoYW5nZWQgJiYgaW5zZXJ0UG9zaXRpb25IaW50IHx8IHBhcmVudFBhdGhDaGFuZ2VkKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocGF0aENoYW5nZWQgfHwgaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCwgRkxVU0hfREVMQVkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSW5wdXQgPSAoKSA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gXyA9PiB7XG4gICAgLy8gQ09NUEFUOiBTd2lmdGtleSBjbG9zZXMgdGhlIGtleWJvYXJkIHdoZW4gdHlwaW5nIGluc2lkZSBhIGVtcHR5IG5vZGVcbiAgICAvLyBkaXJlY3RseSBuZXh0IHRvIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50ICg9IHRoZSBwbGFjZWhvbGRlcikuXG4gICAgLy8gVGhlIG9ubHkgZXZlbnQgZmlyZWQgc29vbiBlbm91Z2ggZm9yIHVzIHRvIGFsbG93IGhpZGluZyB0aGUgcGxhY2Vob2xkZXJcbiAgICAvLyB3aXRob3V0IHN3aWZ0a2V5IHBpY2tpbmcgaXQgdXAgaXMgdGhlIGtleWRvd24gZXZlbnQsIHNvIHdlIGhhdmUgdG8gaGlkZSBpdFxuICAgIC8vIGhlcmUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC80OTg4I2lzc3VlY29tbWVudC0xMjAxMDUwNTM1XG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgc2V0VGltZW91dCh1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2NoZWR1bGVGbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoIWhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVEb21NdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobXV0YXRpb25zLnNvbWUobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX0ZPUkNFX1JFTkQ7XG5cbiAgICAgIC8vIENhdXNlIGEgcmUtcmVuZGVyIHRvIHJlc3RvcmUgdGhlIGRvbSBzdGF0ZSBpZiB3ZSBlbmNvdW50ZXIgdHJhY2tlZCBtdXRhdGlvbnMgd2l0aG91dFxuICAgICAgLy8gYSBjb3JyZXNwb25kaW5nIHBlbmRpbmcgYWN0aW9uLlxuICAgICAgKF9FRElUT1JfVE9fRk9SQ0VfUkVORCA9IEVESVRPUl9UT19GT1JDRV9SRU5ERVIuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fRk9SQ0VfUkVORCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19GT1JDRV9SRU5EKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZmx1c2gsXG4gICAgc2NoZWR1bGVGbHVzaCxcbiAgICBoYXNQZW5kaW5nRGlmZnMsXG4gICAgaGFzUGVuZGluZ0FjdGlvbixcbiAgICBoYXNQZW5kaW5nQ2hhbmdlcyxcbiAgICBpc0ZsdXNoaW5nLFxuICAgIGhhbmRsZVVzZXJTZWxlY3QsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25FbmQsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25TdGFydCxcbiAgICBoYW5kbGVET01CZWZvcmVJbnB1dCxcbiAgICBoYW5kbGVLZXlEb3duLFxuICAgIGhhbmRsZURvbU11dGF0aW9ucyxcbiAgICBoYW5kbGVJbnB1dFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gIHZhciBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBpc01vdW50ZWRSZWYuY3VycmVudDtcbn1cblxuLyoqXHJcbiAqIFByZXZlbnQgd2FybmluZyBvbiBTU1IgYnkgZmFsbGluZyBiYWNrIHRvIHVzZUVmZmVjdCB3aGVuIERPTSBpc24ndCBhdmFpbGFibGVcclxuICovXG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIobm9kZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIFttdXRhdGlvbk9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERpc2NhcmQgbXV0YXRpb25zIGNhdXNlZCBkdXJpbmcgcmVuZGVyIHBoYXNlLiBUaGlzIHdvcmtzIGR1ZSB0byByZWFjdCBjYWxsaW5nXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHJlbmRlciBwaGFzZSBiZWZvcmUgdGhlIG5leHQgdGljay5cbiAgICBtdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbm9kZS5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdHRhY2ggTXV0YXRpb25PYnNlcnZlciwgYG5vZGVgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShub2RlLmN1cnJlbnQsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW211dGF0aW9uT2JzZXJ2ZXIsIG5vZGUsIG9wdGlvbnNdKTtcbn1cblxudmFyIF9leGNsdWRlZCQzID0gW1wibm9kZVwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxufTtcbnZhciB1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyID0gIUlTX0FORFJPSUQgPyAoKSA9PiBudWxsIDogX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgbm9kZVxuICB9ID0gX3JlZixcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDMpO1xuXG4gIGlmICghSVNfQU5EUk9JRCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdmFyIFtpbnB1dE1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfb2JqZWN0U3ByZWFkJDIoe1xuICAgIGVkaXRvclxuICB9LCBvcHRpb25zKSkpO1xuICB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGlucHV0TWFuYWdlci5oYW5kbGVEb21NdXRhdGlvbnMsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxKTtcbiAgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILnNldChlZGl0b3IsIGlucHV0TWFuYWdlci5zY2hlZHVsZUZsdXNoKTtcblxuICBpZiAoaXNNb3VudGVkKSB7XG4gICAgaW5wdXRNYW5hZ2VyLmZsdXNoKCk7XG4gIH1cblxuICByZXR1cm4gaW5wdXRNYW5hZ2VyO1xufTtcblxudmFyIF9leGNsdWRlZCQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0sXG4gICAgX2V4Y2x1ZGVkMiQxID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG52YXIgc2hhbGxvd0NvbXBhcmUgPSAob2JqMSwgb2JqMikgPT4gT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGggJiYgT2JqZWN0LmtleXMob2JqMSkuZXZlcnkoa2V5ID0+IG9iajIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmoxW2tleV0gPT09IG9iajJba2V5XSk7XG5cbnZhciBpc0RlY29yYXRpb25GbGFnc0VxdWFsID0gKHJhbmdlLCBvdGhlcikgPT4ge1xuICB2YXIgcmFuZ2VPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkJDIpO1xuXG4gIHZhciBvdGhlck93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG90aGVyLCBfZXhjbHVkZWQyJDEpO1xuXG4gIHJldHVybiByYW5nZVtQTEFDRUhPTERFUl9TWU1CT0xdID09PSBvdGhlcltQTEFDRUhPTERFUl9TWU1CT0xdICYmIHNoYWxsb3dDb21wYXJlKHJhbmdlT3duUHJvcHMsIG90aGVyT3duUHJvcHMpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cblxudmFyIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldO1xuXG4gICAgaWYgKCFSYW5nZS5lcXVhbHMocmFuZ2UsIG90aGVyKSB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxyXG4gKlxyXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXHJcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXHJcbiAqIGtlcHQgaW4gb3JkZXIsIGFuZCB0aGUgb2RkIGNhc2Ugd2hlcmUgdGhleSBhcmVuJ3QgaXMgb2theSB0byByZS1yZW5kZXIgZm9yLlxyXG4gKi9cblxudmFyIGlzVGV4dERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldOyAvLyBjb21wYXJlIG9ubHkgb2Zmc2V0cyBiZWNhdXNlIHBhdGhzIGRvZXNuJ3QgbWF0dGVyIGZvciB0ZXh0XG5cbiAgICBpZiAocmFuZ2UuYW5jaG9yLm9mZnNldCAhPT0gb3RoZXIuYW5jaG9yLm9mZnNldCB8fCByYW5nZS5mb2N1cy5vZmZzZXQgIT09IG90aGVyLmZvY3VzLm9mZnNldCB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcclxuICogTGVhZiBjb250ZW50IHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgU3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGlzTGFzdCxcbiAgICBsZWFmLFxuICAgIHBhcmVudCxcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGlzTWFya1BsYWNlaG9sZGVyID0gbGVhZltNQVJLX1BMQUNFSE9MREVSX1NZTUJPTF0gPT09IHRydWU7IC8vIENPTVBBVDogUmVuZGVyIHRleHQgaW5zaWRlIHZvaWQgbm9kZXMgd2l0aCBhIHplcm8td2lkdGggc3BhY2UuXG4gIC8vIFNvIHRoZSBub2RlIGNhbiBjb250YWluIHNlbGVjdGlvbiBidXQgdGhlIHRleHQgaXMgbm90IHZpc2libGUuXG5cbiAgaWYgKGVkaXRvci5pc1ZvaWQocGFyZW50KSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGxlbmd0aDogTm9kZS5zdHJpbmcocGFyZW50KS5sZW5ndGhcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IElmIHRoaXMgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGluIGFuIGVtcHR5IGJsb2NrLCByZW5kZXIgYSB6ZXJvLVxuICAvLyB3aWR0aCBzcGFjZSB0aGF0IHdpbGwgY29udmVydCBpbnRvIGEgbGluZSBicmVhayB3aGVuIGNvcHlpbmcgYW5kIHBhc3RpbmdcbiAgLy8gdG8gc3VwcG9ydCBleHBlY3RlZCBwbGFpbiB0ZXh0LlxuXG5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycgJiYgcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gdGV4dCAmJiAhZWRpdG9yLmlzSW5saW5lKHBhcmVudCkgJiYgRWRpdG9yLnN0cmluZyhlZGl0b3IsIHBhcmVudFBhdGgpID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTGluZUJyZWFrOiB0cnVlLFxuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgaXQncyBiZWNhdXNlIGl0J3Mgb24gdGhlIGVkZ2Ugb2YgYW4gaW5saW5lXG4gIC8vIG5vZGUsIHNvIHdlIHJlbmRlciBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB0aGUgc2VsZWN0aW9uIGNhbiBiZVxuICAvLyBpbnNlcnRlZCBuZXh0IHRvIGl0IHN0aWxsLlxuXG5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBpc01hcmtQbGFjZWhvbGRlcjogaXNNYXJrUGxhY2Vob2xkZXJcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IEJyb3dzZXJzIHdpbGwgY29sbGFwc2UgdHJhaWxpbmcgbmV3IGxpbmVzIGF0IHRoZSBlbmQgb2YgYmxvY2tzLFxuICAvLyBzbyB3ZSBuZWVkIHRvIGFkZCBhbiBleHRyYSB0cmFpbGluZyBuZXcgbGluZXMgdG8gcHJldmVudCB0aGF0LlxuXG5cbiAgaWYgKGlzTGFzdCAmJiBsZWFmLnRleHQuc2xpY2UoLTEpID09PSAnXFxuJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgICBpc1RyYWlsaW5nOiB0cnVlLFxuICAgICAgdGV4dDogbGVhZi50ZXh0XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgIHRleHQ6IGxlYWYudGV4dFxuICB9KTtcbn07XG4vKipcclxuICogTGVhZiBzdHJpbmdzIHdpdGggdGV4dCBpbiB0aGVtLlxyXG4gKi9cblxuXG52YXIgVGV4dFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICB0ZXh0LFxuICAgIGlzVHJhaWxpbmcgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdmFyIGdldFRleHRDb250ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiAnJykuY29uY2F0KGlzVHJhaWxpbmcgPyAnXFxuJyA6ICcnKTtcbiAgfTtcblxuICB2YXIgW2luaXRpYWxUZXh0XSA9IHVzZVN0YXRlKGdldFRleHRDb250ZW50KTsgLy8gVGhpcyBpcyB0aGUgYWN0dWFsIHRleHQgcmVuZGVyaW5nIGJvdW5kYXJ5IHdoZXJlIHdlIGludGVyZmFjZSB3aXRoIHRoZSBET01cbiAgLy8gVGhlIHRleHQgaXMgbm90IHJlbmRlcmVkIGFzIHBhcnQgb2YgdGhlIHZpcnR1YWwgRE9NLCBhcyBzaW5jZSB3ZSBoYW5kbGUgYmFzaWMgY2hhcmFjdGVyIGluc2VydGlvbnMgbmF0aXZlbHksXG4gIC8vIHVwZGF0aW5nIHRoZSBET00gaXMgbm90IGEgb25lIHdheSBkYXRhZmxvdyBhbnltb3JlLiBXaGF0IHdlIG5lZWQgaGVyZSBpcyBub3QgcmVjb25jaWxpYXRpb24gYW5kIGRpZmZpbmdcbiAgLy8gd2l0aCBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSB2aXJ0dWFsIERPTSwgYnV0IHJhdGhlciBkaWZmaW5nIHdpdGggdGhlIGFjdHVhbCBET00gZWxlbWVudCwgYW5kIHJlcGxhY2UgdGhlIERPTSA8c3Bhbj4gY29udGVudFxuICAvLyBleGFjdGx5IGlmIGFuZCBvbmx5IGlmIGl0cyBjdXJyZW50IGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggb3VyIGN1cnJlbnQgdmlydHVhbCBET00uXG4gIC8vIE90aGVyd2lzZSB0aGUgRE9NIFRleHROb2RlIHdvdWxkIGFsd2F5cyBiZSByZXBsYWNlZCBieSBSZWFjdCBhcyB0aGUgdXNlciB0eXBlcywgd2hpY2ggaW50ZXJmZXJlcyB3aXRoIG5hdGl2ZSB0ZXh0IGZlYXR1cmVzLFxuICAvLyBlZyBtYWtlcyBuYXRpdmUgc3BlbGxjaGVjayBvcHQgb3V0IGZyb20gY2hlY2tpbmcgdGhlIHRleHQgbm9kZS5cbiAgLy8gdXNlTGF5b3V0RWZmZWN0OiB1cGRhdGluZyBvdXIgc3BhbiBiZWZvcmUgYnJvd3NlciBwYWludFxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIG51bGwgY29hbGVzY2luZyB0ZXh0IHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3Qgb3V0cHV0aW5nIFwibnVsbFwiIGFzIGEgc3RyaW5nIGluIHRoZSBleHRyZW1lIGNhc2UgaXQgaXMgbnVsbGlzaCBhdCBydW50aW1lXG4gICAgdmFyIHRleHRXaXRoVHJhaWxpbmcgPSBnZXRUZXh0Q29udGVudCgpO1xuXG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnRleHRDb250ZW50ICE9PSB0ZXh0V2l0aFRyYWlsaW5nKSB7XG4gICAgICByZWYuY3VycmVudC50ZXh0Q29udGVudCA9IHRleHRXaXRoVHJhaWxpbmc7XG4gICAgfSAvLyBpbnRlbnRpb25hbGx5IG5vdCBzcGVjaWZ5aW5nIGRlcGVuZGVuY2llcywgc28gdGhhdCB0aGlzIGVmZmVjdCBydW5zIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGFzIHRoaXMgZWZmZWN0aXZlbHkgcmVwbGFjZXMgXCJzcGVjaWZ5aW5nIHRoZSB0ZXh0IGluIHRoZSB2aXJ0dWFsIERPTSB1bmRlciB0aGUgPHNwYW4+IGJlbG93XCIgb24gZWFjaCByZW5kZXJcblxuICB9KTsgLy8gV2UgaW50ZW50aW9uYWxseSByZW5kZXIgYSBtZW1vaXplZCA8c3Bhbj4gdGhhdCBvbmx5IHJlY2VpdmVzIHRoZSBpbml0aWFsIHRleHQgY29udGVudCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgLy8gV2UgZGVmZXIgdG8gdGhlIGxheW91dCBlZmZlY3QgYWJvdmUgdG8gdXBkYXRlIHRoZSBgdGV4dENvbnRlbnRgIG9mIHRoZSBzcGFuIGVsZW1lbnQgd2hlbiBuZWVkZWQuXG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCQxLCB7XG4gICAgcmVmOiByZWZcbiAgfSwgaW5pdGlhbFRleHQpO1xufTtcblxudmFyIE1lbW9pemVkVGV4dCQxID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1zdHJpbmdcIjogdHJ1ZSxcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcy5jaGlsZHJlbik7XG59KSk7XG4vKipcclxuICogTGVhZiBzdHJpbmdzIHdpdGhvdXQgdGV4dCwgcmVuZGVyIGFzIHplcm8td2lkdGggc3RyaW5ncy5cclxuICovXG5cbnZhciBaZXJvV2lkdGhTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVuZ3RoID0gMCxcbiAgICBpc0xpbmVCcmVhayA9IGZhbHNlLFxuICAgIGlzTWFya1BsYWNlaG9sZGVyID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJzogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgJ2RhdGEtc2xhdGUtbGVuZ3RoJzogbGVuZ3RoXG4gIH07XG5cbiAgaWYgKGlzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJ10gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgIUlTX0FORFJPSUQgfHwgIWlzTGluZUJyZWFrID8gJ1xcdUZFRkYnIDogbnVsbCwgaXNMaW5lQnJlYWsgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpIDogbnVsbCk7XG59O1xuXG5mdW5jdGlvbiBkaXNjb25uZWN0UGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlcihwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLCByZWxlYXNlT2JzZXJ2ZXIpIHtcbiAgaWYgKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAocmVsZWFzZU9ic2VydmVyKSB7XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhclRpbWVvdXRSZWYodGltZW91dFJlZikge1xuICBpZiAodGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfVxufVxuLyoqXHJcbiAqIEluZGl2aWR1YWwgbGVhdmVzIGluIGEgdGV4dCBub2RlIHdpdGggdW5pcXVlIGZvcm1hdHRpbmcuXHJcbiAqL1xuXG5cbnZhciBMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlYWYsXG4gICAgaXNMYXN0LFxuICAgIHRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0TGVhZiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgW3Nob3dQbGFjZWhvbGRlciwgc2V0U2hvd1BsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBjYWxsYmFja1BsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2socGxhY2Vob2xkZXJFbCA9PiB7XG4gICAgZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciwgcGxhY2Vob2xkZXJFbCA9PSBudWxsKTtcblxuICAgIGlmIChwbGFjZWhvbGRlckVsID09IG51bGwpIHtcbiAgICAgIHZhciBfbGVhZiRvblBsYWNlaG9sZGVyUmU7XG5cbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgKF9sZWFmJG9uUGxhY2Vob2xkZXJSZSA9IGxlYWYub25QbGFjZWhvbGRlclJlc2l6ZSkgPT09IG51bGwgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGVhZiRvblBsYWNlaG9sZGVyUmUuY2FsbChsZWFmLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuc2V0KGVkaXRvciwgcGxhY2Vob2xkZXJFbCk7XG5cbiAgICAgIGlmICghcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50KSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYnNlcnZlciBhbmQgb2JzZXJ2ZSB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudC5cbiAgICAgICAgdmFyIFJlc2l6ZU9ic2VydmVyJDEgPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgUmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlciQxKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2xlYWYkb25QbGFjZWhvbGRlclJlMjtcblxuICAgICAgICAgIChfbGVhZiRvblBsYWNlaG9sZGVyUmUyID0gbGVhZi5vblBsYWNlaG9sZGVyUmVzaXplKSA9PT0gbnVsbCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGVhZiRvblBsYWNlaG9sZGVyUmUyLmNhbGwobGVhZiwgcGxhY2Vob2xkZXJFbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQub2JzZXJ2ZShwbGFjZWhvbGRlckVsKTtcbiAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSBwbGFjZWhvbGRlckVsO1xuICAgIH1cbiAgfSwgW3BsYWNlaG9sZGVyUmVmLCBsZWFmLCBlZGl0b3JdKTtcbiAgdmFyIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3RyaW5nLCB7XG4gICAgaXNMYXN0OiBpc0xhc3QsXG4gICAgbGVhZjogbGVhZixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB0ZXh0OiB0ZXh0XG4gIH0pO1xuICB2YXIgbGVhZklzUGxhY2Vob2xkZXIgPSBsZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAoIXNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgcGxhY2Vob2xkZXIgc28gaXQgd2lsbCBub3QgcmVuZGVyIGluIGEgc2VsZWN0aW9uXG4gICAgICAgIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgICBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXRSZWYoc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZik7XG4gICAgICBzZXRTaG93UGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXRSZWYoc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZik7XG4gIH0sIFtsZWFmSXNQbGFjZWhvbGRlciwgc2V0U2hvd1BsYWNlaG9sZGVyXSk7XG5cbiAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyICYmIHNob3dQbGFjZWhvbGRlcikge1xuICAgIHZhciBwbGFjZWhvbGRlclByb3BzID0ge1xuICAgICAgY2hpbGRyZW46IGxlYWYucGxhY2Vob2xkZXIsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdkYXRhLXNsYXRlLXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgIG9wYWNpdHk6ICcwLjMzMycsXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3VkZWNvZGUvcGxhdGUvaXNzdWVzLzIzMTVcbiAgICAgICAgICBXZWJraXRVc2VyTW9kaWZ5OiBJU19XRUJLSVQgPyAnaW5oZXJpdCcgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudEVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgcmVmOiBjYWxsYmFja1BsYWNlaG9sZGVyUmVmXG4gICAgICB9XG4gICAgfTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXJQbGFjZWhvbGRlcihwbGFjZWhvbGRlclByb3BzKSwgY2hpbGRyZW4pO1xuICB9IC8vIENPTVBBVDogSGF2aW5nIHRoZSBgZGF0YS1gIGF0dHJpYnV0ZXMgb24gdGhlc2UgbGVhZiBlbGVtZW50cyBlbnN1cmVzIHRoYXRcbiAgLy8gaW4gY2VydGFpbiBtaXNiZWhhdmluZyBicm93c2VycyB0aGV5IGFyZW4ndCB3ZWlyZGx5IGNsb25lZC9kZXN0cm95ZWQgYnlcbiAgLy8gY29udGVudGVkaXRhYmxlIGJlaGF2aW9ycy4gKDIwMTkvMDUvMDgpXG5cblxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1sZWFmJzogdHJ1ZVxuICB9O1xuICByZXR1cm4gcmVuZGVyTGVhZih7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBsZWFmLFxuICAgIHRleHRcbiAgfSk7XG59O1xuXG52YXIgTWVtb2l6ZWRMZWFmID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oTGVhZiwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBUZXh0JDEuZXF1YWxzKG5leHQubGVhZiwgcHJldi5sZWFmKSAmJiBuZXh0LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gcHJldi5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG59KTtcbnZhciBEZWZhdWx0TGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIFRleHQuXHJcbiAqL1xuXG52YXIgVGV4dCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBpc0xhc3QsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgbGVhdmVzID0gVGV4dCQxLmRlY29yYXRpb25zKHRleHQsIGRlY29yYXRpb25zKTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGVhZiA9IGxlYXZlc1tpXTtcbiAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZExlYWYsIHtcbiAgICAgIGlzTGFzdDogaXNMYXN0ICYmIGkgPT09IGxlYXZlcy5sZW5ndGggLSAxLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXkuaWQsIFwiLVwiKS5jb25jYXQoaSksXG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBsZWFmOiBsZWFmLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZlxuICAgIH0pKTtcbiAgfSAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG5cblxuICB2YXIgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjayhzcGFuID0+IHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoc3Bhbikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHNwYW4pO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldCh0ZXh0LCBzcGFuKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQoc3BhbiwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUodGV4dCk7XG5cbiAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICBFTEVNRU5UX1RPX05PREUuZGVsZXRlKHJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWYuY3VycmVudCA9IHNwYW47XG4gIH0sIFtyZWYsIGVkaXRvciwga2V5LCB0ZXh0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1ub2RlXCI6IFwidGV4dFwiLFxuICAgIHJlZjogY2FsbGJhY2tSZWZcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIE1lbW9pemVkVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbChuZXh0LmRlY29yYXRpb25zLCBwcmV2LmRlY29yYXRpb25zKTtcbn0pO1xuXG4vKipcclxuICogRWxlbWVudC5cclxuICovXG5cbnZhciBFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCA9IHAgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIHApKSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVhZE9ubHkgPSB1c2VSZWFkT25seSgpO1xuICB2YXIgaXNJbmxpbmUgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgZWxlbWVudCk7XG4gIHZhciByZWYgPSB1c2VDYWxsYmFjayhyZWYgPT4ge1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAocmVmKSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgcmVmKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWxlbWVudCwgcmVmKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIGtleSwgZWxlbWVudF0pO1xuICB2YXIgY2hpbGRyZW4gPSB1c2VDaGlsZHJlbih7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0pOyAvLyBBdHRyaWJ1dGVzIHRoYXQgdGhlIGRldmVsb3BlciBtdXN0IG1peCBpbnRvIHRoZSBlbGVtZW50IGluIHRoZWlyXG4gIC8vIGN1c3RvbSBub2RlIHJlbmRlcmVyIGNvbXBvbmVudC5cblxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1ub2RlJzogJ2VsZW1lbnQnLFxuICAgIHJlZlxuICB9O1xuXG4gIGlmIChpc0lubGluZSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtaW5saW5lJ10gPSB0cnVlO1xuICB9IC8vIElmIGl0J3MgYSBibG9jayBub2RlIHdpdGggaW5saW5lIGNoaWxkcmVuLCBhZGQgdGhlIHByb3BlciBgZGlyYCBhdHRyaWJ1dGVcbiAgLy8gZm9yIHRleHQgZGlyZWN0aW9uLlxuXG5cbiAgaWYgKCFpc0lubGluZSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgdmFyIHRleHQgPSBOb2RlLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKHRleHQpO1xuXG4gICAgaWYgKGRpciA9PT0gJ3J0bCcpIHtcbiAgICAgIGF0dHJpYnV0ZXMuZGlyID0gZGlyO1xuICAgIH1cbiAgfSAvLyBJZiBpdCdzIGEgdm9pZCBub2RlLCB3cmFwIHRoZSBjaGlsZHJlbiBpbiBleHRyYSB2b2lkLXNwZWNpZmljIGVsZW1lbnRzLlxuXG5cbiAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtdm9pZCddID0gdHJ1ZTtcblxuICAgIGlmICghcmVhZE9ubHkgJiYgaXNJbmxpbmUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFRhZyA9IGlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgdmFyIFtbX3RleHRdXSA9IE5vZGUudGV4dHMoZWxlbWVudCk7XG4gICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgIFwiZGF0YS1zbGF0ZS1zcGFjZXJcIjogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogJzAnLFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgZGVjb3JhdGlvbnM6IFtdLFxuICAgICAgaXNMYXN0OiBmYWxzZSxcbiAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgIHRleHQ6IF90ZXh0XG4gICAgfSkpO1xuICAgIE5PREVfVE9fSU5ERVguc2V0KF90ZXh0LCAwKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQoX3RleHQsIGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckVsZW1lbnQoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhFbGVtZW50LCAocHJldiwgbmV4dCkgPT4ge1xuICByZXR1cm4gcHJldi5lbGVtZW50ID09PSBuZXh0LmVsZW1lbnQgJiYgcHJldi5yZW5kZXJFbGVtZW50ID09PSBuZXh0LnJlbmRlckVsZW1lbnQgJiYgcHJldi5yZW5kZXJMZWFmID09PSBuZXh0LnJlbmRlckxlYWYgJiYgcHJldi5yZW5kZXJQbGFjZWhvbGRlciA9PT0gbmV4dC5yZW5kZXJQbGFjZWhvbGRlciAmJiBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsKHByZXYuZGVjb3JhdGlvbnMsIG5leHQuZGVjb3JhdGlvbnMpICYmIChwcmV2LnNlbGVjdGlvbiA9PT0gbmV4dC5zZWxlY3Rpb24gfHwgISFwcmV2LnNlbGVjdGlvbiAmJiAhIW5leHQuc2VsZWN0aW9uICYmIFJhbmdlLmVxdWFscyhwcmV2LnNlbGVjdGlvbiwgbmV4dC5zZWxlY3Rpb24pKTtcbn0pO1xuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGVsZW1lbnQgcmVuZGVyZXIuXHJcbiAqL1xuXG52YXIgRGVmYXVsdEVsZW1lbnQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBUYWcgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyAnc3BhbicgOiAnZGl2JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcywge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUuXHJcbiAqL1xuXG52YXIgRGVjb3JhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoKCkgPT4gW10pO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZGVjb3JhdGVgIHByb3Agb2YgdGhlIGVkaXRhYmxlLlxyXG4gKi9cblxudmFyIHVzZURlY29yYXRlID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChEZWNvcmF0ZUNvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHNlbGVjdGVkYCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gKi9cblxudmFyIFNlbGVjdGVkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHNlbGVjdGVkYCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gKi9cblxudmFyIHVzZVNlbGVjdGVkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWxlY3RlZENvbnRleHQpO1xufTtcblxuLyoqXHJcbiAqIENoaWxkcmVuLlxyXG4gKi9cblxudmFyIHVzZUNoaWxkcmVuID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGUsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBkZWNvcmF0ZSA9IHVzZURlY29yYXRlKCk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgaXNMZWFmQmxvY2sgPSBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhdGguY29uY2F0KGkpO1xuICAgIHZhciBuID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG4pO1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHApO1xuICAgIHZhciBzZWwgPSBzZWxlY3Rpb24gJiYgUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBkcyA9IGRlY29yYXRlKFtuLCBwXSk7XG5cbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciBkID0gUmFuZ2UuaW50ZXJzZWN0aW9uKGRlYywgcmFuZ2UpO1xuXG4gICAgICBpZiAoZCkge1xuICAgICAgICBkcy5wdXNoKGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG4pKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAga2V5OiBcInByb3ZpZGVyLVwiLmNvbmNhdChrZXkuaWQpLFxuICAgICAgICB2YWx1ZTogISFzZWxcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkRWxlbWVudCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsXG4gICAgICB9KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgaXNMYXN0OiBpc0xlYWZCbG9jayAmJiBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICB0ZXh0OiBuXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KG4sIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIFJlYWRPbmx5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIHVzZVJlYWRPbmx5ID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChSZWFkT25seUNvbnRleHQpO1xufTtcblxudmFyIFNsYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqL1xuXG52YXIgdXNlU2xhdGUgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZWRpdG9yXG4gIH0gPSBjb250ZXh0O1xuICByZXR1cm4gZWRpdG9yO1xufTtcbnZhciB1c2VTbGF0ZVdpdGhWID0gKCkgPT4ge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmZ1bmN0aW9uIHVzZVRyYWNrVXNlcklucHV0KCkge1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlY2VpdmVkVXNlcklucHV0ID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGFuaW1hdGlvbkZyYW1lSWRSZWYgPSB1c2VSZWYoMCk7XG4gIHZhciBvblVzZXJJbnB1dCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSB0cnVlO1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KTtcbiAgICBhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KSwgW10pO1xuICByZXR1cm4ge1xuICAgIHJlY2VpdmVkVXNlcklucHV0LFxuICAgIG9uVXNlcklucHV0XG4gIH07XG59XG5cbnZhciBUUklQTEVfQ0xJQ0sgPSAzO1xuXG4vKipcclxuICogSG90a2V5IG1hcHBpbmdzIGZvciBlYWNoIHBsYXRmb3JtLlxyXG4gKi9cblxudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIGluc2VydFNvZnRCcmVhazogJ3NoaWZ0K2VudGVyJyxcbiAgc3BsaXRCbG9jazogJ2VudGVyJyxcbiAgdW5kbzogJ21vZCt6J1xufTtcbnZhciBBUFBMRV9IT1RLRVlTID0ge1xuICBtb3ZlTGluZUJhY2t3YXJkOiAnb3B0K3VwJyxcbiAgbW92ZUxpbmVGb3J3YXJkOiAnb3B0K2Rvd24nLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnb3B0K2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdvcHQrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogWydjdHJsK2JhY2tzcGFjZScsICdjdHJsK2gnXSxcbiAgZGVsZXRlRm9yd2FyZDogWydjdHJsK2RlbGV0ZScsICdjdHJsK2QnXSxcbiAgZGVsZXRlTGluZUJhY2t3YXJkOiAnY21kK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVMaW5lRm9yd2FyZDogWydjbWQrc2hpZnQ/K2RlbGV0ZScsICdjdHJsK2snXSxcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnb3B0K3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ29wdCtzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kTGluZUJhY2t3YXJkOiAnb3B0K3NoaWZ0K3VwJyxcbiAgZXh0ZW5kTGluZUZvcndhcmQ6ICdvcHQrc2hpZnQrZG93bicsXG4gIHJlZG86ICdjbWQrc2hpZnQreicsXG4gIHRyYW5zcG9zZUNoYXJhY3RlcjogJ2N0cmwrdCdcbn07XG52YXIgV0lORE9XU19IT1RLRVlTID0ge1xuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdjdHJsK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ2N0cmwrc2hpZnQ/K2RlbGV0ZScsXG4gIHJlZG86IFsnY3RybCt5JywgJ2N0cmwrc2hpZnQreiddXG59O1xuLyoqXHJcbiAqIENyZWF0ZSBhIHBsYXRmb3JtLWF3YXJlIGhvdGtleSBjaGVja2VyLlxyXG4gKi9cblxudmFyIGNyZWF0ZSA9IGtleSA9PiB7XG4gIHZhciBnZW5lcmljID0gSE9US0VZU1trZXldO1xuICB2YXIgYXBwbGUgPSBBUFBMRV9IT1RLRVlTW2tleV07XG4gIHZhciB3aW5kb3dzID0gV0lORE9XU19IT1RLRVlTW2tleV07XG4gIHZhciBpc0dlbmVyaWMgPSBnZW5lcmljICYmIGlzSG90a2V5KGdlbmVyaWMpO1xuICB2YXIgaXNBcHBsZSA9IGFwcGxlICYmIGlzSG90a2V5KGFwcGxlKTtcbiAgdmFyIGlzV2luZG93cyA9IHdpbmRvd3MgJiYgaXNIb3RrZXkod2luZG93cyk7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgaWYgKGlzR2VuZXJpYyAmJiBpc0dlbmVyaWMoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoSVNfQVBQTEUgJiYgaXNBcHBsZSAmJiBpc0FwcGxlKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFJU19BUFBMRSAmJiBpc1dpbmRvd3MgJiYgaXNXaW5kb3dzKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTtcbi8qKlxyXG4gKiBIb3RrZXlzLlxyXG4gKi9cblxuXG52YXIgSG90a2V5cyA9IHtcbiAgaXNCb2xkOiBjcmVhdGUoJ2JvbGQnKSxcbiAgaXNDb21wb3NlOiBjcmVhdGUoJ2NvbXBvc2UnKSxcbiAgaXNNb3ZlQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUJhY2t3YXJkJyksXG4gIGlzTW92ZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lQmFja3dhcmQnKSxcbiAgaXNEZWxldGVMaW5lRm9yd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lRm9yd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkQmFja3dhcmQnKSxcbiAgaXNEZWxldGVXb3JkRm9yd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkRm9yd2FyZCcpLFxuICBpc0V4dGVuZEJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZEJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kRm9yd2FyZDogY3JlYXRlKCdleHRlbmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVCYWNrd2FyZCcpLFxuICBpc0V4dGVuZExpbmVGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVGb3J3YXJkJyksXG4gIGlzSXRhbGljOiBjcmVhdGUoJ2l0YWxpYycpLFxuICBpc01vdmVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVCYWNrd2FyZCcpLFxuICBpc01vdmVMaW5lRm9yd2FyZDogY3JlYXRlKCdtb3ZlTGluZUZvcndhcmQnKSxcbiAgaXNNb3ZlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ21vdmVXb3JkQmFja3dhcmQnKSxcbiAgaXNNb3ZlV29yZEZvcndhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRGb3J3YXJkJyksXG4gIGlzUmVkbzogY3JlYXRlKCdyZWRvJyksXG4gIGlzU29mdEJyZWFrOiBjcmVhdGUoJ2luc2VydFNvZnRCcmVhaycpLFxuICBpc1NwbGl0QmxvY2s6IGNyZWF0ZSgnc3BsaXRCbG9jaycpLFxuICBpc1RyYW5zcG9zZUNoYXJhY3RlcjogY3JlYXRlKCd0cmFuc3Bvc2VDaGFyYWN0ZXInKSxcbiAgaXNVbmRvOiBjcmVhdGUoJ3VuZG8nKVxufTtcblxudmFyIGNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyID0gKGVkaXRvciwgcmVjZWl2ZWRVc2VySW5wdXQpID0+IHtcbiAgdmFyIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG5cbiAgdmFyIGNsZWFyID0gKCkgPT4ge1xuICAgIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG4gIH07XG5cbiAgdmFyIHJlZ2lzdGVyTXV0YXRpb25zID0gbXV0YXRpb25zID0+IHtcbiAgICBpZiAoIXJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tlZE11dGF0aW9ucyA9IG11dGF0aW9ucy5maWx0ZXIobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSk7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMucHVzaCguLi50cmFja2VkTXV0YXRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXN0b3JlRE9NKCkge1xuICAgIGlmIChidWZmZXJlZE11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBidWZmZXJlZE11dGF0aW9ucy5yZXZlcnNlKCkuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlc3RvcmUgdGhlIERPTSBmb3IgY2hhcmFjdGVyRGF0YSBtdXRhdGlvbnNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaW50ZXJydXB0cyB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBtdXRhdGlvbi5uZXh0U2libGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBDbGVhciBidWZmZXJlZCBtdXRhdGlvbnMgdG8gZW5zdXJlIHdlIGRvbid0IHVuZG8gdGhlbSB0d2ljZVxuXG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbnMsXG4gICAgcmVzdG9yZURPTSxcbiAgICBjbGVhclxuICB9O1xufTtcblxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyA9IHtcbiAgc3VidHJlZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07IC8vIFdlIGhhdmUgdG8gdXNlIGEgY2xhc3MgY29tcG9uZW50IGhlcmUgc2luY2Ugd2UgcmVseSBvbiBgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVgIHdoaWNoIGhhcyBubyBGQyBlcXVpdmFsZW50XG4vLyB0byBydW4gY29kZSBzeW5jaHJvbm91c2x5IGltbWVkaWF0ZWx5IGJlZm9yZSByZWFjdCBjb21taXRzIHRoZSBjb21wb25lbnQgdXBkYXRlIHRvIHRoZSBET00uXG5cbmNsYXNzIFJlc3RvcmVET01Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuICB9XG5cbiAgb2JzZXJ2ZSgpIHtcbiAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlO1xuXG4gICAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghbm9kZS5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdHRhY2ggTXV0YXRpb25PYnNlcnZlciwgYG5vZGVgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmUgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlLm9ic2VydmUobm9kZS5jdXJyZW50LCBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkaXRvciA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLm1hbmFnZXIgPSBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlcihlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLm1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIsIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMsIF90aGlzJG1hbmFnZXIyO1xuXG4gICAgdmFyIHBlbmRpbmdNdXRhdGlvbnMgPSAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlMi50YWtlUmVjb3JkcygpO1xuXG4gICAgaWYgKHBlbmRpbmdNdXRhdGlvbnMgIT09IG51bGwgJiYgcGVuZGluZ011dGF0aW9ucyAhPT0gdm9pZCAwICYmIHBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFuYWdlcjtcblxuICAgICAgKF90aGlzJG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMocGVuZGluZ011dGF0aW9ucyk7XG4gICAgfVxuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMuZGlzY29ubmVjdCgpO1xuICAgIChfdGhpcyRtYW5hZ2VyMiA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIyLnJlc3RvcmVET00oKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkbWFuYWdlcjM7XG5cbiAgICAoX3RoaXMkbWFuYWdlcjMgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMy5jbGVhcigpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQ7XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlNC5kaXNjb25uZWN0KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cblxufVxuXG5SZXN0b3JlRE9NQ29tcG9uZW50LmNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcbnZhciBSZXN0b3JlRE9NID0gSVNfQU5EUk9JRCA/IFJlc3RvcmVET01Db21wb25lbnQgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJhdXRvRm9jdXNcIiwgXCJkZWNvcmF0ZVwiLCBcIm9uRE9NQmVmb3JlSW5wdXRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyRWxlbWVudFwiLCBcInJlbmRlckxlYWZcIiwgXCJyZW5kZXJQbGFjZWhvbGRlclwiLCBcInNjcm9sbFNlbGVjdGlvbkludG9WaWV3XCIsIFwic3R5bGVcIiwgXCJhc1wiLCBcImRpc2FibGVEZWZhdWx0U3R5bGVzXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIENoaWxkcmVuID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHVzZUNoaWxkcmVuKHByb3BzKSk7XG4vKipcclxuICogRWRpdGFibGUuXHJcbiAqL1xuXG5cbnZhciBFZGl0YWJsZSA9IHByb3BzID0+IHtcbiAgdmFyIGRlZmF1bHRSZW5kZXJQbGFjZWhvbGRlciA9IHVzZUNhbGxiYWNrKHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRQbGFjZWhvbGRlciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSwgW10pO1xuXG4gIHZhciB7XG4gICAgYXV0b0ZvY3VzLFxuICAgIGRlY29yYXRlID0gZGVmYXVsdERlY29yYXRlLFxuICAgIG9uRE9NQmVmb3JlSW5wdXQ6IHByb3BzT25ET01CZWZvcmVJbnB1dCxcbiAgICBwbGFjZWhvbGRlcixcbiAgICByZWFkT25seSA9IGZhbHNlLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyTGVhZixcbiAgICByZW5kZXJQbGFjZWhvbGRlciA9IGRlZmF1bHRSZW5kZXJQbGFjZWhvbGRlcixcbiAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyxcbiAgICBzdHlsZTogdXNlclN0eWxlID0ge30sXG4gICAgYXM6IENvbXBvbmVudCA9ICdkaXYnLFxuICAgIGRpc2FibGVEZWZhdWx0U3R5bGVzID0gZmFsc2VcbiAgfSA9IHByb3BzLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuXG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZSgpOyAvLyBSZXJlbmRlciBlZGl0b3Igd2hlbiBjb21wb3NpdGlvbiBzdGF0dXMgY2hhbmdlZFxuXG4gIHZhciBbaXNDb21wb3NpbmcsIHNldElzQ29tcG9zaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGRlZmVycmVkT3BlcmF0aW9ucyA9IHVzZVJlZihbXSk7XG4gIHZhciBbcGxhY2Vob2xkZXJIZWlnaHQsIHNldFBsYWNlaG9sZGVySGVpZ2h0XSA9IHVzZVN0YXRlKCk7XG4gIHZhciB7XG4gICAgb25Vc2VySW5wdXQsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXRcbiAgfSA9IHVzZVRyYWNrVXNlcklucHV0KCk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLnNldChlZGl0b3IsIGZvcmNlUmVuZGVyKTsgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIG9uIGVhY2ggcmVuZGVyLlxuXG4gIElTX1JFQURfT05MWS5zZXQoZWRpdG9yLCByZWFkT25seSk7IC8vIEtlZXAgdHJhY2sgb2Ygc29tZSBzdGF0ZSBmb3IgdGhlIGV2ZW50IGhhbmRsZXIgbG9naWMuXG5cbiAgdmFyIHN0YXRlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmdJbnRlcm5hbGx5OiBmYWxzZSxcbiAgICBpc1VwZGF0aW5nU2VsZWN0aW9uOiBmYWxzZSxcbiAgICBsYXRlc3RFbGVtZW50OiBudWxsLFxuICAgIGhhc01hcmtQbGFjZWhvbGRlcjogZmFsc2VcbiAgfSksIFtdKTsgLy8gVGhlIGF1dG9Gb2N1cyBUZXh0YXJlYUhUTUxBdHRyaWJ1dGUgZG9lc24ndCBkbyBhbnl0aGluZyBvbiBhIGRpdiwgc28gaXRcbiAgLy8gbmVlZHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZC5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBhdXRvRm9jdXMpIHtcbiAgICAgIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzXSk7XG4gIC8qKlxyXG4gICAqIFRoZSBBbmRyb2lkSW5wdXRNYW5hZ2VyIG9iamVjdCBoYXMgYSBjeWNsaWNhbCBkZXBlbmRlbmN5IG9uIG9uRE9NU2VsZWN0aW9uQ2hhbmdlXHJcbiAgICpcclxuICAgKiBJdCBpcyBkZWZpbmVkIGFzIGEgcmVmZXJlbmNlIHRvIHNpbXBsaWZ5IGhvb2sgZGVwZW5kZW5jaWVzIGFuZCBjbGFyaWZ5IHRoYXRcclxuICAgKiBpdCBuZWVkcyB0byBiZSBpbml0aWFsaXplZC5cclxuICAgKi9cblxuICB2YXIgYW5kcm9pZElucHV0TWFuYWdlclJlZiA9IHVzZVJlZigpOyAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgc2VsZWN0aW9uY2hhbmdlYCBldmVudCB0byBiZSBhYmxlIHRvIHVwZGF0ZSBhbnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBvblNlbGVjdGAgaXMgbGVha3lcbiAgLy8gYW5kIG5vbi1zdGFuZGFyZCBzbyBpdCBkb2Vzbid0IGZpcmUgdW50aWwgYWZ0ZXIgYSBzZWxlY3Rpb24gaGFzIGJlZW5cbiAgLy8gcmVsZWFzZWQuIFRoaXMgY2F1c2VzIGlzc3VlcyBpbiBzaXR1YXRpb25zIHdoZXJlIGFub3RoZXIgY2hhbmdlIGhhcHBlbnNcbiAgLy8gd2hpbGUgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZC5cblxuICB2YXIgb25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IHRocm90dGxlKCgpID0+IHtcbiAgICB2YXIgYW5kcm9pZElucHV0TWFuYWdlciA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudDtcblxuICAgIGlmICgoSVNfQU5EUk9JRCB8fCAhUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkgJiYgKCFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSAmJiAhc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICB2YXIge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gcm9vdDtcbiAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgZm9jdXNOb2RlXG4gICAgICB9ID0gZG9tU2VsZWN0aW9uO1xuICAgICAgdmFyIGFuY2hvck5vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBhbmNob3JOb2RlKSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIGFuY2hvck5vZGUpO1xuICAgICAgdmFyIGZvY3VzTm9kZVNlbGVjdGFibGUgPSBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGZvY3VzTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBmb2N1c05vZGUpO1xuXG4gICAgICBpZiAoYW5jaG9yTm9kZVNlbGVjdGFibGUgJiYgZm9jdXNOb2RlU2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhKGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFzUGVuZGluZ0NoYW5nZXMoKSkgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlVXNlclNlbGVjdChyYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIERlc2VsZWN0IHRoZSBlZGl0b3IgaWYgdGhlIGRvbSBzZWxlY3Rpb24gaXMgbm90IHNlbGVjdGFibGUgaW4gcmVhZG9ubHkgbW9kZVxuXG5cbiAgICAgIGlmIChyZWFkT25seSAmJiAoIWFuY2hvck5vZGVTZWxlY3RhYmxlIHx8ICFmb2N1c05vZGVTZWxlY3RhYmxlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDApLCBbZWRpdG9yLCByZWFkT25seSwgc3RhdGVdKTtcbiAgdmFyIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IGRlYm91bmNlKG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCAwKSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCA9IHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIoe1xuICAgIG5vZGU6IHJlZixcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSLCBfYW5kcm9pZElucHV0TWFuYWdlclIyO1xuXG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciB3aW5kb3c7XG5cbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgKHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHJlZi5jdXJyZW50KSkpIHtcbiAgICAgIEVESVRPUl9UT19XSU5ET1cuc2V0KGVkaXRvciwgd2luZG93KTtcbiAgICAgIEVESVRPUl9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZi5jdXJyZW50LCBlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgaW4gc3luYy5cblxuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghZG9tU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSB8fCAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIgIT09IHZvaWQgMCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIuaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNldERvbVNlbGVjdGlvbiA9IGZvcmNlQ2hhbmdlID0+IHtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb24gPSBkb21TZWxlY3Rpb24udHlwZSAhPT0gJ05vbmUnOyAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBwcm9wZXJseSB1bnNldCwgd2UncmUgZG9uZS5cblxuICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgIWhhc0RvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEdldCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGVcblxuXG4gICAgICB2YXIgZm9jdXNOb2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgIHZhciBhbmNob3JOb2RlOyAvLyBDT01QQVQ6IEluIGZpcmVmb3ggdGhlIG5vcm1hbCBzZWxldGlvbiB3YXkgZG9lcyBub3Qgd29ya1xuICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcblxuICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCAtIDEpOyAvLyBSaWdodCB0byBsZWZ0XG5cbiAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgfSAvLyB2ZXJpZnkgdGhhdCB0aGUgZG9tIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yXG5cblxuICAgICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IGZhbHNlO1xuXG4gICAgICBpZiAoZWRpdG9yRWxlbWVudC5jb250YWlucyhhbmNob3JOb2RlKSAmJiBlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSB0cnVlO1xuICAgICAgfSAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgZWRpdG9yIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGNvcnJlY3QsIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKGhhc0RvbVNlbGVjdGlvbiAmJiBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciAmJiBzZWxlY3Rpb24gJiYgIWZvcmNlQ2hhbmdlKSB7XG4gICAgICAgIHZhciBzbGF0ZVJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogdHJ1ZSxcbiAgICAgICAgICAvLyBkb21TZWxlY3Rpb24gaXMgbm90IG5lY2Vzc2FyaWx5IGEgdmFsaWQgU2xhdGUgcmFuZ2VcbiAgICAgICAgICAvLyAoZS5nLiB3aGVuIGNsaWNraW5nIG9uIGNvbnRlbnRFZGl0YWJsZTpmYWxzZSBlbGVtZW50KVxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNsYXRlUmFuZ2UgJiYgUmFuZ2UuZXF1YWxzKHNsYXRlUmFuZ2UsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgX2FuY2hvck5vZGUsIF9hbmNob3JOb2RlJHBhcmVudEVsZTtcblxuICAgICAgICAgIGlmICghc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBFbnN1cmUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlclxuXG5cbiAgICAgICAgICBpZiAoKF9hbmNob3JOb2RlID0gYW5jaG9yTm9kZSkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUgIT09IHZvaWQgMCAmJiAoX2FuY2hvck5vZGUkcGFyZW50RWxlID0gX2FuY2hvck5vZGUucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlICE9PSB2b2lkIDAgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2hlbiA8RWRpdGFibGUvPiBpcyBiZWluZyBjb250cm9sbGVkIHRocm91Z2ggZXh0ZXJuYWwgdmFsdWVcbiAgICAgIC8vIHRoZW4gaXRzIGNoaWxkcmVuIG1pZ2h0IGp1c3QgY2hhbmdlIC0gRE9NIHJlc3BvbmRzIHRvIGl0IG9uIGl0cyBvd25cbiAgICAgIC8vIGJ1dCBTbGF0ZSdzIHZhbHVlIGlzIG5vdCBiZWluZyB1cGRhdGVkIHRocm91Z2ggYW55IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHRodXMgaXQgZG9lc24ndCB0cmFuc2Zvcm0gc2VsZWN0aW9uIG9uIGl0cyBvd25cblxuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSZWFjdEVkaXRvci5oYXNSYW5nZShlZGl0b3IsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG5cblxuICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICB2YXIgbmV3RG9tUmFuZ2UgPSBzZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChuZXdEb21SYW5nZSkge1xuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhSVNfQU5EUk9JRCkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQsIG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0LCBuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhlZGl0b3IsIG5ld0RvbVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0RvbVJhbmdlO1xuICAgIH07IC8vIEluIGZpcmVmb3ggaWYgdGhlcmUgaXMgbW9yZSB0aGVuIDEgcmFuZ2UgYW5kIHdlIGNhbGwgc2V0RG9tU2VsZWN0aW9uIHdlIHJlbW92ZSB0aGUgYWJpbGl0eSB0byBzZWxlY3QgbW9yZSBjZWxscyBpbiBhIHRhYmxlXG5cblxuICAgIGlmIChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAxKSB7XG4gICAgICBzZXREb21TZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgZW5zdXJlU2VsZWN0aW9uID0gKChfYW5kcm9pZElucHV0TWFuYWdlclIyID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclIyLmlzRmx1c2hpbmcoKSkgPT09ICdhY3Rpb24nO1xuXG4gICAgaWYgKCFJU19BTkRST0lEIHx8ICFlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGltZW91dElkID0gbnVsbDtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnN1cmVEb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgc2V0RG9tU2VsZWN0aW9uKGZvcmNlQ2hhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7Ly8gSWdub3JlLCBkb20gYW5kIHN0YXRlIG1pZ2h0IGJlIG91dCBvZiBzeW5jXG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBDb21wYXQ6IEFuZHJvaWQgSU1FcyB0cnkgdG8gZm9yY2UgdGhlaXIgc2VsZWN0aW9uIGJ5IG1hbnVhbGx5IHJlLWFwcGx5aW5nIGl0IGV2ZW4gYWZ0ZXIgd2Ugc2V0IGl0LlxuICAgICAgICAvLyBUaGlzIGVzc2VudGlhbGx5IHdvdWxkIG1ha2Ugc2V0dGluZyB0aGUgc2xhdGUgc2VsZWN0aW9uIGR1cmluZyBhbiB1cGRhdGUgbWVhbmluZ2xlc3MsIHNvIHdlIGZvcmNlIGl0XG4gICAgICAgIC8vIGFnYWluIGhlcmUuIFdlIGNhbid0IG9ubHkgZG8gaXQgaW4gdGhlIHNldFRpbWVvdXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBmcmFtZSBzaW5jZSB0aGF0IHdvdWxkIGNhdXNlIGFcbiAgICAgICAgLy8gdmlzaWJsZSBmbGlja2VyLlxuXG5cbiAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKCk7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgc2V0dGluZyB0aGUgc2VsZWN0aW9uIGluIGFuIGFuaW1hdGlvbiBmcmFtZSB2aXN1YWxseSBjb3JyZWN0bHkgc2V0cyB0aGUgc2VsZWN0aW9uLFxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgdXBkYXRlIEdCb2FyZHMgc3BlbGxjaGVja2VyIHN0YXRlLiBXZSBoYXZlIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZWxlY3Rpb24gY2hhbmdlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBmcmFtZSB0byBlbnN1cmUgaXQgZGlzcGxheXMgdGhlIGNvcnJlY3Qgc3RhdGUuXG4gICAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuXG4gICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pOyAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgYmVmb3JlaW5wdXRgIGV2ZW50IHRvIGdldCByZWFsIFwiTGV2ZWwgMlwiIGV2ZW50cy4gVGhpc1xuICAvLyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYGJlZm9yZWlucHV0YCBpcyBmYWtlIGFuZCBuZXZlciByZWFsbHkgYXR0YWNoZXNcbiAgLy8gdG8gdGhlIHJlYWwgZXZlbnQgc2FkbHkuICgyMDE5LzExLzAxKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG5cbiAgdmFyIG9uRE9NQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgb25Vc2VySW5wdXQoKTtcblxuICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0RPTUV2ZW50SGFuZGxlZChldmVudCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0KSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fVVNFUl9TRUxFQztcblxuICAgICAgLy8gQ09NUEFUOiBCZWZvcmVJbnB1dCBldmVudHMgYXJlbid0IGNhbmNlbGFibGUgb24gYW5kcm9pZCwgc28gd2UgaGF2ZSB0byBoYW5kbGUgdGhlbSBkaWZmZXJlbnRseSB1c2luZyB0aGUgYW5kcm9pZCBpbnB1dCBtYW5hZ2VyLlxuICAgICAgaWYgKGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50LmhhbmRsZURPTUJlZm9yZUlucHV0KGV2ZW50KTtcbiAgICAgIH0gLy8gU29tZSBJTUVzL0Nocm9tZSBleHRlbnNpb25zIGxpa2UgZS5nLiBHcmFtbWFybHkgc2V0IHRoZSBzZWxlY3Rpb24gaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyB0cmlnZ2VyaW5nIGEgYGJlZm9yZWlucHV0YCBleHBlY3RpbmcgdGhlIGNoYW5nZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHNldCBzZWxlY3Rpb24uXG5cblxuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciB7XG4gICAgICAgIGlucHV0VHlwZTogdHlwZVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXNDb21wb3NpdGlvbkNoYW5nZSA9IHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnIHx8IHR5cGUgPT09ICdkZWxldGVDb21wb3NpdGlvblRleHQnOyAvLyBDT01QQVQ6IHVzZSBjb21wb3NpdGlvbiBjaGFuZ2UgZXZlbnRzIGFzIGEgaGludCB0byB3aGVyZSB3ZSBzaG91bGQgaW5zZXJ0XG4gICAgICAvLyBjb21wb3NpdGlvbiB0ZXh0IGlmIHdlIGFyZW4ndCBjb21wb3NpbmcgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MDM4XG5cbiAgICAgIGlmIChpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmF0aXZlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgLy8gT25seSB1c2UgbmF0aXZlIGNoYXJhY3RlciBpbnNlcnRpb24gZm9yIHNpbmdsZSBjaGFyYWN0ZXJzIGEteiBvciBzcGFjZSBmb3Igbm93LlxuICAgICAgLy8gTG9uZy1wcmVzcyBldmVudHMgKGhvbGQgYSArIHByZXNzIDQgPSDDpCkgdG8gY2hvb3NlIGEgc3BlY2lhbCBjaGFyYWN0ZXIgb3RoZXJ3aXNlXG4gICAgICAvLyBjYXVzZXMgZHVwbGljYXRlIGluc2VydHMuXG4gICAgICBldmVudC5kYXRhICYmIGV2ZW50LmRhdGEubGVuZ3RoID09PSAxICYmIC9bYS16IF0vaS50ZXN0KGV2ZW50LmRhdGEpICYmIC8vIENocm9tZSBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBzdGFydCBvZiBub2RlczogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTI0OTQwNVxuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhbiBpbmxpbmUgZWxlbWVudCwgZS5nLiBhIGxpbmssIGFuZCB5b3Ugc2VsZWN0XG4gICAgICAvLyByaWdodCBhZnRlciBpdCAodGhlIHN0YXJ0IG9mIHRoZSBuZXh0IG5vZGUpLlxuICAgICAgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFyIF9ub2RlJHBhcmVudEVsZW1lbnQsIF93aW5kb3ckZ2V0Q29tcHV0ZWRTdDtcblxuICAgICAgICBuYXRpdmUgPSB0cnVlOyAvLyBTa2lwIG5hdGl2ZSBpZiB0aGVyZSBhcmUgbWFya3MsIGFzXG4gICAgICAgIC8vIGBpbnNlcnRUZXh0YCB3aWxsIGluc2VydCBhIG5vZGUsIG5vdCBqdXN0IHRleHQuXG5cbiAgICAgICAgaWYgKGVkaXRvci5tYXJrcykge1xuICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IC8vIENocm9tZSBhbHNvIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIGVuZCBvZiBhbmNob3IgZWxlbWVudHM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNTkxMDBcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGFsbG93IG5hdGl2ZSBldmVudHMgdG8gaW5zZXJ0IHRleHQgYXQgdGhlIGVuZCBvZiBhbmNob3Igbm9kZXMuXG5cblxuICAgICAgICB2YXIge1xuICAgICAgICAgIGFuY2hvclxuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICB2YXIgW25vZGUsIG9mZnNldF0gPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSAoX25vZGUkcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX25vZGUkcGFyZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGFyZW50RWxlbWVudC5jbG9zZXN0KCdhJyk7XG4gICAgICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcblxuICAgICAgICBpZiAobmF0aXZlICYmIGFuY2hvck5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgdmFyIF9sYXN0VGV4dCR0ZXh0Q29udGVudDtcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgdGV4dCBub2RlIGluc2lkZSB0aGUgYW5jaG9yLlxuICAgICAgICAgIHZhciBsYXN0VGV4dCA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGFuY2hvck5vZGUsIE5vZGVGaWx0ZXIuU0hPV19URVhUKS5sYXN0Q2hpbGQoKTtcblxuICAgICAgICAgIGlmIChsYXN0VGV4dCA9PT0gbm9kZSAmJiAoKF9sYXN0VGV4dCR0ZXh0Q29udGVudCA9IGxhc3RUZXh0LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfbGFzdFRleHQkdGV4dENvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXN0VGV4dCR0ZXh0Q29udGVudC5sZW5ndGgpID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDaHJvbWUgaGFzIGlzc3VlcyB3aXRoIHRoZSBwcmVzZW5jZSBvZiB0YWIgY2hhcmFjdGVycyBpbnNpZGUgZWxlbWVudHMgd2l0aCB3aGl0ZVNwYWNlID0gJ3ByZSdcbiAgICAgICAgLy8gY2F1c2luZyBhYm5vcm1hbCBpbnNlcnQgYmVoYXZpb3I6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMTkxMzlcblxuXG4gICAgICAgIGlmIChuYXRpdmUgJiYgbm9kZS5wYXJlbnRFbGVtZW50ICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3dpbmRvdyRnZXRDb21wdXRlZFN0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZS5wYXJlbnRFbGVtZW50KSkgPT09IG51bGwgfHwgX3dpbmRvdyRnZXRDb21wdXRlZFN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGdldENvbXB1dGVkU3Qud2hpdGVTcGFjZSkgPT09ICdwcmUnKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGFuY2hvci5wYXRoLFxuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoYmxvY2sgJiYgTm9kZS5zdHJpbmcoYmxvY2tbMF0pLmluY2x1ZGVzKCdcXHQnKSkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENPTVBBVDogRm9yIHRoZSBkZWxldGluZyBmb3J3YXJkL2JhY2t3YXJkIGlucHV0IHR5cGVzIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgaXQgaXMgdGhlIHJhbmdlIHRoYXQgd2lsbCBiZSBkZWxldGVkLFxuICAgICAgLy8gYW5kIHRob3NlIGNvbW1hbmRzIGRldGVybWluZSB0aGF0IGZvciB0aGVtc2VsdmVzLlxuXG5cbiAgICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZUJ5JykpIHtcbiAgICAgICAgdmFyIFt0YXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICAgICAgICBpZiAodGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCB0YXJnZXRSYW5nZSwge1xuICAgICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVmID0gIWlzQ29tcG9zaXRpb25DaGFuZ2UgJiYgZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uUmVmKSB7XG4gICAgICAgICAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5zZXQoZWRpdG9yLCBzZWxlY3Rpb25SZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDb21wb3NpdGlvbiBjaGFuZ2UgdHlwZXMgb2NjdXIgd2hpbGUgYSB1c2VyIGlzIGNvbXBvc2luZyB0ZXh0IGFuZCBjYW4ndCBiZVxuICAgICAgLy8gY2FuY2VsbGVkLiBMZXQgdGhlbSB0aHJvdWdoIGFuZCB3YWl0IGZvciB0aGUgY29tcG9zaXRpb24gdG8gZW5kLlxuXG5cbiAgICAgIGlmIChpc0NvbXBvc2l0aW9uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuYXRpdmUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGV4cGFuZGVkLCBldmVuIGlmIHRoZSBjb21tYW5kIHNlZW1zIGxpa2VcbiAgICAgIC8vIGEgZGVsZXRlIGZvcndhcmQvYmFja3dhcmQgY29tbWFuZCBpdCBzaG91bGQgZGVsZXRlIHRoZSBzZWxlY3Rpb24uXG5cblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJykge1xuICAgICAgICAgICAgICAvLyBDT01QQVQ6IGluIFNhZmFyaSwgYGNvbXBvc2l0aW9uZW5kYCBpcyBkaXNwYXRjaGVkIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGZvciBcImluc2VydEZyb21Db21wb3NpdGlvblwiLiBCdXQgaWYgd2Ugd2FpdCBmb3IgaXRcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGFib3J0IGJlY2F1c2Ugd2UncmUgc3RpbGwgY29tcG9zaW5nIGFuZCB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgIC8vIHdvbid0IGJlIHVwZGF0ZWQgcHJvcGVybHkuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9pbnB1dC1ldmVudHMtMi9cbiAgICAgICAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyB1c2UgYSB3ZWFrIGNvbXBhcmlzb24gaW5zdGVhZCBvZiAnaW5zdGFuY2VvZicgdG8gYWxsb3dcbiAgICAgICAgICAgIC8vIHByb2dyYW1tYXRpYyBhY2Nlc3Mgb2YgcGFzdGUgZXZlbnRzIGNvbWluZyBmcm9tIGV4dGVybmFsIHdpbmRvd3NcbiAgICAgICAgICAgIC8vIGxpa2UgY3lwcmVzcyB3aGVyZSBjeS53aW5kb3cgZG9lcyBub3Qgd29yayByZWFsaWJseVxuXG5cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUpID09PSAnRGF0YVRyYW5zZmVyJykge1xuICAgICAgICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyBPbmx5IGluc2VydFRleHQgb3BlcmF0aW9ucyB1c2UgdGhlIG5hdGl2ZSBmdW5jdGlvbmFsaXR5LCBmb3Igbm93LlxuICAgICAgICAgICAgICAvLyBQb3RlbnRpYWxseSBleHBhbmQgdG8gc2luZ2xlIGNoYXJhY3RlciBkZWxldGVzLCBhcyB3ZWxsLlxuICAgICAgICAgICAgICBpZiAobmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQucHVzaCgoKSA9PiBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRhdGEpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gUmVzdG9yZSB0aGUgYWN0dWFsIHVzZXIgc2VjdGlvbiBpZiBub3RoaW5nIG1hbnVhbGx5IHNldCBpdC5cblxuXG4gICAgICB2YXIgdG9SZXN0b3JlID0gKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcblxuICAgICAgaWYgKHRvUmVzdG9yZSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCB0b1Jlc3RvcmUpKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRvUmVzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZWRpdG9yLCBvbkRPTVNlbGVjdGlvbkNoYW5nZSwgb25Vc2VySW5wdXQsIHByb3BzT25ET01CZWZvcmVJbnB1dCwgcmVhZE9ubHksIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgIGlmIChyZWYuY3VycmVudCAmJiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICByZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCBiZWNhdXNlIFJlYWN0J3NcbiAgICAgIC8vIGJ1aWx0LWluIGBvbkJlZm9yZUlucHV0YCBpcyBhY3R1YWxseSBhIGxlYWt5IHBvbHlmaWxsIHRoYXQgZG9lc24ndCBleHBvc2VcbiAgICAgIC8vIHJlYWwgYGJlZm9yZWlucHV0YCBldmVudHMgc2FkbHkuLi4gKDIwMTkvMTEvMDQpXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG4gICAgICBpZiAoSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBlZGl0b3IsIG9uRE9NQmVmb3JlSW5wdXRdKTsgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgc2VsZWN0aW9uY2hhbmdlYCwgYmVjYXVzZSBSZWFjdCdzXG4gIC8vIGJ1aWx0LWluIGBvblNlbGVjdGAgaGFuZGxlciBkb2Vzbid0IGZpcmUgZm9yIGFsbCBzZWxlY3Rpb24gY2hhbmdlcy4gSXQncyBhXG4gIC8vIGxlYWt5IHBvbHlmaWxsIHRoYXQgb25seSBmaXJlcyBvbiBrZXlwcmVzc2VzIG9yIGNsaWNrcy4gSW5zdGVhZCwgd2Ugd2FudCB0b1xuICAvLyBmaXJlIGZvciBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBlZGl0b3IuICgyMDE5LzExLzA0KVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU3ODVcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3NjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGRlY29yYXRpb25zID0gZGVjb3JhdGUoW2VkaXRvciwgW11dKTtcbiAgdmFyIHNob3dQbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgQXJyYXkuZnJvbShOb2RlLnRleHRzKGVkaXRvcikpLmxlbmd0aCA9PT0gMSAmJiBOb2RlLnN0cmluZyhlZGl0b3IpID09PSAnJyAmJiAhaXNDb21wb3Npbmc7XG4gIHZhciBwbGFjZUhvbGRlclJlc2l6ZUhhbmRsZXIgPSB1c2VDYWxsYmFjayhwbGFjZWhvbGRlckVsID0+IHtcbiAgICBpZiAocGxhY2Vob2xkZXJFbCAmJiBzaG93UGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBfcGxhY2Vob2xkZXJFbCRnZXRCb3U7XG5cbiAgICAgIHNldFBsYWNlaG9sZGVySGVpZ2h0KChfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPSBwbGFjZWhvbGRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA9PT0gbnVsbCB8fCBfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wbGFjZWhvbGRlckVsJGdldEJvdS5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Nob3dQbGFjZWhvbGRlcl0pO1xuXG4gIGlmIChzaG93UGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICBbUExBQ0VIT0xERVJfU1lNQk9MXTogdHJ1ZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgb25QbGFjZWhvbGRlclJlc2l6ZTogcGxhY2VIb2xkZXJSZXNpemVIYW5kbGVyLFxuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBzdGFydFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBtYXJrc1xuICB9ID0gZWRpdG9yO1xuICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZTtcblxuICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBtYXJrcykge1xuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcblxuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGxlYWYsIF9leGNsdWRlZDIpOyAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG5cblxuICAgIGlmICghVGV4dCQxLmVxdWFscyhsZWFmLCBtYXJrcywge1xuICAgICAgbG9vc2U6IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHZhciB1bnNldCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhyZXN0KS5tYXAobWFyayA9PiBbbWFyaywgbnVsbF0pKTtcbiAgICAgIGRlY29yYXRpb25zLnB1c2goX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgICBbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlXG4gICAgICB9LCB1bnNldCksIG1hcmtzKSwge30sIHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1czogYW5jaG9yXG4gICAgICB9KSk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBFRElUT1JfVE9fTUFSS19QTEFDRUhPTERFUl9NQVJLUyBpbiBzZXRUaW1lb3V0IHVzZUVmZmVjdCB0byBlbnN1cmUgd2UgZG9uJ3Qgc2V0IGl0XG4gIC8vIGJlZm9yZSB3ZSByZWNlaXZlIHRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQuXG5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gTm9kZS5sZWFmKGVkaXRvciwgX2FuY2hvci5wYXRoKTsgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAgICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cblxuXG4gICAgICAgIGlmIChtYXJrcyAmJiAhVGV4dCQxLmVxdWFscyhfdGV4dCwgbWFya3MsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZWRpdG9yLCBtYXJrcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFkT25seUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVhZE9ubHlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlY29yYXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc3RvcmVET00sIHtcbiAgICBub2RlOiByZWYsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQ6IHJlY2VpdmVkVXNlcklucHV0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCcsXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWVcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIC8vIEZvciBTU1Igc2l0dWF0aW9ucyBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgaXMgZmFsc2UgYW5kIHJlc3VsdHMgaW4gcHJvcFxuICAgIC8vIG1pc21hdGNoIHdhcm5pbmcgYXBwIG1vdmVzIHRvIGJyb3dzZXIuIFBhc3MtdGhyb3VnaCBjb25zdW1lciBwcm9wcyB3aGVuXG4gICAgLy8gbm90IENBTl9VU0VfRE9NIChTU1IpIGFuZCBkZWZhdWx0IHRvIGZhbHN5IHZhbHVlXG4gICAgc3BlbGxDaGVjazogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayA6IGZhbHNlLFxuICAgIGF1dG9Db3JyZWN0OiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ29ycmVjdCA6ICdmYWxzZScsXG4gICAgYXV0b0NhcGl0YWxpemU6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplIDogJ2ZhbHNlJyxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRoaXNcbiAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAvLyBpbiBzb21lIGNhc2VzLCBhIGRlY29yYXRpb24gbmVlZHMgYWNjZXNzIHRvIHRoZSByYW5nZSAvIHNlbGVjdGlvbiB0byBkZWNvcmF0ZSBhIHRleHQgbm9kZSxcbiAgICAvLyB0aGVuIHlvdSB3aWxsIHNlbGVjdCB0aGUgd2hvbGUgdGV4dCBub2RlIHdoZW4geW91IHNlbGVjdCBwYXJ0IHRoZSBvZiB0ZXh0XG4gICAgLy8gdGhpcyBtYWdpYyB6SW5kZXg9XCItMVwiIHdpbGwgZml4IGl0XG4gICAgemluZGV4OiAtMSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgcmVmOiBjYWxsYmFja1JlZixcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgZGlzYWJsZURlZmF1bHRTdHlsZXMgPyB7fSA6IF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAvLyBBbGxvdyBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgLy8gUHJlc2VydmUgYWRqYWNlbnQgd2hpdGVzcGFjZSBhbmQgbmV3IGxpbmVzLlxuICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgIC8vIEFsbG93IHdvcmRzIHRvIGJyZWFrIGlmIHRoZXkgYXJlIHRvbyBsb25nLlxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH0sIHBsYWNlaG9sZGVySGVpZ2h0ID8ge1xuICAgICAgbWluSGVpZ2h0OiBwbGFjZWhvbGRlckhlaWdodFxuICAgIH0gOiB7fSkpLCB1c2VyU3R5bGUpLFxuICAgIG9uQmVmb3JlSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgbGVha3kgcG9seWZpbGwgaW5zdGVhZCBqdXN0IGZvciBpdC4gSXRcbiAgICAgIC8vIG9ubHkgd29ya3MgZm9yIHRoZSBgaW5zZXJ0VGV4dGAgaW5wdXQgdHlwZS5cbiAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICB2YXIgX3RleHQyID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkJlZm9yZUlucHV0LCBlZGl0b3IsIHJlYWRPbmx5XSksXG4gICAgb25JbnB1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uSW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQuaGFuZGxlSW5wdXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGbHVzaCBuYXRpdmUgb3BlcmF0aW9ucywgYXMgbmF0aXZlIGV2ZW50cyB3aWxsIGhhdmUgcHJvcG9nYXRlZFxuICAgICAgLy8gYW5kIHdlIGNhbiBjb3JyZWN0bHkgY29tcGFyZSBET00gdGV4dCB2YWx1ZXMgaW4gY29tcG9uZW50c1xuICAgICAgLy8gdG8gc3RvcCByZW5kZXJpbmcsIHNvIHRoYXQgYnJvd3NlciBmdW5jdGlvbnMgbGlrZSBhdXRvY29ycmVjdFxuICAgICAgLy8gYW5kIHNwZWxsY2hlY2sgd29yayBhcyBleHBlY3RlZC5cblxuXG4gICAgICBmb3IgKHZhciBvcCBvZiBkZWZlcnJlZE9wZXJhdGlvbnMuY3VycmVudCkge1xuICAgICAgICBvcCgpO1xuICAgICAgfVxuXG4gICAgICBkZWZlcnJlZE9wZXJhdGlvbnMuY3VycmVudCA9IFtdO1xuICAgIH0sIFthdHRyaWJ1dGVzLm9uSW5wdXRdKSxcbiAgICBvbkJsdXI6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChyZWFkT25seSB8fCBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSB8fCBpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkJsdXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgY3VycmVudCBgYWN0aXZlRWxlbWVudGAgaXMgc3RpbGwgdGhlIHByZXZpb3VzXG4gICAgICAvLyBvbmUsIHRoaXMgaXMgZHVlIHRvIHRoZSB3aW5kb3cgYmVpbmcgYmx1cnJlZCB3aGVuIHRoZSB0YWJcbiAgICAgIC8vIGl0c2VsZiBiZWNvbWVzIHVuZm9jdXNlZCwgc28gd2Ugd2FudCB0byBhYm9ydCBlYXJseSB0byBhbGxvdyB0b1xuICAgICAgLy8gZWRpdG9yIHRvIHN0YXkgZm9jdXNlZCB3aGVuIHRoZSB0YWIgYmVjb21lcyBmb2N1c2VkIGFnYWluLlxuXG5cbiAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG5cbiAgICAgIGlmIChzdGF0ZS5sYXRlc3RFbGVtZW50ID09PSByb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpOyAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgcmV0dXJuaW5nXG4gICAgICAvLyB0byB0aGUgZWRpdG9yIGZyb20gYW4gZW1iZWRkZWQgZWRpdGFibGUgZWxlbWVudCAoZWcuIGFuIDxpbnB1dD5cbiAgICAgIC8vIGVsZW1lbnQgaW5zaWRlIGEgdm9pZCBub2RlKS5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyBmcm9tXG4gICAgICAvLyB0aGUgZWRpdG9yIHRvIGluc2lkZSBhIHZvaWQgbm9kZSdzIHNwYWNlciBlbGVtZW50LlxuXG5cbiAgICAgIGlmIChpc0RPTUVsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3BhY2VyJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIHRvIGFcbiAgICAgIC8vIG5vbi0gZWRpdGFibGUgc2VjdGlvbiBvZiBhbiBlbGVtZW50IHRoYXQgaXNuJ3QgYSB2b2lkIG5vZGUgKGVnLlxuICAgICAgLy8gYSBsaXN0IGl0ZW0gb2YgdGhlIGNoZWNrIGxpc3QgZXhhbXBsZSkuXG5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiBpc0RPTU5vZGUocmVsYXRlZFRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDT01QQVQ6IFNhZmFyaSBkb2Vzbid0IGFsd2F5cyByZW1vdmUgdGhlIHNlbGVjdGlvbiBldmVuIGlmIHRoZSBjb250ZW50LVxuICAgICAgLy8gZWRpdGFibGUgZWxlbWVudCBubyBsb25nZXIgaGFzIGZvY3VzLiBSZWZlciB0bzpcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMzUzMjQ3L2ZvcmNlLWNvbnRlbnRlZGl0YWJsZS1kaXYtdG8tc3RvcC1hY2NlcHRpbmctaW5wdXQtYWZ0ZXItaXQtbG9zZXMtZm9jdXMtdW5kZXItd2ViXG5cblxuICAgICAgaWYgKElTX1dFQktJVCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuXG4gICAgICBJU19GT0NVU0VELmRlbGV0ZShlZGl0b3IpO1xuICAgIH0sIFtyZWFkT25seSwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiwgc3RhdGUubGF0ZXN0RWxlbWVudCwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQmx1cl0pLFxuICAgIG9uQ2xpY2s6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNsaWNrKSAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpOyAvLyBBdCB0aGlzIHRpbWUsIHRoZSBTbGF0ZSBkb2N1bWVudCBtYXkgYmUgYXJiaXRyYXJpbHkgZGlmZmVyZW50LFxuICAgICAgICAvLyBiZWNhdXNlIG9uQ2xpY2sgaGFuZGxlcnMgY2FuIGNoYW5nZSB0aGUgZG9jdW1lbnQgYmVmb3JlIHdlIGdldCBoZXJlLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbXVzdCBjaGVjayB0aGF0IHRoaXMgcGF0aCBhY3R1YWxseSBleGlzdHMsXG4gICAgICAgIC8vIGFuZCB0aGF0IGl0IHN0aWxsIHJlZmVycyB0byB0aGUgc2FtZSBub2RlLlxuXG4gICAgICAgIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSB8fCBOb2RlLmdldChlZGl0b3IsIHBhdGgpICE9PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbCA9PT0gVFJJUExFX0NMSUNLICYmIHBhdGgubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICB2YXIgYmxvY2tQYXRoID0gcGF0aDtcblxuICAgICAgICAgIGlmICghKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBub2RlKSkpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2skO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmxvY2tQYXRoID0gKF9ibG9jayQgPSBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tbMV0pICE9PSBudWxsICYmIF9ibG9jayQgIT09IHZvaWQgMCA/IF9ibG9jayQgOiBwYXRoLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYWRPbmx5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Vm9pZCAmJiBlbmRWb2lkICYmIFBhdGguZXF1YWxzKHN0YXJ0Vm9pZFsxXSwgZW5kVm9pZFsxXSkpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgX3N0YXJ0KTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtlZGl0b3IsIGF0dHJpYnV0ZXMub25DbGljaywgcmVhZE9ubHldKSxcbiAgICBvbkNvbXBvc2l0aW9uRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjM7XG5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclIzID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclIzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclIzLmhhbmRsZUNvbXBvc2l0aW9uRW5kKGV2ZW50KTtcblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCkgfHwgSVNfQU5EUk9JRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IEluIENocm9tZSwgYGJlZm9yZWlucHV0YCBldmVudHMgZm9yIGNvbXBvc2l0aW9uc1xuICAgICAgICAvLyBhcmVuJ3QgY29ycmVjdCBhbmQgbmV2ZXIgZmlyZSB0aGUgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIlxuICAgICAgICAvLyB0eXBlIHRoYXQgd2UgbmVlZC4gU28gaW5zdGVhZCwgaW5zZXJ0IHdoZW5ldmVyIGEgY29tcG9zaXRpb25cbiAgICAgICAgLy8gZW5kcyBzaW5jZSBpdCB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGNvbW1pdHRlZCB0byB0aGUgRE9NLlxuXG5cbiAgICAgICAgaWYgKCFJU19XRUJLSVQgJiYgIUlTX0ZJUkVGT1hfTEVHQUNZICYmICFJU19JT1MgJiYgIUlTX1dFQ0hBVEJST1dTRVIgJiYgIUlTX1VDX01PQklMRSAmJiBldmVudC5kYXRhKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyTWFya3MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpOyAvLyBFbnN1cmUgd2UgaW5zZXJ0IHRleHQgd2l0aCB0aGUgbWFya3MgdGhlIHVzZXIgd2FzIGFjdHVhbGx5IHNlZWluZ1xuXG4gICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHBsYWNlaG9sZGVyTWFya3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgICAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uRW5kLCBlZGl0b3JdKSxcbiAgICBvbkNvbXBvc2l0aW9uVXBkYXRlOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25VcGRhdGUpKSB7XG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHNldElzQ29tcG9zaW5nKHRydWUpO1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25VcGRhdGUsIGVkaXRvcl0pLFxuICAgIG9uQ29tcG9zaXRpb25TdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI0O1xuXG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclI0ID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclI0LmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uU3RhcnQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlubGluZSA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBbLCBpbmxpbmVQYXRoXSA9IGlubGluZTtcblxuICAgICAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IsIGlubGluZVBhdGgpKSB7XG4gICAgICAgICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGlubGluZVBhdGgpO1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IHBvaW50LFxuICAgICAgICAgICAgICAgIGZvY3VzOiBwb2ludFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uU3RhcnQsIGVkaXRvcl0pLFxuICAgIG9uQ29weTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvcHkpICYmICFpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjb3B5Jyk7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db3B5LCBlZGl0b3JdKSxcbiAgICBvbkN1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DdXQpICYmICFpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjdXQnKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25DdXRdKSxcbiAgICBvbkRyYWdPdmVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25EcmFnT3ZlcikpIHtcbiAgICAgICAgLy8gT25seSB3aGVuIHRoZSB0YXJnZXQgaXMgdm9pZCwgY2FsbCBgcHJldmVudERlZmF1bHRgIHRvIHNpZ25hbFxuICAgICAgICAvLyB0aGF0IGRyb3BzIGFyZSBhbGxvd2VkLiBFZGl0YWJsZSBjb250ZW50IGlzIGRyb3BwYWJsZSBieVxuICAgICAgICAvLyBkZWZhdWx0LCBhbmQgY2FsbGluZyBgcHJldmVudERlZmF1bHRgIGhpZGVzIHRoZSBjdXJzb3IuXG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkRyYWdPdmVyLCBlZGl0b3JdKSxcbiAgICBvbkRyYWdTdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdTdGFydCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pOyAvLyBJZiBzdGFydGluZyBhIGRyYWcgb24gYSB2b2lkIG5vZGUsIG1ha2Ugc3VyZSBpdCBpcyBzZWxlY3RlZFxuICAgICAgICAvLyBzbyB0aGF0IGl0IHNob3dzIHVwIGluIHRoZSBzZWxlY3Rpb24ncyBmcmFnbWVudC5cblxuICAgICAgICBpZiAodm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSA9IHRydWU7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmRhdGFUcmFuc2ZlciwgJ2RyYWcnKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkRyYWdTdGFydCwgc3RhdGVdKSxcbiAgICBvbkRyb3A6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Ecm9wKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkcmFnZ2VkIHJhbmdlIGJlZm9yZSB1cGRhdGluZyBzZWxlY3Rpb25cblxuICAgICAgICB2YXIgZHJhZ2dlZFJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbjsgLy8gRmluZCB0aGUgcmFuZ2Ugd2hlcmUgdGhlIGRyb3AgaGFwcGVuZWRcblxuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgICAgIGlmIChkcmFnZ2VkUmFuZ2UgJiYgIVJhbmdlLmVxdWFscyhkcmFnZ2VkUmFuZ2UsIHJhbmdlKSAmJiAhRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IGRyYWdnZWRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpOyAvLyBXaGVuIGRyYWdnaW5nIGZyb20gYW5vdGhlciBzb3VyY2UgaW50byB0aGUgZWRpdG9yLCBpdCdzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRoYXQgdGhlIGN1cnJlbnQgZWRpdG9yIGRvZXMgbm90IGhhdmUgZm9jdXMuXG5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkRyb3AsIHN0YXRlXSksXG4gICAgb25EcmFnRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ICYmIGF0dHJpYnV0ZXMub25EcmFnRW5kICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfSAvLyBXaGVuIGRyb3BwaW5nIG9uIGEgZGlmZmVyZW50IGRyb3BwYWJsZSBlbGVtZW50IHRoYW4gdGhlIGN1cnJlbnQgZWRpdG9yLFxuICAgICAgLy8gYG9uRHJvcGAgaXMgbm90IGNhbGxlZC4gU28gd2UgbmVlZCB0byBjbGVhbiB1cCBpbiBgb25EcmFnRW5kYCBpbnN0ZWFkLlxuICAgICAgLy8gTm90ZTogYG9uRHJhZ0VuZGAgaXMgb25seSBjYWxsZWQgd2hlbiBgb25Ecm9wYCBpcyBub3QgY2FsbGVkXG5cblxuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLCBhdHRyaWJ1dGVzLCBlZGl0b3JdKSxcbiAgICBvbkZvY3VzOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmICFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Gb2N1cykpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDsgLy8gQ09NUEFUOiBJZiB0aGUgZWRpdG9yIGhhcyBuZXN0ZWQgZWRpdGFibGUgZWxlbWVudHMsIHRoZSBmb2N1c1xuICAgICAgICAvLyBjYW4gZ28gdG8gdGhlbS4gSW4gRmlyZWZveCwgdGhpcyBtdXN0IGJlIHByZXZlbnRlZCBiZWNhdXNlIGl0XG4gICAgICAgIC8vIHJlc3VsdHMgaW4gaXNzdWVzIHdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbi4gKDIwMTcvMDMvMzApXG5cbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLCBlZGl0b3IsIGF0dHJpYnV0ZXMub25Gb2N1c10pLFxuICAgIG9uS2V5RG93bjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjU7XG5cbiAgICAgICAgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUuaGFuZGxlS2V5RG93bihldmVudCk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50OyAvLyBDT01QQVQ6IFRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQgaXNuJ3QgZmlyZWQgcmVsaWFibHkgaW4gYWxsIGJyb3dzZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzb21ldGltZXMgbWlnaHQgZW5kIHVwIHN0dWNrIGluIGEgY29tcG9zaXRpb24gc3RhdGUgZXZlbiB0aG91Z2ggd2VcbiAgICAgICAgLy8gYXJlbid0IGNvbXBvc2luZyBhbnkgbW9yZS5cblxuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiBuYXRpdmVFdmVudC5pc0NvbXBvc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIHNldElzQ29tcG9zaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbktleURvd24pIHx8IFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGVkaXRvci5jaGlsZHJlbltzZWxlY3Rpb24gIT09IG51bGwgPyBzZWxlY3Rpb24uZm9jdXMucGF0aFswXSA6IDBdO1xuICAgICAgICB2YXIgaXNSVEwgPSBnZXREaXJlY3Rpb24oTm9kZS5zdHJpbmcoZWxlbWVudCkpID09PSAncnRsJzsgLy8gQ09NUEFUOiBTaW5jZSB3ZSBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9uXG4gICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCB0aGUgYnJvd3NlciBkb2Vzbid0IHRoaW5rIHRoZXJlJ3MgZXZlclxuICAgICAgICAvLyBhbnkgaGlzdG9yeSBzdGFjayB0byB1bmRvIG9yIHJlZG8sIHNvIHdlIGhhdmUgdG8gbWFuYWdlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgb3Vyc2VsdmVzLiAoMjAxOS8xMS8wNilcblxuICAgICAgICBpZiAoSG90a2V5cy5pc1JlZG8obmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgbWF5YmVIaXN0b3J5RWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUhpc3RvcnlFZGl0b3IucmVkbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc1VuZG8obmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgX21heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX21heWJlSGlzdG9yeUVkaXRvci51bmRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcGVybHkuIEluIENocm9tZSwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBleHRlbmRlZC5cbiAgICAgICAgLy8gQW5kIGluIEZpcmVmb3gsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgY29sbGFwc2VkLlxuICAgICAgICAvLyAoMjAxNy8xMC8xNylcblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IElmIGEgdm9pZCBub2RlIGlzIHNlbGVjdGVkLCBvciBhIHplcm8td2lkdGggdGV4dCBub2RlXG4gICAgICAgIC8vIGFkamFjZW50IHRvIGFuIGlubGluZSBpcyBzZWxlY3RlZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhlc2VcbiAgICAgICAgLy8gaG90a2V5cyBtYW51YWxseSBiZWNhdXNlIGJyb3dzZXJzIHdvbid0IGJlIGFibGUgdG8gc2tpcCBvdmVyXG4gICAgICAgIC8vIHRoZSB2b2lkIG5vZGUgd2l0aCB0aGUgemVyby13aWR0aCBzcGFjZSBub3QgYmVpbmcgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nLlxuXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICByZXZlcnNlOiAhaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogIWlzUlRMXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCcsXG4gICAgICAgICAgICByZXZlcnNlOiBpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGd1ZXNzaW5nIGF0IHRoZSBpbnB1dCBpbnRlbnRpb24gZm9yIGhvdGtleXMuXG4gICAgICAgIC8vIENPTVBBVDogSW4gaU9TLCBzb21lIG9mIHRoZXNlIGhvdGtleXMgYXJlIGhhbmRsZWQgaW4gdGhlXG5cblxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBjb3JlIGJlaGF2aW9yIGZvciB0aGVzZSwgYnV0IHRoZXkgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIERPTSBpZiB3ZSBkb24ndCBwcmV2ZW50IHRoZW0sIHNvIHdlIGhhdmUgdG8uXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNCb2xkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzSXRhbGljKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzVHJhbnNwb3NlQ2hhcmFjdGVyKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NvZnRCcmVhayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTcGxpdEJsb2NrKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoSVNfQ0hST01FIHx8IElTX1dFQktJVCkge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBDaHJvbWUgYW5kIFNhZmFyaSBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgZXZlbnQgYnV0IGRvIG5vdCBmaXJlXG4gICAgICAgICAgICAvLyBhbiBldmVudCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkcyBpbiBhIHNlbGVjdGVkIHZvaWQgaW5saW5lIG5vZGVcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgKEhvdGtleXMuaXNEZWxldGVCYWNrd2FyZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcblxuICAgICAgICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGN1cnJlbnROb2RlKSAmJiAoRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgY3VycmVudE5vZGUpIHx8IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgY3VycmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uS2V5RG93bl0pLFxuICAgIG9uUGFzdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCBlbWl0IGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAgIC8vIHdoZW4gXCJwYXN0ZSB3aXRob3V0IGZvcm1hdHRpbmdcIiBpcyB1c2VkLCBzbyBmYWxsYmFjay4gKDIwMjAvMDIvMjApXG4gICAgICAgIC8vIENPTVBBVDogU2FmYXJpIElucHV0RXZlbnRzIGdlbmVyYXRlZCBieSBwYXN0aW5nIHdvbid0IGluY2x1ZGVcbiAgICAgICAgLy8gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBpdGVtcywgc28gdXNlIHRoZVxuICAgICAgICAvLyBDbGlwYm9hcmRFdmVudCBoZXJlLiAoMjAyMy8wMy8xNSlcbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IElTX1dFQktJVCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25QYXN0ZV0pXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkpKSkpO1xufTtcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciBlbGVtZW50XHJcbiAqL1xuXG52YXIgRGVmYXVsdFBsYWNlaG9sZGVyID0gX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQ09NUEFUOiBBcnRpZmljaWFsbHkgYWRkIGEgbGluZS1icmVhayB0byB0aGUgZW5kIG9uIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50XG4gICAgLy8gdG8gcHJldmVudCBBbmRyb2lkIElNRXMgdG8gcGljayB1cCBpdHMgY29udGVudCBpbiBhdXRvY29ycmVjdCBhbmQgdG8gYXV0by1jYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXJcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4sIElTX0FORFJPSUQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSlcbiAgKTtcbn07XG4vKipcclxuICogQSBkZWZhdWx0IG1lbW9pemVkIGRlY29yYXRlIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIGRlZmF1bHREZWNvcmF0ZSA9ICgpID0+IFtdO1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnQgdG8gc2Nyb2xsIGRvbSByYW5nZSBpbnRvIHZpZXcuXHJcbiAqL1xuXG52YXIgZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gKGVkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgLy8gVGhpcyB3YXMgYWZmZWN0aW5nIHRoZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgYmxvY2tzIGFuZCBkcmFnZ2luZyBiZWhhdmlvcixcbiAgLy8gc28gZW5hYmxlZCBvbmx5IGlmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gY29sbGFwc2VkLlxuICBpZiAoZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgIHZhciBsZWFmRWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZChkb21SYW5nZSk7XG4gICAgc2Nyb2xsSW50b1ZpZXcobGVhZkVsLCB7XG4gICAgICBzY3JvbGxNb2RlOiAnaWYtbmVlZGVkJ1xuICAgIH0pOyAvLyBAdHMtZXhwZWN0LWVycm9yIGFuIHVub3J0aG9kb3ggZGVsZXRlIEQ6XG5cbiAgICBkZWxldGUgbGVhZkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxyXG4gKi9cblxuXG52YXIgaXNFdmVudEhhbmRsZWQgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG5cblxuICB2YXIgc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCA9IGhhbmRsZXIoZXZlbnQpO1xuXG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuXG4gIHJldHVybiBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZXZlbnQncyB0YXJnZXQgaXMgYW4gaW5wdXQgZWxlbWVudFxyXG4gKi9cblxudmFyIGlzRE9NRXZlbnRUYXJnZXRJbnB1dCA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZShldmVudC50YXJnZXQpICYmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxyXG4gKi9cblxudmFyIGlzRE9NRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBmb2N1c2VkYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIEZvY3VzZWRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB1c2VGb2N1c2VkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChGb2N1c2VkQ29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xufVxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIHNlbGVjdG9yIGNvbnRleHQgaW4gYSB3YXkgdG8gY29udHJvbCByZXJlbmRlcnNcclxuICovXG5cblxudmFyIFNsYXRlU2VsZWN0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoe30pO1xuXG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbi8qKlxyXG4gKiB1c2UgcmVkdXggc3R5bGUgc2VsZWN0b3JzIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgb24gZXZlcnkga2V5c3Ryb2tlLlxyXG4gKiBCZWFyIGluIG1pbmQgcmVyZW5kZXJpbmcgY2FuIG9ubHkgcHJldmVudGVkIGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhIHZhbHVlIHR5cGUgb3IgZm9yIHJlZmVyZW5jZSB0eXBlcyAoZS5nLiBvYmplY3RzIGFuZCBhcnJheXMpIGFkZCBhIGN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvbi5cclxuICpcclxuICogRXhhbXBsZTpcclxuICogYGBgXHJcbiAqICBjb25zdCBpc1NlbGVjdGlvbkFjdGl2ZSA9IHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IEJvb2xlYW4oZWRpdG9yLnNlbGVjdGlvbikpO1xyXG4gKiBgYGBcclxuICovXG5cblxuZnVuY3Rpb24gdXNlU2xhdGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgZXF1YWxpdHlGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVmRXF1YWxpdHk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVTZWxlY3RvckNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTZWxlY3RvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgdmFyIHtcbiAgICBnZXRTbGF0ZSxcbiAgICBhZGRFdmVudExpc3RlbmVyXG4gIH0gPSBjb250ZXh0O1xuICB2YXIgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IHVzZVJlZigpO1xuICB2YXIgbGF0ZXN0U2VsZWN0b3IgPSB1c2VSZWYoKCkgPT4gbnVsbCk7XG4gIHZhciBsYXRlc3RTZWxlY3RlZFN0YXRlID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2VsZWN0ZWRTdGF0ZTtcblxuICB0cnkge1xuICAgIGlmIChzZWxlY3RvciAhPT0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudCB8fCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBzZWxlY3RvcihnZXRTbGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgJiYgaXNFcnJvcihlcnIpKSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIlxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuXCIuY29uY2F0KGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFjaywgXCJcXG5cXG5cIik7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgbGF0ZXN0U2VsZWN0b3IuY3VycmVudCA9IHNlbGVjdG9yO1xuICAgIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCA9IHNlbGVjdGVkU3RhdGU7XG4gICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3Rvci5jdXJyZW50KGdldFNsYXRlKCkpO1xuXG4gICAgICAgIGlmIChlcXVhbGl0eUZuKG5ld1NlbGVjdGVkU3RhdGUsIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBuZXdTZWxlY3RlZFN0YXRlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIGlnbm9yZSBhbGwgZXJyb3JzIGhlcmUsIHNpbmNlIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpcyByZS1yZW5kZXJlZCwgdGhlIHNlbGVjdG9ycyBhcmUgY2FsbGVkIGFnYWluLCBhbmRcbiAgICAgICAgLy8gd2lsbCB0aHJvdyBhZ2FpbiwgaWYgbmVpdGhlciBwcm9wcyBub3Igc3RvcmUgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlZFxuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSBlcnI7XG4gICAgICB9XG5cbiAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc3Vic2NyaWJlID0gYWRkRXZlbnRMaXN0ZW5lcihjaGVja0ZvclVwZGF0ZXMpO1xuICAgIGNoZWNrRm9yVXBkYXRlcygpO1xuICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xuICB9LCAvLyBkb24ndCByZXJlbmRlciBvbiBlcXVhbGl0eUZuIGNoYW5nZSBzaW5jZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gZGVmaW5lIGl0IGlubGluZVxuICBbYWRkRXZlbnRMaXN0ZW5lciwgZ2V0U2xhdGVdKTtcbiAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG59XG4vKipcclxuICogQ3JlYXRlIHNlbGVjdG9yIGNvbnRleHQgd2l0aCBlZGl0b3IgdXBkYXRpbmcgb24gZXZlcnkgZWRpdG9yIGNoYW5nZVxyXG4gKi9cblxuZnVuY3Rpb24gdXNlU2VsZWN0b3JDb250ZXh0KGVkaXRvcikge1xuICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB1c2VSZWYoW10pLmN1cnJlbnQ7XG4gIHZhciBzbGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgZWRpdG9yXG4gIH0pLmN1cnJlbnQ7XG4gIHZhciBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKGVkaXRvciA9PiB7XG4gICAgc2xhdGVSZWYuZWRpdG9yID0gZWRpdG9yO1xuICAgIGV2ZW50TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZWRpdG9yKSk7XG4gIH0sIFtldmVudExpc3RlbmVycywgc2xhdGVSZWZdKTtcbiAgdmFyIHNlbGVjdG9yQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTbGF0ZTogKCkgPT4gc2xhdGVSZWYuZWRpdG9yLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY2FsbGJhY2sgPT4ge1xuICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtldmVudExpc3RlbmVycywgc2xhdGVSZWZdKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImVkaXRvclwiLCBcImNoaWxkcmVuXCIsIFwib25DaGFuZ2VcIiwgXCJpbml0aWFsVmFsdWVcIl07XG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgcHJvdmlkZXIgdG8gaGFuZGxlIGBvbkNoYW5nZWAgZXZlbnRzLCBiZWNhdXNlIHRoZSBlZGl0b3JcclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cclxuICovXG5cbnZhciBTbGF0ZSA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgY2hpbGRyZW4sXG4gICAgb25DaGFuZ2UsXG4gICAgaW5pdGlhbFZhbHVlXG4gIH0gPSBwcm9wcyxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgdmFyIFtjb250ZXh0LCBzZXRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICBpZiAoIU5vZGUuaXNOb2RlTGlzdChpbml0aWFsVmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbU2xhdGVdIGluaXRpYWxWYWx1ZSBpcyBpbnZhbGlkISBFeHBlY3RlZCBhIGxpc3Qgb2YgZWxlbWVudHMgYnV0IGdvdDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShpbml0aWFsVmFsdWUpKSk7XG4gICAgfVxuXG4gICAgaWYgKCFFZGl0b3IuaXNFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBlZGl0b3IgaXMgaW52YWxpZCEgWW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShlZGl0b3IpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmNoaWxkcmVuID0gaW5pdGlhbFZhbHVlO1xuICAgIE9iamVjdC5hc3NpZ24oZWRpdG9yLCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMCxcbiAgICAgIGVkaXRvclxuICAgIH07XG4gIH0pO1xuICB2YXIge1xuICAgIHNlbGVjdG9yQ29udGV4dCxcbiAgICBvbkNoYW5nZTogaGFuZGxlU2VsZWN0b3JDaGFuZ2VcbiAgfSA9IHVzZVNlbGVjdG9yQ29udGV4dChlZGl0b3IpO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0KHByZXZDb250ZXh0ID0+ICh7XG4gICAgICB2OiBwcmV2Q29udGV4dC52ICsgMSxcbiAgICAgIGVkaXRvclxuICAgIH0pKTtcbiAgICBoYW5kbGVTZWxlY3RvckNoYW5nZShlZGl0b3IpO1xuICB9LCBbZWRpdG9yLCBoYW5kbGVTZWxlY3RvckNoYW5nZSwgb25DaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsIG9uQ29udGV4dENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIG9uQ29udGV4dENoYW5nZV0pO1xuICB2YXIgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBmbiA9ICgpID0+IHNldElzRm9jdXNlZChSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG5cbiAgICBpZiAoUkVBQ1RfTUFKT1JfVkVSU0lPTiA+PSAxNykge1xuICAgICAgLy8gSW4gUmVhY3QgPj0gMTcgb25Gb2N1cyBhbmQgb25CbHVyIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuXG4gICAgICAvLyBUaGVyZWZvcmUgaW4gb3JkZXIgZm9yIDxFZGl0YWJsZSAvPidzIGhhbmRsZXJzIHRvIHJ1biBmaXJzdCwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKVxuICAgICAgLy8gdG8gcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlLCB3ZSBoYXZlIHRvIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIHdpdGhvdXQgdXNlQ2FwdHVyZSBoZXJlLlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGZuLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbGF0ZVNlbGVjdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZWxlY3RvckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0LmVkaXRvclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c2VkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBpc0ZvY3VzZWRcbiAgfSwgY2hpbGRyZW4pKSkpO1xufTtcblxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB1c2VTbGF0ZVN0YXRpYyBpbnN0ZWFkLlxyXG4gKi9cblxudmFyIHVzZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZUVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2xhdGUgc2VsZWN0aW9uLlxyXG4gKiBPbmx5IHRyaWdnZXJzIGEgcmVyZW5kZXIgd2hlbiB0aGUgc2VsZWN0aW9uIGFjdHVhbGx5IGNoYW5nZXNcclxuICovXG5cbnZhciB1c2VTbGF0ZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IGVkaXRvci5zZWxlY3Rpb24sIGlzU2VsZWN0aW9uRXF1YWwpO1xufTtcblxudmFyIGlzU2VsZWN0aW9uRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiB0cnVlO1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFJhbmdlLmVxdWFscyhhLCBiKTtcbn07XG5cbi8qKlxyXG4gKiBVdGlsaXRpZXMgZm9yIHNpbmdsZS1saW5lIGRlbGV0aW9uXHJcbiAqL1xuXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IChyZWN0LCBjb21wYXJlUmVjdCkgPT4ge1xuICB2YXIgbWlkZGxlID0gKGNvbXBhcmVSZWN0LnRvcCArIGNvbXBhcmVSZWN0LmJvdHRvbSkgLyAyO1xuICByZXR1cm4gcmVjdC50b3AgPD0gbWlkZGxlICYmIHJlY3QuYm90dG9tID49IG1pZGRsZTtcbn07XG5cbnZhciBhcmVSYW5nZXNTYW1lTGluZSA9IChlZGl0b3IsIHJhbmdlMSwgcmFuZ2UyKSA9PiB7XG4gIHZhciByZWN0MSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdDIgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXHJcbiAqIEEgaGVscGVyIHV0aWxpdHkgdGhhdCByZXR1cm5zIHRoZSBlbmQgcG9ydGlvbiBvZiBhIGBSYW5nZWBcclxuICogd2hpY2ggaXMgbG9jYXRlZCBvbiBhIHNpbmdsZSBsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3Igb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge1JhbmdlfSBwYXJlbnRSYW5nZSBUaGUgcGFyZW50IHJhbmdlIHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcclxuICovXG5cblxudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gKGVkaXRvciwgcGFyZW50UmFuZ2UpID0+IHtcbiAgdmFyIHBhcmVudFJhbmdlQm91bmRhcnkgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBSYW5nZS5lbmQocGFyZW50UmFuZ2UpKTtcbiAgdmFyIHBvc2l0aW9ucyA9IEFycmF5LmZyb20oRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICBhdDogcGFyZW50UmFuZ2VcbiAgfSkpO1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG5cbiAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuXG4gIHdoaWxlIChtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0KSB7XG4gICAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW21pZGRsZV0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgfVxuXG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG5cbiAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tyaWdodF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIGB3aXRoUmVhY3RgIGFkZHMgUmVhY3QgYW5kIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cclxuICpcclxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcclxuICogdGhpcyBwbHVnaW4uXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXHJcbiAqL1xuXG52YXIgd2l0aFJlYWN0ID0gZnVuY3Rpb24gd2l0aFJlYWN0KGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGFwcGx5LFxuICAgIG9uQ2hhbmdlLFxuICAgIGRlbGV0ZUJhY2t3YXJkLFxuICAgIGFkZE1hcmssXG4gICAgcmVtb3ZlTWFya1xuICB9ID0gZTsgLy8gVGhlIFdlYWtNYXAgd2hpY2ggbWFwcyBhIGtleSB0byBhIHNwZWNpZmljIEhUTUxFbGVtZW50IG11c3QgYmUgc2NvcGVkIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG9cbiAgLy8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVkaXRvcnMgaW4gdGhlIERPTSB0aGF0IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuXG4gIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5zZXQoZSwgbmV3IFdlYWtNYXAoKSk7XG5cbiAgZS5hZGRNYXJrID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GLCBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG5cbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcblxuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIGFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH07XG5cbiAgZS5yZW1vdmVNYXJrID0ga2V5ID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJMjtcblxuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMiAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIHJlbW92ZU1hcmsoa2V5KTtcbiAgfTtcblxuICBlLmRlbGV0ZUJhY2t3YXJkID0gdW5pdCA9PiB7XG4gICAgaWYgKHVuaXQgIT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgIH1cblxuICAgIGlmIChlLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlLnNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBwYXJlbnRCbG9ja0VudHJ5ID0gRWRpdG9yLmFib3ZlKGUsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlLCBuKSxcbiAgICAgICAgYXQ6IGUuc2VsZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmVudEJsb2NrRW50cnkpIHtcbiAgICAgICAgdmFyIFssIHBhcmVudEJsb2NrUGF0aF0gPSBwYXJlbnRCbG9ja0VudHJ5O1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudFJhbmdlID0gRWRpdG9yLnJhbmdlKGUsIHBhcmVudEJsb2NrUGF0aCwgZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lUmFuZ2UgPSBmaW5kQ3VycmVudExpbmVSYW5nZShlLCBwYXJlbnRFbGVtZW50UmFuZ2UpO1xuXG4gICAgICAgIGlmICghUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlLCB7XG4gICAgICAgICAgICBhdDogY3VycmVudExpbmVSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBUaGlzIGF0dGVtcHRzIHRvIHJlc2V0IHRoZSBOT0RFX1RPX0tFWSBlbnRyeSB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBhcyBhcHBseSgpIGNoYW5nZXMgdGhlIG9iamVjdCByZWZlcmVuY2UgYW5kIGhlbmNlIGludmFsaWRhdGVzIHRoZSBOT0RFX1RPX0tFWSBlbnRyeVxuXG5cbiAgZS5hcHBseSA9IG9wID0+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ0RpZmZzICE9PSBudWxsICYmIHBlbmRpbmdEaWZmcyAhPT0gdm9pZCAwICYmIHBlbmRpbmdEaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHBlbmRpbmdEaWZmcy5tYXAodGV4dERpZmYgPT4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGUsIHRyYW5zZm9ybWVkKTtcbiAgICB9XG5cbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlLCB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ1NlbGVjdGlvbiwgb3ApKTtcbiAgICB9XG5cbiAgICB2YXIgcGVuZGluZ0FjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ0FjdGlvbiAhPT0gbnVsbCAmJiBwZW5kaW5nQWN0aW9uICE9PSB2b2lkIDAgJiYgcGVuZGluZ0FjdGlvbi5hdCkge1xuICAgICAgdmFyIGF0ID0gUG9pbnQuaXNQb2ludChwZW5kaW5nQWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdBY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdBY3Rpb24uYXQpID8gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKSA6IHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCk7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGUsIGF0ID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwZW5kaW5nQWN0aW9uKSwge30sIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIG9wLnBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG5cbiAgICAgICAgICAvLyBTZWxlY3Rpb24gd2FzIG1hbnVhbGx5IHNldCwgZG9uJ3QgcmVzdG9yZSB0aGUgdXNlciBzZWxlY3Rpb24gYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAgICAgICAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKG9wLnBhdGgpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIHByZXZQYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24oUGF0aC5wYXJlbnQob3AucGF0aCksIFBhdGgucGFyZW50KG9wLm5ld1BhdGgpKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBjb21tb25QYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShvcCk7XG5cbiAgICBmb3IgKHZhciBbcGF0aCwga2V5XSBvZiBtYXRjaGVzKSB7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZSwgcGF0aCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZS5zZXRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGU7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogc3RhcnQucGF0aFxuICAgIH0pO1xuICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IGVuZC5wYXRoXG4gICAgfSk7XG5cbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgYSBmYWtlIHNlbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgYSBCYXNlNjQtZW5jb2RlZCBjb3B5IG9mIHRoZVxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSBIVE1MLCB0byBkZWNvZGUgb24gZnV0dXJlIHBhc3Rlcy5cblxuXG4gICAgdmFyIGRvbVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICB2YXIgYXR0YWNoID0gY29udGVudHMuY2hpbGROb2Rlc1swXTsgLy8gTWFrZSBzdXJlIGF0dGFjaCBpcyBub24tZW1wdHksIHNpbmNlIGVtcHR5IG5vZGVzIHdpbGwgbm90IGdldCBjb3BpZWQuXG5cbiAgICBjb250ZW50cy5jaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIFt2b2lkTm9kZV0gPSBlbmRWb2lkO1xuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9IC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuXG5cbiAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1zcGFjZXJdJyk7XG4gICAgfSAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cblxuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKHp3ID0+IHtcbiAgICAgIHZhciBpc05ld2xpbmUgPSB6dy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAnbic7XG4gICAgICB6dy50ZXh0Q29udGVudCA9IGlzTmV3bGluZSA/ICdcXG4nIDogJyc7XG4gICAgfSk7IC8vIFNldCBhIGBkYXRhLXNsYXRlLWZyYWdtZW50YCBhdHRyaWJ1dGUgb24gYSBub24tZW1wdHkgbm9kZSwgc28gaXQgc2hvd3MgdXBcbiAgICAvLyBpbiB0aGUgSFRNTCwgYW5kIGNhbiBiZSB1c2VkIGZvciBpbnRyYS1TbGF0ZSBwYXN0aW5nLiBJZiBpdCdzIGEgdGV4dFxuICAgIC8vIG5vZGUsIHdyYXAgaXQgaW4gYSBgPHNwYW4+YCBzbyB3ZSBoYXZlIHNvbWV0aGluZyB0byBzZXQgYW4gYXR0cmlidXRlIG9uLlxuXG4gICAgaWYgKGlzRE9NVGV4dChhdHRhY2gpKSB7XG4gICAgICB2YXIgc3BhbiA9IGF0dGFjaC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTsgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuXG4gICAgICBzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKTtcbiAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgYXR0YWNoID0gc3BhbjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSBlLmdldEZyYWdtZW50KCk7XG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGZyYWdtZW50KTtcbiAgICB2YXIgZW5jb2RlZCA9IHdpbmRvdy5idG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcbiAgICBhdHRhY2guc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWZyYWdtZW50JywgZW5jb2RlZCk7XG4gICAgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSksIGVuY29kZWQpOyAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG5cbiAgICB2YXIgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICd0cnVlJyk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBkaXYuaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBnZXRQbGFpblRleHQoZGl2KSk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKCFlLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSkge1xuICAgICAgZS5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgZS5pbnNlcnRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICAvKipcclxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxyXG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gQ09NUEFUOiBSZWFjdCA8IDE4IGRvZXNuJ3QgYmF0Y2ggYHNldFN0YXRlYCBob29rIGNhbGxzLCB3aGljaCBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIGNoaWxkcmVuIGFuZCBzZWxlY3Rpb24gY2FuIGdldCBvdXQgb2Ygc3luYyBmb3Igb25lIHJlbmRlclxuICAgIC8vIHBhc3MuIFNvIHdlIGhhdmUgdG8gdXNlIHRoaXMgdW5zdGFibGUgQVBJIHRvIGVuc3VyZSBpdCBiYXRjaGVzIHRoZW0uXG4gICAgLy8gKDIwMTkvMTIvMDMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDI1OSNpc3N1ZWNvbW1lbnQtNDM5NzAyMzY3XG4gICAgdmFyIG1heWJlQmF0Y2hVcGRhdGVzID0gUkVBQ1RfTUFKT1JfVkVSU0lPTiA8IDE4ID8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgOiBjYWxsYmFjayA9PiBjYWxsYmFjaygpO1xuICAgIG1heWJlQmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIHZhciBvbkNvbnRleHRDaGFuZ2UgPSBFRElUT1JfVE9fT05fQ0hBTkdFLmdldChlKTtcblxuICAgICAgaWYgKG9uQ29udGV4dENoYW5nZSkge1xuICAgICAgICBvbkNvbnRleHRDaGFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgb25DaGFuZ2Uob3B0aW9ucyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGU7XG59O1xuXG52YXIgZ2V0TWF0Y2hlcyA9IChlLCBwYXRoKSA9PiB7XG4gIHZhciBtYXRjaGVzID0gW107XG5cbiAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZSwge1xuICAgIGF0OiBwYXRoXG4gIH0pKSB7XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZSwgbik7XG4gICAgbWF0Y2hlcy5wdXNoKFtwLCBrZXldKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxuZXhwb3J0IHsgRGVmYXVsdEVsZW1lbnQsIERlZmF1bHRMZWFmLCBEZWZhdWx0UGxhY2Vob2xkZXIsIEVkaXRhYmxlLCBSZWFjdEVkaXRvciwgU2xhdGUsIHVzZUVkaXRvciwgdXNlRm9jdXNlZCwgdXNlUmVhZE9ubHksIHVzZVNlbGVjdGVkLCB1c2VTbGF0ZSwgdXNlU2xhdGVTZWxlY3Rpb24sIHVzZVNsYXRlU2VsZWN0b3IsIHVzZVNsYXRlU3RhdGljLCB1c2VTbGF0ZVdpdGhWLCB3aXRoUmVhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldERpcmVjdGlvbiIsImRlYm91bmNlIiwidGhyb3R0bGUiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU3RhdGUiLCJtZW1vIiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwiQ29tcG9uZW50IiwidXNlUmVkdWNlciIsInVzZU1lbW8iLCJzY3JvbGxJbnRvVmlldyIsIlRyYW5zZm9ybXMiLCJFbGVtZW50IiwiRWxlbWVudCQxIiwiRWRpdG9yIiwiU2NydWJiZXIiLCJSYW5nZSIsIlBhdGgiLCJQb2ludCIsIk5vZGUiLCJUZXh0IiwiVGV4dCQxIiwiUmVzaXplT2JzZXJ2ZXIiLCJpc0hvdGtleSIsIlJlYWN0RE9NIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIkVkaXRvckNvbnRleHQiLCJ1c2VTbGF0ZVN0YXRpYyIsImVkaXRvciIsIkVycm9yIiwiUkVBQ1RfTUFKT1JfVkVSU0lPTiIsInBhcnNlSW50IiwidmVyc2lvbiIsInNwbGl0IiwiSVNfSU9TIiwibmF2aWdhdG9yIiwidGVzdCIsInVzZXJBZ2VudCIsIndpbmRvdyIsIk1TU3RyZWFtIiwiSVNfQVBQTEUiLCJJU19BTkRST0lEIiwiSVNfRklSRUZPWCIsIklTX1dFQktJVCIsIklTX0VER0VfTEVHQUNZIiwiSVNfQ0hST01FIiwiSVNfQ0hST01FX0xFR0FDWSIsIklTX0FORFJPSURfQ0hST01FX0xFR0FDWSIsIklTX0ZJUkVGT1hfTEVHQUNZIiwiSVNfVUNfTU9CSUxFIiwiSVNfV0VDSEFUQlJPV1NFUiIsIkNBTl9VU0VfRE9NIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIiwiZ2xvYmFsVGhpcyIsIklucHV0RXZlbnQiLCJnZXRUYXJnZXRSYW5nZXMiLCJOT0RFX1RPX0lOREVYIiwiV2Vha01hcCIsIk5PREVfVE9fUEFSRU5UIiwiRURJVE9SX1RPX1dJTkRPVyIsIkVESVRPUl9UT19FTEVNRU5UIiwiRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQiLCJFTEVNRU5UX1RPX05PREUiLCJOT0RFX1RPX0VMRU1FTlQiLCJOT0RFX1RPX0tFWSIsIkVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCIsIklTX1JFQURfT05MWSIsIklTX0ZPQ1VTRUQiLCJJU19DT01QT1NJTkciLCJFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04iLCJFRElUT1JfVE9fT05fQ0hBTkdFIiwiRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIIiwiRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTIiwiRURJVE9SX1RPX1VTRVJfTUFSS1MiLCJFRElUT1JfVE9fUEVORElOR19ESUZGUyIsIkVESVRPUl9UT19QRU5ESU5HX0FDVElPTiIsIkVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiIsIkVESVRPUl9UT19GT1JDRV9SRU5ERVIiLCJQTEFDRUhPTERFUl9TWU1CT0wiLCJTeW1ib2wiLCJNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCIsIkRPTVRleHQiLCJnZXREZWZhdWx0VmlldyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzRE9NQ29tbWVudCIsImlzRE9NTm9kZSIsIm5vZGVUeXBlIiwiaXNET01FbGVtZW50IiwiaXNET01TZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiU2VsZWN0aW9uIiwiaXNET01UZXh0IiwiaXNQbGFpblRleHRPbmx5UGFzdGUiLCJldmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidHlwZXMiLCJub3JtYWxpemVET01Qb2ludCIsImRvbVBvaW50Iiwibm9kZSIsIm9mZnNldCIsImNoaWxkTm9kZXMiLCJpc0xhc3QiLCJpbmRleCIsImdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleCIsImdldEVkaXRhYmxlQ2hpbGQiLCJ0ZXh0Q29udGVudCIsImhhc1NoYWRvd1Jvb3QiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwidG9TdHJpbmciLCJkaXJlY3Rpb24iLCJjaGlsZCIsInRyaWVkRm9yd2FyZCIsInRyaWVkQmFja3dhcmQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRQbGFpblRleHQiLCJkb21Ob2RlIiwidGV4dCIsIm5vZGVWYWx1ZSIsImNoaWxkTm9kZSIsIkFycmF5IiwiZnJvbSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRhZ05hbWUiLCJjYXRjaFNsYXRlRnJhZ21lbnQiLCJnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlIiwiZGF0YVRyYW5zZmVyIiwiaHRtbERhdGEiLCJmcmFnbWVudCIsIm1hdGNoIiwiaXNUcmFja2VkTXV0YXRpb24iLCJtdXRhdGlvbiIsImJhdGNoIiwibWF0Y2hlcyIsIlJlYWN0RWRpdG9yIiwiZ2V0V2luZG93IiwiY29udGFpbnMiLCJoYXNET01Ob2RlIiwiZWRpdGFibGUiLCJwYXJlbnRNdXRhdGlvbiIsImZpbmQiLCJfcmVmIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsIl9ub2RlIiwibiIsIktleSIsImNvbnN0cnVjdG9yIiwiaWQiLCJjb25jYXQiLCJhbmRyb2lkUGVuZGluZ0RpZmZzIiwiZ2V0IiwiYW5kcm9pZFNjaGVkdWxlRmx1c2giLCJfRURJVE9SX1RPX1NDSEVEVUxFX0YiLCJibHVyIiwiZWwiLCJ0b0RPTU5vZGUiLCJyb290IiwiZmluZERvY3VtZW50T3JTaGFkb3dSb290Iiwic2V0IiwiYWN0aXZlRWxlbWVudCIsImRlc2VsZWN0Iiwic2VsZWN0aW9uIiwiZG9tU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsInJlbW92ZUFsbFJhbmdlcyIsImdldFJvb3ROb2RlIiwiRG9jdW1lbnQiLCJTaGFkb3dSb290IiwiZmluZEV2ZW50UmFuZ2UiLCJuYXRpdmVFdmVudCIsImNsaWVudFgiLCJ4IiwiY2xpZW50WSIsInkiLCJ0b1NsYXRlTm9kZSIsInBhdGgiLCJmaW5kUGF0aCIsImlzRWxlbWVudCIsImlzVm9pZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc1ByZXYiLCJpc0lubGluZSIsImxlZnQiLCJ3aWR0aCIsInRvcCIsImhlaWdodCIsImVkZ2UiLCJwb2ludCIsImJlZm9yZSIsImFmdGVyIiwiX3JhbmdlIiwicmFuZ2UiLCJkb21SYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJwb3NpdGlvbiIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwib2Zmc2V0Tm9kZSIsInNldEVuZCIsInRvU2xhdGVSYW5nZSIsImV4YWN0TWF0Y2giLCJzdXBwcmVzc1Rocm93IiwiZmluZEtleSIsImlzRWRpdG9yIiwidW5zaGlmdCIsInN0cmluZ2lmeSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJlZGl0b3JFbCIsInRhcmdldEVsIiwicGFyZW50RWxlbWVudCIsImVyciIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsImNsb3Nlc3QiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImhhc0VkaXRhYmxlVGFyZ2V0IiwiaGFzUmFuZ2UiLCJhbmNob3IiLCJoYXNQYXRoIiwiaGFzU2VsZWN0YWJsZVRhcmdldCIsImlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkIiwiaGFzVGFyZ2V0IiwiaW5zZXJ0RGF0YSIsImRhdGEiLCJpbnNlcnRGcmFnbWVudERhdGEiLCJpbnNlcnRUZXh0RGF0YSIsImlzQ29tcG9zaW5nIiwiaXNGb2N1c2VkIiwiaXNSZWFkT25seSIsInNsYXRlTm9kZSIsInNldEZyYWdtZW50RGF0YSIsIm9yaWdpbkV2ZW50IiwiS0VZX1RPX0VMRU1FTlQiLCJ0b0RPTVBvaW50Iiwidm9pZCIsImF0Iiwic2VsZWN0b3IiLCJ0ZXh0cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzdGFydCIsImF0dHIiLCJ0cnVlTGVuZ3RoIiwiZW5kIiwibmV4dFRleHQiLCJoYXNBdHRyaWJ1dGUiLCJfbmV4dFRleHQkdGV4dENvbnRlbnQiLCJkb21UZXh0Iiwic3RhcnRzV2l0aCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ0b0RPTVJhbmdlIiwiaXNCYWNrd2FyZCIsImRvbUFuY2hvciIsImRvbUZvY3VzIiwiaXNDb2xsYXBzZWQiLCJzdGFydE5vZGUiLCJzdGFydE9mZnNldCIsImVuZE5vZGUiLCJlbmRPZmZzZXQiLCJzdGFydEVsIiwiaXNTdGFydEF0WmVyb1dpZHRoIiwiZW5kRWwiLCJpc0VuZEF0WmVyb1dpZHRoIiwiZG9tRWwiLCJ0b1NsYXRlUG9pbnQiLCJuZWFyZXN0Tm9kZSIsIm5lYXJlc3RPZmZzZXQiLCJ0ZXh0Tm9kZSIsIl9kb21Ob2RlJHRleHRDb250ZW50IiwiX2RvbU5vZGUkdGV4dENvbnRlbnQyIiwicG90ZW50aWFsVm9pZE5vZGUiLCJ2b2lkTm9kZSIsImxlYWZOb2RlIiwiY29udGVudHMiLCJjbG9uZUNvbnRlbnRzIiwicmVtb3ZhbHMiLCJzbGljZSIsImZvckVhY2giLCJ0ZXh0Q29udGV4dCIsInJlbW92ZUNoaWxkIiwibGVhZk5vZGVzIiwiY3VycmVudCIsImVuZHNXaXRoIiwiX3NsYXRlTm9kZSIsIl9wYXRoIiwiX29mZnNldCIsInF1ZXJ5U2VsZWN0b3IiLCJzdGFydENvbnRhaW5lciIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZmlyc3RSYW5nZSIsImdldFJhbmdlQXQiLCJsYXN0UmFuZ2UiLCJIVE1MVGFibGVSb3dFbGVtZW50IiwiZ2V0TGFzdENoaWxkcmVuIiwiZWxlbWVudCIsImNoaWxkRWxlbWVudENvdW50IiwiY2hpbGRyZW4iLCJmaXJzdE5vZGVSb3ciLCJsYXN0Tm9kZVJvdyIsImZpcnN0Tm9kZSIsImxhc3ROb2RlIiwiSFRNTEVsZW1lbnQiLCJpbm5lckhUTUwiLCJlbmRDb250YWluZXIiLCJjb2xsYXBzZWQiLCJfYW5jaG9yTm9kZSR0ZXh0Q29udGUiLCJpc0V4cGFuZGVkIiwiaXNGb3J3YXJkIiwibW9kZSIsInVuaGFuZ1JhbmdlIiwidm9pZHMiLCJ2ZXJpZnlEaWZmU3RhdGUiLCJ0ZXh0RGlmZiIsImRpZmYiLCJpc1RleHQiLCJuZXh0UGF0aCIsIm5leHQiLCJuZXh0Tm9kZSIsImFwcGx5U3RyaW5nRGlmZiIsIl9sZW4iLCJkaWZmcyIsIl9rZXkiLCJyZWR1Y2UiLCJsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoIiwic3RyIiwiYW5vdGhlciIsImNoYXJBdCIsImxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgiLCJub3JtYWxpemVTdHJpbmdEaWZmIiwidGFyZ2V0VGV4dCIsInJlbW92ZWRUZXh0IiwicHJlZml4TGVuZ3RoIiwic3VmZml4TGVuZ3RoIiwibm9ybWFsaXplZCIsIm1lcmdlU3RyaW5nRGlmZnMiLCJhIiwiYiIsIm92ZXJsYXAiLCJhcHBsaWVkIiwic2xpY2VFbmQiLCJ0YXJnZXRSYW5nZSIsIm5vcm1hbGl6ZVBvaW50IiwibGVhZiIsInBhcmVudEJsb2NrIiwiYWJvdmUiLCJpc0Jsb2NrIiwiZW50cnkiLCJpc0Rlc2NlbmRhbnQiLCJub3JtYWxpemVSYW5nZSIsInRyYW5zZm9ybVBlbmRpbmdQb2ludCIsIm9wIiwicGVuZGluZ0RpZmZzIiwiZXF1YWxzIiwidHJhbnNmb3JtIiwiYWZmaW5pdHkiLCJfYW5jaG9yIiwiX3RyYW5zZm9ybWVkIiwidHJhbnNmb3JtZWQiLCJ0eXBlIiwidHJhbnNmb3JtUGVuZGluZ1JhbmdlIiwidHJhbnNmb3JtVGV4dERpZmYiLCJuZXdQYXRoIiwib3duS2V5cyQzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJSRVNPTFZFX0RFTEFZIiwiRkxVU0hfREVMQVkiLCJkZWJ1ZyIsImlzRGF0YVRyYW5zZmVyIiwibmFtZSIsImNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIiLCJzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlIiwib25ET01TZWxlY3Rpb25DaGFuZ2UiLCJmbHVzaGluZyIsImNvbXBvc2l0aW9uRW5kVGltZW91dElkIiwiZmx1c2hUaW1lb3V0SWQiLCJhY3Rpb25UaW1lb3V0SWQiLCJpZENvdW50ZXIiLCJpbnNlcnRQb3NpdGlvbkhpbnQiLCJhcHBseVBlbmRpbmdTZWxlY3Rpb24iLCJwZW5kaW5nU2VsZWN0aW9uIiwiZGVsZXRlIiwic2VsZWN0IiwicGVyZm9ybUFjdGlvbiIsImFjdGlvbiIsImlzUG9pbnQiLCJfdGFyZ2V0UmFuZ2UiLCJydW4iLCJmbHVzaCIsImNsZWFyVGltZW91dCIsImhhc1BlbmRpbmdEaWZmcyIsImhhc1BlbmRpbmdBY3Rpb24iLCJzZXRUaW1lb3V0Iiwic2VsZWN0aW9uUmVmIiwicmFuZ2VSZWYiLCJtYXJrcyIsInNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlIiwiX0VESVRPUl9UT19QRU5ESU5HX0RJIiwiX0VESVRPUl9UT19QRU5ESU5HX0RJMiIsInBlbmRpbmdNYXJrcyIsImluc2VydFRleHQiLCJkZWxldGVGcmFnbWVudCIsIl9yZWYyIiwiY2FuY2VsIiwidW5yZWYiLCJ1c2VyTWFya3MiLCJvbkNoYW5nZSIsImhhbmRsZUNvbXBvc2l0aW9uRW5kIiwiX2V2ZW50IiwiaGFuZGxlQ29tcG9zaXRpb25TdGFydCIsInVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSIsImZvcmNlSGlkZSIsInBsYWNlaG9sZGVyRWxlbWVudCIsInN0eWxlIiwicmVtb3ZlUHJvcGVydHkiLCJzdG9yZURpZmYiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkzIiwiaWR4IiwiZmluZEluZGV4IiwiY2hhbmdlIiwibWVyZ2VkIiwic3BsaWNlIiwic2NoZWR1bGVBY3Rpb24iLCJoYW5kbGVET01CZWZvcmVJbnB1dCIsIl90YXJnZXRSYW5nZTIiLCJpbnB1dFR5cGUiLCJuYXRpdmVUYXJnZXRSYW5nZSIsImNhblN0b3JlRGlmZiIsIl9zdGFydCIsIl9lbmQiLCJlZGdlcyIsIl9sZWFmIiwicmVsZXZhbnRQZW5kaW5nRGlmZnMiLCJoYW5kbGVVc2VyU2VsZWN0IiwidGFyZ2V0Tm9kZSIsImRlbGV0ZUZvcndhcmQiLCJfbmF0aXZlVGFyZ2V0UmFuZ2UiLCJuYXRpdmVDb2xsYXBzZWQiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJpbnNlcnRTb2Z0QnJlYWsiLCJpbnNlcnRCcmVhayIsIl90ZXh0IiwicmVwbGFjZSIsInBhcnRzIiwibGluZSIsIl9zdGFydDIiLCJfZW5kMiIsIl9kaWZmIiwiaGludFBvc2l0aW9uIiwic2VhcmNoIiwiZGlmZlBvc2l0aW9uIiwic2NoZWR1bGVGbHVzaCIsIl9FRElUT1JfVE9fUEVORElOR19ESTQiLCJoYXNQZW5kaW5nQ2hhbmdlcyIsImlzRmx1c2hpbmciLCJwYXRoQ2hhbmdlZCIsInBhcmVudFBhdGhDaGFuZ2VkIiwiaGFuZGxlSW5wdXQiLCJoYW5kbGVLZXlEb3duIiwiXyIsImhhbmRsZURvbU11dGF0aW9ucyIsIm11dGF0aW9ucyIsInNvbWUiLCJfRURJVE9SX1RPX0ZPUkNFX1JFTkQiLCJ1c2VJc01vdW50ZWQiLCJpc01vdW50ZWRSZWYiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrIiwibXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJ0YWtlUmVjb3JkcyIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiX2V4Y2x1ZGVkJDMiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwidXNlQW5kcm9pZElucHV0TWFuYWdlciIsImlzTW91bnRlZCIsImlucHV0TWFuYWdlciIsIl9leGNsdWRlZCQyIiwiX2V4Y2x1ZGVkMiQxIiwic2hhbGxvd0NvbXBhcmUiLCJvYmoxIiwib2JqMiIsImV2ZXJ5IiwiaGFzT3duUHJvcGVydHkiLCJpc0RlY29yYXRpb25GbGFnc0VxdWFsIiwib3RoZXIiLCJyYW5nZU93blByb3BzIiwib3RoZXJPd25Qcm9wcyIsImlzRWxlbWVudERlY29yYXRpb25zRXF1YWwiLCJsaXN0IiwiaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCIsIlN0cmluZyIsInByb3BzIiwicGFyZW50UGF0aCIsImlzTWFya1BsYWNlaG9sZGVyIiwiWmVyb1dpZHRoU3RyaW5nIiwic3RyaW5nIiwiaXNMaW5lQnJlYWsiLCJUZXh0U3RyaW5nIiwiaXNUcmFpbGluZyIsInJlZiIsImdldFRleHRDb250ZW50IiwiaW5pdGlhbFRleHQiLCJ0ZXh0V2l0aFRyYWlsaW5nIiwiTWVtb2l6ZWRUZXh0JDEiLCJhdHRyaWJ1dGVzIiwiYXNzaWduIiwiZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIiLCJwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyIiwicmVsZWFzZU9ic2VydmVyIiwiY2xlYXJUaW1lb3V0UmVmIiwidGltZW91dFJlZiIsIkxlYWYiLCJyZW5kZXJQbGFjZWhvbGRlciIsInJlbmRlckxlYWYiLCJEZWZhdWx0TGVhZiIsInBsYWNlaG9sZGVyUmVmIiwic2hvd1BsYWNlaG9sZGVyIiwic2V0U2hvd1BsYWNlaG9sZGVyIiwic2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZiIsImNhbGxiYWNrUGxhY2Vob2xkZXJSZWYiLCJwbGFjZWhvbGRlckVsIiwiX2xlYWYkb25QbGFjZWhvbGRlclJlIiwib25QbGFjZWhvbGRlclJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyJDEiLCJfbGVhZiRvblBsYWNlaG9sZGVyUmUyIiwibGVhZklzUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlclByb3BzIiwicGxhY2Vob2xkZXIiLCJwb2ludGVyRXZlbnRzIiwibWF4V2lkdGgiLCJvcGFjaXR5IiwidXNlclNlbGVjdCIsInRleHREZWNvcmF0aW9uIiwiV2Via2l0VXNlck1vZGlmeSIsImNvbnRlbnRFZGl0YWJsZSIsIkZyYWdtZW50IiwiTWVtb2l6ZWRMZWFmIiwicHJldiIsImRlY29yYXRpb25zIiwibGVhdmVzIiwiY2FsbGJhY2tSZWYiLCJzcGFuIiwiTWVtb2l6ZWRUZXh0IiwicmVuZGVyRWxlbWVudCIsInAiLCJEZWZhdWx0RWxlbWVudCIsInJlYWRPbmx5IiwidXNlUmVhZE9ubHkiLCJ1c2VDaGlsZHJlbiIsImhhc0lubGluZXMiLCJkaXIiLCJUYWciLCJjb2xvciIsIm91dGxpbmUiLCJNZW1vaXplZEVsZW1lbnQiLCJEZWNvcmF0ZUNvbnRleHQiLCJ1c2VEZWNvcmF0ZSIsIlNlbGVjdGVkQ29udGV4dCIsInVzZVNlbGVjdGVkIiwiZGVjb3JhdGUiLCJpc0xlYWZCbG9jayIsInNlbCIsImludGVyc2VjdGlvbiIsImRzIiwiZGVjIiwiZCIsIlByb3ZpZGVyIiwiUmVhZE9ubHlDb250ZXh0IiwiU2xhdGVDb250ZXh0IiwidXNlU2xhdGUiLCJjb250ZXh0IiwidXNlU2xhdGVXaXRoViIsInVzZVRyYWNrVXNlcklucHV0IiwicmVjZWl2ZWRVc2VySW5wdXQiLCJhbmltYXRpb25GcmFtZUlkUmVmIiwib25Vc2VySW5wdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIlRSSVBMRV9DTElDSyIsIkhPVEtFWVMiLCJib2xkIiwiY29tcG9zZSIsIm1vdmVCYWNrd2FyZCIsIm1vdmVGb3J3YXJkIiwibW92ZVdvcmRCYWNrd2FyZCIsIm1vdmVXb3JkRm9yd2FyZCIsImV4dGVuZEJhY2t3YXJkIiwiZXh0ZW5kRm9yd2FyZCIsIml0YWxpYyIsInNwbGl0QmxvY2siLCJ1bmRvIiwiQVBQTEVfSE9US0VZUyIsIm1vdmVMaW5lQmFja3dhcmQiLCJtb3ZlTGluZUZvcndhcmQiLCJkZWxldGVMaW5lQmFja3dhcmQiLCJkZWxldGVMaW5lRm9yd2FyZCIsImRlbGV0ZVdvcmRCYWNrd2FyZCIsImRlbGV0ZVdvcmRGb3J3YXJkIiwiZXh0ZW5kTGluZUJhY2t3YXJkIiwiZXh0ZW5kTGluZUZvcndhcmQiLCJyZWRvIiwidHJhbnNwb3NlQ2hhcmFjdGVyIiwiV0lORE9XU19IT1RLRVlTIiwiY3JlYXRlIiwiZ2VuZXJpYyIsImFwcGxlIiwid2luZG93cyIsImlzR2VuZXJpYyIsImlzQXBwbGUiLCJpc1dpbmRvd3MiLCJIb3RrZXlzIiwiaXNCb2xkIiwiaXNDb21wb3NlIiwiaXNNb3ZlQmFja3dhcmQiLCJpc01vdmVGb3J3YXJkIiwiaXNEZWxldGVCYWNrd2FyZCIsImlzRGVsZXRlRm9yd2FyZCIsImlzRGVsZXRlTGluZUJhY2t3YXJkIiwiaXNEZWxldGVMaW5lRm9yd2FyZCIsImlzRGVsZXRlV29yZEJhY2t3YXJkIiwiaXNEZWxldGVXb3JkRm9yd2FyZCIsImlzRXh0ZW5kQmFja3dhcmQiLCJpc0V4dGVuZEZvcndhcmQiLCJpc0V4dGVuZExpbmVCYWNrd2FyZCIsImlzRXh0ZW5kTGluZUZvcndhcmQiLCJpc0l0YWxpYyIsImlzTW92ZUxpbmVCYWNrd2FyZCIsImlzTW92ZUxpbmVGb3J3YXJkIiwiaXNNb3ZlV29yZEJhY2t3YXJkIiwiaXNNb3ZlV29yZEZvcndhcmQiLCJpc1JlZG8iLCJpc1NvZnRCcmVhayIsImlzU3BsaXRCbG9jayIsImlzVHJhbnNwb3NlQ2hhcmFjdGVyIiwiaXNVbmRvIiwiY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIiLCJidWZmZXJlZE11dGF0aW9ucyIsImNsZWFyIiwicmVnaXN0ZXJNdXRhdGlvbnMiLCJ0cmFja2VkTXV0YXRpb25zIiwicmVzdG9yZURPTSIsInJldmVyc2UiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsIk1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsIlJlc3RvcmVET01Db21wb25lbnQiLCJtYW5hZ2VyIiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlIiwiY29tcG9uZW50RGlkTW91bnQiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIl90aGlzJG11dGF0aW9uT2JzZXJ2ZTIiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmUzIiwiX3RoaXMkbWFuYWdlcjIiLCJwZW5kaW5nTXV0YXRpb25zIiwiX3RoaXMkbWFuYWdlciIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl90aGlzJG1hbmFnZXIzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmU0IiwicmVuZGVyIiwiY29udGV4dFR5cGUiLCJSZXN0b3JlRE9NIiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyIiwib3duS2V5cyQxIiwiX29iamVjdFNwcmVhZCQxIiwiQ2hpbGRyZW4iLCJFZGl0YWJsZSIsImRlZmF1bHRSZW5kZXJQbGFjZWhvbGRlciIsIkRlZmF1bHRQbGFjZWhvbGRlciIsImF1dG9Gb2N1cyIsImRlZmF1bHREZWNvcmF0ZSIsIm9uRE9NQmVmb3JlSW5wdXQiLCJwcm9wc09uRE9NQmVmb3JlSW5wdXQiLCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyIsImRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyIsInVzZXJTdHlsZSIsImFzIiwiZGlzYWJsZURlZmF1bHRTdHlsZXMiLCJzZXRJc0NvbXBvc2luZyIsImRlZmVycmVkT3BlcmF0aW9ucyIsInBsYWNlaG9sZGVySGVpZ2h0Iiwic2V0UGxhY2Vob2xkZXJIZWlnaHQiLCJmb3JjZVJlbmRlciIsInMiLCJzdGF0ZSIsImlzRHJhZ2dpbmdJbnRlcm5hbGx5IiwiaXNVcGRhdGluZ1NlbGVjdGlvbiIsImxhdGVzdEVsZW1lbnQiLCJoYXNNYXJrUGxhY2Vob2xkZXIiLCJhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmIiwiYW5kcm9pZElucHV0TWFuYWdlciIsImFuY2hvck5vZGVTZWxlY3RhYmxlIiwiZm9jdXNOb2RlU2VsZWN0YWJsZSIsIl9hbmRyb2lkSW5wdXRNYW5hZ2VyUiIsIl9hbmRyb2lkSW5wdXRNYW5hZ2VyUjIiLCJzZXREb21TZWxlY3Rpb24iLCJmb3JjZUNoYW5nZSIsImhhc0RvbVNlbGVjdGlvbiIsImVkaXRvckVsZW1lbnQiLCJoYXNEb21TZWxlY3Rpb25JbkVkaXRvciIsInNsYXRlUmFuZ2UiLCJfYW5jaG9yTm9kZSIsIl9hbmNob3JOb2RlJHBhcmVudEVsZSIsIm5ld0RvbVJhbmdlIiwiY29sbGFwc2VUb0VuZCIsInNldEJhc2VBbmRFeHRlbnQiLCJlbnN1cmVTZWxlY3Rpb24iLCJ0aW1lb3V0SWQiLCJhbmltYXRpb25GcmFtZUlkIiwiZW5zdXJlRG9tU2VsZWN0aW9uIiwiZSIsImlzRE9NRXZlbnRIYW5kbGVkIiwiX0VESVRPUl9UT19VU0VSX1NFTEVDIiwiaXNDb21wb3NpdGlvbkNoYW5nZSIsIm5hdGl2ZSIsIl9ub2RlJHBhcmVudEVsZW1lbnQiLCJfd2luZG93JGdldENvbXB1dGVkU3QiLCJfbGFzdFRleHQkdGV4dENvbnRlbnQiLCJsYXN0VGV4dCIsImNyZWF0ZVRyZWVXYWxrZXIiLCJOb2RlRmlsdGVyIiwiU0hPV19URVhUIiwibGFzdENoaWxkIiwid2hpdGVTcGFjZSIsImJsb2NrIiwicHJldmVudERlZmF1bHQiLCJ0b1Jlc3RvcmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYWNlSG9sZGVyUmVzaXplSGFuZGxlciIsIl9wbGFjZWhvbGRlckVsJGdldEJvdSIsInJlc3QiLCJsb29zZSIsInVuc2V0IiwiZnJvbUVudHJpZXMiLCJtYXAiLCJtYXJrIiwicm9sZSIsInNwZWxsQ2hlY2siLCJhdXRvQ29ycmVjdCIsImF1dG9DYXBpdGFsaXplIiwiemluZGV4Iiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwid29yZFdyYXAiLCJtaW5IZWlnaHQiLCJvbkJlZm9yZUlucHV0IiwiaXNFdmVudEhhbmRsZWQiLCJfdGV4dDIiLCJvbklucHV0Iiwib25CbHVyIiwicmVsYXRlZFRhcmdldCIsIm9uQ2xpY2siLCJkZXRhaWwiLCJibG9ja1BhdGgiLCJfYmxvY2skIiwic3RhcnRWb2lkIiwiZW5kVm9pZCIsIm9uQ29tcG9zaXRpb25FbmQiLCJfYW5kcm9pZElucHV0TWFuYWdlclIzIiwicGxhY2Vob2xkZXJNYXJrcyIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfYW5kcm9pZElucHV0TWFuYWdlclI0IiwiaW5saW5lIiwiaW5saW5lUGF0aCIsImlzRW5kIiwic2V0U2VsZWN0aW9uIiwib25Db3B5IiwiaXNET01FdmVudFRhcmdldElucHV0Iiwib25DdXQiLCJvbkRyYWdPdmVyIiwib25EcmFnU3RhcnQiLCJ2b2lkTWF0Y2giLCJvbkRyb3AiLCJkcmFnZ2VkUmFuZ2UiLCJvbkRyYWdFbmQiLCJvbkZvY3VzIiwib25LZXlEb3duIiwiX2FuZHJvaWRJbnB1dE1hbmFnZXJSNSIsImlzUlRMIiwibWF5YmVIaXN0b3J5RWRpdG9yIiwiX21heWJlSGlzdG9yeUVkaXRvciIsIm1vdmUiLCJjb2xsYXBzZSIsImN1cnJlbnROb2RlIiwib25QYXN0ZSIsImxlYWZFbCIsImJpbmQiLCJzY3JvbGxNb2RlIiwiaGFuZGxlciIsInNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiZGVmYXVsdFByZXZlbnRlZCIsIkZvY3VzZWRDb250ZXh0IiwidXNlRm9jdXNlZCIsImlzRXJyb3IiLCJlcnJvciIsIlNsYXRlU2VsZWN0b3JDb250ZXh0IiwicmVmRXF1YWxpdHkiLCJ1c2VTbGF0ZVNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsImdldFNsYXRlIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImxhdGVzdFNlbGVjdG9yIiwibGF0ZXN0U2VsZWN0ZWRTdGF0ZSIsInNlbGVjdGVkU3RhdGUiLCJzdGFjayIsImNoZWNrRm9yVXBkYXRlcyIsIm5ld1NlbGVjdGVkU3RhdGUiLCJ1bnN1YnNjcmliZSIsInVzZVNlbGVjdG9yQ29udGV4dCIsImV2ZW50TGlzdGVuZXJzIiwic2xhdGVSZWYiLCJsaXN0ZW5lciIsInNlbGVjdG9yQ29udGV4dCIsIl9leGNsdWRlZCIsIlNsYXRlIiwiaW5pdGlhbFZhbHVlIiwic2V0Q29udGV4dCIsImlzTm9kZUxpc3QiLCJ2IiwiaGFuZGxlU2VsZWN0b3JDaGFuZ2UiLCJvbkNvbnRleHRDaGFuZ2UiLCJwcmV2Q29udGV4dCIsInNldElzRm9jdXNlZCIsImZuIiwidXNlRWRpdG9yIiwidXNlU2xhdGVTZWxlY3Rpb24iLCJpc1NlbGVjdGlvbkVxdWFsIiwiZG9SZWN0c0ludGVyc2VjdCIsImNvbXBhcmVSZWN0IiwibWlkZGxlIiwiYm90dG9tIiwiYXJlUmFuZ2VzU2FtZUxpbmUiLCJyYW5nZTEiLCJyYW5nZTIiLCJyZWN0MSIsInJlY3QyIiwiZmluZEN1cnJlbnRMaW5lUmFuZ2UiLCJwYXJlbnRSYW5nZSIsInBhcmVudFJhbmdlQm91bmRhcnkiLCJwb3NpdGlvbnMiLCJyaWdodCIsImZsb29yIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJ3aXRoUmVhY3QiLCJjbGlwYm9hcmRGb3JtYXRLZXkiLCJhZGRNYXJrIiwicmVtb3ZlTWFyayIsInBhcmVudEJsb2NrRW50cnkiLCJwYXJlbnRCbG9ja1BhdGgiLCJwYXJlbnRFbGVtZW50UmFuZ2UiLCJjdXJyZW50TGluZVJhbmdlIiwiQm9vbGVhbiIsInBlbmRpbmdBY3Rpb24iLCJnZXRNYXRjaGVzIiwicHJldlBhdGgiLCJwcmV2aW91cyIsImNvbW1vblBhdGgiLCJjb21tb24iLCJhdHRhY2giLCJ0cmltIiwiciIsImNsb25lUmFuZ2UiLCJzZXRFbmRBZnRlciIsInp3IiwiaXNOZXdsaW5lIiwiYXBwZW5kQ2hpbGQiLCJnZXRGcmFnbWVudCIsIkpTT04iLCJlbmNvZGVkIiwiYnRvYSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNldEF0dHJpYnV0ZSIsInNldERhdGEiLCJkaXYiLCJib2R5IiwiZGVjb2RlZCIsImRlY29kZVVSSUNvbXBvbmVudCIsImF0b2IiLCJwYXJzZWQiLCJwYXJzZSIsImluc2VydEZyYWdtZW50IiwibGluZXMiLCJzcGxpdE5vZGVzIiwiYWx3YXlzIiwibWF5YmVCYXRjaFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImxldmVscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/dist/index.es.js\n");

/***/ })

};
;