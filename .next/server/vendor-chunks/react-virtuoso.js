"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-virtuoso";
exports.ids = ["vendor-chunks/react-virtuoso"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-virtuoso/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-virtuoso/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupedVirtuoso: () => (/* binding */ GroupedVirtuoso),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   TableVirtuoso: () => (/* binding */ TableVirtuoso),\n/* harmony export */   Virtuoso: () => (/* binding */ Virtuoso),\n/* harmony export */   VirtuosoGrid: () => (/* binding */ VirtuosoGrid),\n/* harmony export */   VirtuosoGridMockContext: () => (/* binding */ VirtuosoGridMockContext),\n/* harmony export */   VirtuosoMockContext: () => (/* binding */ VirtuosoMockContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n    return (arg)=>a(b(arg));\n}\nfunction thrush(arg, proc) {\n    return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n    return (arg2)=>proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n    return ()=>proc(arg);\n}\nfunction tap(arg, proc) {\n    proc(arg);\n    return arg;\n}\nfunction tup(...args) {\n    return args;\n}\nfunction call(proc) {\n    proc();\n}\nfunction always(value) {\n    return ()=>value;\n}\nfunction joinProc(...procs) {\n    return ()=>{\n        procs.map(call);\n    };\n}\nfunction isDefined(arg) {\n    return arg !== void 0;\n}\nfunction noop() {}\nfunction subscribe(emitter, subscription) {\n    return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n    publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n    emitter(RESET);\n}\nfunction getValue(depot) {\n    return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n    return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n    const unsub = emitter(SUBSCRIBE, (value)=>{\n        unsub();\n        subscription(value);\n    });\n    return unsub;\n}\nfunction stream() {\n    const subscriptions = [];\n    return (action, arg)=>{\n        switch(action){\n            case RESET:\n                subscriptions.splice(0, subscriptions.length);\n                return;\n            case SUBSCRIBE:\n                subscriptions.push(arg);\n                return ()=>{\n                    const indexOf = subscriptions.indexOf(arg);\n                    if (indexOf > -1) {\n                        subscriptions.splice(indexOf, 1);\n                    }\n                };\n            case PUBLISH:\n                subscriptions.slice().forEach((subscription)=>{\n                    subscription(arg);\n                });\n                return;\n            default:\n                throw new Error(`unrecognized action ${action}`);\n        }\n    };\n}\nfunction statefulStream(initial) {\n    let value = initial;\n    const innerSubject = stream();\n    return (action, arg)=>{\n        switch(action){\n            case SUBSCRIBE:\n                const subscription = arg;\n                subscription(value);\n                break;\n            case PUBLISH:\n                value = arg;\n                break;\n            case VALUE:\n                return value;\n        }\n        return innerSubject(action, arg);\n    };\n}\nfunction eventHandler(emitter) {\n    let unsub;\n    let currentSubscription;\n    const cleanup = ()=>unsub && unsub();\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                if (subscription) {\n                    if (currentSubscription === subscription) {\n                        return;\n                    }\n                    cleanup();\n                    currentSubscription = subscription;\n                    unsub = subscribe(emitter, subscription);\n                    return unsub;\n                } else {\n                    cleanup();\n                    return noop;\n                }\n            case RESET:\n                cleanup();\n                currentSubscription = null;\n                return;\n            default:\n                throw new Error(`unrecognized action ${action}`);\n        }\n    };\n}\nfunction streamFromEmitter(emitter) {\n    return tap(stream(), (stream2)=>connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n    return tap(statefulStream(initial), (stream2)=>connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n    return (subscriber)=>{\n        return operators.reduceRight(thrush, subscriber);\n    };\n}\nfunction pipe(source, ...operators) {\n    const project = combineOperators(...operators);\n    return (action, subscription)=>{\n        switch(action){\n            case SUBSCRIBE:\n                return subscribe(source, project(subscription));\n            case RESET:\n                reset(source);\n                return;\n        }\n    };\n}\nfunction defaultComparator(previous, next) {\n    return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n    let current;\n    return (done)=>(next)=>{\n            if (!comparator(current, next)) {\n                current = next;\n                done(next);\n            }\n        };\n}\nfunction filter(predicate) {\n    return (done)=>(value)=>{\n            predicate(value) && done(value);\n        };\n}\nfunction map(project) {\n    return (done)=>compose(done, project);\n}\nfunction mapTo(value) {\n    return (done)=>()=>done(value);\n}\nfunction scan(scanner, initial) {\n    return (done)=>(value)=>done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n    return (done)=>(value)=>{\n            times > 0 ? times-- : done(value);\n        };\n}\nfunction throttleTime(interval) {\n    let currentValue = null;\n    let timeout;\n    return (done)=>(value)=>{\n            currentValue = value;\n            if (timeout) {\n                return;\n            }\n            timeout = setTimeout(()=>{\n                timeout = void 0;\n                done(currentValue);\n            }, interval);\n        };\n}\nfunction debounceTime(interval) {\n    let currentValue;\n    let timeout;\n    return (done)=>(value)=>{\n            currentValue = value;\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                done(currentValue);\n            }, interval);\n        };\n}\nfunction withLatestFrom(...sources) {\n    const values = new Array(sources.length);\n    let called = 0;\n    let pendingCall = null;\n    const allCalled = Math.pow(2, sources.length) - 1;\n    sources.forEach((source, index)=>{\n        const bit = Math.pow(2, index);\n        subscribe(source, (value)=>{\n            const prevCalled = called;\n            called = called | bit;\n            values[index] = value;\n            if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n                pendingCall();\n                pendingCall = null;\n            }\n        });\n    });\n    return (done)=>(value)=>{\n            const call2 = ()=>done([\n                    value\n                ].concat(values));\n            if (called === allCalled) {\n                call2();\n            } else {\n                pendingCall = call2;\n            }\n        };\n}\nfunction merge(...sources) {\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                return joinProc(...sources.map((source)=>subscribe(source, subscription)));\n            case RESET:\n                return;\n            default:\n                throw new Error(`unrecognized action ${action}`);\n        }\n    };\n}\nfunction duc(source, comparator = defaultComparator) {\n    return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n    const innerSubject = stream();\n    const values = new Array(emitters.length);\n    let called = 0;\n    const allCalled = Math.pow(2, emitters.length) - 1;\n    emitters.forEach((source, index)=>{\n        const bit = Math.pow(2, index);\n        subscribe(source, (value)=>{\n            values[index] = value;\n            called = called | bit;\n            if (called === allCalled) {\n                publish(innerSubject, values);\n            }\n        });\n    });\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                if (called === allCalled) {\n                    subscription(values);\n                }\n                return subscribe(innerSubject, subscription);\n            case RESET:\n                return reset(innerSubject);\n            default:\n                throw new Error(`unrecognized action ${action}`);\n        }\n    };\n}\nfunction system(constructor, dependencies = [], { singleton } = {\n    singleton: true\n}) {\n    return {\n        id: id(),\n        constructor,\n        dependencies,\n        singleton\n    };\n}\nconst id = ()=>Symbol();\nfunction init(systemSpec) {\n    const singletons = /* @__PURE__ */ new Map();\n    const _init = ({ id: id2, constructor, dependencies, singleton })=>{\n        if (singleton && singletons.has(id2)) {\n            return singletons.get(id2);\n        }\n        const system2 = constructor(dependencies.map((e)=>_init(e)));\n        if (singleton) {\n            singletons.set(id2, system2);\n        }\n        return system2;\n    };\n    return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n    const result = {};\n    const index = {};\n    let idx = 0;\n    const len = keys.length;\n    while(idx < len){\n        index[keys[idx]] = 1;\n        idx += 1;\n    }\n    for(const prop in obj){\n        if (!index.hasOwnProperty(prop)) {\n            result[prop] = obj[prop];\n        }\n    }\n    return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n    const requiredPropNames = Object.keys(map2.required || {});\n    const optionalPropNames = Object.keys(map2.optional || {});\n    const methodNames = Object.keys(map2.methods || {});\n    const eventNames = Object.keys(map2.events || {});\n    const Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\n    function applyPropsToSystem(system2, props) {\n        if (system2[\"propsReady\"]) {\n            publish(system2[\"propsReady\"], false);\n        }\n        for (const requiredPropName of requiredPropNames){\n            const stream2 = system2[map2.required[requiredPropName]];\n            publish(stream2, props[requiredPropName]);\n        }\n        for (const optionalPropName of optionalPropNames){\n            if (optionalPropName in props) {\n                const stream2 = system2[map2.optional[optionalPropName]];\n                publish(stream2, props[optionalPropName]);\n            }\n        }\n        if (system2[\"propsReady\"]) {\n            publish(system2[\"propsReady\"], true);\n        }\n    }\n    function buildMethods(system2) {\n        return methodNames.reduce((acc, methodName)=>{\n            acc[methodName] = (value)=>{\n                const stream2 = system2[map2.methods[methodName]];\n                publish(stream2, value);\n            };\n            return acc;\n        }, {});\n    }\n    function buildEventHandlers(system2) {\n        return eventNames.reduce((handlers, eventName)=>{\n            handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n            return handlers;\n        }, {});\n    }\n    const Component = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((propsWithChildren, ref)=>{\n        const { children, ...props } = propsWithChildren;\n        const [system2] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n            return tap(init(systemSpec), (system22)=>applyPropsToSystem(system22, props));\n        });\n        const [handlers] = react__WEBPACK_IMPORTED_MODULE_0__.useState(curry1to0(buildEventHandlers, system2));\n        useIsomorphicLayoutEffect$2(()=>{\n            for (const eventName of eventNames){\n                if (eventName in props) {\n                    subscribe(handlers[eventName], props[eventName]);\n                }\n            }\n            return ()=>{\n                Object.values(handlers).map(reset);\n            };\n        }, [\n            props,\n            handlers,\n            system2\n        ]);\n        useIsomorphicLayoutEffect$2(()=>{\n            applyPropsToSystem(system2, props);\n        });\n        react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, always(buildMethods(system2)));\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n            value: system2\n        }, Root ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, omit([\n            ...requiredPropNames,\n            ...optionalPropNames,\n            ...eventNames\n        ], props), children) : children);\n    });\n    const usePublisher2 = (key)=>{\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(curry2to1(publish, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context)[key]), [\n            key\n        ]);\n    };\n    const useEmitterValue2 = (key)=>{\n        const system2 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n        const source = system2[key];\n        const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(curry1to0(getValue, source));\n        useIsomorphicLayoutEffect$2(()=>subscribe(source, (next)=>{\n                if (next !== value) {\n                    setValue(always(next));\n                }\n            }), [\n            source,\n            value\n        ]);\n        return value;\n    };\n    const useEmitter2 = (key, callback)=>{\n        const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n        const source = context[key];\n        useIsomorphicLayoutEffect$2(()=>subscribe(source, callback), [\n            callback,\n            source\n        ]);\n    };\n    return {\n        Component,\n        usePublisher: usePublisher2,\n        useEmitterValue: useEmitterValue2,\n        useEmitter: useEmitter2\n    };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2)=>{\n    LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n    LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n    LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n    return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n    [0]: \"debug\",\n    [1]: \"log\",\n    [2]: \"warn\",\n    [3]: \"error\"\n};\nconst getGlobalThis = ()=>typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(()=>{\n    const logLevel = statefulStream(3);\n    const log = statefulStream((label, message, level = 1)=>{\n        var _a;\n        const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n        if (level >= currentLevel) {\n            console[CONSOLE_METHOD_MAP[level]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", label, message);\n        }\n    });\n    return {\n        log,\n        logLevel\n    };\n}, [], {\n    singleton: true\n});\nfunction useSizeWithElRef(callback, enabled = true) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    let callbackRef = (_el)=>{};\n    if (typeof ResizeObserver !== \"undefined\") {\n        const observer = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return new ResizeObserver((entries)=>{\n                const element = entries[0].target;\n                if (element.offsetParent !== null) {\n                    callback(element);\n                }\n            });\n        }, [\n            callback\n        ]);\n        callbackRef = (elRef)=>{\n            if (elRef && enabled) {\n                observer.observe(elRef);\n                ref.current = elRef;\n            } else {\n                if (ref.current) {\n                    observer.unobserve(ref.current);\n                }\n                ref.current = null;\n            }\n        };\n    }\n    return {\n        ref,\n        callbackRef\n    };\n}\nfunction useSize(callback, enabled = true) {\n    return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n    const memoedCallback = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((el)=>{\n        const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n        let scrollableElement = el.parentElement;\n        while(!scrollableElement.dataset[\"virtuosoScroller\"]){\n            scrollableElement = scrollableElement.parentElement;\n        }\n        const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n        const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n        const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n        const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n        scrollContainerStateCallback({\n            scrollTop: Math.max(scrollTop, 0),\n            scrollHeight,\n            viewportHeight\n        });\n        gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n        if (ranges !== null) {\n            callback(ranges);\n        }\n    }, [\n        callback,\n        itemSize,\n        log,\n        gap,\n        customScrollParent,\n        scrollContainerStateCallback\n    ]);\n    return useSizeWithElRef(memoedCallback, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n    const length = children.length;\n    if (length === 0) {\n        return null;\n    }\n    const results = [];\n    for(let i = 0; i < length; i++){\n        const child = children.item(i);\n        if (!child || child.dataset.index === void 0) {\n            continue;\n        }\n        const index = parseInt(child.dataset.index);\n        const knownSize = parseFloat(child.dataset.knownSize);\n        const size = itemSize(child, field);\n        if (size === 0) {\n            log(\"Zero-sized element, this should not happen\", {\n                child\n            }, LogLevel.ERROR);\n        }\n        if (size === knownSize) {\n            continue;\n        }\n        const lastResult = results[results.length - 1];\n        if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n            results.push({\n                startIndex: index,\n                endIndex: index,\n                size\n            });\n        } else {\n            results[results.length - 1].endIndex++;\n        }\n    }\n    return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n    if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n        log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n    }\n    if (value === \"normal\") {\n        return 0;\n    }\n    return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n    return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n    return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {\n    const scrollerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const scrollTopTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const handler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev)=>{\n        const el = ev.target;\n        const windowScroll = el === window || el === document;\n        const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n        const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n        const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n        const call2 = ()=>{\n            scrollContainerStateCallback({\n                scrollTop: Math.max(scrollTop, 0),\n                scrollHeight,\n                viewportHeight\n            });\n        };\n        if (ev.suppressFlushSync) {\n            call2();\n        } else {\n            react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(call2);\n        }\n        if (scrollTopTarget.current !== null) {\n            if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n                scrollTopTarget.current = null;\n                smoothScrollTargetReached(true);\n                if (timeoutRef.current) {\n                    clearTimeout(timeoutRef.current);\n                    timeoutRef.current = null;\n                }\n            }\n        }\n    }, [\n        scrollContainerStateCallback,\n        smoothScrollTargetReached\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n        scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n        handler({\n            target: localRef,\n            suppressFlushSync: true\n        });\n        localRef.addEventListener(\"scroll\", handler, {\n            passive: true\n        });\n        return ()=>{\n            scrollerRefCallback(null);\n            localRef.removeEventListener(\"scroll\", handler);\n        };\n    }, [\n        scrollerRef,\n        handler,\n        scrollerElement,\n        scrollerRefCallback,\n        customScrollParent\n    ]);\n    function scrollToCallback(location) {\n        const scrollerElement2 = scrollerRef.current;\n        if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n            return;\n        }\n        const isSmooth = location.behavior === \"smooth\";\n        let offsetHeight;\n        let scrollHeight;\n        let scrollTop;\n        if (scrollerElement2 === window) {\n            scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n            offsetHeight = window.innerHeight;\n            scrollTop = document.documentElement.scrollTop;\n        } else {\n            scrollHeight = scrollerElement2.scrollHeight;\n            offsetHeight = correctItemSize(scrollerElement2, \"height\");\n            scrollTop = scrollerElement2.scrollTop;\n        }\n        const maxScrollTop = scrollHeight - offsetHeight;\n        location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n        if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n            scrollContainerStateCallback({\n                scrollTop,\n                scrollHeight,\n                viewportHeight: offsetHeight\n            });\n            if (isSmooth) {\n                smoothScrollTargetReached(true);\n            }\n            return;\n        }\n        if (isSmooth) {\n            scrollTopTarget.current = location.top;\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n            timeoutRef.current = setTimeout(()=>{\n                timeoutRef.current = null;\n                scrollTopTarget.current = null;\n                smoothScrollTargetReached(true);\n            }, 1e3);\n        } else {\n            scrollTopTarget.current = null;\n        }\n        scrollerElement2.scrollTo(location);\n    }\n    function scrollByCallback(location) {\n        scrollerRef.current.scrollBy(location);\n    }\n    return {\n        scrollerRef,\n        scrollByCallback,\n        scrollToCallback\n    };\n}\nconst domIOSystem = system(()=>{\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    connect(pipe(scrollContainerState, map(({ scrollTop: scrollTop2 })=>scrollTop2)), scrollTop);\n    connect(pipe(scrollContainerState, map(({ scrollHeight: scrollHeight2 })=>scrollHeight2)), scrollHeight);\n    connect(scrollTop, statefulScrollTop);\n    return {\n        // input\n        scrollContainerState,\n        scrollTop,\n        viewportHeight,\n        headerHeight,\n        fixedHeaderHeight,\n        fixedFooterHeight,\n        footerHeight,\n        scrollHeight,\n        smoothScrollTargetReached,\n        // signals\n        scrollTo,\n        scrollBy,\n        // state\n        statefulScrollTop,\n        deviation,\n        scrollingInProgress\n    };\n}, [], {\n    singleton: true\n});\nconst NIL_NODE = {\n    lvl: 0\n};\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n    return {\n        k,\n        v,\n        lvl,\n        l,\n        r\n    };\n}\nfunction empty(node) {\n    return node === NIL_NODE;\n}\nfunction newTree() {\n    return NIL_NODE;\n}\nfunction remove(node, key) {\n    if (empty(node)) return NIL_NODE;\n    const { k, l, r } = node;\n    if (key === k) {\n        if (empty(l)) {\n            return r;\n        } else if (empty(r)) {\n            return l;\n        } else {\n            const [lastKey, lastValue] = last(l);\n            return adjust(clone(node, {\n                k: lastKey,\n                v: lastValue,\n                l: deleteLast(l)\n            }));\n        }\n    } else if (key < k) {\n        return adjust(clone(node, {\n            l: remove(l, key)\n        }));\n    } else {\n        return adjust(clone(node, {\n            r: remove(r, key)\n        }));\n    }\n}\nfunction find(node, key) {\n    if (empty(node)) {\n        return;\n    }\n    if (key === node.k) {\n        return node.v;\n    } else if (key < node.k) {\n        return find(node.l, key);\n    } else {\n        return find(node.r, key);\n    }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n    if (empty(node)) {\n        return [\n            -Infinity,\n            void 0\n        ];\n    }\n    if (Number(node[field]) === value) {\n        return [\n            node.k,\n            node.v\n        ];\n    }\n    if (Number(node[field]) < value) {\n        const r = findMaxKeyValue(node.r, value, field);\n        if (r[0] === -Infinity) {\n            return [\n                node.k,\n                node.v\n            ];\n        } else {\n            return r;\n        }\n    }\n    return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n    if (empty(node)) {\n        return newAANode(k, v, 1);\n    }\n    if (k === node.k) {\n        return clone(node, {\n            k,\n            v\n        });\n    } else if (k < node.k) {\n        return rebalance(clone(node, {\n            l: insert(node.l, k, v)\n        }));\n    } else {\n        return rebalance(clone(node, {\n            r: insert(node.r, k, v)\n        }));\n    }\n}\nfunction walkWithin(node, start, end) {\n    if (empty(node)) {\n        return [];\n    }\n    const { k, v, l, r } = node;\n    let result = [];\n    if (k > start) {\n        result = result.concat(walkWithin(l, start, end));\n    }\n    if (k >= start && k <= end) {\n        result.push({\n            k,\n            v\n        });\n    }\n    if (k <= end) {\n        result = result.concat(walkWithin(r, start, end));\n    }\n    return result;\n}\nfunction walk(node) {\n    if (empty(node)) {\n        return [];\n    }\n    return [\n        ...walk(node.l),\n        {\n            k: node.k,\n            v: node.v\n        },\n        ...walk(node.r)\n    ];\n}\nfunction last(node) {\n    return empty(node.r) ? [\n        node.k,\n        node.v\n    ] : last(node.r);\n}\nfunction deleteLast(node) {\n    return empty(node.r) ? node.l : adjust(clone(node, {\n        r: deleteLast(node.r)\n    }));\n}\nfunction clone(node, args) {\n    return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);\n}\nfunction isSingle(node) {\n    return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n    return split(skew(node));\n}\nfunction adjust(node) {\n    const { l, r, lvl } = node;\n    if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n        return node;\n    } else if (lvl > r.lvl + 1) {\n        if (isSingle(l)) {\n            return skew(clone(node, {\n                lvl: lvl - 1\n            }));\n        } else {\n            if (!empty(l) && !empty(l.r)) {\n                return clone(l.r, {\n                    l: clone(l, {\n                        r: l.r.l\n                    }),\n                    r: clone(node, {\n                        l: l.r.r,\n                        lvl: lvl - 1\n                    }),\n                    lvl\n                });\n            } else {\n                throw new Error(\"Unexpected empty nodes\");\n            }\n        }\n    } else {\n        if (isSingle(node)) {\n            return split(clone(node, {\n                lvl: lvl - 1\n            }));\n        } else {\n            if (!empty(r) && !empty(r.l)) {\n                const rl = r.l;\n                const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n                return clone(rl, {\n                    l: clone(node, {\n                        r: rl.l,\n                        lvl: lvl - 1\n                    }),\n                    r: split(clone(r, {\n                        l: rl.r,\n                        lvl: rlvl\n                    })),\n                    lvl: rl.lvl + 1\n                });\n            } else {\n                throw new Error(\"Unexpected empty nodes\");\n            }\n        }\n    }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n    if (empty(node)) {\n        return [];\n    }\n    const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n    return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n    const length = items.length;\n    if (length === 0) {\n        return [];\n    }\n    let { index: start, value } = parser(items[0]);\n    const result = [];\n    for(let i = 1; i < length; i++){\n        const { index: nextIndex, value: nextValue } = parser(items[i]);\n        result.push({\n            start,\n            end: nextIndex - 1,\n            value\n        });\n        start = nextIndex;\n        value = nextValue;\n    }\n    result.push({\n        start,\n        end: Infinity,\n        value\n    });\n    return result;\n}\nfunction toRanges(nodes) {\n    return arrayToRanges(nodes, ({ k: index, v: value })=>({\n            index,\n            value\n        }));\n}\nfunction split(node) {\n    const { r, lvl } = node;\n    return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, {\n        l: clone(node, {\n            r: r.l\n        }),\n        lvl: lvl + 1\n    }) : node;\n}\nfunction skew(node) {\n    const { l } = node;\n    return !empty(l) && l.lvl === node.lvl ? clone(l, {\n        r: clone(node, {\n            l: l.r\n        })\n    }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n    let end = items.length - 1;\n    while(start <= end){\n        const index = Math.floor((start + end) / 2);\n        const item = items[index];\n        const match = comparator(item, value);\n        if (match === 0) {\n            return index;\n        }\n        if (match === -1) {\n            if (end - start < 2) {\n                return index - 1;\n            }\n            end = index - 1;\n        } else {\n            if (end === start) {\n                return index;\n            }\n            start = index + 1;\n        }\n    }\n    throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n    return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n    const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n    const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n    return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(()=>{\n    const recalcInProgress = statefulStream(false);\n    return {\n        recalcInProgress\n    };\n}, [], {\n    singleton: true\n});\nfunction rangeIncludes(refRange) {\n    const { size, startIndex, endIndex } = refRange;\n    return (range)=>{\n        return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n    };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n    let recognizedOffsetItems = 0;\n    let groupIndex = 0;\n    while(recognizedOffsetItems < offset){\n        recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n        groupIndex++;\n    }\n    const offsetIsExact = recognizedOffsetItems === offset;\n    return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n    let syncStart = empty(sizeTree) ? 0 : Infinity;\n    for (const range of ranges){\n        const { size, startIndex, endIndex } = range;\n        syncStart = Math.min(syncStart, startIndex);\n        if (empty(sizeTree)) {\n            sizeTree = insert(sizeTree, 0, size);\n            continue;\n        }\n        const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n        if (overlappingRanges.some(rangeIncludes(range))) {\n            continue;\n        }\n        let firstPassDone = false;\n        let shouldInsert = false;\n        for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges){\n            if (!firstPassDone) {\n                shouldInsert = rangeValue !== size;\n                firstPassDone = true;\n            } else {\n                if (endIndex >= rangeStart || size === rangeValue) {\n                    sizeTree = remove(sizeTree, rangeStart);\n                }\n            }\n            if (rangeEnd > endIndex && endIndex >= rangeStart) {\n                if (rangeValue !== size) {\n                    sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n                }\n            }\n        }\n        if (shouldInsert) {\n            sizeTree = insert(sizeTree, startIndex, size);\n        }\n    }\n    return [\n        sizeTree,\n        syncStart\n    ];\n}\nfunction initialSizeState() {\n    return {\n        offsetTree: [],\n        sizeTree: newTree(),\n        groupOffsetTree: newTree(),\n        lastIndex: 0,\n        lastOffset: 0,\n        lastSize: 0,\n        groupIndices: []\n    };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n    return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n    return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n    return {\n        index: point.index,\n        value: point\n    };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n    if (minStartIndex > 0) {\n        startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n    }\n    return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n    let offsetTree = prevOffsetTree;\n    let prevIndex = 0;\n    let prevSize = 0;\n    let prevOffset = 0;\n    let startIndex = 0;\n    if (syncStart !== 0) {\n        startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n        const offsetInfo = offsetTree[startIndex];\n        prevOffset = offsetInfo.offset;\n        const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n        prevIndex = kv[0];\n        prevSize = kv[1];\n        if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n            startIndex -= 1;\n        }\n        offsetTree = offsetTree.slice(0, startIndex + 1);\n    } else {\n        offsetTree = [];\n    }\n    for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)){\n        const indexOffset = startIndex2 - prevIndex;\n        const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n        offsetTree.push({\n            offset: aOffset,\n            size: value,\n            index: startIndex2\n        });\n        prevIndex = startIndex2;\n        prevOffset = aOffset;\n        prevSize = value;\n    }\n    return {\n        offsetTree,\n        lastIndex: prevIndex,\n        lastOffset: prevOffset,\n        lastSize: prevSize\n    };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n    if (ranges.length > 0) {\n        log(\"received item sizes\", ranges, LogLevel.DEBUG);\n    }\n    const sizeTree = state.sizeTree;\n    let newSizeTree = sizeTree;\n    let syncStart = 0;\n    if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n        const groupSize = ranges[0].size;\n        const itemSize = ranges[1].size;\n        newSizeTree = groupIndices.reduce((tree, groupIndex)=>{\n            return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n        }, newSizeTree);\n    } else {\n        [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n    }\n    if (newSizeTree === sizeTree) {\n        return state;\n    }\n    const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n    return {\n        sizeTree: newSizeTree,\n        offsetTree: newOffsetTree,\n        lastIndex,\n        lastOffset,\n        lastSize,\n        groupOffsetTree: groupIndices.reduce((tree, index)=>{\n            return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n        }, newTree()),\n        groupIndices\n    };\n}\nfunction offsetOf(index, tree, gap) {\n    if (tree.length === 0) {\n        return 0;\n    }\n    const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n    const itemCount = index - startIndex;\n    const top = size * itemCount + (itemCount - 1) * gap + offset;\n    return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n    return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n    if (isGroupLocation(location)) {\n        return sizes.groupIndices[location.groupIndex] + 1;\n    } else {\n        const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n        let result = originalIndexFromItemIndex(numericIndex, sizes);\n        result = Math.max(0, result, Math.min(lastIndex, result));\n        return result;\n    }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n    if (!hasGroups(sizes)) {\n        return itemIndex;\n    }\n    let groupOffset = 0;\n    while(sizes.groupIndices[groupOffset] <= itemIndex + groupOffset){\n        groupOffset++;\n    }\n    return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n    return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n    return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray)=>{\n        const nextSize = sizeArray[index + 1];\n        const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n        return {\n            startIndex,\n            endIndex,\n            size\n        };\n    });\n}\nconst SIZE_MAP = {\n    offsetHeight: \"height\",\n    offsetWidth: \"width\"\n};\nconst sizeSystem = system(([{ log }, { recalcInProgress }])=>{\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field)=>correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);\n    const prevGroupIndices = statefulStreamFromEmitter(pipe(groupIndices, distinctUntilChanged(), scan((prev, curr)=>({\n            prev: prev.current,\n            current: curr\n        }), {\n        prev: [],\n        current: []\n    }), map(({ prev })=>prev)), []);\n    connect(pipe(groupIndices, filter((indexes)=>indexes.length > 0), withLatestFrom(sizes, gap), map(([groupIndices2, sizes2, gap2])=>{\n        const groupOffsetTree = groupIndices2.reduce((tree, index, idx)=>{\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n        }, newTree());\n        return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n        };\n    })), sizes);\n    connect(pipe(totalCount, withLatestFrom(sizes), filter(([totalCount2, { lastIndex }])=>{\n        return totalCount2 < lastIndex;\n    }), map(([totalCount2, { lastIndex, lastSize }])=>{\n        return [\n            {\n                startIndex: totalCount2,\n                endIndex: lastIndex,\n                size: lastSize\n            }\n        ];\n    })), sizeRanges);\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map((size)=>size === void 0)), true);\n    connect(pipe(defaultItemSize, filter((value)=>{\n        return value !== void 0 && empty(getValue(sizes).sizeTree);\n    }), map((size)=>[\n            {\n                startIndex: 0,\n                endIndex: 0,\n                size\n            }\n        ])), sizeRanges);\n    const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan(({ sizes: oldSizes }, [_, newSizes])=>{\n        return {\n            changed: newSizes !== oldSizes,\n            sizes: newSizes\n        };\n    }, {\n        changed: false,\n        sizes: initial\n    }), map((value)=>value.changed)));\n    subscribe(pipe(firstItemIndex, scan((prev, next)=>{\n        return {\n            diff: prev.prev - next,\n            prev: next\n        };\n    }, {\n        diff: 0,\n        prev: 0\n    }), map((val)=>val.diff)), (offset)=>{\n        const { groupIndices: groupIndices2 } = getValue(sizes);\n        if (offset > 0) {\n            publish(recalcInProgress, true);\n            publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n        } else if (offset < 0) {\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            if (prevGroupIndicesValue.length > 0) {\n                offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n            }\n            publish(shiftWith, offset);\n        }\n    });\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2])=>{\n        if (index < 0) {\n            log2(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n                firstItemIndex\n            }, LogLevel.ERROR);\n        }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(pipe(unshiftWith, withLatestFrom(sizes), map(([unshiftWith2, sizes2])=>{\n        const groupedMode = sizes2.groupIndices.length > 0;\n        const initialRanges = [];\n        const defaultSize = sizes2.lastSize;\n        if (groupedMode) {\n            const firstGroupSize = find(sizes2.sizeTree, 0);\n            let prependedGroupItemsCount = 0;\n            let groupIndex = 0;\n            while(prependedGroupItemsCount < unshiftWith2){\n                const theGroupIndex = sizes2.groupIndices[groupIndex];\n                const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n                initialRanges.push({\n                    startIndex: theGroupIndex,\n                    endIndex: theGroupIndex,\n                    size: firstGroupSize\n                });\n                initialRanges.push({\n                    startIndex: theGroupIndex + 1,\n                    endIndex: theGroupIndex + 1 + groupItemCount - 1,\n                    size: defaultSize\n                });\n                groupIndex++;\n                prependedGroupItemsCount += groupItemCount + 1;\n            }\n            const sizeTreeKV = walk(sizes2.sizeTree);\n            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n            if (firstGroupIsExpanded) {\n                sizeTreeKV.shift();\n            }\n            return sizeTreeKV.reduce((acc, { k: index, v: size })=>{\n                let ranges = acc.ranges;\n                if (acc.prevSize !== 0) {\n                    ranges = [\n                        ...acc.ranges,\n                        {\n                            startIndex: acc.prevIndex,\n                            endIndex: index + unshiftWith2 - 1,\n                            size: acc.prevSize\n                        }\n                    ];\n                }\n                return {\n                    ranges,\n                    prevIndex: index + unshiftWith2,\n                    prevSize: size\n                };\n            }, {\n                ranges: initialRanges,\n                prevIndex: unshiftWith2,\n                prevSize: 0\n            }).ranges;\n        }\n        return walk(sizes2.sizeTree).reduce((acc, { k: index, v: size })=>{\n            return {\n                ranges: [\n                    ...acc.ranges,\n                    {\n                        startIndex: acc.prevIndex,\n                        endIndex: index + unshiftWith2 - 1,\n                        size: acc.prevSize\n                    }\n                ],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n            };\n        }, {\n            ranges: [],\n            prevIndex: 0,\n            prevSize: defaultSize\n        }).ranges;\n    })), sizeRanges);\n    const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, { offsetTree }, gap2])=>{\n        const newFirstItemIndex = -shiftWith2;\n        return offsetOf(newFirstItemIndex, offsetTree, gap2);\n    })));\n    connect(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, sizes2, gap2])=>{\n        const groupedMode = sizes2.groupIndices.length > 0;\n        if (groupedMode) {\n            if (empty(sizes2.sizeTree)) {\n                return sizes2;\n            }\n            let newSizeTree = newTree();\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            let removedItemsCount = 0;\n            let groupIndex = 0;\n            let groupOffset = 0;\n            while(removedItemsCount < -shiftWith2){\n                groupOffset = prevGroupIndicesValue[groupIndex];\n                const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n                groupIndex++;\n                removedItemsCount += groupItemCount + 1;\n            }\n            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v })=>{\n                return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newSizeTree);\n            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n            if (aGroupIsShrunk) {\n                const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n                newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n                const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n                newSizeTree = insert(newSizeTree, 1, nextItemSize);\n            }\n            return {\n                ...sizes2,\n                sizeTree: newSizeTree,\n                ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n        } else {\n            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v })=>{\n                return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newTree());\n            return {\n                ...sizes2,\n                sizeTree: newSizeTree,\n                ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n        }\n    })), sizes);\n    return {\n        // input\n        data,\n        totalCount,\n        sizeRanges,\n        groupIndices,\n        defaultItemSize,\n        fixedItemSize,\n        unshiftWith,\n        shiftWith,\n        shiftWithOffset,\n        beforeUnshiftWith,\n        firstItemIndex,\n        gap,\n        // output\n        sizes,\n        listRefresh,\n        statefulTotalCount,\n        trackItemSizes,\n        itemSize\n    };\n}, tup(loggerSystem, recalcSystem), {\n    singleton: true\n});\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n    const result = typeof location === \"number\" ? {\n        index: location\n    } : location;\n    if (!result.align) {\n        result.align = \"start\";\n    }\n    if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n        result.behavior = \"auto\";\n    }\n    if (!result.offset) {\n        result.offset = 0;\n    }\n    return result;\n}\nconst scrollToIndexSystem = system(([{ sizes, totalCount, listRefresh, gap }, { scrollingInProgress, viewportHeight, scrollTo, smoothScrollTargetReached, headerHeight, footerHeight, fixedHeaderHeight, fixedFooterHeight }, { log }])=>{\n    const scrollToIndex = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n        if (unsubscribeNextListRefresh) {\n            unsubscribeNextListRefresh();\n            unsubscribeNextListRefresh = null;\n        }\n        if (unsubscribeListRefresh) {\n            unsubscribeListRefresh();\n            unsubscribeListRefresh = null;\n        }\n        if (cleartTimeoutRef) {\n            clearTimeout(cleartTimeoutRef);\n            cleartTimeoutRef = null;\n        }\n        publish(scrollingInProgress, false);\n    }\n    connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map(([[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2])=>{\n        const normalLocation = normalizeIndexLocation(location);\n        const { align, behavior, offset } = normalLocation;\n        const lastIndex = totalCount2 - 1;\n        const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n        let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n        if (align === \"end\") {\n            top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n            if (index === lastIndex) {\n                top += footerHeight2;\n            }\n        } else if (align === \"center\") {\n            top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n        } else {\n            top -= topListHeight2;\n        }\n        if (offset) {\n            top += offset;\n        }\n        const retry = (listChanged)=>{\n            cleanup();\n            if (listChanged) {\n                log2(\"retrying to scroll to\", {\n                    location\n                }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n            } else {\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n            }\n        };\n        cleanup();\n        if (behavior === \"smooth\") {\n            let listChanged = false;\n            unsubscribeListRefresh = subscribe(listRefresh, (changed)=>{\n                listChanged = listChanged || changed;\n            });\n            unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, ()=>{\n                retry(listChanged);\n            });\n        } else {\n            unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n        }\n        cleartTimeoutRef = setTimeout(()=>{\n            cleanup();\n        }, 1200);\n        publish(scrollingInProgress, true);\n        log2(\"scrolling from index to\", {\n            index,\n            top,\n            behavior\n        }, LogLevel.DEBUG);\n        return {\n            top,\n            behavior\n        };\n    })), scrollTo);\n    return {\n        scrollToIndex,\n        topListHeight\n    };\n}, tup(sizeSystem, domIOSystem, loggerSystem), {\n    singleton: true\n});\nfunction watchChangesFor(limit) {\n    return (done)=>{\n        const timeoutRef = setTimeout(()=>{\n            done(false);\n        }, limit);\n        return (value)=>{\n            if (value) {\n                done(true);\n                clearTimeout(timeoutRef);\n            }\n        };\n    };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n    atBottom: false,\n    notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n    state: {\n        offsetBottom: 0,\n        scrollTop: 0,\n        viewportHeight: 0,\n        scrollHeight: 0\n    }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }])=>{\n    const isAtBottom = statefulStream(false);\n    const isAtTop = statefulStream(true);\n    const atBottomStateChange = stream();\n    const atTopStateChange = stream();\n    const atBottomThreshold = statefulStream(4);\n    const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n    const isScrolling = statefulStreamFromEmitter(pipe(merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);\n    const isScrollingBy = statefulStreamFromEmitter(pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);\n    connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map(([top, atTopThreshold2])=>top <= atTopThreshold2), distinctUntilChanged()), isAtTop);\n    connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n    const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2])=>{\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n            viewportHeight: viewportHeight2,\n            scrollTop: scrollTop2,\n            scrollHeight\n        };\n        if (isAtBottom2) {\n            let atBottomBecause;\n            let scrollTopDelta;\n            if (scrollTop2 > current.state.scrollTop) {\n                atBottomBecause = \"SCROLLED_DOWN\";\n                scrollTopDelta = current.state.scrollTop - scrollTop2;\n            } else {\n                atBottomBecause = \"SIZE_DECREASED\";\n                scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n            }\n            return {\n                atBottom: true,\n                state,\n                atBottomBecause,\n                scrollTopDelta\n            };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n            notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n            notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n            notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n            notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n            atBottom: false,\n            notAtBottomBecause,\n            state\n        };\n    }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next)=>{\n        return prev && prev.atBottom === next.atBottom;\n    })));\n    const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 })=>{\n        if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n                return {\n                    scrollHeight,\n                    scrollTop: scrollTop2,\n                    jump: current.scrollTop - scrollTop2,\n                    changed: true\n                };\n            } else {\n                return {\n                    scrollHeight,\n                    scrollTop: scrollTop2,\n                    jump: 0,\n                    changed: true\n                };\n            }\n        } else {\n            return {\n                scrollTop: scrollTop2,\n                scrollHeight,\n                jump: 0,\n                changed: false\n            };\n        }\n    }, {\n        scrollHeight: 0,\n        jump: 0,\n        scrollTop: 0,\n        changed: false\n    }), filter((value)=>value.changed), map((value)=>value.jump)), 0);\n    connect(pipe(atBottomState, map((state)=>state.atBottom)), isAtBottom);\n    connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n    const scrollDirection = statefulStream(DOWN);\n    connect(pipe(scrollContainerState, map(({ scrollTop: scrollTop2 })=>scrollTop2), distinctUntilChanged(), scan((acc, scrollTop2)=>{\n        if (getValue(isScrollingBy)) {\n            return {\n                direction: acc.direction,\n                prevScrollTop: scrollTop2\n            };\n        }\n        return {\n            direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,\n            prevScrollTop: scrollTop2\n        };\n    }, {\n        direction: DOWN,\n        prevScrollTop: 0\n    }), map((value)=>value.direction)), scrollDirection);\n    connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n    const scrollVelocity = statefulStream(0);\n    connect(pipe(isScrolling, filter((value)=>!value), // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    mapTo(0)), scrollVelocity);\n    connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(([_, isScrolling2])=>!!isScrolling2), scan(([_, prev], [next])=>[\n            prev,\n            next\n        ], [\n        0,\n        0\n    ]), map(([prev, next])=>next - prev)), scrollVelocity);\n    return {\n        isScrolling,\n        isAtTop,\n        isAtBottom,\n        atBottomState,\n        atTopStateChange,\n        atBottomStateChange,\n        scrollDirection,\n        atBottomThreshold,\n        atTopThreshold,\n        scrollVelocity,\n        lastJumpDueToItemResize\n    };\n}, tup(domIOSystem));\nconst propsReadySystem = system(([{ log }])=>{\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(pipe(propsReady, filter((ready)=>ready), distinctUntilChanged()));\n    subscribe(propsReady, (value)=>{\n        value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return {\n        propsReady,\n        didMount\n    };\n}, tup(loggerSystem), {\n    singleton: true\n});\nfunction skipFrames(frameCount, callback) {\n    if (frameCount == 0) {\n        callback();\n    } else {\n        requestAnimationFrame(()=>skipFrames(frameCount - 1, callback));\n    }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n    const lastIndex = totalCount - 1;\n    const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n    return index;\n}\nconst initialTopMostItemIndexSystem = system(([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex }, { didMount }])=>{\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrollScheduled = statefulStream(false);\n    connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location])=>!!location), mapTo(false)), scrolledToInitialItem);\n    subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled), filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled2])=>{\n        return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;\n    }), withLatestFrom(initialTopMostItemIndex)), ([, initialTopMostItemIndex2])=>{\n        publish(scrollScheduled, true);\n        skipFrames(3, ()=>{\n            handleNext(scrollTop, ()=>publish(scrolledToInitialItem, true));\n            publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n    });\n    return {\n        scrolledToInitialItem,\n        initialTopMostItemIndex\n    };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {\n    singleton: true\n});\nfunction normalizeFollowOutput(follow) {\n    if (!follow) {\n        return false;\n    }\n    return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom)=>{\n    if (typeof follow === \"function\") {\n        return normalizeFollowOutput(follow(isAtBottom));\n    }\n    return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(([{ totalCount, listRefresh }, { isAtBottom, atBottomState }, { scrollToIndex }, { scrolledToInitialItem }, { propsReady, didMount }, { log }, { scrollingInProgress }])=>{\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n        publish(scrollToIndex, {\n            index: \"LAST\",\n            align: \"end\",\n            behavior: followOutputBehavior\n        });\n    }\n    subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2])=>{\n        let shouldFollow = didMount2 && scrolledToInitialItem2;\n        let followOutputBehavior = \"auto\";\n        if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n        }\n        return {\n            totalCount: totalCount2,\n            shouldFollow,\n            followOutputBehavior\n        };\n    }), filter(({ shouldFollow })=>shouldFollow)), ({ totalCount: totalCount2, followOutputBehavior })=>{\n        if (pendingScrollHandle) {\n            pendingScrollHandle();\n            pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, ()=>{\n            getValue(log)(\"following output to \", {\n                totalCount: totalCount2\n            }, LogLevel.DEBUG);\n            scrollToBottom(followOutputBehavior);\n            pendingScrollHandle = null;\n        });\n    });\n    function trapNextSizeIncrease(followOutput2) {\n        const cancel = handleNext(atBottomState, (state)=>{\n            if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n                getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n                scrollToBottom(\"auto\");\n            }\n        });\n        setTimeout(cancel, 100);\n    }\n    subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(([follow, , ready])=>follow && ready), scan(({ value }, [, next])=>{\n        return {\n            refreshed: value === next,\n            value: next\n        };\n    }, {\n        refreshed: false,\n        value: 0\n    }), filter(({ refreshed })=>refreshed), withLatestFrom(followOutput, totalCount)), ([, followOutput2])=>{\n        trapNextSizeIncrease(followOutput2 !== false);\n    });\n    subscribe(autoscrollToBottom, ()=>{\n        trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state])=>{\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n            scrollToBottom(\"auto\");\n        }\n    });\n    return {\n        followOutput,\n        autoscrollToBottom\n    };\n}, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));\nfunction groupCountsToIndicesAndCount(counts) {\n    return counts.reduce((acc, groupCount)=>{\n        acc.groupIndices.push(acc.totalCount);\n        acc.totalCount += groupCount + 1;\n        return acc;\n    }, {\n        totalCount: 0,\n        groupIndices: []\n    });\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }])=>{\n    const groupCounts = stream();\n    const topItemsIndexes = stream();\n    const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n    connect(pipe(groupIndicesAndCount, map((value)=>value.totalCount)), totalCount);\n    connect(pipe(groupIndicesAndCount, map((value)=>value.groupIndices)), groupIndices);\n    connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(([_, sizes2])=>hasGroups(sizes2)), map(([scrollTop2, state, headerHeight2])=>findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]), distinctUntilChanged(), map((index)=>[\n            index\n        ])), topItemsIndexes);\n    return {\n        groupCounts,\n        topItemsIndexes\n    };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n    return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n    return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n    if (typeof overscan === \"number\") {\n        return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n    } else {\n        if (direction === UP) {\n            return end === TOP ? overscan.main : overscan.reverse;\n        } else {\n            return end === BOTTOM ? overscan.main : overscan.reverse;\n        }\n    }\n}\nfunction getViewportIncrease(value, end) {\n    return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }])=>{\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map(([scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2])=>{\n        const top = scrollTop2 - deviation2;\n        const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n        const headerVisible = Math.max(headerHeight2 - top, 0);\n        let direction = NONE;\n        const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n        const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n        listTop -= deviation2;\n        listTop += headerHeight2 + fixedHeaderHeight2;\n        listBottom += headerHeight2 + fixedHeaderHeight2;\n        listBottom -= deviation2;\n        if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n            direction = UP;\n        }\n        if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n            direction = DOWN;\n        }\n        if (direction !== NONE) {\n            return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n            ];\n        }\n        return null;\n    }), filter((value)=>value != null), distinctUntilChanged(tupleComparator)), [\n        0,\n        0\n    ]);\n    return {\n        // input\n        listBoundary,\n        overscan,\n        topListHeight,\n        increaseViewportBy,\n        // output\n        visibleRange\n    };\n}, tup(domIOSystem), {\n    singleton: true\n});\nfunction probeItemSet(index, sizes, data) {\n    if (hasGroups(sizes)) {\n        const itemIndex = originalIndexFromItemIndex(index, sizes);\n        const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n        return [\n            {\n                index: groupIndex,\n                size: 0,\n                offset: 0\n            },\n            {\n                index: itemIndex,\n                size: 0,\n                offset: 0,\n                data: data && data[0]\n            }\n        ];\n    }\n    return [\n        {\n            index,\n            size: 0,\n            offset: 0,\n            data: data && data[0]\n        }\n    ];\n}\nconst EMPTY_LIST_STATE = {\n    items: [],\n    topItems: [],\n    offsetTop: 0,\n    offsetBottom: 0,\n    top: 0,\n    bottom: 0,\n    topListHeight: 0,\n    totalCount: 0,\n    firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n    if (items.length === 0) {\n        return [];\n    }\n    if (!hasGroups(sizes)) {\n        return items.map((item)=>({\n                ...item,\n                index: item.index + firstItemIndex,\n                originalIndex: item.index\n            }));\n    }\n    const startIndex = items[0].index;\n    const endIndex = items[items.length - 1].index;\n    const transposedItems = [];\n    const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n    let currentRange = void 0;\n    let currentGroupIndex = 0;\n    for (const item of items){\n        if (!currentRange || currentRange.end < item.index) {\n            currentRange = groupRanges.shift();\n            currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n        }\n        let transposedItem;\n        if (item.index === currentRange.start) {\n            transposedItem = {\n                type: \"group\",\n                index: currentGroupIndex\n            };\n        } else {\n            transposedItem = {\n                index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n                groupIndex: currentGroupIndex\n            };\n        }\n        transposedItems.push({\n            ...transposedItem,\n            size: item.size,\n            offset: item.offset,\n            originalIndex: item.index,\n            data: item.data\n        });\n    }\n    return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n    const { lastSize, lastOffset, lastIndex } = sizes;\n    let offsetTop = 0;\n    let bottom = 0;\n    if (items.length > 0) {\n        offsetTop = items[0].offset;\n        const lastItem = items[items.length - 1];\n        bottom = lastItem.offset + lastItem.size;\n    }\n    const itemCount = totalCount - lastIndex;\n    const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n    const top = offsetTop;\n    const offsetBottom = total - bottom;\n    return {\n        items: transposeItems(items, sizes, firstItemIndex),\n        topItems: transposeItems(topItems, sizes, firstItemIndex),\n        topListHeight: topItems.reduce((height, item)=>item.size + height, 0),\n        offsetTop,\n        offsetBottom,\n        top,\n        bottom,\n        totalCount,\n        firstItemIndex\n    };\n}\nfunction buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {\n    let includedGroupsCount = 0;\n    if (sizes.groupIndices.length > 0) {\n        for (const index of sizes.groupIndices){\n            if (index - includedGroupsCount >= itemCount) {\n                break;\n            }\n            includedGroupsCount++;\n        }\n    }\n    const adjustedCount = itemCount + includedGroupsCount;\n    const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);\n    const items = Array.from({\n        length: adjustedCount\n    }).map((_, index)=>({\n            index: index + initialTopMostItemIndexNumber,\n            size: 0,\n            offset: 0,\n            data: data[index + initialTopMostItemIndexNumber]\n        }));\n    return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);\n}\nconst listStateSystem = system(([{ sizes, totalCount, data, firstItemIndex, gap }, groupedListSystem2, { visibleRange, listBoundary, topListHeight: rangeTopListHeight }, { scrolledToInitialItem, initialTopMostItemIndex }, { topListHeight }, stateFlags, { didMount }, { recalcInProgress }])=>{\n    const topItemsIndexes = statefulStream([]);\n    const initialItemCount = statefulStream(0);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2])=>{\n        const dataChangeInProgress = data2 && data2.length !== totalCount2;\n        return mount && !recalcInProgress2 && !dataChangeInProgress;\n    }), map(([, , [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2])=>{\n        const sizesValue = sizes2;\n        const { sizeTree, offsetTree } = sizesValue;\n        const initialItemCountValue = getValue(initialItemCount);\n        if (totalCount2 === 0) {\n            return {\n                ...EMPTY_LIST_STATE,\n                totalCount: totalCount2\n            };\n        }\n        if (startOffset === 0 && endOffset === 0) {\n            if (initialItemCountValue === 0) {\n                return {\n                    ...EMPTY_LIST_STATE,\n                    totalCount: totalCount2\n                };\n            } else {\n                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);\n            }\n        }\n        if (empty(sizeTree)) {\n            if (initialItemCountValue > 0) {\n                return null;\n            }\n            const state = buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);\n            return state;\n        }\n        const topItems = [];\n        if (topItemsIndexes2.length > 0) {\n            const startIndex = topItemsIndexes2[0];\n            const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n            let offset = 0;\n            for (const range of rangesWithin(sizeTree, startIndex, endIndex)){\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for(let i = rangeStartIndex; i <= rangeEndIndex; i++){\n                    topItems.push({\n                        index: i,\n                        size,\n                        offset,\n                        data: data2 && data2[i]\n                    });\n                    offset += size;\n                }\n            }\n        }\n        if (!scrolledToInitialItem2) {\n            return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n        }\n        const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n        const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n        if (offsetPointRanges.length === 0) {\n            return null;\n        }\n        const maxIndex = totalCount2 - 1;\n        const items = tap([], (result)=>{\n            for (const range of offsetPointRanges){\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                    rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                    const itemCount = rangeStartIndex - range.start;\n                    offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                    offset += (minStartIndex - rangeStartIndex) * size;\n                    rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for(let i = rangeStartIndex; i <= endIndex; i++){\n                    if (offset >= endOffset) {\n                        break;\n                    }\n                    result.push({\n                        index: i,\n                        size,\n                        offset,\n                        data: data2 && data2[i]\n                    });\n                    offset += size + gap2;\n                }\n            }\n        });\n        return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n    }), //@ts-expect-error filter needs to be fixed\n    filter((value)=>value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);\n    connect(pipe(data, filter(isDefined), map((data2)=>data2 == null ? void 0 : data2.length)), totalCount);\n    connect(pipe(listState, map((value)=>value.topListHeight)), topListHeight);\n    connect(topListHeight, rangeTopListHeight);\n    connect(pipe(listState, map((state)=>[\n            state.top,\n            state.bottom\n        ])), listBoundary);\n    connect(pipe(listState, map((state)=>state.items)), itemsRendered);\n    const endReached = streamFromEmitter(pipe(listState, filter(({ items })=>items.length > 0), withLatestFrom(totalCount, data), filter(([{ items }, totalCount2])=>items[items.length - 1].originalIndex === totalCount2 - 1), map(([, totalCount2, data2])=>[\n            totalCount2 - 1,\n            data2\n        ]), distinctUntilChanged(tupleComparator), map(([count])=>count)));\n    const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(({ items, topItems })=>{\n        return items.length > 0 && items[0].originalIndex === topItems.length;\n    }), map(({ items })=>items[0].index), distinctUntilChanged()));\n    const rangeChanged = streamFromEmitter(pipe(listState, filter(({ items })=>items.length > 0), map(({ items })=>{\n        let startIndex = 0;\n        let endIndex = items.length - 1;\n        while(items[startIndex].type === \"group\" && startIndex < endIndex){\n            startIndex++;\n        }\n        while(items[endIndex].type === \"group\" && endIndex > startIndex){\n            endIndex--;\n        }\n        return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n        };\n    }), distinctUntilChanged(rangeComparator)));\n    return {\n        listState,\n        topItemsIndexes,\n        endReached,\n        startReached,\n        rangeChanged,\n        itemsRendered,\n        initialItemCount,\n        ...stateFlags\n    };\n}, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {\n    singleton: true\n});\nconst initialItemCountSystem = system(([{ sizes, firstItemIndex, data, gap }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }])=>{\n    connect(pipe(didMount, withLatestFrom(initialItemCount), filter(([, count])=>count !== 0), withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data), map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []])=>{\n        return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);\n    })), listState);\n    return {};\n}, tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem), {\n    singleton: true\n});\nconst scrollSeekSystem = system(([{ scrollVelocity }])=>{\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(([_, config])=>!!config), map(([speed, config, isSeeking2, range])=>{\n        const { exit, enter } = config;\n        if (isSeeking2) {\n            if (exit(speed, range)) {\n                return false;\n            }\n        } else {\n            if (enter(speed, range)) {\n                return true;\n            }\n        }\n        return isSeeking2;\n    }), distinctUntilChanged()), isSeeking);\n    subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), ([[isSeeking2, velocity, range], config])=>isSeeking2 && config && config.change && config.change(velocity, range));\n    return {\n        isSeeking,\n        scrollSeekConfiguration,\n        scrollVelocity,\n        scrollSeekRangeChanged: rangeChanged\n    };\n}, tup(stateFlagsSystem), {\n    singleton: true\n});\nconst topItemCountSystem = system(([{ topItemsIndexes }])=>{\n    const topItemCount = statefulStream(0);\n    connect(pipe(topItemCount, filter((length)=>length > 0), map((length)=>Array.from({\n            length\n        }).map((_, index)=>index))), topItemsIndexes);\n    return {\n        topItemCount\n    };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }])=>{\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2])=>{\n        return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n    })), 0);\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return {\n        totalListHeight,\n        totalListHeightChanged\n    };\n}, tup(domIOSystem, listStateSystem), {\n    singleton: true\n});\nfunction simpleMemoize(func) {\n    let called = false;\n    let result;\n    return ()=>{\n        if (!called) {\n            called = true;\n            result = func();\n        }\n        return result;\n    };\n}\nconst isMobileSafari = simpleMemoize(()=>{\n    return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(([{ scrollBy, scrollTop, deviation, scrollingInProgress }, { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize }, { listState }, { beforeUnshiftWith, shiftWithOffset, sizes, gap }, { log }, { recalcInProgress }])=>{\n    const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan(([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2])=>{\n        const totalHeight = bottom + offsetBottom;\n        let newDev = 0;\n        if (prevTotalCount === totalCount) {\n            if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                    newDev = totalHeight - prevTotalHeight;\n                    if (newDev !== 0) {\n                        newDev += lastJumpDueToItemResize2;\n                    }\n                }\n            }\n        }\n        return [\n            newDev,\n            items,\n            totalCount,\n            totalHeight\n        ];\n    }, [\n        0,\n        [],\n        0,\n        0\n    ]), filter(([amount])=>amount !== 0), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress), filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2])=>{\n        return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n    }), map(([[amount], , , , , log2])=>{\n        log2(\"Upward scrolling compensation\", {\n            amount\n        }, LogLevel.DEBUG);\n        return amount;\n    })));\n    function scrollByWith(offset) {\n        if (offset > 0) {\n            publish(scrollBy, {\n                top: -offset,\n                behavior: \"auto\"\n            });\n            publish(deviation, 0);\n        } else {\n            publish(deviation, 0);\n            publish(scrollBy, {\n                top: -offset,\n                behavior: \"auto\"\n            });\n        }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2])=>{\n        if (isScrolling2 && isMobileSafari()) {\n            publish(deviation, deviationAmount - offset);\n        } else {\n            scrollByWith(-offset);\n        }\n    });\n    subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(([is, deviation2, recalc])=>!is && !recalc && deviation2 !== 0), map(([_, deviation2])=>deviation2), throttleTime(1)), scrollByWith);\n    connect(pipe(shiftWithOffset, map((offset)=>{\n        return {\n            top: -offset\n        };\n    })), scrollBy);\n    subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2])=>{\n        function getItemOffset(itemCount) {\n            return itemCount * (defaultItemSize + gap2);\n        }\n        if (groupIndices.length === 0) {\n            return getItemOffset(offset);\n        } else {\n            let amount = 0;\n            const defaultGroupSize = find(sizeTree, 0);\n            let recognizedOffsetItems = 0;\n            let groupIndex = 0;\n            while(recognizedOffsetItems < offset){\n                recognizedOffsetItems++;\n                amount += defaultGroupSize;\n                let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n                if (recognizedOffsetItems + groupItemCount > offset) {\n                    amount -= defaultGroupSize;\n                    groupItemCount = offset - recognizedOffsetItems + 1;\n                }\n                recognizedOffsetItems += groupItemCount;\n                amount += getItemOffset(groupItemCount);\n                groupIndex++;\n            }\n            return amount;\n        }\n    })), (offset)=>{\n        publish(deviation, offset);\n        requestAnimationFrame(()=>{\n            publish(scrollBy, {\n                top: offset\n            });\n            requestAnimationFrame(()=>{\n                publish(deviation, 0);\n                publish(recalcInProgress, false);\n            });\n        });\n    });\n    return {\n        deviation\n    };\n}, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));\nconst initialScrollTopSystem = system(([{ didMount }, { scrollTo }, { listState }])=>{\n    const initialScrollTop = statefulStream(0);\n    subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(([, offset])=>offset !== 0), map(([, offset])=>({\n            top: offset\n        }))), (location)=>{\n        handleNext(pipe(listState, skip(1), filter((state)=>state.items.length > 1)), ()=>{\n            requestAnimationFrame(()=>{\n                publish(scrollTo, location);\n            });\n        });\n    });\n    return {\n        initialScrollTop\n    };\n}, tup(propsReadySystem, domIOSystem, listStateSystem), {\n    singleton: true\n});\nconst alignToBottomSystem = system(([{ viewportHeight }, { totalListHeight }])=>{\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(([enabled])=>enabled), map(([, viewportHeight2, totalListHeight2])=>{\n        return Math.max(0, viewportHeight2 - totalListHeight2);\n    }), throttleTime(0), distinctUntilChanged()), 0);\n    return {\n        alignToBottom,\n        paddingTopAddition\n    };\n}, tup(domIOSystem, totalListHeightSystem), {\n    singleton: true\n});\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }])=>{\n    const windowScrollContainerState = stream();\n    const windowViewportRect = stream();\n    const windowScrollTo = stream();\n    const useWindowScroll = statefulStream(false);\n    const customScrollParent = statefulStream(void 0);\n    connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }])=>{\n        return {\n            scrollTop: Math.max(0, windowScrollTop - offsetTop),\n            scrollHeight,\n            viewportHeight\n        };\n    })), scrollContainerState);\n    connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map(([scrollTo2, { offsetTop }])=>{\n        return {\n            ...scrollTo2,\n            top: scrollTo2.top + offsetTop\n        };\n    })), windowScrollTo);\n    return {\n        // config\n        useWindowScroll,\n        customScrollParent,\n        // input\n        windowScrollContainerState,\n        windowViewportRect,\n        // signals\n        windowScrollTo\n    };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({ itemTop: itemTop2, itemBottom, viewportTop, viewportBottom, locationParams: { behavior, align, ...rest } })=>{\n    if (itemTop2 < viewportTop) {\n        return {\n            ...rest,\n            behavior,\n            align: align != null ? align : \"start\"\n        };\n    }\n    if (itemBottom > viewportBottom) {\n        return {\n            ...rest,\n            behavior,\n            align: align != null ? align : \"end\"\n        };\n    }\n    return null;\n};\nconst scrollIntoViewSystem = system(([{ sizes, totalCount, gap }, { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress }, { scrollToIndex }])=>{\n    const scrollIntoView = stream();\n    connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2])=>{\n        const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;\n        const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n        const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n        const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n        const viewportTop = scrollTop2 + fixedHeaderHeight2;\n        const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n        const location = calculateViewLocation({\n            itemTop: itemTop2,\n            itemBottom,\n            viewportTop,\n            viewportBottom,\n            locationParams: {\n                behavior,\n                align,\n                ...rest\n            }\n        });\n        if (location) {\n            done && handleNext(pipe(scrollingInProgress, filter((value)=>value === false), // skips the initial publish of false, and the cleanup call.\n            // but if scrollingInProgress is true, we skip the initial publish.\n            skip(getValue(scrollingInProgress) ? 1 : 2)), done);\n        } else {\n            done && done();\n        }\n        return location;\n    }), filter((value)=>value !== null)), scrollToIndex);\n    return {\n        scrollIntoView\n    };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {\n    singleton: true\n});\nconst stateLoadSystem = system(([{ sizes, sizeRanges }, { scrollTop }, { initialTopMostItemIndex }, { didMount }, { useWindowScroll, windowScrollContainerState, windowViewportRect }])=>{\n    const getState = stream();\n    const restoreStateFrom = statefulStream(void 0);\n    const statefulWindowScrollContainerState = statefulStream(null);\n    const statefulWindowViewportRect = statefulStream(null);\n    connect(windowScrollContainerState, statefulWindowScrollContainerState);\n    connect(windowViewportRect, statefulWindowViewportRect);\n    subscribe(pipe(getState, withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect)), ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2])=>{\n        const ranges = sizeTreeToRanges(sizes2.sizeTree);\n        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {\n            scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;\n        }\n        callback({\n            ranges,\n            scrollTop: scrollTop2\n        });\n    });\n    connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n    connect(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, state])=>state !== void 0), distinctUntilChanged(), map(([, snapshot])=>{\n        return snapshot.ranges;\n    })), sizeRanges);\n    return {\n        getState,\n        restoreStateFrom\n    };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem));\nfunction locationFromSnapshot(snapshot) {\n    return {\n        offset: snapshot.scrollTop,\n        index: 0,\n        align: \"start\"\n    };\n}\nconst featureGroup1System = system(([sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView, logger])=>{\n    return {\n        ...sizeRange,\n        ...initialItemCount,\n        ...propsReady,\n        ...scrollSeek,\n        ...totalListHeight,\n        ...initialScrollTopSystem2,\n        ...alignToBottom,\n        ...windowScroller,\n        ...scrollIntoView,\n        ...logger\n    };\n}, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem, loggerSystem));\nconst listSystem = system(([{ totalCount, sizeRanges, fixedItemSize, defaultItemSize, trackItemSizes, itemSize, data, firstItemIndex, groupIndices, statefulTotalCount, gap, sizes }, { initialTopMostItemIndex, scrolledToInitialItem }, domIO, stateLoad, followOutput, { listState, topItemsIndexes, ...flags }, { scrollToIndex }, _, { topItemCount }, { groupCounts }, featureGroup1])=>{\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(pipe(featureGroup1.windowViewportRect, map((value)=>value.visibleHeight)), domIO.viewportHeight);\n    return {\n        // input\n        totalCount,\n        data,\n        firstItemIndex,\n        sizeRanges,\n        initialTopMostItemIndex,\n        scrolledToInitialItem,\n        topItemsIndexes,\n        topItemCount,\n        groupCounts,\n        fixedItemHeight: fixedItemSize,\n        defaultItemHeight: defaultItemSize,\n        gap,\n        ...followOutput,\n        // output\n        statefulTotalCount,\n        listState,\n        scrollToIndex,\n        trackItemSizes,\n        itemSize,\n        groupIndices,\n        // exported from stateFlagsSystem\n        ...flags,\n        // the bag of IO from featureGroup1System\n        ...featureGroup1,\n        ...domIO,\n        sizes,\n        ...stateLoad\n    };\n}, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, stateLoadSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System));\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(()=>{\n    if (typeof document === \"undefined\") {\n        return STICKY;\n    }\n    const node = document.createElement(\"div\");\n    node.style.position = WEBKIT_STICKY;\n    return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n    const viewportInfo = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const calculateInfo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((element)=>{\n        if (element === null || !element.offsetParent) {\n            return;\n        }\n        const rect = element.getBoundingClientRect();\n        const visibleWidth = rect.width;\n        let visibleHeight, offsetTop;\n        if (customScrollParent) {\n            const customScrollParentRect = customScrollParent.getBoundingClientRect();\n            const deltaTop = rect.top - customScrollParentRect.top;\n            visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n            offsetTop = deltaTop + customScrollParent.scrollTop;\n        } else {\n            visibleHeight = window.innerHeight - Math.max(0, rect.top);\n            offsetTop = rect.top + window.pageYOffset;\n        }\n        viewportInfo.current = {\n            offsetTop,\n            visibleHeight,\n            visibleWidth\n        };\n        callback(viewportInfo.current);\n    }, [\n        callback,\n        customScrollParent\n    ]);\n    const { callbackRef, ref } = useSizeWithElRef(calculateInfo);\n    const scrollAndResizeEventHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        calculateInfo(ref.current);\n    }, [\n        calculateInfo,\n        ref\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (customScrollParent) {\n            customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n            const observer = new ResizeObserver(scrollAndResizeEventHandler);\n            observer.observe(customScrollParent);\n            return ()=>{\n                customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n                observer.unobserve(customScrollParent);\n            };\n        } else {\n            window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n            window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n            return ()=>{\n                window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n                window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n            };\n        }\n    }, [\n        scrollAndResizeEventHandler,\n        customScrollParent\n    ]);\n    return callbackRef;\n}\nconst VirtuosoMockContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nconst VirtuosoGridMockContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nfunction identity(value) {\n    return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(()=>{\n    const itemContent = statefulStream((index)=>`Item ${index}`);\n    const context = statefulStream(null);\n    const groupContent = statefulStream((index)=>`Group ${index}`);\n    const components = statefulStream({});\n    const computeItemKey = statefulStream(identity);\n    const headerFooterTag = statefulStream(\"div\");\n    const scrollerRef = statefulStream(noop);\n    const distinctProp = (propName, defaultValue = null)=>{\n        return statefulStreamFromEmitter(pipe(components, map((components2)=>components2[propName]), distinctUntilChanged()), defaultValue);\n    };\n    return {\n        context,\n        itemContent,\n        groupContent,\n        components,\n        computeItemKey,\n        headerFooterTag,\n        scrollerRef,\n        FooterComponent: distinctProp(\"Footer\"),\n        HeaderComponent: distinctProp(\"Header\"),\n        TopItemListComponent: distinctProp(\"TopItemList\"),\n        ListComponent: distinctProp(\"List\", \"div\"),\n        ItemComponent: distinctProp(\"Item\", \"div\"),\n        GroupComponent: distinctProp(\"Group\", \"div\"),\n        ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n        EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n        ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n    };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem])=>{\n    return {\n        ...listSystem2,\n        ...propsSystem\n    };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: {\n            height\n        }\n    });\nconst GROUP_STYLE = {\n    position: positionStickyCssValue(),\n    zIndex: 1,\n    overflowAnchor: \"none\"\n};\nconst ITEM_STYLE$1 = {\n    overflowAnchor: \"none\"\n};\nconst Items$1 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoItems({ showTopList = false }) {\n    const listState = useEmitterValue$2(\"listState\");\n    const sizeRanges = usePublisher$2(\"sizeRanges\");\n    const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n    const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n    const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n    const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n    const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n    const itemContent = useEmitterValue$2(\"itemContent\");\n    const context = useEmitterValue$2(\"context\");\n    const groupContent = useEmitterValue$2(\"groupContent\");\n    const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n    const itemSize = useEmitterValue$2(\"itemSize\");\n    const log = useEmitterValue$2(\"log\");\n    const listGap = usePublisher$2(\"gap\");\n    const { callbackRef } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop : scrollContainerStateCallback, log, listGap, customScrollParent);\n    const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    useEmitter$2(\"deviation\", (value)=>{\n        if (deviation !== value) {\n            setDeviation(value);\n        }\n    });\n    const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n    const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n    const ListComponent = useEmitterValue$2(\"ListComponent\");\n    const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n    const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n    const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n    const isSeeking = useEmitterValue$2(\"isSeeking\");\n    const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n    const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n    const scrolledToInitialItem = useEmitterValue$2(\"scrolledToInitialItem\");\n    const containerStyle = showTopList ? {} : {\n        boxSizing: \"border-box\",\n        paddingTop: listState.offsetTop + paddingTopAddition,\n        paddingBottom: listState.offsetBottom,\n        marginTop: deviation,\n        ...scrolledToInitialItem ? {} : {\n            visibility: \"hidden\"\n        }\n    };\n    if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ListComponent, {\n        ...contextPropIfNotDomElement(ListComponent, context),\n        ref: callbackRef,\n        style: containerStyle,\n        \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n    }, (showTopList ? listState.topItems : listState.items).map((item)=>{\n        const index = item.originalIndex;\n        const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n        if (isSeeking) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {\n                ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n                key,\n                index: item.index,\n                height: item.size,\n                type: item.type || \"item\",\n                ...item.type === \"group\" ? {} : {\n                    groupIndex: item.groupIndex\n                }\n            });\n        }\n        if (item.type === \"group\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GroupComponent, {\n                ...contextPropIfNotDomElement(GroupComponent, context),\n                key,\n                \"data-index\": index,\n                \"data-known-size\": item.size,\n                \"data-item-index\": item.index,\n                style: GROUP_STYLE\n            }, groupContent(item.index, context));\n        } else {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ItemComponent, {\n                ...contextPropIfNotDomElement(ItemComponent, context),\n                ...itemPropIfNotDomElement(ItemComponent, item.data),\n                key,\n                \"data-index\": index,\n                \"data-known-size\": item.size,\n                \"data-item-index\": item.index,\n                \"data-item-group-index\": item.groupIndex,\n                style: ITEM_STYLE$1\n            }, hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));\n        }\n    }));\n});\nconst scrollerStyle = {\n    height: \"100%\",\n    outline: \"none\",\n    overflowY: \"auto\",\n    position: \"relative\",\n    WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    position: \"absolute\",\n    top: 0\n};\nconst topItemListStyle = {\n    width: \"100%\",\n    position: positionStickyCssValue(),\n    top: 0,\n    zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n    if (typeof element === \"string\") {\n        return void 0;\n    }\n    return {\n        context\n    };\n}\nfunction itemPropIfNotDomElement(element, item) {\n    return {\n        item: typeof element === \"string\" ? void 0 : item\n    };\n}\nconst Header$1 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoHeader() {\n    const Header2 = useEmitterValue$2(\"HeaderComponent\");\n    const headerHeight = usePublisher$2(\"headerHeight\");\n    const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n    const ref = useSize((el)=>headerHeight(correctItemSize(el, \"height\")));\n    const context = useEmitterValue$2(\"context\");\n    return Header2 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, {\n        ref\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoFooter() {\n    const Footer2 = useEmitterValue$2(\"FooterComponent\");\n    const footerHeight = usePublisher$2(\"footerHeight\");\n    const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n    const ref = useSize((el)=>footerHeight(correctItemSize(el, \"height\")));\n    const context = useEmitterValue$2(\"context\");\n    return Footer2 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, {\n        ref\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n    const Scroller2 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoScroller({ style, children, ...props }) {\n        const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n        const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n        const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n        const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n        const context = useEmitterValue2(\"context\");\n        const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback);\n        useEmitter2(\"scrollTo\", scrollToCallback);\n        useEmitter2(\"scrollBy\", scrollByCallback);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollerComponent, {\n            ref: scrollerRef,\n            style: {\n                ...scrollerStyle,\n                ...style\n            },\n            \"data-test-id\": \"virtuoso-scroller\",\n            \"data-virtuoso-scroller\": true,\n            tabIndex: 0,\n            ...props,\n            ...contextPropIfNotDomElement(ScrollerComponent, context)\n        }, children);\n    });\n    return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n    const Scroller2 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n        const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n        const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n        const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n        const totalListHeight = useEmitterValue2(\"totalListHeight\");\n        const deviation = useEmitterValue2(\"deviation\");\n        const customScrollParent = useEmitterValue2(\"customScrollParent\");\n        const context = useEmitterValue2(\"context\");\n        const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop, customScrollParent);\n        useIsomorphicLayoutEffect$1(()=>{\n            scrollerRef.current = customScrollParent ? customScrollParent : window;\n            return ()=>{\n                scrollerRef.current = null;\n            };\n        }, [\n            scrollerRef,\n            customScrollParent\n        ]);\n        useEmitter2(\"windowScrollTo\", scrollToCallback);\n        useEmitter2(\"scrollBy\", scrollByCallback);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollerComponent, {\n            style: {\n                position: \"relative\",\n                ...style,\n                ...totalListHeight !== 0 ? {\n                    height: totalListHeight + deviation\n                } : {}\n            },\n            \"data-virtuoso-scroller\": true,\n            ...props,\n            ...contextPropIfNotDomElement(ScrollerComponent, context)\n        }, children);\n    });\n    return Scroller2;\n}\nconst Viewport$2 = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);\n    const viewportHeight = usePublisher$2(\"viewportHeight\");\n    const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n    const viewportRef = useSize(compose(viewportHeight, (el)=>correctItemSize(el, \"height\")));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            viewportHeight(ctx.viewportHeight);\n            fixedItemHeight(ctx.itemHeight);\n        }\n    }, [\n        ctx,\n        viewportHeight,\n        fixedItemHeight\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: viewportStyle,\n        ref: viewportRef,\n        \"data-viewport-type\": \"element\"\n    }, children);\n};\nconst WindowViewport$2 = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);\n    const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n    const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n    const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n    const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            fixedItemHeight(ctx.itemHeight);\n            windowViewportRect({\n                offsetTop: 0,\n                visibleHeight: ctx.viewportHeight,\n                visibleWidth: 100\n            });\n        }\n    }, [\n        ctx,\n        windowViewportRect,\n        fixedItemHeight\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: viewportRef,\n        style: viewportStyle,\n        \"data-viewport-type\": \"window\"\n    }, children);\n};\nconst TopItemListContainer = ({ children })=>{\n    const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n    const headerHeight = useEmitterValue$2(\"headerHeight\");\n    const style = {\n        ...topItemListStyle,\n        marginTop: `${headerHeight}px`\n    };\n    const context = useEmitterValue$2(\"context\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TopItemList || \"div\", {\n        style,\n        context\n    }, children);\n};\nconst ListRoot = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoRoot(props) {\n    const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n    const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n    const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n    const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n    const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, {\n        ...props\n    }, showTopList && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TopItemListContainer, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items$1, {\n        showTopList: true\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header$1, null), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items$1, null), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer$1, null)));\n});\nconst { Component: List, usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 } = /* @__PURE__ */ systemToComponent(combinedSystem$2, {\n    required: {},\n    optional: {\n        restoreStateFrom: \"restoreStateFrom\",\n        context: \"context\",\n        followOutput: \"followOutput\",\n        itemContent: \"itemContent\",\n        groupContent: \"groupContent\",\n        overscan: \"overscan\",\n        increaseViewportBy: \"increaseViewportBy\",\n        totalCount: \"totalCount\",\n        groupCounts: \"groupCounts\",\n        topItemCount: \"topItemCount\",\n        firstItemIndex: \"firstItemIndex\",\n        initialTopMostItemIndex: \"initialTopMostItemIndex\",\n        components: \"components\",\n        atBottomThreshold: \"atBottomThreshold\",\n        atTopThreshold: \"atTopThreshold\",\n        computeItemKey: \"computeItemKey\",\n        defaultItemHeight: \"defaultItemHeight\",\n        fixedItemHeight: \"fixedItemHeight\",\n        itemSize: \"itemSize\",\n        scrollSeekConfiguration: \"scrollSeekConfiguration\",\n        headerFooterTag: \"headerFooterTag\",\n        data: \"data\",\n        initialItemCount: \"initialItemCount\",\n        initialScrollTop: \"initialScrollTop\",\n        alignToBottom: \"alignToBottom\",\n        useWindowScroll: \"useWindowScroll\",\n        customScrollParent: \"customScrollParent\",\n        scrollerRef: \"scrollerRef\",\n        logLevel: \"logLevel\"\n    },\n    methods: {\n        scrollToIndex: \"scrollToIndex\",\n        scrollIntoView: \"scrollIntoView\",\n        scrollTo: \"scrollTo\",\n        scrollBy: \"scrollBy\",\n        autoscrollToBottom: \"autoscrollToBottom\",\n        getState: \"getState\"\n    },\n    events: {\n        isScrolling: \"isScrolling\",\n        endReached: \"endReached\",\n        startReached: \"startReached\",\n        rangeChanged: \"rangeChanged\",\n        atBottomStateChange: \"atBottomStateChange\",\n        atTopStateChange: \"atTopStateChange\",\n        totalListHeightChanged: \"totalListHeightChanged\",\n        itemsRendered: \"itemsRendered\",\n        groupIndices: \"groupIndices\"\n    }\n}, ListRoot);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({\n    usePublisher: usePublisher$2,\n    useEmitterValue: useEmitterValue$2,\n    useEmitter: useEmitter$2\n});\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({\n    usePublisher: usePublisher$2,\n    useEmitterValue: useEmitterValue$2,\n    useEmitter: useEmitter$2\n});\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n    items: [],\n    offsetBottom: 0,\n    offsetTop: 0,\n    top: 0,\n    bottom: 0,\n    itemHeight: 0,\n    itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n    items: [\n        {\n            index: 0\n        }\n    ],\n    offsetBottom: 0,\n    offsetTop: 0,\n    top: 0,\n    bottom: 0,\n    itemHeight: 0,\n    itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n    return {\n        ...PROBE_GRID_STATE,\n        items\n    };\n}\nfunction buildItems(startIndex, endIndex, data) {\n    return Array.from({\n        length: endIndex - startIndex + 1\n    }).map((_, i)=>{\n        const dataItem = data === null ? null : data[i + startIndex];\n        return {\n            index: i + startIndex,\n            data: dataItem\n        };\n    });\n}\nfunction gapComparator(prev, next) {\n    return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n    return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(([{ overscan, visibleRange, listBoundary }, { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight }, stateFlags, scrollSeek, { propsReady, didMount }, { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo }, log])=>{\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({\n        height: 0,\n        width: 0\n    });\n    const itemDimensions = statefulStream({\n        height: 0,\n        width: 0\n    });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(null);\n    const gap = statefulStream({\n        row: 0,\n        column: 0\n    });\n    const stateChanged = stream();\n    const restoreStateFrom = stream();\n    const stateRestoreInProgress = statefulStream(false);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrolledToInitialItem = statefulStream(true);\n    const scrollScheduled = statefulStream(false);\n    subscribe(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location])=>!!location)), ()=>{\n        publish(scrolledToInitialItem, false);\n        publish(initialItemCount, 0);\n    });\n    subscribe(pipe(combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled), filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2])=>{\n        return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n    })), ([, , , , initialTopMostItemIndex2])=>{\n        publish(scrollScheduled, true);\n        skipFrames(1, ()=>{\n            publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n        handleNext(pipe(scrollTop), ()=>{\n            publish(listBoundary, [\n                0,\n                0\n            ]);\n            publish(scrolledToInitialItem, true);\n        });\n    });\n    connect(pipe(restoreStateFrom, filter((value)=>value !== void 0 && value !== null && value.scrollTop > 0), mapTo(0)), initialItemCount);\n    subscribe(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, snapshot])=>snapshot !== void 0 && snapshot !== null)), ([, snapshot])=>{\n        if (!snapshot) {\n            return;\n        }\n        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n        publish(gap, snapshot.gap);\n        if (snapshot.scrollTop > 0) {\n            publish(stateRestoreInProgress, true);\n            handleNext(pipe(scrollTop, skip(1)), (_value)=>{\n                publish(stateRestoreInProgress, false);\n            });\n            publish(scrollTo, {\n                top: snapshot.scrollTop\n            });\n        }\n    });\n    connect(pipe(viewportDimensions, map(({ height })=>height)), viewportHeight);\n    connect(pipe(combineLatest(duc(viewportDimensions, dimensionComparator), duc(itemDimensions, dimensionComparator), duc(gap, (prev, next)=>prev && prev.column === next.column && prev.row === next.row), duc(scrollTop)), map(([viewport, item, gap2, scrollTop2])=>({\n            viewport,\n            item,\n            gap: gap2,\n            scrollTop: scrollTop2\n        }))), stateChanged);\n    connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), duc(data), duc(initialItemCount), duc(stateRestoreInProgress), duc(scrolledToInitialItem), duc(initialTopMostItemIndex)), filter(([, , , , , , , stateRestoreInProgress2])=>{\n        return !stateRestoreInProgress2;\n    }), map(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2, initialItemCount2, , scrolledToInitialItem2, initialTopMostItemIndex2])=>{\n        const { row: rowGap, column: columnGap } = gap2;\n        const { height: itemHeight, width: itemWidth } = item;\n        const { width: viewportWidth } = viewport;\n        if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n            return INITIAL_GRID_STATE;\n        }\n        if (itemWidth === 0) {\n            const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n            const endIndex2 = startIndex2 === 0 ? Math.max(initialItemCount2 - 1, 0) : startIndex2;\n            return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n        }\n        const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n        let startIndex;\n        let endIndex;\n        if (!scrolledToInitialItem2) {\n            startIndex = 0;\n            endIndex = -1;\n        } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n            startIndex = 0;\n            endIndex = initialItemCount2 - 1;\n        } else {\n            startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n            endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n            endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n            startIndex = min(endIndex, max(0, startIndex));\n        }\n        const items = buildItems(startIndex, endIndex, data2);\n        const { top, bottom } = gridLayout(viewport, gap2, item, items);\n        const rowCount = ceil(totalCount2 / perRow);\n        const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n        const offsetBottom = totalHeight - bottom;\n        return {\n            items,\n            offsetTop: top,\n            offsetBottom,\n            top,\n            bottom,\n            itemHeight,\n            itemWidth\n        };\n    })), gridState);\n    connect(pipe(data, filter((data2)=>data2 !== null), map((data2)=>data2.length)), totalCount);\n    connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), filter(([viewportDimensions2, itemDimensions2, { items }])=>{\n        return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n    }), map(([viewportDimensions2, itemDimensions2, { items }, gap2])=>{\n        const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n        return [\n            top,\n            bottom\n        ];\n    }), distinctUntilChanged(tupleComparator)), listBoundary);\n    const hasScrolled = statefulStream(false);\n    connect(pipe(scrollTop, withLatestFrom(hasScrolled), map(([scrollTop2, hasScrolled2])=>{\n        return hasScrolled2 || scrollTop2 !== 0;\n    })), hasScrolled);\n    const endReached = streamFromEmitter(pipe(duc(gridState), filter(({ items })=>items.length > 0), withLatestFrom(totalCount, hasScrolled), filter(([{ items }, totalCount2, hasScrolled2])=>hasScrolled2 && items[items.length - 1].index === totalCount2 - 1), map(([, totalCount2])=>totalCount2 - 1), distinctUntilChanged()));\n    const startReached = streamFromEmitter(pipe(duc(gridState), filter(({ items })=>{\n        return items.length > 0 && items[0].index === 0;\n    }), // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    mapTo(0), distinctUntilChanged()));\n    const rangeChanged = streamFromEmitter(pipe(duc(gridState), withLatestFrom(stateRestoreInProgress), filter(([{ items }, stateRestoreInProgress2])=>items.length > 0 && !stateRestoreInProgress2), map(([{ items }])=>{\n        return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n        };\n    }), distinctUntilChanged(rangeComparator), throttleTime(0)));\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2])=>{\n        const normalLocation = normalizeIndexLocation(location);\n        const { align, behavior, offset } = normalLocation;\n        let index = normalLocation.index;\n        if (index === \"LAST\") {\n            index = totalCount2 - 1;\n        }\n        index = max(0, index, min(totalCount2 - 1, index));\n        let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n        if (align === \"end\") {\n            top = round(top - viewportDimensions2.height + itemDimensions2.height);\n        } else if (align === \"center\") {\n            top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n        }\n        if (offset) {\n            top += offset;\n        }\n        return {\n            top,\n            behavior\n        };\n    })), scrollTo);\n    const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map((gridState2)=>{\n        return gridState2.offsetBottom + gridState2.bottom;\n    })), 0);\n    connect(pipe(windowViewportRect, map((viewportInfo)=>({\n            width: viewportInfo.visibleWidth,\n            height: viewportInfo.visibleHeight\n        }))), viewportDimensions);\n    return {\n        // input\n        data,\n        totalCount,\n        viewportDimensions,\n        itemDimensions,\n        scrollTop,\n        scrollHeight,\n        overscan,\n        scrollBy,\n        scrollTo,\n        scrollToIndex,\n        smoothScrollTargetReached,\n        windowViewportRect,\n        windowScrollTo,\n        useWindowScroll,\n        customScrollParent,\n        windowScrollContainerState,\n        deviation,\n        scrollContainerState,\n        footerHeight,\n        headerHeight,\n        initialItemCount,\n        gap,\n        restoreStateFrom,\n        ...scrollSeek,\n        initialTopMostItemIndex,\n        // output\n        gridState,\n        totalListHeight,\n        ...stateFlags,\n        startReached,\n        endReached,\n        rangeChanged,\n        stateChanged,\n        propsReady,\n        stateRestoreInProgress,\n        ...log\n    };\n}, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));\nfunction gridLayout(viewport, gap, item, items) {\n    const { height: itemHeight } = item;\n    if (itemHeight === void 0 || items.length === 0) {\n        return {\n            top: 0,\n            bottom: 0\n        };\n    }\n    const top = itemTop(viewport, gap, item, items[0].index);\n    const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n    return {\n        top,\n        bottom\n    };\n}\nfunction itemTop(viewport, gap, item, index) {\n    const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n    const rowCount = floor(index / perRow);\n    const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n    return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n    return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(()=>{\n    const itemContent = statefulStream((index)=>`Item ${index}`);\n    const components = statefulStream({});\n    const context = statefulStream(null);\n    const itemClassName = statefulStream(\"virtuoso-grid-item\");\n    const listClassName = statefulStream(\"virtuoso-grid-list\");\n    const computeItemKey = statefulStream(identity);\n    const headerFooterTag = statefulStream(\"div\");\n    const scrollerRef = statefulStream(noop);\n    const distinctProp = (propName, defaultValue = null)=>{\n        return statefulStreamFromEmitter(pipe(components, map((components2)=>components2[propName]), distinctUntilChanged()), defaultValue);\n    };\n    return {\n        context,\n        itemContent,\n        components,\n        computeItemKey,\n        itemClassName,\n        listClassName,\n        headerFooterTag,\n        scrollerRef,\n        FooterComponent: distinctProp(\"Footer\"),\n        HeaderComponent: distinctProp(\"Header\"),\n        ListComponent: distinctProp(\"List\", \"div\"),\n        ItemComponent: distinctProp(\"Item\", \"div\"),\n        ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n        ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n    };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2])=>{\n    return {\n        ...gridSystem2,\n        ...gridComponentPropsSystem2\n    };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function GridItems2() {\n    const gridState = useEmitterValue$1(\"gridState\");\n    const listClassName = useEmitterValue$1(\"listClassName\");\n    const itemClassName = useEmitterValue$1(\"itemClassName\");\n    const itemContent = useEmitterValue$1(\"itemContent\");\n    const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n    const isSeeking = useEmitterValue$1(\"isSeeking\");\n    const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n    const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n    const ListComponent = useEmitterValue$1(\"ListComponent\");\n    const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n    const context = useEmitterValue$1(\"context\");\n    const itemDimensions = usePublisher$1(\"itemDimensions\");\n    const gridGap = usePublisher$1(\"gap\");\n    const log = useEmitterValue$1(\"log\");\n    const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n    const listRef = useSize((el)=>{\n        const scrollHeight = el.parentElement.parentElement.scrollHeight;\n        scrollHeightCallback(scrollHeight);\n        const firstItem = el.firstChild;\n        if (firstItem) {\n            const { width, height } = firstItem.getBoundingClientRect();\n            itemDimensions({\n                width,\n                height\n            });\n        }\n        gridGap({\n            row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n            column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n        });\n    });\n    if (stateRestoreInProgress) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ListComponent, {\n        ref: listRef,\n        className: listClassName,\n        ...contextPropIfNotDomElement(ListComponent, context),\n        style: {\n            paddingTop: gridState.offsetTop,\n            paddingBottom: gridState.offsetBottom\n        },\n        \"data-test-id\": \"virtuoso-item-list\"\n    }, gridState.items.map((item)=>{\n        const key = computeItemKey(item.index, item.data, context);\n        return isSeeking ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {\n            key,\n            ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n            index: item.index,\n            height: gridState.itemHeight,\n            width: gridState.itemWidth\n        }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ItemComponent, {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            className: itemClassName,\n            \"data-index\": item.index,\n            key\n        }, itemContent(item.index, item.data, context));\n    }));\n});\nconst Header = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoHeader2() {\n    const Header2 = useEmitterValue$1(\"HeaderComponent\");\n    const headerHeight = usePublisher$1(\"headerHeight\");\n    const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n    const ref = useSize((el)=>headerHeight(correctItemSize(el, \"height\")));\n    const context = useEmitterValue$1(\"context\");\n    return Header2 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, {\n        ref\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoGridFooter() {\n    const Footer2 = useEmitterValue$1(\"FooterComponent\");\n    const footerHeight = usePublisher$1(\"footerHeight\");\n    const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n    const ref = useSize((el)=>footerHeight(correctItemSize(el, \"height\")));\n    const context = useEmitterValue$1(\"context\");\n    return Footer2 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, {\n        ref\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoGridMockContext);\n    const itemDimensions = usePublisher$1(\"itemDimensions\");\n    const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n    const viewportRef = useSize((el)=>{\n        viewportDimensions(el.getBoundingClientRect());\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            viewportDimensions({\n                height: ctx.viewportHeight,\n                width: ctx.viewportWidth\n            });\n            itemDimensions({\n                height: ctx.itemHeight,\n                width: ctx.itemWidth\n            });\n        }\n    }, [\n        ctx,\n        viewportDimensions,\n        itemDimensions\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: viewportStyle,\n        ref: viewportRef\n    }, children);\n};\nconst WindowViewport$1 = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoGridMockContext);\n    const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n    const itemDimensions = usePublisher$1(\"itemDimensions\");\n    const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n    const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            itemDimensions({\n                height: ctx.itemHeight,\n                width: ctx.itemWidth\n            });\n            windowViewportRect({\n                offsetTop: 0,\n                visibleHeight: ctx.viewportHeight,\n                visibleWidth: ctx.viewportWidth\n            });\n        }\n    }, [\n        ctx,\n        windowViewportRect,\n        itemDimensions\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: viewportRef,\n        style: viewportStyle\n    }, children);\n};\nconst GridRoot = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function GridRoot2({ ...props }) {\n    const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n    const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n    const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n    const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, {\n        ...props\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header, null), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GridItems, null), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer, null)));\n});\nconst { Component: Grid, usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 } = /* @__PURE__ */ systemToComponent(combinedSystem$1, {\n    optional: {\n        context: \"context\",\n        totalCount: \"totalCount\",\n        overscan: \"overscan\",\n        itemContent: \"itemContent\",\n        components: \"components\",\n        computeItemKey: \"computeItemKey\",\n        data: \"data\",\n        initialItemCount: \"initialItemCount\",\n        scrollSeekConfiguration: \"scrollSeekConfiguration\",\n        headerFooterTag: \"headerFooterTag\",\n        listClassName: \"listClassName\",\n        itemClassName: \"itemClassName\",\n        useWindowScroll: \"useWindowScroll\",\n        customScrollParent: \"customScrollParent\",\n        scrollerRef: \"scrollerRef\",\n        logLevel: \"logLevel\",\n        restoreStateFrom: \"restoreStateFrom\",\n        initialTopMostItemIndex: \"initialTopMostItemIndex\"\n    },\n    methods: {\n        scrollTo: \"scrollTo\",\n        scrollBy: \"scrollBy\",\n        scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n        isScrolling: \"isScrolling\",\n        endReached: \"endReached\",\n        startReached: \"startReached\",\n        rangeChanged: \"rangeChanged\",\n        atBottomStateChange: \"atBottomStateChange\",\n        atTopStateChange: \"atTopStateChange\",\n        stateChanged: \"stateChanged\"\n    }\n}, GridRoot);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({\n    usePublisher: usePublisher$1,\n    useEmitterValue: useEmitterValue$1,\n    useEmitter: useEmitter$1\n});\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({\n    usePublisher: usePublisher$1,\n    useEmitterValue: useEmitterValue$1,\n    useEmitter: useEmitter$1\n});\nfunction resolveGapValue(property, value, log) {\n    if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n        log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n    }\n    if (value === \"normal\") {\n        return 0;\n    }\n    return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(()=>{\n    const itemContent = statefulStream((index)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"td\", null, \"Item $\", index));\n    const context = statefulStream(null);\n    const fixedHeaderContent = statefulStream(null);\n    const fixedFooterContent = statefulStream(null);\n    const components = statefulStream({});\n    const computeItemKey = statefulStream(identity);\n    const scrollerRef = statefulStream(noop);\n    const distinctProp = (propName, defaultValue = null)=>{\n        return statefulStreamFromEmitter(pipe(components, map((components2)=>components2[propName]), distinctUntilChanged()), defaultValue);\n    };\n    return {\n        context,\n        itemContent,\n        fixedHeaderContent,\n        fixedFooterContent,\n        components,\n        computeItemKey,\n        scrollerRef,\n        TableComponent: distinctProp(\"Table\", \"table\"),\n        TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n        TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n        TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n        TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n        ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n        EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n        ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n        FillerRow: distinctProp(\"FillerRow\")\n    };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem])=>{\n    return {\n        ...listSystem2,\n        ...propsSystem\n    };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tr\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"td\", {\n        style: {\n            height\n        }\n    }));\nconst DefaultFillerRow = ({ height })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tr\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"td\", {\n        style: {\n            height,\n            padding: 0,\n            border: 0\n        }\n    }));\nconst ITEM_STYLE = {\n    overflowAnchor: \"none\"\n};\nconst Items = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoItems2() {\n    const listState = useEmitterValue(\"listState\");\n    const sizeRanges = usePublisher(\"sizeRanges\");\n    const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n    const customScrollParent = useEmitterValue(\"customScrollParent\");\n    const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n    const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n    const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n    const itemContent = useEmitterValue(\"itemContent\");\n    const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n    const itemSize = useEmitterValue(\"itemSize\");\n    const log = useEmitterValue(\"log\");\n    const { callbackRef, ref } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, scrollContainerStateCallback, log, void 0, customScrollParent);\n    const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    useEmitter(\"deviation\", (value)=>{\n        if (deviation !== value) {\n            ref.current.style.marginTop = `${value}px`;\n            setDeviation(value);\n        }\n    });\n    const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n    const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n    const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n    const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n    const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n    const computeItemKey = useEmitterValue(\"computeItemKey\");\n    const isSeeking = useEmitterValue(\"isSeeking\");\n    const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n    const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n    const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n    const context = useEmitterValue(\"context\");\n    if (statefulTotalCount === 0 && EmptyPlaceholder) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n    }\n    const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n    const paddingBottom = listState.offsetBottom;\n    const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FillerRow, {\n        height: paddingTop,\n        key: \"padding-top\",\n        context\n    }) : null;\n    const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FillerRow, {\n        height: paddingBottom,\n        key: \"padding-bottom\",\n        context\n    }) : null;\n    const items = listState.items.map((item)=>{\n        const index = item.originalIndex;\n        const key = computeItemKey(index + firstItemIndex, item.data, context);\n        if (isSeeking) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {\n                ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n                key,\n                index: item.index,\n                height: item.size,\n                type: item.type || \"item\"\n            });\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TableRowComponent, {\n            ...contextPropIfNotDomElement(TableRowComponent, context),\n            ...itemPropIfNotDomElement(TableRowComponent, item.data),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            style: ITEM_STYLE\n        }, itemContent(item.index, item.data, context));\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TableBodyComponent, {\n        ref: callbackRef,\n        \"data-test-id\": \"virtuoso-item-list\",\n        ...contextPropIfNotDomElement(TableBodyComponent, context)\n    }, [\n        paddingTopEl,\n        ...items,\n        paddingBottomEl\n    ]);\n});\nconst Viewport = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);\n    const viewportHeight = usePublisher(\"viewportHeight\");\n    const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n    const viewportRef = useSize(compose(viewportHeight, (el)=>correctItemSize(el, \"height\")));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            viewportHeight(ctx.viewportHeight);\n            fixedItemHeight(ctx.itemHeight);\n        }\n    }, [\n        ctx,\n        viewportHeight,\n        fixedItemHeight\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: viewportStyle,\n        ref: viewportRef,\n        \"data-viewport-type\": \"element\"\n    }, children);\n};\nconst WindowViewport = ({ children })=>{\n    const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);\n    const windowViewportRect = usePublisher(\"windowViewportRect\");\n    const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n    const customScrollParent = useEmitterValue(\"customScrollParent\");\n    const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (ctx) {\n            fixedItemHeight(ctx.itemHeight);\n            windowViewportRect({\n                offsetTop: 0,\n                visibleHeight: ctx.viewportHeight,\n                visibleWidth: 100\n            });\n        }\n    }, [\n        ctx,\n        windowViewportRect,\n        fixedItemHeight\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: viewportRef,\n        style: viewportStyle,\n        \"data-viewport-type\": \"window\"\n    }, children);\n};\nconst TableRoot = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(function TableVirtuosoRoot(props) {\n    const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n    const customScrollParent = useEmitterValue(\"customScrollParent\");\n    const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n    const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n    const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n    const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n    const context = useEmitterValue(\"context\");\n    const theadRef = useSize(compose(fixedHeaderHeight, (el)=>correctItemSize(el, \"height\")));\n    const tfootRef = useSize(compose(fixedFooterHeight, (el)=>correctItemSize(el, \"height\")));\n    const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n    const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n    const TheTable = useEmitterValue(\"TableComponent\");\n    const TheTHead = useEmitterValue(\"TableHeadComponent\");\n    const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n    const theHead = fixedHeaderContent ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheTHead, {\n        key: \"TableHead\",\n        style: {\n            zIndex: 2,\n            position: \"sticky\",\n            top: 0\n        },\n        ref: theadRef,\n        ...contextPropIfNotDomElement(TheTHead, context)\n    }, fixedHeaderContent()) : null;\n    const theFoot = fixedFooterContent ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheTFoot, {\n        key: \"TableFoot\",\n        style: {\n            zIndex: 1,\n            position: \"sticky\",\n            bottom: 0\n        },\n        ref: tfootRef,\n        ...contextPropIfNotDomElement(TheTFoot, context)\n    }, fixedFooterContent()) : null;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, {\n        ...props\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheTable, {\n        style: {\n            borderSpacing: 0,\n            overflowAnchor: \"none\"\n        },\n        ...contextPropIfNotDomElement(TheTable, context)\n    }, [\n        theHead,\n        /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items, {\n            key: \"TableBody\"\n        }),\n        theFoot\n    ])));\n});\nconst { Component: Table, usePublisher, useEmitterValue, useEmitter } = /* @__PURE__ */ systemToComponent(combinedSystem, {\n    required: {},\n    optional: {\n        restoreStateFrom: \"restoreStateFrom\",\n        context: \"context\",\n        followOutput: \"followOutput\",\n        firstItemIndex: \"firstItemIndex\",\n        itemContent: \"itemContent\",\n        fixedHeaderContent: \"fixedHeaderContent\",\n        fixedFooterContent: \"fixedFooterContent\",\n        overscan: \"overscan\",\n        increaseViewportBy: \"increaseViewportBy\",\n        totalCount: \"totalCount\",\n        topItemCount: \"topItemCount\",\n        initialTopMostItemIndex: \"initialTopMostItemIndex\",\n        components: \"components\",\n        groupCounts: \"groupCounts\",\n        atBottomThreshold: \"atBottomThreshold\",\n        atTopThreshold: \"atTopThreshold\",\n        computeItemKey: \"computeItemKey\",\n        defaultItemHeight: \"defaultItemHeight\",\n        fixedItemHeight: \"fixedItemHeight\",\n        itemSize: \"itemSize\",\n        scrollSeekConfiguration: \"scrollSeekConfiguration\",\n        data: \"data\",\n        initialItemCount: \"initialItemCount\",\n        initialScrollTop: \"initialScrollTop\",\n        alignToBottom: \"alignToBottom\",\n        useWindowScroll: \"useWindowScroll\",\n        customScrollParent: \"customScrollParent\",\n        scrollerRef: \"scrollerRef\",\n        logLevel: \"logLevel\"\n    },\n    methods: {\n        scrollToIndex: \"scrollToIndex\",\n        scrollIntoView: \"scrollIntoView\",\n        scrollTo: \"scrollTo\",\n        scrollBy: \"scrollBy\",\n        getState: \"getState\"\n    },\n    events: {\n        isScrolling: \"isScrolling\",\n        endReached: \"endReached\",\n        startReached: \"startReached\",\n        rangeChanged: \"rangeChanged\",\n        atBottomStateChange: \"atBottomStateChange\",\n        atTopStateChange: \"atTopStateChange\",\n        totalListHeightChanged: \"totalListHeightChanged\",\n        itemsRendered: \"itemsRendered\",\n        groupIndices: \"groupIndices\"\n    }\n}, TableRoot);\nconst Scroller = /* @__PURE__ */ buildScroller({\n    usePublisher,\n    useEmitterValue,\n    useEmitter\n});\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({\n    usePublisher,\n    useEmitterValue,\n    useEmitter\n});\nconst TableVirtuoso = Table;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ087QUFDakMsTUFBTUUsVUFBVTtBQUNoQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxRQUFRO0FBQ2QsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLE9BQU8sQ0FBQ0MsTUFBUUYsRUFBRUMsRUFBRUM7QUFDdEI7QUFDQSxTQUFTQyxPQUFPRCxHQUFHLEVBQUVFLElBQUk7SUFDdkIsT0FBT0EsS0FBS0Y7QUFDZDtBQUNBLFNBQVNHLFVBQVVELElBQUksRUFBRUUsSUFBSTtJQUMzQixPQUFPLENBQUNDLE9BQVNILEtBQUtFLE1BQU1DO0FBQzlCO0FBQ0EsU0FBU0MsVUFBVUosSUFBSSxFQUFFRixHQUFHO0lBQzFCLE9BQU8sSUFBTUUsS0FBS0Y7QUFDcEI7QUFDQSxTQUFTTyxJQUFJUCxHQUFHLEVBQUVFLElBQUk7SUFDcEJBLEtBQUtGO0lBQ0wsT0FBT0E7QUFDVDtBQUNBLFNBQVNRLElBQUksR0FBR0MsSUFBSTtJQUNsQixPQUFPQTtBQUNUO0FBQ0EsU0FBU0MsS0FBS1IsSUFBSTtJQUNoQkE7QUFDRjtBQUNBLFNBQVNTLE9BQU9DLEtBQUs7SUFDbkIsT0FBTyxJQUFNQTtBQUNmO0FBQ0EsU0FBU0MsU0FBUyxHQUFHQyxLQUFLO0lBQ3hCLE9BQU87UUFDTEEsTUFBTUMsR0FBRyxDQUFDTDtJQUNaO0FBQ0Y7QUFDQSxTQUFTTSxVQUFVaEIsR0FBRztJQUNwQixPQUFPQSxRQUFRLEtBQUs7QUFDdEI7QUFDQSxTQUFTaUIsUUFDVDtBQUNBLFNBQVNDLFVBQVVDLE9BQU8sRUFBRUMsWUFBWTtJQUN0QyxPQUFPRCxRQUFRekIsV0FBVzBCO0FBQzVCO0FBQ0EsU0FBU0MsUUFBUUMsU0FBUyxFQUFFVixLQUFLO0lBQy9CVSxVQUFVN0IsU0FBU21CO0FBQ3JCO0FBQ0EsU0FBU1cs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QjtRQUN4QmxDLGVBQWU7UUFDZnpQLGNBQWM7SUFDaEI7QUFDRixHQUNBMmhCO0FBRUYsTUFBTUssV0FBVyxhQUFhLEdBQUc5RyxjQUFjO0lBQUV0bUI7SUFBY0M7SUFBaUJDO0FBQVc7QUFDM0YsTUFBTWl0QixpQkFBaUIsYUFBYSxHQUFHekcsb0JBQW9CO0lBQUUxbUI7SUFBY0M7SUFBaUJDO0FBQVc7QUFDdkcsTUFBTTB0QixnQkFBZ0JEO0FBU3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlnbWEvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanM/MWI4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuY29uc3QgUFVCTElTSCA9IDA7XG5jb25zdCBTVUJTQ1JJQkUgPSAxO1xuY29uc3QgUkVTRVQgPSAyO1xuY29uc3QgVkFMVUUgPSA0O1xuZnVuY3Rpb24gY29tcG9zZShhLCBiKSB7XG4gIHJldHVybiAoYXJnKSA9PiBhKGIoYXJnKSk7XG59XG5mdW5jdGlvbiB0aHJ1c2goYXJnLCBwcm9jKSB7XG4gIHJldHVybiBwcm9jKGFyZyk7XG59XG5mdW5jdGlvbiBjdXJyeTJ0bzEocHJvYywgYXJnMSkge1xuICByZXR1cm4gKGFyZzIpID0+IHByb2MoYXJnMSwgYXJnMik7XG59XG5mdW5jdGlvbiBjdXJyeTF0bzAocHJvYywgYXJnKSB7XG4gIHJldHVybiAoKSA9PiBwcm9jKGFyZyk7XG59XG5mdW5jdGlvbiB0YXAoYXJnLCBwcm9jKSB7XG4gIHByb2MoYXJnKTtcbiAgcmV0dXJuIGFyZztcbn1cbmZ1bmN0aW9uIHR1cCguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzO1xufVxuZnVuY3Rpb24gY2FsbChwcm9jKSB7XG4gIHByb2MoKTtcbn1cbmZ1bmN0aW9uIGFsd2F5cyh2YWx1ZSkge1xuICByZXR1cm4gKCkgPT4gdmFsdWU7XG59XG5mdW5jdGlvbiBqb2luUHJvYyguLi5wcm9jcykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHByb2NzLm1hcChjYWxsKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShlbWl0dGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIGVtaXR0ZXIoU1VCU0NSSUJFLCBzdWJzY3JpcHRpb24pO1xufVxuZnVuY3Rpb24gcHVibGlzaChwdWJsaXNoZXIsIHZhbHVlKSB7XG4gIHB1Ymxpc2hlcihQVUJMSVNILCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNldChlbWl0dGVyKSB7XG4gIGVtaXR0ZXIoUkVTRVQpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUoZGVwb3QpIHtcbiAgcmV0dXJuIGRlcG90KFZBTFVFKTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3QoZW1pdHRlciwgcHVibGlzaGVyKSB7XG4gIHJldHVybiBzdWJzY3JpYmUoZW1pdHRlciwgY3VycnkydG8xKHB1Ymxpc2hlciwgUFVCTElTSCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlTmV4dChlbWl0dGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgdW5zdWIgPSBlbWl0dGVyKFNVQlNDUklCRSwgKHZhbHVlKSA9PiB7XG4gICAgdW5zdWIoKTtcbiAgICBzdWJzY3JpcHRpb24odmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHVuc3ViO1xufVxuZnVuY3Rpb24gc3RyZWFtKCkge1xuICBjb25zdCBzdWJzY3JpcHRpb25zID0gW107XG4gIHJldHVybiAoYWN0aW9uLCBhcmcpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoMCwgc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGFyZyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kZXhPZiA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihhcmcpO1xuICAgICAgICAgIGlmIChpbmRleE9mID4gLTEpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKGluZGV4T2YsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgUFVCTElTSDpcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zbGljZSgpLmZvckVhY2goKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbihhcmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYWN0aW9uICR7YWN0aW9ufWApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0YXRlZnVsU3RyZWFtKGluaXRpYWwpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbDtcbiAgY29uc3QgaW5uZXJTdWJqZWN0ID0gc3RyZWFtKCk7XG4gIHJldHVybiAoYWN0aW9uLCBhcmcpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFyZztcbiAgICAgICAgc3Vic2NyaXB0aW9uKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBVQkxJU0g6XG4gICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVkFMVUU6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlubmVyU3ViamVjdChhY3Rpb24sIGFyZyk7XG4gIH07XG59XG5mdW5jdGlvbiBldmVudEhhbmRsZXIoZW1pdHRlcikge1xuICBsZXQgdW5zdWI7XG4gIGxldCBjdXJyZW50U3Vic2NyaXB0aW9uO1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4gdW5zdWIgJiYgdW5zdWIoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpcHRpb24gPT09IHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgY3VycmVudFN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICB1bnN1YiA9IHN1YnNjcmliZShlbWl0dGVyLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICAgIHJldHVybiB1bnN1YjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgY3VycmVudFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFjdGlvbiAke2FjdGlvbn1gKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJlYW1Gcm9tRW1pdHRlcihlbWl0dGVyKSB7XG4gIHJldHVybiB0YXAoc3RyZWFtKCksIChzdHJlYW0yKSA9PiBjb25uZWN0KGVtaXR0ZXIsIHN0cmVhbTIpKTtcbn1cbmZ1bmN0aW9uIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoZW1pdHRlciwgaW5pdGlhbCkge1xuICByZXR1cm4gdGFwKHN0YXRlZnVsU3RyZWFtKGluaXRpYWwpLCAoc3RyZWFtMikgPT4gY29ubmVjdChlbWl0dGVyLCBzdHJlYW0yKSk7XG59XG5mdW5jdGlvbiBjb21iaW5lT3BlcmF0b3JzKC4uLm9wZXJhdG9ycykge1xuICByZXR1cm4gKHN1YnNjcmliZXIpID0+IHtcbiAgICByZXR1cm4gb3BlcmF0b3JzLnJlZHVjZVJpZ2h0KHRocnVzaCwgc3Vic2NyaWJlcik7XG4gIH07XG59XG5mdW5jdGlvbiBwaXBlKHNvdXJjZSwgLi4ub3BlcmF0b3JzKSB7XG4gIGNvbnN0IHByb2plY3QgPSBjb21iaW5lT3BlcmF0b3JzKC4uLm9wZXJhdG9ycyk7XG4gIHJldHVybiAoYWN0aW9uLCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUoc291cmNlLCBwcm9qZWN0KHN1YnNjcmlwdGlvbikpO1xuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgcmVzZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKHByZXZpb3VzLCBuZXh0KSB7XG4gIHJldHVybiBwcmV2aW91cyA9PT0gbmV4dDtcbn1cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcikge1xuICBsZXQgY3VycmVudDtcbiAgcmV0dXJuIChkb25lKSA9PiAobmV4dCkgPT4ge1xuICAgIGlmICghY29tcGFyYXRvcihjdXJyZW50LCBuZXh0KSkge1xuICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICBkb25lKG5leHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IHtcbiAgICBwcmVkaWNhdGUodmFsdWUpICYmIGRvbmUodmFsdWUpO1xuICB9O1xufVxuZnVuY3Rpb24gbWFwKHByb2plY3QpIHtcbiAgcmV0dXJuIChkb25lKSA9PiBjb21wb3NlKGRvbmUsIHByb2plY3QpO1xufVxuZnVuY3Rpb24gbWFwVG8odmFsdWUpIHtcbiAgcmV0dXJuIChkb25lKSA9PiAoKSA9PiBkb25lKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNjYW4oc2Nhbm5lciwgaW5pdGlhbCkge1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4gZG9uZShpbml0aWFsID0gc2Nhbm5lcihpbml0aWFsLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gc2tpcCh0aW1lcykge1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4ge1xuICAgIHRpbWVzID4gMCA/IHRpbWVzLS0gOiBkb25lKHZhbHVlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRocm90dGxlVGltZShpbnRlcnZhbCkge1xuICBsZXQgY3VycmVudFZhbHVlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgIGRvbmUoY3VycmVudFZhbHVlKTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoaW50ZXJ2YWwpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZTtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9uZShjdXJyZW50VmFsdWUpO1xuICAgIH0sIGludGVydmFsKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tKC4uLnNvdXJjZXMpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KHNvdXJjZXMubGVuZ3RoKTtcbiAgbGV0IGNhbGxlZCA9IDA7XG4gIGxldCBwZW5kaW5nQ2FsbCA9IG51bGw7XG4gIGNvbnN0IGFsbENhbGxlZCA9IE1hdGgucG93KDIsIHNvdXJjZXMubGVuZ3RoKSAtIDE7XG4gIHNvdXJjZXMuZm9yRWFjaCgoc291cmNlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGJpdCA9IE1hdGgucG93KDIsIGluZGV4KTtcbiAgICBzdWJzY3JpYmUoc291cmNlLCAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHByZXZDYWxsZWQgPSBjYWxsZWQ7XG4gICAgICBjYWxsZWQgPSBjYWxsZWQgfCBiaXQ7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICBpZiAocHJldkNhbGxlZCAhPT0gYWxsQ2FsbGVkICYmIGNhbGxlZCA9PT0gYWxsQ2FsbGVkICYmIHBlbmRpbmdDYWxsKSB7XG4gICAgICAgIHBlbmRpbmdDYWxsKCk7XG4gICAgICAgIHBlbmRpbmdDYWxsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2FsbDIgPSAoKSA9PiBkb25lKFt2YWx1ZV0uY29uY2F0KHZhbHVlcykpO1xuICAgIGlmIChjYWxsZWQgPT09IGFsbENhbGxlZCkge1xuICAgICAgY2FsbDIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0NhbGwgPSBjYWxsMjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZSguLi5zb3VyY2VzKSB7XG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24sIHN1YnNjcmlwdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgcmV0dXJuIGpvaW5Qcm9jKC4uLnNvdXJjZXMubWFwKChzb3VyY2UpID0+IHN1YnNjcmliZShzb3VyY2UsIHN1YnNjcmlwdGlvbikpKTtcbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFjdGlvbiAke2FjdGlvbn1gKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkdWMoc291cmNlLCBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3IpIHtcbiAgcmV0dXJuIHBpcGUoc291cmNlLCBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yKSk7XG59XG5mdW5jdGlvbiBjb21iaW5lTGF0ZXN0KC4uLmVtaXR0ZXJzKSB7XG4gIGNvbnN0IGlubmVyU3ViamVjdCA9IHN0cmVhbSgpO1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoZW1pdHRlcnMubGVuZ3RoKTtcbiAgbGV0IGNhbGxlZCA9IDA7XG4gIGNvbnN0IGFsbENhbGxlZCA9IE1hdGgucG93KDIsIGVtaXR0ZXJzLmxlbmd0aCkgLSAxO1xuICBlbWl0dGVycy5mb3JFYWNoKChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgYml0ID0gTWF0aC5wb3coMiwgaW5kZXgpO1xuICAgIHN1YnNjcmliZShzb3VyY2UsICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgY2FsbGVkID0gY2FsbGVkIHwgYml0O1xuICAgICAgaWYgKGNhbGxlZCA9PT0gYWxsQ2FsbGVkKSB7XG4gICAgICAgIHB1Ymxpc2goaW5uZXJTdWJqZWN0LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24odmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGlubmVyU3ViamVjdCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHJldHVybiByZXNldChpbm5lclN1YmplY3QpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYWN0aW9uICR7YWN0aW9ufWApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN5c3RlbShjb25zdHJ1Y3RvciwgZGVwZW5kZW5jaWVzID0gW10sIHsgc2luZ2xldG9uIH0gPSB7IHNpbmdsZXRvbjogdHJ1ZSB9KSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGlkKCksXG4gICAgY29uc3RydWN0b3IsXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIHNpbmdsZXRvblxuICB9O1xufVxuY29uc3QgaWQgPSAoKSA9PiBTeW1ib2woKTtcbmZ1bmN0aW9uIGluaXQoc3lzdGVtU3BlYykge1xuICBjb25zdCBzaW5nbGV0b25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgX2luaXQgPSAoeyBpZDogaWQyLCBjb25zdHJ1Y3RvciwgZGVwZW5kZW5jaWVzLCBzaW5nbGV0b24gfSkgPT4ge1xuICAgIGlmIChzaW5nbGV0b24gJiYgc2luZ2xldG9ucy5oYXMoaWQyKSkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbnMuZ2V0KGlkMik7XG4gICAgfVxuICAgIGNvbnN0IHN5c3RlbTIgPSBjb25zdHJ1Y3RvcihkZXBlbmRlbmNpZXMubWFwKChlKSA9PiBfaW5pdChlKSkpO1xuICAgIGlmIChzaW5nbGV0b24pIHtcbiAgICAgIHNpbmdsZXRvbnMuc2V0KGlkMiwgc3lzdGVtMik7XG4gICAgfVxuICAgIHJldHVybiBzeXN0ZW0yO1xuICB9O1xuICByZXR1cm4gX2luaXQoc3lzdGVtU3BlYyk7XG59XG5mdW5jdGlvbiBvbWl0KGtleXMsIG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgaW5kZXggPSB7fTtcbiAgbGV0IGlkeCA9IDA7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaW5kZXhba2V5c1tpZHhdXSA9IDE7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgIGlmICghaW5kZXguaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHN5c3RlbVRvQ29tcG9uZW50KHN5c3RlbVNwZWMsIG1hcDIsIFJvb3QpIHtcbiAgY29uc3QgcmVxdWlyZWRQcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhtYXAyLnJlcXVpcmVkIHx8IHt9KTtcbiAgY29uc3Qgb3B0aW9uYWxQcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhtYXAyLm9wdGlvbmFsIHx8IHt9KTtcbiAgY29uc3QgbWV0aG9kTmFtZXMgPSBPYmplY3Qua2V5cyhtYXAyLm1ldGhvZHMgfHwge30pO1xuICBjb25zdCBldmVudE5hbWVzID0gT2JqZWN0LmtleXMobWFwMi5ldmVudHMgfHwge30pO1xuICBjb25zdCBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG4gIGZ1bmN0aW9uIGFwcGx5UHJvcHNUb1N5c3RlbShzeXN0ZW0yLCBwcm9wcykge1xuICAgIGlmIChzeXN0ZW0yW1wicHJvcHNSZWFkeVwiXSkge1xuICAgICAgcHVibGlzaChzeXN0ZW0yW1wicHJvcHNSZWFkeVwiXSwgZmFsc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVpcmVkUHJvcE5hbWUgb2YgcmVxdWlyZWRQcm9wTmFtZXMpIHtcbiAgICAgIGNvbnN0IHN0cmVhbTIgPSBzeXN0ZW0yW21hcDIucmVxdWlyZWRbcmVxdWlyZWRQcm9wTmFtZV1dO1xuICAgICAgcHVibGlzaChzdHJlYW0yLCBwcm9wc1tyZXF1aXJlZFByb3BOYW1lXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3B0aW9uYWxQcm9wTmFtZSBvZiBvcHRpb25hbFByb3BOYW1lcykge1xuICAgICAgaWYgKG9wdGlvbmFsUHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtMiA9IHN5c3RlbTJbbWFwMi5vcHRpb25hbFtvcHRpb25hbFByb3BOYW1lXV07XG4gICAgICAgIHB1Ymxpc2goc3RyZWFtMiwgcHJvcHNbb3B0aW9uYWxQcm9wTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3lzdGVtMltcInByb3BzUmVhZHlcIl0pIHtcbiAgICAgIHB1Ymxpc2goc3lzdGVtMltcInByb3BzUmVhZHlcIl0sIHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBidWlsZE1ldGhvZHMoc3lzdGVtMikge1xuICAgIHJldHVybiBtZXRob2ROYW1lcy5yZWR1Y2UoKGFjYywgbWV0aG9kTmFtZSkgPT4ge1xuICAgICAgYWNjW21ldGhvZE5hbWVdID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmVhbTIgPSBzeXN0ZW0yW21hcDIubWV0aG9kc1ttZXRob2ROYW1lXV07XG4gICAgICAgIHB1Ymxpc2goc3RyZWFtMiwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkRXZlbnRIYW5kbGVycyhzeXN0ZW0yKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZXMucmVkdWNlKChoYW5kbGVycywgZXZlbnROYW1lKSA9PiB7XG4gICAgICBoYW5kbGVyc1tldmVudE5hbWVdID0gZXZlbnRIYW5kbGVyKHN5c3RlbTJbbWFwMi5ldmVudHNbZXZlbnROYW1lXV0pO1xuICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgIH0sIHt9KTtcbiAgfVxuICBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wc1dpdGhDaGlsZHJlbiwgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucHJvcHMgfSA9IHByb3BzV2l0aENoaWxkcmVuO1xuICAgIGNvbnN0IFtzeXN0ZW0yXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgIHJldHVybiB0YXAoaW5pdChzeXN0ZW1TcGVjKSwgKHN5c3RlbTIyKSA9PiBhcHBseVByb3BzVG9TeXN0ZW0oc3lzdGVtMjIsIHByb3BzKSk7XG4gICAgfSk7XG4gICAgY29uc3QgW2hhbmRsZXJzXSA9IFJlYWN0LnVzZVN0YXRlKGN1cnJ5MXRvMChidWlsZEV2ZW50SGFuZGxlcnMsIHN5c3RlbTIpKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDIoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgb2YgZXZlbnROYW1lcykge1xuICAgICAgICBpZiAoZXZlbnROYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgc3Vic2NyaWJlKGhhbmRsZXJzW2V2ZW50TmFtZV0sIHByb3BzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBPYmplY3QudmFsdWVzKGhhbmRsZXJzKS5tYXAocmVzZXQpO1xuICAgICAgfTtcbiAgICB9LCBbcHJvcHMsIGhhbmRsZXJzLCBzeXN0ZW0yXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCQyKCgpID0+IHtcbiAgICAgIGFwcGx5UHJvcHNUb1N5c3RlbShzeXN0ZW0yLCBwcm9wcyk7XG4gICAgfSk7XG4gICAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGFsd2F5cyhidWlsZE1ldGhvZHMoc3lzdGVtMikpKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7IHZhbHVlOiBzeXN0ZW0yIH0sXG4gICAgICBSb290ID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUm9vdCxcbiAgICAgICAgb21pdChbLi4ucmVxdWlyZWRQcm9wTmFtZXMsIC4uLm9wdGlvbmFsUHJvcE5hbWVzLCAuLi5ldmVudE5hbWVzXSwgcHJvcHMpLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKSA6IGNoaWxkcmVuXG4gICAgKTtcbiAgfSk7XG4gIGNvbnN0IHVzZVB1Ymxpc2hlcjIgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJ5MnRvMShwdWJsaXNoLCBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpW2tleV0pLCBba2V5XSk7XG4gIH07XG4gIGNvbnN0IHVzZUVtaXR0ZXJWYWx1ZTIgPSAoa2V5KSA9PiB7XG4gICAgY29uc3Qgc3lzdGVtMiA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgY29uc3Qgc291cmNlID0gc3lzdGVtMltrZXldO1xuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoY3VycnkxdG8wKGdldFZhbHVlLCBzb3VyY2UpKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDIoXG4gICAgICAoKSA9PiBzdWJzY3JpYmUoc291cmNlLCAobmV4dCkgPT4ge1xuICAgICAgICBpZiAobmV4dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShhbHdheXMobmV4dCkpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFtzb3VyY2UsIHZhbHVlXVxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBjb25zdCB1c2VFbWl0dGVyMiA9IChrZXksIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgY29uc3Qgc291cmNlID0gY29udGV4dFtrZXldO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMigoKSA9PiBzdWJzY3JpYmUoc291cmNlLCBjYWxsYmFjayksIFtjYWxsYmFjaywgc291cmNlXSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50LFxuICAgIHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyMixcbiAgICB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZTIsXG4gICAgdXNlRW1pdHRlcjogdXNlRW1pdHRlcjJcbiAgfTtcbn1cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDEgPSB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0O1xudmFyIExvZ0xldmVsID0gLyogQF9fUFVSRV9fICovICgoTG9nTGV2ZWwyKSA9PiB7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gIHJldHVybiBMb2dMZXZlbDI7XG59KShMb2dMZXZlbCB8fCB7fSk7XG5jb25zdCBDT05TT0xFX01FVEhPRF9NQVAgPSB7XG4gIFtcbiAgICAwXG4gICAgLyogREVCVUcgKi9cbiAgXTogXCJkZWJ1Z1wiLFxuICBbXG4gICAgMVxuICAgIC8qIElORk8gKi9cbiAgXTogXCJsb2dcIixcbiAgW1xuICAgIDJcbiAgICAvKiBXQVJOICovXG4gIF06IFwid2FyblwiLFxuICBbXG4gICAgM1xuICAgIC8qIEVSUk9SICovXG4gIF06IFwiZXJyb3JcIlxufTtcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IGdsb2JhbFRoaXM7XG5jb25zdCBsb2dnZXJTeXN0ZW0gPSBzeXN0ZW0oXG4gICgpID0+IHtcbiAgICBjb25zdCBsb2dMZXZlbCA9IHN0YXRlZnVsU3RyZWFtKFxuICAgICAgM1xuICAgICAgLyogRVJST1IgKi9cbiAgICApO1xuICAgIGNvbnN0IGxvZyA9IHN0YXRlZnVsU3RyZWFtKChsYWJlbCwgbWVzc2FnZSwgbGV2ZWwgPSAxKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSAoX2EgPSBnZXRHbG9iYWxUaGlzKClbXCJWSVJUVU9TT19MT0dfTEVWRUxcIl0pICE9IG51bGwgPyBfYSA6IGdldFZhbHVlKGxvZ0xldmVsKTtcbiAgICAgIGlmIChsZXZlbCA+PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgY29uc29sZVtDT05TT0xFX01FVEhPRF9NQVBbbGV2ZWxdXShcbiAgICAgICAgICBcIiVjcmVhY3QtdmlydHVvc286ICVjJXMgJW9cIixcbiAgICAgICAgICBcImNvbG9yOiAjMDI1M2IzOyBmb250LXdlaWdodDogYm9sZFwiLFxuICAgICAgICAgIFwiY29sb3I6IGluaXRpYWxcIixcbiAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZyxcbiAgICAgIGxvZ0xldmVsXG4gICAgfTtcbiAgfSxcbiAgW10sXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiB1c2VTaXplV2l0aEVsUmVmKGNhbGxiYWNrLCBlbmFibGVkID0gdHJ1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGxldCBjYWxsYmFja1JlZiA9IChfZWwpID0+IHtcbiAgfTtcbiAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IG9ic2VydmVyID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyaWVzWzBdLnRhcmdldDtcbiAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIFtjYWxsYmFja10pO1xuICAgIGNhbGxiYWNrUmVmID0gKGVsUmVmKSA9PiB7XG4gICAgICBpZiAoZWxSZWYgJiYgZW5hYmxlZCkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsUmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBlbFJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgcmVmLCBjYWxsYmFja1JlZiB9O1xufVxuZnVuY3Rpb24gdXNlU2l6ZShjYWxsYmFjaywgZW5hYmxlZCA9IHRydWUpIHtcbiAgcmV0dXJuIHVzZVNpemVXaXRoRWxSZWYoY2FsbGJhY2ssIGVuYWJsZWQpLmNhbGxiYWNrUmVmO1xufVxuZnVuY3Rpb24gdXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzKGNhbGxiYWNrLCBpdGVtU2l6ZSwgZW5hYmxlZCwgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjaywgbG9nLCBnYXAsIGN1c3RvbVNjcm9sbFBhcmVudCkge1xuICBjb25zdCBtZW1vZWRDYWxsYmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbCkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VzID0gZ2V0Q2hhbmdlZENoaWxkU2l6ZXMoZWwuY2hpbGRyZW4sIGl0ZW1TaXplLCBcIm9mZnNldEhlaWdodFwiLCBsb2cpO1xuICAgICAgbGV0IHNjcm9sbGFibGVFbGVtZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICAgIHdoaWxlICghc2Nyb2xsYWJsZUVsZW1lbnQuZGF0YXNldFtcInZpcnR1b3NvU2Nyb2xsZXJcIl0pIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQgPSBzY3JvbGxhYmxlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgd2luZG93U2Nyb2xsaW5nID0gc2Nyb2xsYWJsZUVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZC5kYXRhc2V0W1widmlld3BvcnRUeXBlXCJdID09PSBcIndpbmRvd1wiO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA6IHdpbmRvd1Njcm9sbGluZyA/IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbEhlaWdodCA6IHdpbmRvd1Njcm9sbGluZyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGN1c3RvbVNjcm9sbFBhcmVudCA/IGN1c3RvbVNjcm9sbFBhcmVudC5vZmZzZXRIZWlnaHQgOiB3aW5kb3dTY3JvbGxpbmcgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBzY3JvbGxhYmxlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrKHtcbiAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChzY3JvbGxUb3AsIDApLFxuICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgIHZpZXdwb3J0SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGdhcCA9PSBudWxsID8gdm9pZCAwIDogZ2FwKHJlc29sdmVHYXBWYWx1ZSQxKFwicm93LWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGVsKS5yb3dHYXAsIGxvZykpO1xuICAgICAgaWYgKHJhbmdlcyAhPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayhyYW5nZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2NhbGxiYWNrLCBpdGVtU2l6ZSwgbG9nLCBnYXAsIGN1c3RvbVNjcm9sbFBhcmVudCwgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFja11cbiAgKTtcbiAgcmV0dXJuIHVzZVNpemVXaXRoRWxSZWYobWVtb2VkQ2FsbGJhY2ssIGVuYWJsZWQpO1xufVxuZnVuY3Rpb24gZ2V0Q2hhbmdlZENoaWxkU2l6ZXMoY2hpbGRyZW4sIGl0ZW1TaXplLCBmaWVsZCwgbG9nKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4uaXRlbShpKTtcbiAgICBpZiAoIWNoaWxkIHx8IGNoaWxkLmRhdGFzZXQuaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY2hpbGQuZGF0YXNldC5pbmRleCk7XG4gICAgY29uc3Qga25vd25TaXplID0gcGFyc2VGbG9hdChjaGlsZC5kYXRhc2V0Lmtub3duU2l6ZSk7XG4gICAgY29uc3Qgc2l6ZSA9IGl0ZW1TaXplKGNoaWxkLCBmaWVsZCk7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGxvZyhcIlplcm8tc2l6ZWQgZWxlbWVudCwgdGhpcyBzaG91bGQgbm90IGhhcHBlblwiLCB7IGNoaWxkIH0sIExvZ0xldmVsLkVSUk9SKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPT09IGtub3duU2l6ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSZXN1bHQgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwIHx8IGxhc3RSZXN1bHQuc2l6ZSAhPT0gc2l6ZSB8fCBsYXN0UmVzdWx0LmVuZEluZGV4ICE9PSBpbmRleCAtIDEpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IHN0YXJ0SW5kZXg6IGluZGV4LCBlbmRJbmRleDogaW5kZXgsIHNpemUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5lbmRJbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVHYXBWYWx1ZSQxKHByb3BlcnR5LCB2YWx1ZSwgbG9nKSB7XG4gIGlmICh2YWx1ZSAhPT0gXCJub3JtYWxcIiAmJiAhKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5lbmRzV2l0aChcInB4XCIpKSkge1xuICAgIGxvZyhgJHtwcm9wZXJ0eX0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCB2YWx1ZSwgTG9nTGV2ZWwuV0FSTik7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiMFwiLCAxMCk7XG59XG5mdW5jdGlvbiBjb3JyZWN0SXRlbVNpemUoZWwsIGRpbWVuc2lvbikge1xuICByZXR1cm4gTWF0aC5yb3VuZChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dKTtcbn1cbmZ1bmN0aW9uIGFwcHJveGltYXRlbHlFcXVhbChudW0xLCBudW0yKSB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCAxLjAxO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9wKHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2ssIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsIHNjcm9sbGVyRWxlbWVudCwgc2Nyb2xsZXJSZWZDYWxsYmFjayA9IG5vb3AsIGN1c3RvbVNjcm9sbFBhcmVudCkge1xuICBjb25zdCBzY3JvbGxlclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2Nyb2xsVG9wVGFyZ2V0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBoYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2KSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGV2LnRhcmdldDtcbiAgICAgIGNvbnN0IHdpbmRvd1Njcm9sbCA9IGVsID09PSB3aW5kb3cgfHwgZWwgPT09IGRvY3VtZW50O1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93U2Nyb2xsID8gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBlbC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB3aW5kb3dTY3JvbGwgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3dTY3JvbGwgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBjYWxsMiA9ICgpID0+IHtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayh7XG4gICAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChzY3JvbGxUb3AsIDApLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAoZXYuc3VwcHJlc3NGbHVzaFN5bmMpIHtcbiAgICAgICAgY2FsbDIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYyhjYWxsMik7XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNjcm9sbFRvcCA9PT0gc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgfHwgc2Nyb2xsVG9wIDw9IDAgfHwgc2Nyb2xsVG9wID09PSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodCkge1xuICAgICAgICAgIHNjcm9sbFRvcFRhcmdldC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkKHRydWUpO1xuICAgICAgICAgIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLCBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkXVxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvY2FsUmVmID0gY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50IDogc2Nyb2xsZXJSZWYuY3VycmVudDtcbiAgICBzY3JvbGxlclJlZkNhbGxiYWNrKGN1c3RvbVNjcm9sbFBhcmVudCA/IGN1c3RvbVNjcm9sbFBhcmVudCA6IHNjcm9sbGVyUmVmLmN1cnJlbnQpO1xuICAgIGhhbmRsZXIoeyB0YXJnZXQ6IGxvY2FsUmVmLCBzdXBwcmVzc0ZsdXNoU3luYzogdHJ1ZSB9KTtcbiAgICBsb2NhbFJlZi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2Nyb2xsZXJSZWZDYWxsYmFjayhudWxsKTtcbiAgICAgIGxvY2FsUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW3Njcm9sbGVyUmVmLCBoYW5kbGVyLCBzY3JvbGxlckVsZW1lbnQsIHNjcm9sbGVyUmVmQ2FsbGJhY2ssIGN1c3RvbVNjcm9sbFBhcmVudF0pO1xuICBmdW5jdGlvbiBzY3JvbGxUb0NhbGxiYWNrKGxvY2F0aW9uKSB7XG4gICAgY29uc3Qgc2Nyb2xsZXJFbGVtZW50MiA9IHNjcm9sbGVyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFzY3JvbGxlckVsZW1lbnQyIHx8IFwib2Zmc2V0SGVpZ2h0XCIgaW4gc2Nyb2xsZXJFbGVtZW50MiAmJiBzY3JvbGxlckVsZW1lbnQyLm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1Ntb290aCA9IGxvY2F0aW9uLmJlaGF2aW9yID09PSBcInNtb290aFwiO1xuICAgIGxldCBvZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHNjcm9sbEhlaWdodDtcbiAgICBsZXQgc2Nyb2xsVG9wO1xuICAgIGlmIChzY3JvbGxlckVsZW1lbnQyID09PSB3aW5kb3cpIHtcbiAgICAgIHNjcm9sbEhlaWdodCA9IE1hdGgubWF4KGNvcnJlY3RJdGVtU2l6ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwiaGVpZ2h0XCIpLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KTtcbiAgICAgIG9mZnNldEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIHNjcm9sbFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbEhlaWdodCA9IHNjcm9sbGVyRWxlbWVudDIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29ycmVjdEl0ZW1TaXplKHNjcm9sbGVyRWxlbWVudDIsIFwiaGVpZ2h0XCIpO1xuICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsZXJFbGVtZW50Mi5zY3JvbGxUb3A7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjcm9sbFRvcCA9IHNjcm9sbEhlaWdodCAtIG9mZnNldEhlaWdodDtcbiAgICBsb2NhdGlvbi50b3AgPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5taW4obWF4U2Nyb2xsVG9wLCBsb2NhdGlvbi50b3ApLCAwKSk7XG4gICAgaWYgKGFwcHJveGltYXRlbHlFcXVhbChvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCkgfHwgbG9jYXRpb24udG9wID09PSBzY3JvbGxUb3ApIHtcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2soeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgdmlld3BvcnRIZWlnaHQ6IG9mZnNldEhlaWdodCB9KTtcbiAgICAgIGlmIChpc1Ntb290aCkge1xuICAgICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNTbW9vdGgpIHtcbiAgICAgIHNjcm9sbFRvcFRhcmdldC5jdXJyZW50ID0gbG9jYXRpb24udG9wO1xuICAgICAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBzY3JvbGxUb3BUYXJnZXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQodHJ1ZSk7XG4gICAgICB9LCAxZTMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb3BUYXJnZXQuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHNjcm9sbGVyRWxlbWVudDIuc2Nyb2xsVG8obG9jYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbEJ5Q2FsbGJhY2sobG9jYXRpb24pIHtcbiAgICBzY3JvbGxlclJlZi5jdXJyZW50LnNjcm9sbEJ5KGxvY2F0aW9uKTtcbiAgfVxuICByZXR1cm4geyBzY3JvbGxlclJlZiwgc2Nyb2xsQnlDYWxsYmFjaywgc2Nyb2xsVG9DYWxsYmFjayB9O1xufVxuY29uc3QgZG9tSU9TeXN0ZW0gPSBzeXN0ZW0oXG4gICgpID0+IHtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJTdGF0ZSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IGRldmlhdGlvbiA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzdGF0ZWZ1bFNjcm9sbFRvcCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gc3RyZWFtKCk7XG4gICAgY29uc3QgaGVhZGVySGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZml4ZWRIZWFkZXJIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBmaXhlZEZvb3RlckhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGZvb3RlckhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IHNjcm9sbFRvID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsQnkgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxpbmdJblByb2dyZXNzID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgICAgbWFwKCh7IHNjcm9sbFRvcDogc2Nyb2xsVG9wMiB9KSA9PiBzY3JvbGxUb3AyKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbFRvcFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgICBtYXAoKHsgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxIZWlnaHQyIH0pID0+IHNjcm9sbEhlaWdodDIpXG4gICAgICApLFxuICAgICAgc2Nyb2xsSGVpZ2h0XG4gICAgKTtcbiAgICBjb25uZWN0KHNjcm9sbFRvcCwgc3RhdGVmdWxTY3JvbGxUb3ApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0LFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHQsXG4gICAgICBmb290ZXJIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgLy8gc2lnbmFsc1xuICAgICAgc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeSxcbiAgICAgIC8vIHN0YXRlXG4gICAgICBzdGF0ZWZ1bFNjcm9sbFRvcCxcbiAgICAgIGRldmlhdGlvbixcbiAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3NcbiAgICB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IE5JTF9OT0RFID0geyBsdmw6IDAgfTtcbmZ1bmN0aW9uIG5ld0FBTm9kZShrLCB2LCBsdmwsIGwgPSBOSUxfTk9ERSwgciA9IE5JTF9OT0RFKSB7XG4gIHJldHVybiB7IGssIHYsIGx2bCwgbCwgciB9O1xufVxuZnVuY3Rpb24gZW1wdHkobm9kZSkge1xuICByZXR1cm4gbm9kZSA9PT0gTklMX05PREU7XG59XG5mdW5jdGlvbiBuZXdUcmVlKCkge1xuICByZXR1cm4gTklMX05PREU7XG59XG5mdW5jdGlvbiByZW1vdmUobm9kZSwga2V5KSB7XG4gIGlmIChlbXB0eShub2RlKSlcbiAgICByZXR1cm4gTklMX05PREU7XG4gIGNvbnN0IHsgaywgbCwgciB9ID0gbm9kZTtcbiAgaWYgKGtleSA9PT0gaykge1xuICAgIGlmIChlbXB0eShsKSkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSBlbHNlIGlmIChlbXB0eShyKSkge1xuICAgICAgcmV0dXJuIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtsYXN0S2V5LCBsYXN0VmFsdWVdID0gbGFzdChsKTtcbiAgICAgIHJldHVybiBhZGp1c3QoY2xvbmUobm9kZSwgeyBrOiBsYXN0S2V5LCB2OiBsYXN0VmFsdWUsIGw6IGRlbGV0ZUxhc3QobCkgfSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgPCBrKSB7XG4gICAgcmV0dXJuIGFkanVzdChjbG9uZShub2RlLCB7IGw6IHJlbW92ZShsLCBrZXkpIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWRqdXN0KGNsb25lKG5vZGUsIHsgcjogcmVtb3ZlKHIsIGtleSkgfSkpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kKG5vZGUsIGtleSkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleSA9PT0gbm9kZS5rKSB7XG4gICAgcmV0dXJuIG5vZGUudjtcbiAgfSBlbHNlIGlmIChrZXkgPCBub2RlLmspIHtcbiAgICByZXR1cm4gZmluZChub2RlLmwsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmQobm9kZS5yLCBrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kTWF4S2V5VmFsdWUobm9kZSwgdmFsdWUsIGZpZWxkID0gXCJrXCIpIHtcbiAgaWYgKGVtcHR5KG5vZGUpKSB7XG4gICAgcmV0dXJuIFstSW5maW5pdHksIHZvaWQgMF07XG4gIH1cbiAgaWYgKE51bWJlcihub2RlW2ZpZWxkXSkgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIFtub2RlLmssIG5vZGUudl07XG4gIH1cbiAgaWYgKE51bWJlcihub2RlW2ZpZWxkXSkgPCB2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSBmaW5kTWF4S2V5VmFsdWUobm9kZS5yLCB2YWx1ZSwgZmllbGQpO1xuICAgIGlmIChyWzBdID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBbbm9kZS5rLCBub2RlLnZdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmRNYXhLZXlWYWx1ZShub2RlLmwsIHZhbHVlLCBmaWVsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnQobm9kZSwgaywgdikge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gbmV3QUFOb2RlKGssIHYsIDEpO1xuICB9XG4gIGlmIChrID09PSBub2RlLmspIHtcbiAgICByZXR1cm4gY2xvbmUobm9kZSwgeyBrLCB2IH0pO1xuICB9IGVsc2UgaWYgKGsgPCBub2RlLmspIHtcbiAgICByZXR1cm4gcmViYWxhbmNlKGNsb25lKG5vZGUsIHsgbDogaW5zZXJ0KG5vZGUubCwgaywgdikgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWJhbGFuY2UoY2xvbmUobm9kZSwgeyByOiBpbnNlcnQobm9kZS5yLCBrLCB2KSB9KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhbGtXaXRoaW4obm9kZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgeyBrLCB2LCBsLCByIH0gPSBub2RlO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGlmIChrID4gc3RhcnQpIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHdhbGtXaXRoaW4obCwgc3RhcnQsIGVuZCkpO1xuICB9XG4gIGlmIChrID49IHN0YXJ0ICYmIGsgPD0gZW5kKSB7XG4gICAgcmVzdWx0LnB1c2goeyBrLCB2IH0pO1xuICB9XG4gIGlmIChrIDw9IGVuZCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod2Fsa1dpdGhpbihyLCBzdGFydCwgZW5kKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi53YWxrKG5vZGUubCksIHsgazogbm9kZS5rLCB2OiBub2RlLnYgfSwgLi4ud2Fsayhub2RlLnIpXTtcbn1cbmZ1bmN0aW9uIGxhc3Qobm9kZSkge1xuICByZXR1cm4gZW1wdHkobm9kZS5yKSA/IFtub2RlLmssIG5vZGUudl0gOiBsYXN0KG5vZGUucik7XG59XG5mdW5jdGlvbiBkZWxldGVMYXN0KG5vZGUpIHtcbiAgcmV0dXJuIGVtcHR5KG5vZGUucikgPyBub2RlLmwgOiBhZGp1c3QoY2xvbmUobm9kZSwgeyByOiBkZWxldGVMYXN0KG5vZGUucikgfSkpO1xufVxuZnVuY3Rpb24gY2xvbmUobm9kZSwgYXJncykge1xuICByZXR1cm4gbmV3QUFOb2RlKFxuICAgIGFyZ3MuayAhPT0gdm9pZCAwID8gYXJncy5rIDogbm9kZS5rLFxuICAgIGFyZ3MudiAhPT0gdm9pZCAwID8gYXJncy52IDogbm9kZS52LFxuICAgIGFyZ3MubHZsICE9PSB2b2lkIDAgPyBhcmdzLmx2bCA6IG5vZGUubHZsLFxuICAgIGFyZ3MubCAhPT0gdm9pZCAwID8gYXJncy5sIDogbm9kZS5sLFxuICAgIGFyZ3MuciAhPT0gdm9pZCAwID8gYXJncy5yIDogbm9kZS5yXG4gICk7XG59XG5mdW5jdGlvbiBpc1NpbmdsZShub2RlKSB7XG4gIHJldHVybiBlbXB0eShub2RlKSB8fCBub2RlLmx2bCA+IG5vZGUuci5sdmw7XG59XG5mdW5jdGlvbiByZWJhbGFuY2Uobm9kZSkge1xuICByZXR1cm4gc3BsaXQoc2tldyhub2RlKSk7XG59XG5mdW5jdGlvbiBhZGp1c3Qobm9kZSkge1xuICBjb25zdCB7IGwsIHIsIGx2bCB9ID0gbm9kZTtcbiAgaWYgKHIubHZsID49IGx2bCAtIDEgJiYgbC5sdmwgPj0gbHZsIC0gMSkge1xuICAgIHJldHVybiBub2RlO1xuICB9IGVsc2UgaWYgKGx2bCA+IHIubHZsICsgMSkge1xuICAgIGlmIChpc1NpbmdsZShsKSkge1xuICAgICAgcmV0dXJuIHNrZXcoY2xvbmUobm9kZSwgeyBsdmw6IGx2bCAtIDEgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWVtcHR5KGwpICYmICFlbXB0eShsLnIpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZShsLnIsIHtcbiAgICAgICAgICBsOiBjbG9uZShsLCB7IHI6IGwuci5sIH0pLFxuICAgICAgICAgIHI6IGNsb25lKG5vZGUsIHtcbiAgICAgICAgICAgIGw6IGwuci5yLFxuICAgICAgICAgICAgbHZsOiBsdmwgLSAxXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbHZsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzU2luZ2xlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc3BsaXQoY2xvbmUobm9kZSwgeyBsdmw6IGx2bCAtIDEgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWVtcHR5KHIpICYmICFlbXB0eShyLmwpKSB7XG4gICAgICAgIGNvbnN0IHJsID0gci5sO1xuICAgICAgICBjb25zdCBybHZsID0gaXNTaW5nbGUocmwpID8gci5sdmwgLSAxIDogci5sdmw7XG4gICAgICAgIHJldHVybiBjbG9uZShybCwge1xuICAgICAgICAgIGw6IGNsb25lKG5vZGUsIHtcbiAgICAgICAgICAgIHI6IHJsLmwsXG4gICAgICAgICAgICBsdmw6IGx2bCAtIDFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByOiBzcGxpdChjbG9uZShyLCB7IGw6IHJsLnIsIGx2bDogcmx2bCB9KSksXG4gICAgICAgICAgbHZsOiBybC5sdmwgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlc1dpdGhpbihub2RlLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWRTdGFydCA9IGZpbmRNYXhLZXlWYWx1ZShub2RlLCBzdGFydEluZGV4KVswXTtcbiAgcmV0dXJuIHRvUmFuZ2VzKHdhbGtXaXRoaW4obm9kZSwgYWRqdXN0ZWRTdGFydCwgZW5kSW5kZXgpKTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9SYW5nZXMoaXRlbXMsIHBhcnNlcikge1xuICBjb25zdCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IHsgaW5kZXg6IHN0YXJ0LCB2YWx1ZSB9ID0gcGFyc2VyKGl0ZW1zWzBdKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IGluZGV4OiBuZXh0SW5kZXgsIHZhbHVlOiBuZXh0VmFsdWUgfSA9IHBhcnNlcihpdGVtc1tpXSk7XG4gICAgcmVzdWx0LnB1c2goeyBzdGFydCwgZW5kOiBuZXh0SW5kZXggLSAxLCB2YWx1ZSB9KTtcbiAgICBzdGFydCA9IG5leHRJbmRleDtcbiAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcbiAgfVxuICByZXN1bHQucHVzaCh7IHN0YXJ0LCBlbmQ6IEluZmluaXR5LCB2YWx1ZSB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvUmFuZ2VzKG5vZGVzKSB7XG4gIHJldHVybiBhcnJheVRvUmFuZ2VzKG5vZGVzLCAoeyBrOiBpbmRleCwgdjogdmFsdWUgfSkgPT4gKHsgaW5kZXgsIHZhbHVlIH0pKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KG5vZGUpIHtcbiAgY29uc3QgeyByLCBsdmwgfSA9IG5vZGU7XG4gIHJldHVybiAhZW1wdHkocikgJiYgIWVtcHR5KHIucikgJiYgci5sdmwgPT09IGx2bCAmJiByLnIubHZsID09PSBsdmwgPyBjbG9uZShyLCB7IGw6IGNsb25lKG5vZGUsIHsgcjogci5sIH0pLCBsdmw6IGx2bCArIDEgfSkgOiBub2RlO1xufVxuZnVuY3Rpb24gc2tldyhub2RlKSB7XG4gIGNvbnN0IHsgbCB9ID0gbm9kZTtcbiAgcmV0dXJuICFlbXB0eShsKSAmJiBsLmx2bCA9PT0gbm9kZS5sdmwgPyBjbG9uZShsLCB7IHI6IGNsb25lKG5vZGUsIHsgbDogbC5yIH0pIH0pIDogbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCB2YWx1ZSwgY29tcGFyYXRvciwgc3RhcnQgPSAwKSB7XG4gIGxldCBlbmQgPSBpdGVtcy5sZW5ndGggLSAxO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IG1hdGNoID0gY29tcGFyYXRvcihpdGVtLCB2YWx1ZSk7XG4gICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PT0gLTEpIHtcbiAgICAgIGlmIChlbmQgLSBzdGFydCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGluZGV4IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGJpbmFyeSBmaW5kaW5nIHJlY29yZCBpbiBhcnJheSAtICR7aXRlbXMuam9pbihcIixcIil9LCBzZWFyY2hlZCBmb3IgJHt2YWx1ZX1gKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0U21hbGxlck9yRXF1YWwoaXRlbXMsIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHJldHVybiBpdGVtc1tmaW5kSW5kZXhPZkNsb3Nlc3RTbWFsbGVyT3JFcXVhbChpdGVtcywgdmFsdWUsIGNvbXBhcmF0b3IpXTtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpdGVtcywgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCBzdGFydFZhbHVlLCBjb21wYXJhdG9yKTtcbiAgY29uc3QgZW5kSW5kZXggPSBmaW5kSW5kZXhPZkNsb3Nlc3RTbWFsbGVyT3JFcXVhbChpdGVtcywgZW5kVmFsdWUsIGNvbXBhcmF0b3IsIHN0YXJ0SW5kZXgpO1xuICByZXR1cm4gaXRlbXMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXggKyAxKTtcbn1cbmNvbnN0IHJlY2FsY1N5c3RlbSA9IHN5c3RlbShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHJlY2FsY0luUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgcmV0dXJuIHsgcmVjYWxjSW5Qcm9ncmVzcyB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHJhbmdlSW5jbHVkZXMocmVmUmFuZ2UpIHtcbiAgY29uc3QgeyBzaXplLCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmVmUmFuZ2U7XG4gIHJldHVybiAocmFuZ2UpID0+IHtcbiAgICByZXR1cm4gcmFuZ2Uuc3RhcnQgPT09IHN0YXJ0SW5kZXggJiYgKHJhbmdlLmVuZCA9PT0gZW5kSW5kZXggfHwgcmFuZ2UuZW5kID09PSBJbmZpbml0eSkgJiYgcmFuZ2UudmFsdWUgPT09IHNpemU7XG4gIH07XG59XG5mdW5jdGlvbiBhZmZlY3RlZEdyb3VwQ291bnQob2Zmc2V0LCBncm91cEluZGljZXMpIHtcbiAgbGV0IHJlY29nbml6ZWRPZmZzZXRJdGVtcyA9IDA7XG4gIGxldCBncm91cEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyA8IG9mZnNldCkge1xuICAgIHJlY29nbml6ZWRPZmZzZXRJdGVtcyArPSBncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXhdIC0gMTtcbiAgICBncm91cEluZGV4Kys7XG4gIH1cbiAgY29uc3Qgb2Zmc2V0SXNFeGFjdCA9IHJlY29nbml6ZWRPZmZzZXRJdGVtcyA9PT0gb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXBJbmRleCAtIChvZmZzZXRJc0V4YWN0ID8gMCA6IDEpO1xufVxuZnVuY3Rpb24gaW5zZXJ0UmFuZ2VzKHNpemVUcmVlLCByYW5nZXMpIHtcbiAgbGV0IHN5bmNTdGFydCA9IGVtcHR5KHNpemVUcmVlKSA/IDAgOiBJbmZpbml0eTtcbiAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHtcbiAgICBjb25zdCB7IHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBzeW5jU3RhcnQgPSBNYXRoLm1pbihzeW5jU3RhcnQsIHN0YXJ0SW5kZXgpO1xuICAgIGlmIChlbXB0eShzaXplVHJlZSkpIHtcbiAgICAgIHNpemVUcmVlID0gaW5zZXJ0KHNpemVUcmVlLCAwLCBzaXplKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwcGluZ1JhbmdlcyA9IHJhbmdlc1dpdGhpbihzaXplVHJlZSwgc3RhcnRJbmRleCAtIDEsIGVuZEluZGV4ICsgMSk7XG4gICAgaWYgKG92ZXJsYXBwaW5nUmFuZ2VzLnNvbWUocmFuZ2VJbmNsdWRlcyhyYW5nZSkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGZpcnN0UGFzc0RvbmUgPSBmYWxzZTtcbiAgICBsZXQgc2hvdWxkSW5zZXJ0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB7IHN0YXJ0OiByYW5nZVN0YXJ0LCBlbmQ6IHJhbmdlRW5kLCB2YWx1ZTogcmFuZ2VWYWx1ZSB9IG9mIG92ZXJsYXBwaW5nUmFuZ2VzKSB7XG4gICAgICBpZiAoIWZpcnN0UGFzc0RvbmUpIHtcbiAgICAgICAgc2hvdWxkSW5zZXJ0ID0gcmFuZ2VWYWx1ZSAhPT0gc2l6ZTtcbiAgICAgICAgZmlyc3RQYXNzRG9uZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW5kSW5kZXggPj0gcmFuZ2VTdGFydCB8fCBzaXplID09PSByYW5nZVZhbHVlKSB7XG4gICAgICAgICAgc2l6ZVRyZWUgPSByZW1vdmUoc2l6ZVRyZWUsIHJhbmdlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VFbmQgPiBlbmRJbmRleCAmJiBlbmRJbmRleCA+PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgIGlmIChyYW5nZVZhbHVlICE9PSBzaXplKSB7XG4gICAgICAgICAgc2l6ZVRyZWUgPSBpbnNlcnQoc2l6ZVRyZWUsIGVuZEluZGV4ICsgMSwgcmFuZ2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEluc2VydCkge1xuICAgICAgc2l6ZVRyZWUgPSBpbnNlcnQoc2l6ZVRyZWUsIHN0YXJ0SW5kZXgsIHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NpemVUcmVlLCBzeW5jU3RhcnRdO1xufVxuZnVuY3Rpb24gaW5pdGlhbFNpemVTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvZmZzZXRUcmVlOiBbXSxcbiAgICBzaXplVHJlZTogbmV3VHJlZSgpLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogbmV3VHJlZSgpLFxuICAgIGxhc3RJbmRleDogMCxcbiAgICBsYXN0T2Zmc2V0OiAwLFxuICAgIGxhc3RTaXplOiAwLFxuICAgIGdyb3VwSW5kaWNlczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4Q29tcGFyYXRvcih7IGluZGV4OiBpdGVtSW5kZXggfSwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSBpdGVtSW5kZXggPyAwIDogaW5kZXggPCBpdGVtSW5kZXggPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBvZmZzZXRDb21wYXJhdG9yKHsgb2Zmc2V0OiBpdGVtT2Zmc2V0IH0sIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ID09PSBpdGVtT2Zmc2V0ID8gMCA6IG9mZnNldCA8IGl0ZW1PZmZzZXQgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBvZmZzZXRQb2ludFBhcnNlcihwb2ludCkge1xuICByZXR1cm4geyBpbmRleDogcG9pbnQuaW5kZXgsIHZhbHVlOiBwb2ludCB9O1xufVxuZnVuY3Rpb24gcmFuZ2VzV2l0aGluT2Zmc2V0cyh0cmVlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBtaW5TdGFydEluZGV4ID0gMCkge1xuICBpZiAobWluU3RhcnRJbmRleCA+IDApIHtcbiAgICBzdGFydE9mZnNldCA9IE1hdGgubWF4KHN0YXJ0T2Zmc2V0LCBmaW5kQ2xvc2VzdFNtYWxsZXJPckVxdWFsKHRyZWUsIG1pblN0YXJ0SW5kZXgsIGluZGV4Q29tcGFyYXRvcikub2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gYXJyYXlUb1JhbmdlcyhmaW5kUmFuZ2UodHJlZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgb2Zmc2V0Q29tcGFyYXRvciksIG9mZnNldFBvaW50UGFyc2VyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9mZnNldFRyZWUocHJldk9mZnNldFRyZWUsIHN5bmNTdGFydCwgc2l6ZVRyZWUsIGdhcCkge1xuICBsZXQgb2Zmc2V0VHJlZSA9IHByZXZPZmZzZXRUcmVlO1xuICBsZXQgcHJldkluZGV4ID0gMDtcbiAgbGV0IHByZXZTaXplID0gMDtcbiAgbGV0IHByZXZPZmZzZXQgPSAwO1xuICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gIGlmIChzeW5jU3RhcnQgIT09IDApIHtcbiAgICBzdGFydEluZGV4ID0gZmluZEluZGV4T2ZDbG9zZXN0U21hbGxlck9yRXF1YWwob2Zmc2V0VHJlZSwgc3luY1N0YXJ0IC0gMSwgaW5kZXhDb21wYXJhdG9yKTtcbiAgICBjb25zdCBvZmZzZXRJbmZvID0gb2Zmc2V0VHJlZVtzdGFydEluZGV4XTtcbiAgICBwcmV2T2Zmc2V0ID0gb2Zmc2V0SW5mby5vZmZzZXQ7XG4gICAgY29uc3Qga3YgPSBmaW5kTWF4S2V5VmFsdWUoc2l6ZVRyZWUsIHN5bmNTdGFydCAtIDEpO1xuICAgIHByZXZJbmRleCA9IGt2WzBdO1xuICAgIHByZXZTaXplID0ga3ZbMV07XG4gICAgaWYgKG9mZnNldFRyZWUubGVuZ3RoICYmIG9mZnNldFRyZWVbc3RhcnRJbmRleF0uc2l6ZSA9PT0gZmluZE1heEtleVZhbHVlKHNpemVUcmVlLCBzeW5jU3RhcnQpWzFdKSB7XG4gICAgICBzdGFydEluZGV4IC09IDE7XG4gICAgfVxuICAgIG9mZnNldFRyZWUgPSBvZmZzZXRUcmVlLnNsaWNlKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRUcmVlID0gW107XG4gIH1cbiAgZm9yIChjb25zdCB7IHN0YXJ0OiBzdGFydEluZGV4MiwgdmFsdWUgfSBvZiByYW5nZXNXaXRoaW4oc2l6ZVRyZWUsIHN5bmNTdGFydCwgSW5maW5pdHkpKSB7XG4gICAgY29uc3QgaW5kZXhPZmZzZXQgPSBzdGFydEluZGV4MiAtIHByZXZJbmRleDtcbiAgICBjb25zdCBhT2Zmc2V0ID0gaW5kZXhPZmZzZXQgKiBwcmV2U2l6ZSArIHByZXZPZmZzZXQgKyBpbmRleE9mZnNldCAqIGdhcDtcbiAgICBvZmZzZXRUcmVlLnB1c2goe1xuICAgICAgb2Zmc2V0OiBhT2Zmc2V0LFxuICAgICAgc2l6ZTogdmFsdWUsXG4gICAgICBpbmRleDogc3RhcnRJbmRleDJcbiAgICB9KTtcbiAgICBwcmV2SW5kZXggPSBzdGFydEluZGV4MjtcbiAgICBwcmV2T2Zmc2V0ID0gYU9mZnNldDtcbiAgICBwcmV2U2l6ZSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgb2Zmc2V0VHJlZSxcbiAgICBsYXN0SW5kZXg6IHByZXZJbmRleCxcbiAgICBsYXN0T2Zmc2V0OiBwcmV2T2Zmc2V0LFxuICAgIGxhc3RTaXplOiBwcmV2U2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gc2l6ZVN0YXRlUmVkdWNlcihzdGF0ZSwgW3JhbmdlcywgZ3JvdXBJbmRpY2VzLCBsb2csIGdhcF0pIHtcbiAgaWYgKHJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgbG9nKFwicmVjZWl2ZWQgaXRlbSBzaXplc1wiLCByYW5nZXMsIExvZ0xldmVsLkRFQlVHKTtcbiAgfVxuICBjb25zdCBzaXplVHJlZSA9IHN0YXRlLnNpemVUcmVlO1xuICBsZXQgbmV3U2l6ZVRyZWUgPSBzaXplVHJlZTtcbiAgbGV0IHN5bmNTdGFydCA9IDA7XG4gIGlmIChncm91cEluZGljZXMubGVuZ3RoID4gMCAmJiBlbXB0eShzaXplVHJlZSkgJiYgcmFuZ2VzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IGdyb3VwU2l6ZSA9IHJhbmdlc1swXS5zaXplO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gcmFuZ2VzWzFdLnNpemU7XG4gICAgbmV3U2l6ZVRyZWUgPSBncm91cEluZGljZXMucmVkdWNlKCh0cmVlLCBncm91cEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaW5zZXJ0KGluc2VydCh0cmVlLCBncm91cEluZGV4LCBncm91cFNpemUpLCBncm91cEluZGV4ICsgMSwgaXRlbVNpemUpO1xuICAgIH0sIG5ld1NpemVUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBbbmV3U2l6ZVRyZWUsIHN5bmNTdGFydF0gPSBpbnNlcnRSYW5nZXMobmV3U2l6ZVRyZWUsIHJhbmdlcyk7XG4gIH1cbiAgaWYgKG5ld1NpemVUcmVlID09PSBzaXplVHJlZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7IG9mZnNldFRyZWU6IG5ld09mZnNldFRyZWUsIGxhc3RJbmRleCwgbGFzdFNpemUsIGxhc3RPZmZzZXQgfSA9IGNyZWF0ZU9mZnNldFRyZWUoc3RhdGUub2Zmc2V0VHJlZSwgc3luY1N0YXJ0LCBuZXdTaXplVHJlZSwgZ2FwKTtcbiAgcmV0dXJuIHtcbiAgICBzaXplVHJlZTogbmV3U2l6ZVRyZWUsXG4gICAgb2Zmc2V0VHJlZTogbmV3T2Zmc2V0VHJlZSxcbiAgICBsYXN0SW5kZXgsXG4gICAgbGFzdE9mZnNldCxcbiAgICBsYXN0U2l6ZSxcbiAgICBncm91cE9mZnNldFRyZWU6IGdyb3VwSW5kaWNlcy5yZWR1Y2UoKHRyZWUsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaW5zZXJ0KHRyZWUsIGluZGV4LCBvZmZzZXRPZihpbmRleCwgbmV3T2Zmc2V0VHJlZSwgZ2FwKSk7XG4gICAgfSwgbmV3VHJlZSgpKSxcbiAgICBncm91cEluZGljZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG9mZnNldE9mKGluZGV4LCB0cmVlLCBnYXApIHtcbiAgaWYgKHRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgeyBvZmZzZXQsIGluZGV4OiBzdGFydEluZGV4LCBzaXplIH0gPSBmaW5kQ2xvc2VzdFNtYWxsZXJPckVxdWFsKHRyZWUsIGluZGV4LCBpbmRleENvbXBhcmF0b3IpO1xuICBjb25zdCBpdGVtQ291bnQgPSBpbmRleCAtIHN0YXJ0SW5kZXg7XG4gIGNvbnN0IHRvcCA9IHNpemUgKiBpdGVtQ291bnQgKyAoaXRlbUNvdW50IC0gMSkgKiBnYXAgKyBvZmZzZXQ7XG4gIHJldHVybiB0b3AgPiAwID8gdG9wICsgZ2FwIDogdG9wO1xufVxuZnVuY3Rpb24gaXNHcm91cExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24uZ3JvdXBJbmRleCAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsSW5kZXhGcm9tTG9jYXRpb24obG9jYXRpb24sIHNpemVzLCBsYXN0SW5kZXgpIHtcbiAgaWYgKGlzR3JvdXBMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICByZXR1cm4gc2l6ZXMuZ3JvdXBJbmRpY2VzW2xvY2F0aW9uLmdyb3VwSW5kZXhdICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBudW1lcmljSW5kZXggPSBsb2NhdGlvbi5pbmRleCA9PT0gXCJMQVNUXCIgPyBsYXN0SW5kZXggOiBsb2NhdGlvbi5pbmRleDtcbiAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxJbmRleEZyb21JdGVtSW5kZXgobnVtZXJpY0luZGV4LCBzaXplcyk7XG4gICAgcmVzdWx0ID0gTWF0aC5tYXgoMCwgcmVzdWx0LCBNYXRoLm1pbihsYXN0SW5kZXgsIHJlc3VsdCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG9yaWdpbmFsSW5kZXhGcm9tSXRlbUluZGV4KGl0ZW1JbmRleCwgc2l6ZXMpIHtcbiAgaWYgKCFoYXNHcm91cHMoc2l6ZXMpKSB7XG4gICAgcmV0dXJuIGl0ZW1JbmRleDtcbiAgfVxuICBsZXQgZ3JvdXBPZmZzZXQgPSAwO1xuICB3aGlsZSAoc2l6ZXMuZ3JvdXBJbmRpY2VzW2dyb3VwT2Zmc2V0XSA8PSBpdGVtSW5kZXggKyBncm91cE9mZnNldCkge1xuICAgIGdyb3VwT2Zmc2V0Kys7XG4gIH1cbiAgcmV0dXJuIGl0ZW1JbmRleCArIGdyb3VwT2Zmc2V0O1xufVxuZnVuY3Rpb24gaGFzR3JvdXBzKHNpemVzKSB7XG4gIHJldHVybiAhZW1wdHkoc2l6ZXMuZ3JvdXBPZmZzZXRUcmVlKTtcbn1cbmZ1bmN0aW9uIHNpemVUcmVlVG9SYW5nZXMoc2l6ZVRyZWUpIHtcbiAgcmV0dXJuIHdhbGsoc2l6ZVRyZWUpLm1hcCgoeyBrOiBzdGFydEluZGV4LCB2OiBzaXplIH0sIGluZGV4LCBzaXplQXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXh0U2l6ZSA9IHNpemVBcnJheVtpbmRleCArIDFdO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gbmV4dFNpemUgPyBuZXh0U2l6ZS5rIC0gMSA6IEluZmluaXR5O1xuICAgIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzaXplIH07XG4gIH0pO1xufVxuY29uc3QgU0laRV9NQVAgPSB7XG4gIG9mZnNldEhlaWdodDogXCJoZWlnaHRcIixcbiAgb2Zmc2V0V2lkdGg6IFwid2lkdGhcIlxufTtcbmNvbnN0IHNpemVTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBsb2cgfSwgeyByZWNhbGNJblByb2dyZXNzIH1dKSA9PiB7XG4gICAgY29uc3Qgc2l6ZVJhbmdlcyA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvdGFsQ291bnQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzdGF0ZWZ1bFRvdGFsQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKHRvdGFsQ291bnQsIDApO1xuICAgIGNvbnN0IHVuc2hpZnRXaXRoID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2hpZnRXaXRoID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBncm91cEluZGljZXMgPSBzdGF0ZWZ1bFN0cmVhbShbXSk7XG4gICAgY29uc3QgZml4ZWRJdGVtU2l6ZSA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gc3RhdGVmdWxTdHJlYW0odm9pZCAwKTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IHN0YXRlZnVsU3RyZWFtKChlbCwgZmllbGQpID0+IGNvcnJlY3RJdGVtU2l6ZShlbCwgU0laRV9NQVBbZmllbGRdKSk7XG4gICAgY29uc3QgZGF0YSA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gICAgY29uc3QgZ2FwID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgaW5pdGlhbCA9IGluaXRpYWxTaXplU3RhdGUoKTtcbiAgICBjb25zdCBzaXplcyA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKHNpemVSYW5nZXMsIHdpdGhMYXRlc3RGcm9tKGdyb3VwSW5kaWNlcywgbG9nLCBnYXApLCBzY2FuKHNpemVTdGF0ZVJlZHVjZXIsIGluaXRpYWwpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKSxcbiAgICAgIGluaXRpYWxcbiAgICApO1xuICAgIGNvbnN0IHByZXZHcm91cEluZGljZXMgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICBzY2FuKChwcmV2LCBjdXJyKSA9PiAoeyBwcmV2OiBwcmV2LmN1cnJlbnQsIGN1cnJlbnQ6IGN1cnIgfSksIHtcbiAgICAgICAgICBwcmV2OiBbXSxcbiAgICAgICAgICBjdXJyZW50OiBbXVxuICAgICAgICB9KSxcbiAgICAgICAgbWFwKCh7IHByZXYgfSkgPT4gcHJldilcbiAgICAgICksXG4gICAgICBbXVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgICAgZmlsdGVyKChpbmRleGVzKSA9PiBpbmRleGVzLmxlbmd0aCA+IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgZ2FwKSxcbiAgICAgICAgbWFwKChbZ3JvdXBJbmRpY2VzMiwgc2l6ZXMyLCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdyb3VwT2Zmc2V0VHJlZSA9IGdyb3VwSW5kaWNlczIucmVkdWNlKCh0cmVlLCBpbmRleCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0KHRyZWUsIGluZGV4LCBvZmZzZXRPZihpbmRleCwgc2l6ZXMyLm9mZnNldFRyZWUsIGdhcDIpIHx8IGlkeCk7XG4gICAgICAgICAgfSwgbmV3VHJlZSgpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc2l6ZXMyLFxuICAgICAgICAgICAgZ3JvdXBJbmRpY2VzOiBncm91cEluZGljZXMyLFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXRUcmVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBzaXplc1xuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHRvdGFsQ291bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzKSxcbiAgICAgICAgZmlsdGVyKChbdG90YWxDb3VudDIsIHsgbGFzdEluZGV4IH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsQ291bnQyIDwgbGFzdEluZGV4O1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKChbdG90YWxDb3VudDIsIHsgbGFzdEluZGV4LCBsYXN0U2l6ZSB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHRvdGFsQ291bnQyLFxuICAgICAgICAgICAgICBlbmRJbmRleDogbGFzdEluZGV4LFxuICAgICAgICAgICAgICBzaXplOiBsYXN0U2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZVJhbmdlc1xuICAgICk7XG4gICAgY29ubmVjdChmaXhlZEl0ZW1TaXplLCBkZWZhdWx0SXRlbVNpemUpO1xuICAgIGNvbnN0IHRyYWNrSXRlbVNpemVzID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGZpeGVkSXRlbVNpemUsXG4gICAgICAgIG1hcCgoc2l6ZSkgPT4gc2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgKSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkZWZhdWx0SXRlbVNpemUsXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiBlbXB0eShnZXRWYWx1ZShzaXplcykuc2l6ZVRyZWUpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKChzaXplKSA9PiBbeyBzdGFydEluZGV4OiAwLCBlbmRJbmRleDogMCwgc2l6ZSB9XSlcbiAgICAgICksXG4gICAgICBzaXplUmFuZ2VzXG4gICAgKTtcbiAgICBjb25zdCBsaXN0UmVmcmVzaCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgc2l6ZVJhbmdlcyxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMpLFxuICAgICAgICBzY2FuKFxuICAgICAgICAgICh7IHNpemVzOiBvbGRTaXplcyB9LCBbXywgbmV3U2l6ZXNdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjaGFuZ2VkOiBuZXdTaXplcyAhPT0gb2xkU2l6ZXMsXG4gICAgICAgICAgICAgIHNpemVzOiBuZXdTaXplc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgY2hhbmdlZDogZmFsc2UsIHNpemVzOiBpbml0aWFsIH1cbiAgICAgICAgKSxcbiAgICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUuY2hhbmdlZClcbiAgICAgIClcbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGZpcnN0SXRlbUluZGV4LFxuICAgICAgICBzY2FuKFxuICAgICAgICAgIChwcmV2LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkaWZmOiBwcmV2LnByZXYgLSBuZXh0LCBwcmV2OiBuZXh0IH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IGRpZmY6IDAsIHByZXY6IDAgfVxuICAgICAgICApLFxuICAgICAgICBtYXAoKHZhbCkgPT4gdmFsLmRpZmYpXG4gICAgICApLFxuICAgICAgKG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdyb3VwSW5kaWNlczogZ3JvdXBJbmRpY2VzMiB9ID0gZ2V0VmFsdWUoc2l6ZXMpO1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHB1Ymxpc2gocmVjYWxjSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgICAgICAgcHVibGlzaCh1bnNoaWZ0V2l0aCwgb2Zmc2V0ICsgYWZmZWN0ZWRHcm91cENvdW50KG9mZnNldCwgZ3JvdXBJbmRpY2VzMikpO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRpY2VzVmFsdWUgPSBnZXRWYWx1ZShwcmV2R3JvdXBJbmRpY2VzKTtcbiAgICAgICAgICBpZiAocHJldkdyb3VwSW5kaWNlc1ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBhZmZlY3RlZEdyb3VwQ291bnQoLW9mZnNldCwgcHJldkdyb3VwSW5kaWNlc1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVibGlzaChzaGlmdFdpdGgsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHN1YnNjcmliZShwaXBlKGZpcnN0SXRlbUluZGV4LCB3aXRoTGF0ZXN0RnJvbShsb2cpKSwgKFtpbmRleCwgbG9nMl0pID0+IHtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgbG9nMihcbiAgICAgICAgICBcImBmaXJzdEl0ZW1JbmRleGAgcHJvcCBzaG91bGQgbm90IGJlIHNldCB0byBsZXNzIHRoYW4gemVyby4gSWYgeW91IGRvbid0IGtub3cgdGhlIHRvdGFsIGNvdW50LCBqdXN0IHVzZSBhIHZlcnkgaGlnaCB2YWx1ZVwiLFxuICAgICAgICAgIHsgZmlyc3RJdGVtSW5kZXggfSxcbiAgICAgICAgICBMb2dMZXZlbC5FUlJPUlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGJlZm9yZVVuc2hpZnRXaXRoID0gc3RyZWFtRnJvbUVtaXR0ZXIodW5zaGlmdFdpdGgpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICB1bnNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMpLFxuICAgICAgICBtYXAoKFt1bnNoaWZ0V2l0aDIsIHNpemVzMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBncm91cGVkTW9kZSA9IHNpemVzMi5ncm91cEluZGljZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICBjb25zdCBpbml0aWFsUmFuZ2VzID0gW107XG4gICAgICAgICAgY29uc3QgZGVmYXVsdFNpemUgPSBzaXplczIubGFzdFNpemU7XG4gICAgICAgICAgaWYgKGdyb3VwZWRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwU2l6ZSA9IGZpbmQoc2l6ZXMyLnNpemVUcmVlLCAwKTtcbiAgICAgICAgICAgIGxldCBwcmVwZW5kZWRHcm91cEl0ZW1zQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGdyb3VwSW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCA8IHVuc2hpZnRXaXRoMikge1xuICAgICAgICAgICAgICBjb25zdCB0aGVHcm91cEluZGV4ID0gc2l6ZXMyLmdyb3VwSW5kaWNlc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJdGVtQ291bnQgPSBzaXplczIuZ3JvdXBJbmRpY2VzLmxlbmd0aCA9PT0gZ3JvdXBJbmRleCArIDEgPyBJbmZpbml0eSA6IHNpemVzMi5ncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gdGhlR3JvdXBJbmRleCAtIDE7XG4gICAgICAgICAgICAgIGluaXRpYWxSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogdGhlR3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogdGhlR3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBzaXplOiBmaXJzdEdyb3VwU2l6ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaW5pdGlhbFJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiB0aGVHcm91cEluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogdGhlR3JvdXBJbmRleCArIDEgKyBncm91cEl0ZW1Db3VudCAtIDEsXG4gICAgICAgICAgICAgICAgc2l6ZTogZGVmYXVsdFNpemVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdyb3VwSW5kZXgrKztcbiAgICAgICAgICAgICAgcHJlcGVuZGVkR3JvdXBJdGVtc0NvdW50ICs9IGdyb3VwSXRlbUNvdW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVUcmVlS1YgPSB3YWxrKHNpemVzMi5zaXplVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwSXNFeHBhbmRlZCA9IHByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCAhPT0gdW5zaGlmdFdpdGgyO1xuICAgICAgICAgICAgaWYgKGZpcnN0R3JvdXBJc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICAgIHNpemVUcmVlS1Yuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXplVHJlZUtWLnJlZHVjZShcbiAgICAgICAgICAgICAgKGFjYywgeyBrOiBpbmRleCwgdjogc2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IGFjYy5yYW5nZXM7XG4gICAgICAgICAgICAgICAgaWYgKGFjYy5wcmV2U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MucmFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogYWNjLnByZXZJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogaW5kZXggKyB1bnNoaWZ0V2l0aDIgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGFjYy5wcmV2U2l6ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VzLFxuICAgICAgICAgICAgICAgICAgcHJldkluZGV4OiBpbmRleCArIHVuc2hpZnRXaXRoMixcbiAgICAgICAgICAgICAgICAgIHByZXZTaXplOiBzaXplXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlczogaW5pdGlhbFJhbmdlcyxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXg6IHVuc2hpZnRXaXRoMixcbiAgICAgICAgICAgICAgICBwcmV2U2l6ZTogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLnJhbmdlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdhbGsoc2l6ZXMyLnNpemVUcmVlKS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCB7IGs6IGluZGV4LCB2OiBzaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByYW5nZXM6IFsuLi5hY2MucmFuZ2VzLCB7IHN0YXJ0SW5kZXg6IGFjYy5wcmV2SW5kZXgsIGVuZEluZGV4OiBpbmRleCArIHVuc2hpZnRXaXRoMiAtIDEsIHNpemU6IGFjYy5wcmV2U2l6ZSB9XSxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXg6IGluZGV4ICsgdW5zaGlmdFdpdGgyLFxuICAgICAgICAgICAgICAgIHByZXZTaXplOiBzaXplXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByYW5nZXM6IFtdLFxuICAgICAgICAgICAgICBwcmV2SW5kZXg6IDAsXG4gICAgICAgICAgICAgIHByZXZTaXplOiBkZWZhdWx0U2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkucmFuZ2VzO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVSYW5nZXNcbiAgICApO1xuICAgIGNvbnN0IHNoaWZ0V2l0aE9mZnNldCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgc2hpZnRXaXRoLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgZ2FwKSxcbiAgICAgICAgbWFwKChbc2hpZnRXaXRoMiwgeyBvZmZzZXRUcmVlIH0sIGdhcDJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3Rmlyc3RJdGVtSW5kZXggPSAtc2hpZnRXaXRoMjtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0T2YobmV3Rmlyc3RJdGVtSW5kZXgsIG9mZnNldFRyZWUsIGdhcDIpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIGdhcCksXG4gICAgICAgIG1hcCgoW3NoaWZ0V2l0aDIsIHNpemVzMiwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBncm91cGVkTW9kZSA9IHNpemVzMi5ncm91cEluZGljZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICBpZiAoZ3JvdXBlZE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChlbXB0eShzaXplczIuc2l6ZVRyZWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaXplczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV3U2l6ZVRyZWUgPSBuZXdUcmVlKCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRpY2VzVmFsdWUgPSBnZXRWYWx1ZShwcmV2R3JvdXBJbmRpY2VzKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkSXRlbXNDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZ3JvdXBPZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW92ZWRJdGVtc0NvdW50IDwgLXNoaWZ0V2l0aDIpIHtcbiAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQgPSBwcmV2R3JvdXBJbmRpY2VzVmFsdWVbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IGdyb3VwSXRlbUNvdW50ID0gcHJldkdyb3VwSW5kaWNlc1ZhbHVlW2dyb3VwSW5kZXggKyAxXSAtIGdyb3VwT2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrO1xuICAgICAgICAgICAgICByZW1vdmVkSXRlbXNDb3VudCArPSBncm91cEl0ZW1Db3VudCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaXplVHJlZSA9IHdhbGsoc2l6ZXMyLnNpemVUcmVlKS5yZWR1Y2UoKGFjYywgeyBrLCB2IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluc2VydChhY2MsIE1hdGgubWF4KDAsIGsgKyBzaGlmdFdpdGgyKSwgdik7XG4gICAgICAgICAgICB9LCBuZXdTaXplVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBhR3JvdXBJc1NocnVuayA9IHJlbW92ZWRJdGVtc0NvdW50ICE9PSAtc2hpZnRXaXRoMjtcbiAgICAgICAgICAgIGlmIChhR3JvdXBJc1NocnVuaykge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwU2l6ZSA9IGZpbmQoc2l6ZXMyLnNpemVUcmVlLCBncm91cE9mZnNldCk7XG4gICAgICAgICAgICAgIG5ld1NpemVUcmVlID0gaW5zZXJ0KG5ld1NpemVUcmVlLCAwLCBmaXJzdEdyb3VwU2l6ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRJdGVtU2l6ZSA9IGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIC1zaGlmdFdpdGgyICsgMSlbMV07XG4gICAgICAgICAgICAgIG5ld1NpemVUcmVlID0gaW5zZXJ0KG5ld1NpemVUcmVlLCAxLCBuZXh0SXRlbVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc2l6ZXMyLFxuICAgICAgICAgICAgICBzaXplVHJlZTogbmV3U2l6ZVRyZWUsXG4gICAgICAgICAgICAgIC4uLmNyZWF0ZU9mZnNldFRyZWUoc2l6ZXMyLm9mZnNldFRyZWUsIDAsIG5ld1NpemVUcmVlLCBnYXAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZVRyZWUgPSB3YWxrKHNpemVzMi5zaXplVHJlZSkucmVkdWNlKChhY2MsIHsgaywgdiB9KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnNlcnQoYWNjLCBNYXRoLm1heCgwLCBrICsgc2hpZnRXaXRoMiksIHYpO1xuICAgICAgICAgICAgfSwgbmV3VHJlZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnNpemVzMixcbiAgICAgICAgICAgICAgc2l6ZVRyZWU6IG5ld1NpemVUcmVlLFxuICAgICAgICAgICAgICAuLi5jcmVhdGVPZmZzZXRUcmVlKHNpemVzMi5vZmZzZXRUcmVlLCAwLCBuZXdTaXplVHJlZSwgZ2FwMilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVzXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaW5wdXRcbiAgICAgIGRhdGEsXG4gICAgICB0b3RhbENvdW50LFxuICAgICAgc2l6ZVJhbmdlcyxcbiAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgIGRlZmF1bHRJdGVtU2l6ZSxcbiAgICAgIGZpeGVkSXRlbVNpemUsXG4gICAgICB1bnNoaWZ0V2l0aCxcbiAgICAgIHNoaWZ0V2l0aCxcbiAgICAgIHNoaWZ0V2l0aE9mZnNldCxcbiAgICAgIGJlZm9yZVVuc2hpZnRXaXRoLFxuICAgICAgZmlyc3RJdGVtSW5kZXgsXG4gICAgICBnYXAsXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHNpemVzLFxuICAgICAgbGlzdFJlZnJlc2gsXG4gICAgICBzdGF0ZWZ1bFRvdGFsQ291bnQsXG4gICAgICB0cmFja0l0ZW1TaXplcyxcbiAgICAgIGl0ZW1TaXplXG4gICAgfTtcbiAgfSxcbiAgdHVwKGxvZ2dlclN5c3RlbSwgcmVjYWxjU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IFNVUFBPUlRTX1NDUk9MTF9UT19PUFRJT05TID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5mdW5jdGlvbiBub3JtYWxpemVJbmRleExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJudW1iZXJcIiA/IHsgaW5kZXg6IGxvY2F0aW9uIH0gOiBsb2NhdGlvbjtcbiAgaWYgKCFyZXN1bHQuYWxpZ24pIHtcbiAgICByZXN1bHQuYWxpZ24gPSBcInN0YXJ0XCI7XG4gIH1cbiAgaWYgKCFyZXN1bHQuYmVoYXZpb3IgfHwgIVNVUFBPUlRTX1NDUk9MTF9UT19PUFRJT05TKSB7XG4gICAgcmVzdWx0LmJlaGF2aW9yID0gXCJhdXRvXCI7XG4gIH1cbiAgaWYgKCFyZXN1bHQub2Zmc2V0KSB7XG4gICAgcmVzdWx0Lm9mZnNldCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHNjcm9sbFRvSW5kZXhTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgdG90YWxDb3VudCwgbGlzdFJlZnJlc2gsIGdhcCB9LFxuICAgIHtcbiAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3MsXG4gICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgIHNjcm9sbFRvLFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgIGZvb3RlckhlaWdodCxcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0LFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHRcbiAgICB9LFxuICAgIHsgbG9nIH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFRvSW5kZXggPSBzdHJlYW0oKTtcbiAgICBjb25zdCB0b3BMaXN0SGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoID0gbnVsbDtcbiAgICBsZXQgY2xlYXJ0VGltZW91dFJlZiA9IG51bGw7XG4gICAgbGV0IHVuc3Vic2NyaWJlTGlzdFJlZnJlc2ggPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBpZiAodW5zdWJzY3JpYmVOZXh0TGlzdFJlZnJlc2gpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVOZXh0TGlzdFJlZnJlc2goKTtcbiAgICAgICAgdW5zdWJzY3JpYmVOZXh0TGlzdFJlZnJlc2ggPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHVuc3Vic2NyaWJlTGlzdFJlZnJlc2gpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVMaXN0UmVmcmVzaCgpO1xuICAgICAgICB1bnN1YnNjcmliZUxpc3RSZWZyZXNoID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjbGVhcnRUaW1lb3V0UmVmKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjbGVhcnRUaW1lb3V0UmVmKTtcbiAgICAgICAgY2xlYXJ0VGltZW91dFJlZiA9IG51bGw7XG4gICAgICB9XG4gICAgICBwdWJsaXNoKHNjcm9sbGluZ0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB9XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzLCB2aWV3cG9ydEhlaWdodCwgdG90YWxDb3VudCwgdG9wTGlzdEhlaWdodCwgaGVhZGVySGVpZ2h0LCBmb290ZXJIZWlnaHQsIGxvZyksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGdhcCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0KSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICBbbG9jYXRpb24sIHNpemVzMiwgdmlld3BvcnRIZWlnaHQyLCB0b3RhbENvdW50MiwgdG9wTGlzdEhlaWdodDIsIGhlYWRlckhlaWdodDIsIGZvb3RlckhlaWdodDIsIGxvZzJdLFxuICAgICAgICAgICAgZ2FwMixcbiAgICAgICAgICAgIGZpeGVkSGVhZGVySGVpZ2h0MixcbiAgICAgICAgICAgIGZpeGVkRm9vdGVySGVpZ2h0MlxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbExvY2F0aW9uID0gbm9ybWFsaXplSW5kZXhMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGFsaWduLCBiZWhhdmlvciwgb2Zmc2V0IH0gPSBub3JtYWxMb2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRvdGFsQ291bnQyIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3JpZ2luYWxJbmRleEZyb21Mb2NhdGlvbihub3JtYWxMb2NhdGlvbiwgc2l6ZXMyLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IG9mZnNldE9mKGluZGV4LCBzaXplczIub2Zmc2V0VHJlZSwgZ2FwMikgKyBoZWFkZXJIZWlnaHQyO1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIHRvcCArPSBmaXhlZEhlYWRlckhlaWdodDIgKyBmaW5kTWF4S2V5VmFsdWUoc2l6ZXMyLnNpemVUcmVlLCBpbmRleClbMV0gLSB2aWV3cG9ydEhlaWdodDIgKyBmaXhlZEZvb3RlckhlaWdodDI7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IGZvb3RlckhlaWdodDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgICAgdG9wICs9IChmaXhlZEhlYWRlckhlaWdodDIgKyBmaW5kTWF4S2V5VmFsdWUoc2l6ZXMyLnNpemVUcmVlLCBpbmRleClbMV0gLSB2aWV3cG9ydEhlaWdodDIgKyBmaXhlZEZvb3RlckhlaWdodDIpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvcCAtPSB0b3BMaXN0SGVpZ2h0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgdG9wICs9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHJ5ID0gKGxpc3RDaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgaWYgKGxpc3RDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbG9nMihcInJldHJ5aW5nIHRvIHNjcm9sbCB0b1wiLCB7IGxvY2F0aW9uIH0sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICAgICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cyKFwibGlzdCBkaWQgbm90IGNoYW5nZSwgc2Nyb2xsIHN1Y2Nlc3NmdWxcIiwge30sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIikge1xuICAgICAgICAgICAgICBsZXQgbGlzdENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdW5zdWJzY3JpYmVMaXN0UmVmcmVzaCA9IHN1YnNjcmliZShsaXN0UmVmcmVzaCwgKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0Q2hhbmdlZCA9IGxpc3RDaGFuZ2VkIHx8IGNoYW5nZWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IGhhbmRsZU5leHQoc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHJ5KGxpc3RDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IGhhbmRsZU5leHQocGlwZShsaXN0UmVmcmVzaCwgd2F0Y2hDaGFuZ2VzRm9yKDE1MCkpLCByZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhcnRUaW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIH0sIDEyMDApO1xuICAgICAgICAgICAgcHVibGlzaChzY3JvbGxpbmdJblByb2dyZXNzLCB0cnVlKTtcbiAgICAgICAgICAgIGxvZzIoXCJzY3JvbGxpbmcgZnJvbSBpbmRleCB0b1wiLCB7IGluZGV4LCB0b3AsIGJlaGF2aW9yIH0sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRvcCwgYmVoYXZpb3IgfTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBzY3JvbGxUb1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICB0b3BMaXN0SGVpZ2h0XG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIGRvbUlPU3lzdGVtLCBsb2dnZXJTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gd2F0Y2hDaGFuZ2VzRm9yKGxpbWl0KSB7XG4gIHJldHVybiAoZG9uZSkgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvbmUoZmFsc2UpO1xuICAgIH0sIGxpbWl0KTtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9uZSh0cnVlKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5jb25zdCBVUCA9IFwidXBcIjtcbmNvbnN0IERPV04gPSBcImRvd25cIjtcbmNvbnN0IE5PTkUkMSA9IFwibm9uZVwiO1xuY29uc3QgSU5JVElBTF9CT1RUT01fU1RBVEUgPSB7XG4gIGF0Qm90dG9tOiBmYWxzZSxcbiAgbm90QXRCb3R0b21CZWNhdXNlOiBcIk5PVF9TSE9XSU5HX0xBU1RfSVRFTVwiLFxuICBzdGF0ZToge1xuICAgIG9mZnNldEJvdHRvbTogMCxcbiAgICBzY3JvbGxUb3A6IDAsXG4gICAgdmlld3BvcnRIZWlnaHQ6IDAsXG4gICAgc2Nyb2xsSGVpZ2h0OiAwXG4gIH1cbn07XG5jb25zdCBERUZBVUxUX0FUX1RPUF9USFJFU0hPTEQgPSAwO1xuY29uc3Qgc3RhdGVGbGFnc1N5c3RlbSA9IHN5c3RlbSgoW3sgc2Nyb2xsQ29udGFpbmVyU3RhdGUsIHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIGhlYWRlckhlaWdodCwgZm9vdGVySGVpZ2h0LCBzY3JvbGxCeSB9XSkgPT4ge1xuICBjb25zdCBpc0F0Qm90dG9tID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICBjb25zdCBpc0F0VG9wID0gc3RhdGVmdWxTdHJlYW0odHJ1ZSk7XG4gIGNvbnN0IGF0Qm90dG9tU3RhdGVDaGFuZ2UgPSBzdHJlYW0oKTtcbiAgY29uc3QgYXRUb3BTdGF0ZUNoYW5nZSA9IHN0cmVhbSgpO1xuICBjb25zdCBhdEJvdHRvbVRocmVzaG9sZCA9IHN0YXRlZnVsU3RyZWFtKDQpO1xuICBjb25zdCBhdFRvcFRocmVzaG9sZCA9IHN0YXRlZnVsU3RyZWFtKERFRkFVTFRfQVRfVE9QX1RIUkVTSE9MRCk7XG4gIGNvbnN0IGlzU2Nyb2xsaW5nID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICBwaXBlKFxuICAgICAgbWVyZ2UocGlwZShkdWMoc2Nyb2xsVG9wKSwgc2tpcCgxKSwgbWFwVG8odHJ1ZSkpLCBwaXBlKGR1YyhzY3JvbGxUb3ApLCBza2lwKDEpLCBtYXBUbyhmYWxzZSksIGRlYm91bmNlVGltZSgxMDApKSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKSxcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBpc1Njcm9sbGluZ0J5ID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICBwaXBlKG1lcmdlKHBpcGUoc2Nyb2xsQnksIG1hcFRvKHRydWUpKSwgcGlwZShzY3JvbGxCeSwgbWFwVG8oZmFsc2UpLCBkZWJvdW5jZVRpbWUoMjAwKSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKSxcbiAgICBmYWxzZVxuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBjb21iaW5lTGF0ZXN0KGR1YyhzY3JvbGxUb3ApLCBkdWMoYXRUb3BUaHJlc2hvbGQpKSxcbiAgICAgIG1hcCgoW3RvcCwgYXRUb3BUaHJlc2hvbGQyXSkgPT4gdG9wIDw9IGF0VG9wVGhyZXNob2xkMiksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKSxcbiAgICBpc0F0VG9wXG4gICk7XG4gIGNvbm5lY3QocGlwZShpc0F0VG9wLCB0aHJvdHRsZVRpbWUoNTApKSwgYXRUb3BTdGF0ZUNoYW5nZSk7XG4gIGNvbnN0IGF0Qm90dG9tU3RhdGUgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICBwaXBlKFxuICAgICAgY29tYmluZUxhdGVzdChzY3JvbGxDb250YWluZXJTdGF0ZSwgZHVjKHZpZXdwb3J0SGVpZ2h0KSwgZHVjKGhlYWRlckhlaWdodCksIGR1Yyhmb290ZXJIZWlnaHQpLCBkdWMoYXRCb3R0b21UaHJlc2hvbGQpKSxcbiAgICAgIHNjYW4oKGN1cnJlbnQsIFt7IHNjcm9sbFRvcDogc2Nyb2xsVG9wMiwgc2Nyb2xsSGVpZ2h0IH0sIHZpZXdwb3J0SGVpZ2h0MiwgX2hlYWRlckhlaWdodCwgX2Zvb3RlckhlaWdodCwgYXRCb3R0b21UaHJlc2hvbGQyXSkgPT4ge1xuICAgICAgICBjb25zdCBpc0F0Qm90dG9tMiA9IHNjcm9sbFRvcDIgKyB2aWV3cG9ydEhlaWdodDIgLSBzY3JvbGxIZWlnaHQgPiAtYXRCb3R0b21UaHJlc2hvbGQyO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodDogdmlld3BvcnRIZWlnaHQyLFxuICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wMixcbiAgICAgICAgICBzY3JvbGxIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQXRCb3R0b20yKSB7XG4gICAgICAgICAgbGV0IGF0Qm90dG9tQmVjYXVzZTtcbiAgICAgICAgICBsZXQgc2Nyb2xsVG9wRGVsdGE7XG4gICAgICAgICAgaWYgKHNjcm9sbFRvcDIgPiBjdXJyZW50LnN0YXRlLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgYXRCb3R0b21CZWNhdXNlID0gXCJTQ1JPTExFRF9ET1dOXCI7XG4gICAgICAgICAgICBzY3JvbGxUb3BEZWx0YSA9IGN1cnJlbnQuc3RhdGUuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXRCb3R0b21CZWNhdXNlID0gXCJTSVpFX0RFQ1JFQVNFRFwiO1xuICAgICAgICAgICAgc2Nyb2xsVG9wRGVsdGEgPSBjdXJyZW50LnN0YXRlLnNjcm9sbFRvcCAtIHNjcm9sbFRvcDIgfHwgY3VycmVudC5zY3JvbGxUb3BEZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0Qm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBhdEJvdHRvbUJlY2F1c2UsXG4gICAgICAgICAgICBzY3JvbGxUb3BEZWx0YVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vdEF0Qm90dG9tQmVjYXVzZTtcbiAgICAgICAgaWYgKHN0YXRlLnNjcm9sbEhlaWdodCA+IGN1cnJlbnQuc3RhdGUuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgbm90QXRCb3R0b21CZWNhdXNlID0gXCJTSVpFX0lOQ1JFQVNFRFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0SGVpZ2h0MiA8IGN1cnJlbnQuc3RhdGUudmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgICBub3RBdEJvdHRvbUJlY2F1c2UgPSBcIlZJRVdQT1JUX0hFSUdIVF9ERUNSRUFTSU5HXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsVG9wMiA8IGN1cnJlbnQuc3RhdGUuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgbm90QXRCb3R0b21CZWNhdXNlID0gXCJTQ1JPTExJTkdfVVBXQVJEU1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZSA9IFwiTk9UX0ZVTExZX1NDUk9MTEVEX1RPX0xBU1RfSVRFTV9CT1RUT01cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF0Qm90dG9tOiBmYWxzZSxcbiAgICAgICAgICBub3RBdEJvdHRvbUJlY2F1c2UsXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgfTtcbiAgICAgIH0sIElOSVRJQUxfQk9UVE9NX1NUQVRFKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKChwcmV2LCBuZXh0KSA9PiB7XG4gICAgICAgIHJldHVybiBwcmV2ICYmIHByZXYuYXRCb3R0b20gPT09IG5leHQuYXRCb3R0b207XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgY29uc3QgbGFzdEp1bXBEdWVUb0l0ZW1SZXNpemUgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgIHBpcGUoXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIHNjYW4oXG4gICAgICAgIChjdXJyZW50LCB7IHNjcm9sbFRvcDogc2Nyb2xsVG9wMiwgc2Nyb2xsSGVpZ2h0LCB2aWV3cG9ydEhlaWdodDogdmlld3BvcnRIZWlnaHQyIH0pID0+IHtcbiAgICAgICAgICBpZiAoIWFwcHJveGltYXRlbHlFcXVhbChjdXJyZW50LnNjcm9sbEhlaWdodCwgc2Nyb2xsSGVpZ2h0KSkge1xuICAgICAgICAgICAgY29uc3QgYXRCb3R0b20gPSBzY3JvbGxIZWlnaHQgLSAoc2Nyb2xsVG9wMiArIHZpZXdwb3J0SGVpZ2h0MikgPCAxO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuc2Nyb2xsVG9wICE9PSBzY3JvbGxUb3AyICYmIGF0Qm90dG9tKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wMixcbiAgICAgICAgICAgICAgICBqdW1wOiBjdXJyZW50LnNjcm9sbFRvcCAtIHNjcm9sbFRvcDIsXG4gICAgICAgICAgICAgICAgY2hhbmdlZDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLFxuICAgICAgICAgICAgICAgIGp1bXA6IDAsXG4gICAgICAgICAgICAgICAgY2hhbmdlZDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsXG4gICAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAganVtcDogMCxcbiAgICAgICAgICAgICAgY2hhbmdlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IHNjcm9sbEhlaWdodDogMCwganVtcDogMCwgc2Nyb2xsVG9wOiAwLCBjaGFuZ2VkOiBmYWxzZSB9XG4gICAgICApLFxuICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuY2hhbmdlZCksXG4gICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS5qdW1wKVxuICAgICksXG4gICAgMFxuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBhdEJvdHRvbVN0YXRlLFxuICAgICAgbWFwKChzdGF0ZSkgPT4gc3RhdGUuYXRCb3R0b20pXG4gICAgKSxcbiAgICBpc0F0Qm90dG9tXG4gICk7XG4gIGNvbm5lY3QocGlwZShpc0F0Qm90dG9tLCB0aHJvdHRsZVRpbWUoNTApKSwgYXRCb3R0b21TdGF0ZUNoYW5nZSk7XG4gIGNvbnN0IHNjcm9sbERpcmVjdGlvbiA9IHN0YXRlZnVsU3RyZWFtKERPV04pO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIG1hcCgoeyBzY3JvbGxUb3A6IHNjcm9sbFRvcDIgfSkgPT4gc2Nyb2xsVG9wMiksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgc2NhbihcbiAgICAgICAgKGFjYywgc2Nyb2xsVG9wMikgPT4ge1xuICAgICAgICAgIGlmIChnZXRWYWx1ZShpc1Njcm9sbGluZ0J5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlyZWN0aW9uOiBhY2MuZGlyZWN0aW9uLCBwcmV2U2Nyb2xsVG9wOiBzY3JvbGxUb3AyIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogc2Nyb2xsVG9wMiA8IGFjYy5wcmV2U2Nyb2xsVG9wID8gVVAgOiBET1dOLCBwcmV2U2Nyb2xsVG9wOiBzY3JvbGxUb3AyIH07XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGlyZWN0aW9uOiBET1dOLCBwcmV2U2Nyb2xsVG9wOiAwIH1cbiAgICAgICksXG4gICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS5kaXJlY3Rpb24pXG4gICAgKSxcbiAgICBzY3JvbGxEaXJlY3Rpb25cbiAgKTtcbiAgY29ubmVjdChwaXBlKHNjcm9sbENvbnRhaW5lclN0YXRlLCB0aHJvdHRsZVRpbWUoNTApLCBtYXBUbyhOT05FJDEpKSwgc2Nyb2xsRGlyZWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVmVsb2NpdHkgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgaXNTY3JvbGxpbmcsXG4gICAgICBmaWx0ZXIoKHZhbHVlKSA9PiAhdmFsdWUpLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgIG1hcFRvKDApXG4gICAgKSxcbiAgICBzY3JvbGxWZWxvY2l0eVxuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBzY3JvbGxUb3AsXG4gICAgICB0aHJvdHRsZVRpbWUoMTAwKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKGlzU2Nyb2xsaW5nKSxcbiAgICAgIGZpbHRlcigoW18sIGlzU2Nyb2xsaW5nMl0pID0+ICEhaXNTY3JvbGxpbmcyKSxcbiAgICAgIHNjYW4oKFtfLCBwcmV2XSwgW25leHRdKSA9PiBbcHJldiwgbmV4dF0sIFswLCAwXSksXG4gICAgICBtYXAoKFtwcmV2LCBuZXh0XSkgPT4gbmV4dCAtIHByZXYpXG4gICAgKSxcbiAgICBzY3JvbGxWZWxvY2l0eVxuICApO1xuICByZXR1cm4ge1xuICAgIGlzU2Nyb2xsaW5nLFxuICAgIGlzQXRUb3AsXG4gICAgaXNBdEJvdHRvbSxcbiAgICBhdEJvdHRvbVN0YXRlLFxuICAgIGF0VG9wU3RhdGVDaGFuZ2UsXG4gICAgYXRCb3R0b21TdGF0ZUNoYW5nZSxcbiAgICBzY3JvbGxEaXJlY3Rpb24sXG4gICAgYXRCb3R0b21UaHJlc2hvbGQsXG4gICAgYXRUb3BUaHJlc2hvbGQsXG4gICAgc2Nyb2xsVmVsb2NpdHksXG4gICAgbGFzdEp1bXBEdWVUb0l0ZW1SZXNpemVcbiAgfTtcbn0sIHR1cChkb21JT1N5c3RlbSkpO1xuY29uc3QgcHJvcHNSZWFkeVN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IGxvZyB9XSkgPT4ge1xuICAgIGNvbnN0IHByb3BzUmVhZHkgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgZGlkTW91bnQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIHByb3BzUmVhZHksXG4gICAgICAgIGZpbHRlcigocmVhZHkpID0+IHJlYWR5KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICk7XG4gICAgc3Vic2NyaWJlKHByb3BzUmVhZHksICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWUgJiYgZ2V0VmFsdWUobG9nKShcInByb3BzIHVwZGF0ZWRcIiwge30sIExvZ0xldmVsLkRFQlVHKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9wc1JlYWR5LCBkaWRNb3VudCB9O1xuICB9LFxuICB0dXAobG9nZ2VyU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHNraXBGcmFtZXMoZnJhbWVDb3VudCwgY2FsbGJhY2spIHtcbiAgaWYgKGZyYW1lQ291bnQgPT0gMCkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHNraXBGcmFtZXMoZnJhbWVDb3VudCAtIDEsIGNhbGxiYWNrKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyKGxvY2F0aW9uLCB0b3RhbENvdW50KSB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHRvdGFsQ291bnQgLSAxO1xuICBjb25zdCBpbmRleCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJudW1iZXJcIiA/IGxvY2F0aW9uIDogbG9jYXRpb24uaW5kZXggPT09IFwiTEFTVFwiID8gbGFzdEluZGV4IDogbG9jYXRpb24uaW5kZXg7XG4gIHJldHVybiBpbmRleDtcbn1cbmNvbnN0IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtID0gc3lzdGVtKFxuICAoW3sgc2l6ZXMsIGxpc3RSZWZyZXNoLCBkZWZhdWx0SXRlbVNpemUgfSwgeyBzY3JvbGxUb3AgfSwgeyBzY3JvbGxUb0luZGV4IH0sIHsgZGlkTW91bnQgfV0pID0+IHtcbiAgICBjb25zdCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0gPSBzdGF0ZWZ1bFN0cmVhbSh0cnVlKTtcbiAgICBjb25zdCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IHNjcm9sbFNjaGVkdWxlZCA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4KSxcbiAgICAgICAgZmlsdGVyKChbXywgbG9jYXRpb25dKSA9PiAhIWxvY2F0aW9uKSxcbiAgICAgICAgbWFwVG8oZmFsc2UpXG4gICAgICApLFxuICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtXG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGxpc3RSZWZyZXNoLCBkaWRNb3VudCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgc2l6ZXMsIGRlZmF1bHRJdGVtU2l6ZSwgc2Nyb2xsU2NoZWR1bGVkKSxcbiAgICAgICAgZmlsdGVyKChbWywgZGlkTW91bnQyXSwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiwgeyBzaXplVHJlZSB9LCBkZWZhdWx0SXRlbVNpemUyLCBzY3JvbGxTY2hlZHVsZWQyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBkaWRNb3VudDIgJiYgKCFlbXB0eShzaXplVHJlZSkgfHwgaXNEZWZpbmVkKGRlZmF1bHRJdGVtU2l6ZTIpKSAmJiAhc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiAmJiAhc2Nyb2xsU2NoZWR1bGVkMjtcbiAgICAgICAgfSksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4KVxuICAgICAgKSxcbiAgICAgIChbLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDJdKSA9PiB7XG4gICAgICAgIHB1Ymxpc2goc2Nyb2xsU2NoZWR1bGVkLCB0cnVlKTtcbiAgICAgICAgc2tpcEZyYW1lcygzLCAoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlTmV4dChzY3JvbGxUb3AsICgpID0+IHB1Ymxpc2goc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCB0cnVlKSk7XG4gICAgICAgICAgcHVibGlzaChzY3JvbGxUb0luZGV4LCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFxuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgc2Nyb2xsVG9JbmRleFN5c3RlbSwgcHJvcHNSZWFkeVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBub3JtYWxpemVGb2xsb3dPdXRwdXQoZm9sbG93KSB7XG4gIGlmICghZm9sbG93KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmb2xsb3cgPT09IFwic21vb3RoXCIgPyBcInNtb290aFwiIDogXCJhdXRvXCI7XG59XG5jb25zdCBiZWhhdmlvckZyb21Gb2xsb3dPdXRwdXQgPSAoZm9sbG93LCBpc0F0Qm90dG9tKSA9PiB7XG4gIGlmICh0eXBlb2YgZm9sbG93ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRm9sbG93T3V0cHV0KGZvbGxvdyhpc0F0Qm90dG9tKSk7XG4gIH1cbiAgcmV0dXJuIGlzQXRCb3R0b20gJiYgbm9ybWFsaXplRm9sbG93T3V0cHV0KGZvbGxvdyk7XG59O1xuY29uc3QgZm9sbG93T3V0cHV0U3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgdG90YWxDb3VudCwgbGlzdFJlZnJlc2ggfSxcbiAgICB7IGlzQXRCb3R0b20sIGF0Qm90dG9tU3RhdGUgfSxcbiAgICB7IHNjcm9sbFRvSW5kZXggfSxcbiAgICB7IHNjcm9sbGVkVG9Jbml0aWFsSXRlbSB9LFxuICAgIHsgcHJvcHNSZWFkeSwgZGlkTW91bnQgfSxcbiAgICB7IGxvZyB9LFxuICAgIHsgc2Nyb2xsaW5nSW5Qcm9ncmVzcyB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBmb2xsb3dPdXRwdXQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgYXV0b3Njcm9sbFRvQm90dG9tID0gc3RyZWFtKCk7XG4gICAgbGV0IHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjcm9sbFRvQm90dG9tKGZvbGxvd091dHB1dEJlaGF2aW9yKSB7XG4gICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIHtcbiAgICAgICAgaW5kZXg6IFwiTEFTVFwiLFxuICAgICAgICBhbGlnbjogXCJlbmRcIixcbiAgICAgICAgYmVoYXZpb3I6IGZvbGxvd091dHB1dEJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChwaXBlKGR1Yyh0b3RhbENvdW50KSwgc2tpcCgxKSksIGRpZE1vdW50KSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZHVjKGZvbGxvd091dHB1dCksIGlzQXRCb3R0b20sIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgc2Nyb2xsaW5nSW5Qcm9ncmVzcyksXG4gICAgICAgIG1hcCgoW1t0b3RhbENvdW50MiwgZGlkTW91bnQyXSwgZm9sbG93T3V0cHV0MiwgaXNBdEJvdHRvbTIsIHNjcm9sbGVkVG9Jbml0aWFsSXRlbTIsIHNjcm9sbGluZ0luUHJvZ3Jlc3MyXSkgPT4ge1xuICAgICAgICAgIGxldCBzaG91bGRGb2xsb3cgPSBkaWRNb3VudDIgJiYgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMjtcbiAgICAgICAgICBsZXQgZm9sbG93T3V0cHV0QmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICAgICAgICBpZiAoc2hvdWxkRm9sbG93KSB7XG4gICAgICAgICAgICBmb2xsb3dPdXRwdXRCZWhhdmlvciA9IGJlaGF2aW9yRnJvbUZvbGxvd091dHB1dChmb2xsb3dPdXRwdXQyLCBpc0F0Qm90dG9tMiB8fCBzY3JvbGxpbmdJblByb2dyZXNzMik7XG4gICAgICAgICAgICBzaG91bGRGb2xsb3cgPSBzaG91bGRGb2xsb3cgJiYgISFmb2xsb3dPdXRwdXRCZWhhdmlvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgdG90YWxDb3VudDogdG90YWxDb3VudDIsIHNob3VsZEZvbGxvdywgZm9sbG93T3V0cHV0QmVoYXZpb3IgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcigoeyBzaG91bGRGb2xsb3cgfSkgPT4gc2hvdWxkRm9sbG93KVxuICAgICAgKSxcbiAgICAgICh7IHRvdGFsQ291bnQ6IHRvdGFsQ291bnQyLCBmb2xsb3dPdXRwdXRCZWhhdmlvciB9KSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nU2Nyb2xsSGFuZGxlKSB7XG4gICAgICAgICAgcGVuZGluZ1Njcm9sbEhhbmRsZSgpO1xuICAgICAgICAgIHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBoYW5kbGVOZXh0KGxpc3RSZWZyZXNoLCAoKSA9PiB7XG4gICAgICAgICAgZ2V0VmFsdWUobG9nKShcImZvbGxvd2luZyBvdXRwdXQgdG8gXCIsIHsgdG90YWxDb3VudDogdG90YWxDb3VudDIgfSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgIHNjcm9sbFRvQm90dG9tKGZvbGxvd091dHB1dEJlaGF2aW9yKTtcbiAgICAgICAgICBwZW5kaW5nU2Nyb2xsSGFuZGxlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBmdW5jdGlvbiB0cmFwTmV4dFNpemVJbmNyZWFzZShmb2xsb3dPdXRwdXQyKSB7XG4gICAgICBjb25zdCBjYW5jZWwgPSBoYW5kbGVOZXh0KGF0Qm90dG9tU3RhdGUsIChzdGF0ZSkgPT4ge1xuICAgICAgICBpZiAoZm9sbG93T3V0cHV0MiAmJiAhc3RhdGUuYXRCb3R0b20gJiYgc3RhdGUubm90QXRCb3R0b21CZWNhdXNlID09PSBcIlNJWkVfSU5DUkVBU0VEXCIgJiYgIXBlbmRpbmdTY3JvbGxIYW5kbGUpIHtcbiAgICAgICAgICBnZXRWYWx1ZShsb2cpKFwic2Nyb2xsaW5nIHRvIGJvdHRvbSBkdWUgdG8gaW5jcmVhc2VkIHNpemVcIiwge30sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICBzY3JvbGxUb0JvdHRvbShcImF1dG9cIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChjYW5jZWwsIDEwMCk7XG4gICAgfVxuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoZHVjKGZvbGxvd091dHB1dCksIHRvdGFsQ291bnQsIHByb3BzUmVhZHkpLFxuICAgICAgICBmaWx0ZXIoKFtmb2xsb3csICwgcmVhZHldKSA9PiBmb2xsb3cgJiYgcmVhZHkpLFxuICAgICAgICBzY2FuKFxuICAgICAgICAgICh7IHZhbHVlIH0sIFssIG5leHRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyByZWZyZXNoZWQ6IHZhbHVlID09PSBuZXh0LCB2YWx1ZTogbmV4dCB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyByZWZyZXNoZWQ6IGZhbHNlLCB2YWx1ZTogMCB9XG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoeyByZWZyZXNoZWQgfSkgPT4gcmVmcmVzaGVkKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZm9sbG93T3V0cHV0LCB0b3RhbENvdW50KVxuICAgICAgKSxcbiAgICAgIChbLCBmb2xsb3dPdXRwdXQyXSkgPT4ge1xuICAgICAgICB0cmFwTmV4dFNpemVJbmNyZWFzZShmb2xsb3dPdXRwdXQyICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBzdWJzY3JpYmUoYXV0b3Njcm9sbFRvQm90dG9tLCAoKSA9PiB7XG4gICAgICB0cmFwTmV4dFNpemVJbmNyZWFzZShnZXRWYWx1ZShmb2xsb3dPdXRwdXQpICE9PSBmYWxzZSk7XG4gICAgfSk7XG4gICAgc3Vic2NyaWJlKGNvbWJpbmVMYXRlc3QoZHVjKGZvbGxvd091dHB1dCksIGF0Qm90dG9tU3RhdGUpLCAoW2ZvbGxvd091dHB1dDIsIHN0YXRlXSkgPT4ge1xuICAgICAgaWYgKGZvbGxvd091dHB1dDIgJiYgIXN0YXRlLmF0Qm90dG9tICYmIHN0YXRlLm5vdEF0Qm90dG9tQmVjYXVzZSA9PT0gXCJWSUVXUE9SVF9IRUlHSFRfREVDUkVBU0lOR1wiKSB7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tKFwiYXV0b1wiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBmb2xsb3dPdXRwdXQsIGF1dG9zY3JvbGxUb0JvdHRvbSB9O1xuICB9LFxuICB0dXAoc2l6ZVN5c3RlbSwgc3RhdGVGbGFnc1N5c3RlbSwgc2Nyb2xsVG9JbmRleFN5c3RlbSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0sIGxvZ2dlclN5c3RlbSwgZG9tSU9TeXN0ZW0pXG4pO1xuZnVuY3Rpb24gZ3JvdXBDb3VudHNUb0luZGljZXNBbmRDb3VudChjb3VudHMpIHtcbiAgcmV0dXJuIGNvdW50cy5yZWR1Y2UoXG4gICAgKGFjYywgZ3JvdXBDb3VudCkgPT4ge1xuICAgICAgYWNjLmdyb3VwSW5kaWNlcy5wdXNoKGFjYy50b3RhbENvdW50KTtcbiAgICAgIGFjYy50b3RhbENvdW50ICs9IGdyb3VwQ291bnQgKyAxO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHtcbiAgICAgIHRvdGFsQ291bnQ6IDAsXG4gICAgICBncm91cEluZGljZXM6IFtdXG4gICAgfVxuICApO1xufVxuY29uc3QgZ3JvdXBlZExpc3RTeXN0ZW0gPSBzeXN0ZW0oKFt7IHRvdGFsQ291bnQsIGdyb3VwSW5kaWNlcywgc2l6ZXMgfSwgeyBzY3JvbGxUb3AsIGhlYWRlckhlaWdodCB9XSkgPT4ge1xuICBjb25zdCBncm91cENvdW50cyA9IHN0cmVhbSgpO1xuICBjb25zdCB0b3BJdGVtc0luZGV4ZXMgPSBzdHJlYW0oKTtcbiAgY29uc3QgZ3JvdXBJbmRpY2VzQW5kQ291bnQgPSBzdHJlYW1Gcm9tRW1pdHRlcihwaXBlKGdyb3VwQ291bnRzLCBtYXAoZ3JvdXBDb3VudHNUb0luZGljZXNBbmRDb3VudCkpKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgZ3JvdXBJbmRpY2VzQW5kQ291bnQsXG4gICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b3RhbENvdW50KVxuICAgICksXG4gICAgdG90YWxDb3VudFxuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBncm91cEluZGljZXNBbmRDb3VudCxcbiAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLmdyb3VwSW5kaWNlcylcbiAgICApLFxuICAgIGdyb3VwSW5kaWNlc1xuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBjb21iaW5lTGF0ZXN0KHNjcm9sbFRvcCwgc2l6ZXMsIGhlYWRlckhlaWdodCksXG4gICAgICBmaWx0ZXIoKFtfLCBzaXplczJdKSA9PiBoYXNHcm91cHMoc2l6ZXMyKSksXG4gICAgICBtYXAoKFtzY3JvbGxUb3AyLCBzdGF0ZSwgaGVhZGVySGVpZ2h0Ml0pID0+IGZpbmRNYXhLZXlWYWx1ZShzdGF0ZS5ncm91cE9mZnNldFRyZWUsIE1hdGgubWF4KHNjcm9sbFRvcDIgLSBoZWFkZXJIZWlnaHQyLCAwKSwgXCJ2XCIpWzBdKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBtYXAoKGluZGV4KSA9PiBbaW5kZXhdKVxuICAgICksXG4gICAgdG9wSXRlbXNJbmRleGVzXG4gICk7XG4gIHJldHVybiB7IGdyb3VwQ291bnRzLCB0b3BJdGVtc0luZGV4ZXMgfTtcbn0sIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSkpO1xuZnVuY3Rpb24gdHVwbGVDb21wYXJhdG9yKHByZXYsIGN1cnJlbnQpIHtcbiAgcmV0dXJuICEhKHByZXYgJiYgcHJldlswXSA9PT0gY3VycmVudFswXSAmJiBwcmV2WzFdID09PSBjdXJyZW50WzFdKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29tcGFyYXRvcihwcmV2LCBuZXh0KSB7XG4gIHJldHVybiAhIShwcmV2ICYmIHByZXYuc3RhcnRJbmRleCA9PT0gbmV4dC5zdGFydEluZGV4ICYmIHByZXYuZW5kSW5kZXggPT09IG5leHQuZW5kSW5kZXgpO1xufVxuY29uc3QgVE9QID0gXCJ0b3BcIjtcbmNvbnN0IEJPVFRPTSA9IFwiYm90dG9tXCI7XG5jb25zdCBOT05FID0gXCJub25lXCI7XG5mdW5jdGlvbiBnZXRPdmVyc2NhbihvdmVyc2NhbiwgZW5kLCBkaXJlY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBvdmVyc2NhbiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IFVQICYmIGVuZCA9PT0gVE9QIHx8IGRpcmVjdGlvbiA9PT0gRE9XTiAmJiBlbmQgPT09IEJPVFRPTSA/IG92ZXJzY2FuIDogMDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBVUCkge1xuICAgICAgcmV0dXJuIGVuZCA9PT0gVE9QID8gb3ZlcnNjYW4ubWFpbiA6IG92ZXJzY2FuLnJldmVyc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbmQgPT09IEJPVFRPTSA/IG92ZXJzY2FuLm1haW4gOiBvdmVyc2Nhbi5yZXZlcnNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRJbmNyZWFzZSh2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IHZhbHVlW2VuZF0gfHwgMDtcbn1cbmNvbnN0IHNpemVSYW5nZVN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIGRldmlhdGlvbiwgaGVhZGVySGVpZ2h0LCBmaXhlZEhlYWRlckhlaWdodCB9XSkgPT4ge1xuICAgIGNvbnN0IGxpc3RCb3VuZGFyeSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvcExpc3RIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBpbmNyZWFzZVZpZXdwb3J0QnkgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBvdmVyc2NhbiA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IHZpc2libGVSYW5nZSA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgIGR1YyhzY3JvbGxUb3ApLFxuICAgICAgICAgIGR1Yyh2aWV3cG9ydEhlaWdodCksXG4gICAgICAgICAgZHVjKGhlYWRlckhlaWdodCksXG4gICAgICAgICAgZHVjKGxpc3RCb3VuZGFyeSwgdHVwbGVDb21wYXJhdG9yKSxcbiAgICAgICAgICBkdWMob3ZlcnNjYW4pLFxuICAgICAgICAgIGR1Yyh0b3BMaXN0SGVpZ2h0KSxcbiAgICAgICAgICBkdWMoZml4ZWRIZWFkZXJIZWlnaHQpLFxuICAgICAgICAgIGR1YyhkZXZpYXRpb24pLFxuICAgICAgICAgIGR1YyhpbmNyZWFzZVZpZXdwb3J0QnkpXG4gICAgICAgICksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgc2Nyb2xsVG9wMixcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0MixcbiAgICAgICAgICAgIGhlYWRlckhlaWdodDIsXG4gICAgICAgICAgICBbbGlzdFRvcCwgbGlzdEJvdHRvbV0sXG4gICAgICAgICAgICBvdmVyc2NhbjIsXG4gICAgICAgICAgICB0b3BMaXN0SGVpZ2h0MixcbiAgICAgICAgICAgIGZpeGVkSGVhZGVySGVpZ2h0MixcbiAgICAgICAgICAgIGRldmlhdGlvbjIsXG4gICAgICAgICAgICBpbmNyZWFzZVZpZXdwb3J0QnkyXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gc2Nyb2xsVG9wMiAtIGRldmlhdGlvbjI7XG4gICAgICAgICAgICBjb25zdCBzdGlja3lIZWFkZXJIZWlnaHQgPSB0b3BMaXN0SGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MjtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclZpc2libGUgPSBNYXRoLm1heChoZWFkZXJIZWlnaHQyIC0gdG9wLCAwKTtcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBOT05FO1xuICAgICAgICAgICAgY29uc3QgdG9wVmlld3BvcnRBZGRpdGlvbiA9IGdldFZpZXdwb3J0SW5jcmVhc2UoaW5jcmVhc2VWaWV3cG9ydEJ5MiwgVE9QKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVZpZXdwb3J0QWRkaXRpb24gPSBnZXRWaWV3cG9ydEluY3JlYXNlKGluY3JlYXNlVmlld3BvcnRCeTIsIEJPVFRPTSk7XG4gICAgICAgICAgICBsaXN0VG9wIC09IGRldmlhdGlvbjI7XG4gICAgICAgICAgICBsaXN0VG9wICs9IGhlYWRlckhlaWdodDIgKyBmaXhlZEhlYWRlckhlaWdodDI7XG4gICAgICAgICAgICBsaXN0Qm90dG9tICs9IGhlYWRlckhlaWdodDIgKyBmaXhlZEhlYWRlckhlaWdodDI7XG4gICAgICAgICAgICBsaXN0Qm90dG9tIC09IGRldmlhdGlvbjI7XG4gICAgICAgICAgICBpZiAobGlzdFRvcCA+IHNjcm9sbFRvcDIgKyBzdGlja3lIZWFkZXJIZWlnaHQgLSB0b3BWaWV3cG9ydEFkZGl0aW9uKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFVQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpc3RCb3R0b20gPCBzY3JvbGxUb3AyIC0gaGVhZGVyVmlzaWJsZSArIHZpZXdwb3J0SGVpZ2h0MiArIGJvdHRvbVZpZXdwb3J0QWRkaXRpb24pIHtcbiAgICAgICAgICAgICAgZGlyZWN0aW9uID0gRE9XTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IE5PTkUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBNYXRoLm1heCh0b3AgLSBoZWFkZXJIZWlnaHQyIC0gZ2V0T3ZlcnNjYW4ob3ZlcnNjYW4yLCBUT1AsIGRpcmVjdGlvbikgLSB0b3BWaWV3cG9ydEFkZGl0aW9uLCAwKSxcbiAgICAgICAgICAgICAgICB0b3AgLSBoZWFkZXJWaXNpYmxlIC0gZml4ZWRIZWFkZXJIZWlnaHQyICsgdmlld3BvcnRIZWlnaHQyICsgZ2V0T3ZlcnNjYW4ob3ZlcnNjYW4yLCBCT1RUT00sIGRpcmVjdGlvbikgKyBib3R0b21WaWV3cG9ydEFkZGl0aW9uXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9IG51bGwpLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCh0dXBsZUNvbXBhcmF0b3IpXG4gICAgICApLFxuICAgICAgWzAsIDBdXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaW5wdXRcbiAgICAgIGxpc3RCb3VuZGFyeSxcbiAgICAgIG92ZXJzY2FuLFxuICAgICAgdG9wTGlzdEhlaWdodCxcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeSxcbiAgICAgIC8vIG91dHB1dFxuICAgICAgdmlzaWJsZVJhbmdlXG4gICAgfTtcbiAgfSxcbiAgdHVwKGRvbUlPU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHByb2JlSXRlbVNldChpbmRleCwgc2l6ZXMsIGRhdGEpIHtcbiAgaWYgKGhhc0dyb3VwcyhzaXplcykpIHtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBvcmlnaW5hbEluZGV4RnJvbUl0ZW1JbmRleChpbmRleCwgc2l6ZXMpO1xuICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF4S2V5VmFsdWUoc2l6ZXMuZ3JvdXBPZmZzZXRUcmVlLCBpdGVtSW5kZXgpWzBdO1xuICAgIHJldHVybiBbXG4gICAgICB7IGluZGV4OiBncm91cEluZGV4LCBzaXplOiAwLCBvZmZzZXQ6IDAgfSxcbiAgICAgIHsgaW5kZXg6IGl0ZW1JbmRleCwgc2l6ZTogMCwgb2Zmc2V0OiAwLCBkYXRhOiBkYXRhICYmIGRhdGFbMF0gfVxuICAgIF07XG4gIH1cbiAgcmV0dXJuIFt7IGluZGV4LCBzaXplOiAwLCBvZmZzZXQ6IDAsIGRhdGE6IGRhdGEgJiYgZGF0YVswXSB9XTtcbn1cbmNvbnN0IEVNUFRZX0xJU1RfU1RBVEUgPSB7XG4gIGl0ZW1zOiBbXSxcbiAgdG9wSXRlbXM6IFtdLFxuICBvZmZzZXRUb3A6IDAsXG4gIG9mZnNldEJvdHRvbTogMCxcbiAgdG9wOiAwLFxuICBib3R0b206IDAsXG4gIHRvcExpc3RIZWlnaHQ6IDAsXG4gIHRvdGFsQ291bnQ6IDAsXG4gIGZpcnN0SXRlbUluZGV4OiAwXG59O1xuZnVuY3Rpb24gdHJhbnNwb3NlSXRlbXMoaXRlbXMsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCkge1xuICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaGFzR3JvdXBzKHNpemVzKSkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+ICh7IC4uLml0ZW0sIGluZGV4OiBpdGVtLmluZGV4ICsgZmlyc3RJdGVtSW5kZXgsIG9yaWdpbmFsSW5kZXg6IGl0ZW0uaW5kZXggfSkpO1xuICB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgY29uc3QgZW5kSW5kZXggPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5pbmRleDtcbiAgY29uc3QgdHJhbnNwb3NlZEl0ZW1zID0gW107XG4gIGNvbnN0IGdyb3VwUmFuZ2VzID0gcmFuZ2VzV2l0aGluKHNpemVzLmdyb3VwT2Zmc2V0VHJlZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICBsZXQgY3VycmVudFJhbmdlID0gdm9pZCAwO1xuICBsZXQgY3VycmVudEdyb3VwSW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICBpZiAoIWN1cnJlbnRSYW5nZSB8fCBjdXJyZW50UmFuZ2UuZW5kIDwgaXRlbS5pbmRleCkge1xuICAgICAgY3VycmVudFJhbmdlID0gZ3JvdXBSYW5nZXMuc2hpZnQoKTtcbiAgICAgIGN1cnJlbnRHcm91cEluZGV4ID0gc2l6ZXMuZ3JvdXBJbmRpY2VzLmluZGV4T2YoY3VycmVudFJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgbGV0IHRyYW5zcG9zZWRJdGVtO1xuICAgIGlmIChpdGVtLmluZGV4ID09PSBjdXJyZW50UmFuZ2Uuc3RhcnQpIHtcbiAgICAgIHRyYW5zcG9zZWRJdGVtID0ge1xuICAgICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICAgIGluZGV4OiBjdXJyZW50R3JvdXBJbmRleFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNwb3NlZEl0ZW0gPSB7XG4gICAgICAgIGluZGV4OiBpdGVtLmluZGV4IC0gKGN1cnJlbnRHcm91cEluZGV4ICsgMSkgKyBmaXJzdEl0ZW1JbmRleCxcbiAgICAgICAgZ3JvdXBJbmRleDogY3VycmVudEdyb3VwSW5kZXhcbiAgICAgIH07XG4gICAgfVxuICAgIHRyYW5zcG9zZWRJdGVtcy5wdXNoKHtcbiAgICAgIC4uLnRyYW5zcG9zZWRJdGVtLFxuICAgICAgc2l6ZTogaXRlbS5zaXplLFxuICAgICAgb2Zmc2V0OiBpdGVtLm9mZnNldCxcbiAgICAgIG9yaWdpbmFsSW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICBkYXRhOiBpdGVtLmRhdGFcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJhbnNwb3NlZEl0ZW1zO1xufVxuZnVuY3Rpb24gYnVpbGRMaXN0U3RhdGUoaXRlbXMsIHRvcEl0ZW1zLCB0b3RhbENvdW50LCBnYXAsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCkge1xuICBjb25zdCB7IGxhc3RTaXplLCBsYXN0T2Zmc2V0LCBsYXN0SW5kZXggfSA9IHNpemVzO1xuICBsZXQgb2Zmc2V0VG9wID0gMDtcbiAgbGV0IGJvdHRvbSA9IDA7XG4gIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgb2Zmc2V0VG9wID0gaXRlbXNbMF0ub2Zmc2V0O1xuICAgIGNvbnN0IGxhc3RJdGVtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgYm90dG9tID0gbGFzdEl0ZW0ub2Zmc2V0ICsgbGFzdEl0ZW0uc2l6ZTtcbiAgfVxuICBjb25zdCBpdGVtQ291bnQgPSB0b3RhbENvdW50IC0gbGFzdEluZGV4O1xuICBjb25zdCB0b3RhbCA9IGxhc3RPZmZzZXQgKyBpdGVtQ291bnQgKiBsYXN0U2l6ZSArIChpdGVtQ291bnQgLSAxKSAqIGdhcDtcbiAgY29uc3QgdG9wID0gb2Zmc2V0VG9wO1xuICBjb25zdCBvZmZzZXRCb3R0b20gPSB0b3RhbCAtIGJvdHRvbTtcbiAgcmV0dXJuIHtcbiAgICBpdGVtczogdHJhbnNwb3NlSXRlbXMoaXRlbXMsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCksXG4gICAgdG9wSXRlbXM6IHRyYW5zcG9zZUl0ZW1zKHRvcEl0ZW1zLCBzaXplcywgZmlyc3RJdGVtSW5kZXgpLFxuICAgIHRvcExpc3RIZWlnaHQ6IHRvcEl0ZW1zLnJlZHVjZSgoaGVpZ2h0LCBpdGVtKSA9PiBpdGVtLnNpemUgKyBoZWlnaHQsIDApLFxuICAgIG9mZnNldFRvcCxcbiAgICBvZmZzZXRCb3R0b20sXG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICB0b3RhbENvdW50LFxuICAgIGZpcnN0SXRlbUluZGV4XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZExpc3RTdGF0ZUZyb21JdGVtQ291bnQoaXRlbUNvdW50LCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCwgc2l6ZXMsIGZpcnN0SXRlbUluZGV4LCBnYXAsIGRhdGEpIHtcbiAgbGV0IGluY2x1ZGVkR3JvdXBzQ291bnQgPSAwO1xuICBpZiAoc2l6ZXMuZ3JvdXBJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHNpemVzLmdyb3VwSW5kaWNlcykge1xuICAgICAgaWYgKGluZGV4IC0gaW5jbHVkZWRHcm91cHNDb3VudCA+PSBpdGVtQ291bnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmNsdWRlZEdyb3Vwc0NvdW50Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFkanVzdGVkQ291bnQgPSBpdGVtQ291bnQgKyBpbmNsdWRlZEdyb3Vwc0NvdW50O1xuICBjb25zdCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlciA9IGdldEluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBhZGp1c3RlZENvdW50KTtcbiAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhZGp1c3RlZENvdW50IH0pLm1hcCgoXywgaW5kZXgpID0+ICh7XG4gICAgaW5kZXg6IGluZGV4ICsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIsXG4gICAgc2l6ZTogMCxcbiAgICBvZmZzZXQ6IDAsXG4gICAgZGF0YTogZGF0YVtpbmRleCArIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyXVxuICB9KSk7XG4gIHJldHVybiBidWlsZExpc3RTdGF0ZShpdGVtcywgW10sIGFkanVzdGVkQ291bnQsIGdhcCwgc2l6ZXMsIGZpcnN0SXRlbUluZGV4KTtcbn1cbmNvbnN0IGxpc3RTdGF0ZVN5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICB7IHNpemVzLCB0b3RhbENvdW50LCBkYXRhLCBmaXJzdEl0ZW1JbmRleCwgZ2FwIH0sXG4gICAgZ3JvdXBlZExpc3RTeXN0ZW0yLFxuICAgIHsgdmlzaWJsZVJhbmdlLCBsaXN0Qm91bmRhcnksIHRvcExpc3RIZWlnaHQ6IHJhbmdlVG9wTGlzdEhlaWdodCB9LFxuICAgIHsgc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCB9LFxuICAgIHsgdG9wTGlzdEhlaWdodCB9LFxuICAgIHN0YXRlRmxhZ3MsXG4gICAgeyBkaWRNb3VudCB9LFxuICAgIHsgcmVjYWxjSW5Qcm9ncmVzcyB9XG4gIF0pID0+IHtcbiAgICBjb25zdCB0b3BJdGVtc0luZGV4ZXMgPSBzdGF0ZWZ1bFN0cmVhbShbXSk7XG4gICAgY29uc3QgaW5pdGlhbEl0ZW1Db3VudCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGl0ZW1zUmVuZGVyZWQgPSBzdHJlYW0oKTtcbiAgICBjb25uZWN0KGdyb3VwZWRMaXN0U3lzdGVtMi50b3BJdGVtc0luZGV4ZXMsIHRvcEl0ZW1zSW5kZXhlcyk7XG4gICAgY29uc3QgbGlzdFN0YXRlID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgZGlkTW91bnQsXG4gICAgICAgICAgcmVjYWxjSW5Qcm9ncmVzcyxcbiAgICAgICAgICBkdWModmlzaWJsZVJhbmdlLCB0dXBsZUNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1Yyh0b3RhbENvdW50KSxcbiAgICAgICAgICBkdWMoc2l6ZXMpLFxuICAgICAgICAgIGR1Yyhpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCksXG4gICAgICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtLFxuICAgICAgICAgIGR1Yyh0b3BJdGVtc0luZGV4ZXMpLFxuICAgICAgICAgIGR1YyhmaXJzdEl0ZW1JbmRleCksXG4gICAgICAgICAgZHVjKGdhcCksXG4gICAgICAgICAgZGF0YVxuICAgICAgICApLFxuICAgICAgICBmaWx0ZXIoKFttb3VudCwgcmVjYWxjSW5Qcm9ncmVzczIsICwgdG90YWxDb3VudDIsICwgLCAsICwgLCAsIGRhdGEyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFDaGFuZ2VJblByb2dyZXNzID0gZGF0YTIgJiYgZGF0YTIubGVuZ3RoICE9PSB0b3RhbENvdW50MjtcbiAgICAgICAgICByZXR1cm4gbW91bnQgJiYgIXJlY2FsY0luUHJvZ3Jlc3MyICYmICFkYXRhQ2hhbmdlSW5Qcm9ncmVzcztcbiAgICAgICAgfSksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgLFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgW3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRdLFxuICAgICAgICAgICAgdG90YWxDb3VudDIsXG4gICAgICAgICAgICBzaXplczIsXG4gICAgICAgICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIsXG4gICAgICAgICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yLFxuICAgICAgICAgICAgdG9wSXRlbXNJbmRleGVzMixcbiAgICAgICAgICAgIGZpcnN0SXRlbUluZGV4MixcbiAgICAgICAgICAgIGdhcDIsXG4gICAgICAgICAgICBkYXRhMlxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemVzVmFsdWUgPSBzaXplczI7XG4gICAgICAgICAgICBjb25zdCB7IHNpemVUcmVlLCBvZmZzZXRUcmVlIH0gPSBzaXplc1ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEl0ZW1Db3VudFZhbHVlID0gZ2V0VmFsdWUoaW5pdGlhbEl0ZW1Db3VudCk7XG4gICAgICAgICAgICBpZiAodG90YWxDb3VudDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uRU1QVFlfTElTVF9TVEFURSwgdG90YWxDb3VudDogdG90YWxDb3VudDIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKGluaXRpYWxJdGVtQ291bnRWYWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLkVNUFRZX0xJU1RfU1RBVEUsIHRvdGFsQ291bnQ6IHRvdGFsQ291bnQyIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkTGlzdFN0YXRlRnJvbUl0ZW1Db3VudChpbml0aWFsSXRlbUNvdW50VmFsdWUsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Miwgc2l6ZXMyLCBmaXJzdEl0ZW1JbmRleDIsIGdhcDIsIGRhdGEyIHx8IFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtcHR5KHNpemVUcmVlKSkge1xuICAgICAgICAgICAgICBpZiAoaW5pdGlhbEl0ZW1Db3VudFZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYnVpbGRMaXN0U3RhdGUoXG4gICAgICAgICAgICAgICAgcHJvYmVJdGVtU2V0KGdldEluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4MiwgdG90YWxDb3VudDIpLCBzaXplc1ZhbHVlLCBkYXRhMiksXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgdG90YWxDb3VudDIsXG4gICAgICAgICAgICAgICAgZ2FwMixcbiAgICAgICAgICAgICAgICBzaXplc1ZhbHVlLFxuICAgICAgICAgICAgICAgIGZpcnN0SXRlbUluZGV4MlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b3BJdGVtcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRvcEl0ZW1zSW5kZXhlczIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdG9wSXRlbXNJbmRleGVzMlswXTtcbiAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0b3BJdGVtc0luZGV4ZXMyW3RvcEl0ZW1zSW5kZXhlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlc1dpdGhpbihzaXplVHJlZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHJhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlU3RhcnRJbmRleCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0LCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZUVuZEluZGV4ID0gTWF0aC5taW4ocmFuZ2UuZW5kLCBlbmRJbmRleCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlU3RhcnRJbmRleDsgaSA8PSByYW5nZUVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHRvcEl0ZW1zLnB1c2goeyBpbmRleDogaSwgc2l6ZSwgb2Zmc2V0LCBkYXRhOiBkYXRhMiAmJiBkYXRhMltpXSB9KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZExpc3RTdGF0ZShbXSwgdG9wSXRlbXMsIHRvdGFsQ291bnQyLCBnYXAyLCBzaXplc1ZhbHVlLCBmaXJzdEl0ZW1JbmRleDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluU3RhcnRJbmRleCA9IHRvcEl0ZW1zSW5kZXhlczIubGVuZ3RoID4gMCA/IHRvcEl0ZW1zSW5kZXhlczJbdG9wSXRlbXNJbmRleGVzMi5sZW5ndGggLSAxXSArIDEgOiAwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UG9pbnRSYW5nZXMgPSByYW5nZXNXaXRoaW5PZmZzZXRzKG9mZnNldFRyZWUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIG1pblN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9mZnNldFBvaW50UmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heEluZGV4ID0gdG90YWxDb3VudDIgLSAxO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0YXAoW10sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiBvZmZzZXRQb2ludFJhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcmFuZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VTdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBvaW50LnNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICByYW5nZVN0YXJ0SW5kZXggKz0gTWF0aC5mbG9vcigoc3RhcnRPZmZzZXQgLSBwb2ludC5vZmZzZXQgKyBnYXAyKSAvIChzaXplICsgZ2FwMikpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbUNvdW50ID0gcmFuZ2VTdGFydEluZGV4IC0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gaXRlbUNvdW50ICogc2l6ZSArIGl0ZW1Db3VudCAqIGdhcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0SW5kZXggPCBtaW5TdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gKG1pblN0YXJ0SW5kZXggLSByYW5nZVN0YXJ0SW5kZXgpICogc2l6ZTtcbiAgICAgICAgICAgICAgICAgIHJhbmdlU3RhcnRJbmRleCA9IG1pblN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gTWF0aC5taW4ocmFuZ2UuZW5kLCBtYXhJbmRleCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlU3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IGVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaW5kZXg6IGksIHNpemUsIG9mZnNldCwgZGF0YTogZGF0YTIgJiYgZGF0YTJbaV0gfSk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZSArIGdhcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZExpc3RTdGF0ZShpdGVtcywgdG9wSXRlbXMsIHRvdGFsQ291bnQyLCBnYXAyLCBzaXplc1ZhbHVlLCBmaXJzdEl0ZW1JbmRleDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yIGZpbHRlciBuZWVkcyB0byBiZSBmaXhlZFxuICAgICAgICBmaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBFTVBUWV9MSVNUX1NUQVRFXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZmlsdGVyKGlzRGVmaW5lZCksXG4gICAgICAgIG1hcCgoZGF0YTIpID0+IGRhdGEyID09IG51bGwgPyB2b2lkIDAgOiBkYXRhMi5sZW5ndGgpXG4gICAgICApLFxuICAgICAgdG90YWxDb3VudFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUudG9wTGlzdEhlaWdodClcbiAgICAgICksXG4gICAgICB0b3BMaXN0SGVpZ2h0XG4gICAgKTtcbiAgICBjb25uZWN0KHRvcExpc3RIZWlnaHQsIHJhbmdlVG9wTGlzdEhlaWdodCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgbWFwKChzdGF0ZSkgPT4gW3N0YXRlLnRvcCwgc3RhdGUuYm90dG9tXSlcbiAgICAgICksXG4gICAgICBsaXN0Qm91bmRhcnlcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIG1hcCgoc3RhdGUpID0+IHN0YXRlLml0ZW1zKVxuICAgICAgKSxcbiAgICAgIGl0ZW1zUmVuZGVyZWRcbiAgICApO1xuICAgIGNvbnN0IGVuZFJlYWNoZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zIH0pID0+IGl0ZW1zLmxlbmd0aCA+IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbSh0b3RhbENvdW50LCBkYXRhKSxcbiAgICAgICAgZmlsdGVyKChbeyBpdGVtcyB9LCB0b3RhbENvdW50Ml0pID0+IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLm9yaWdpbmFsSW5kZXggPT09IHRvdGFsQ291bnQyIC0gMSksXG4gICAgICAgIG1hcCgoWywgdG90YWxDb3VudDIsIGRhdGEyXSkgPT4gW3RvdGFsQ291bnQyIC0gMSwgZGF0YTJdKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQodHVwbGVDb21wYXJhdG9yKSxcbiAgICAgICAgbWFwKChbY291bnRdKSA9PiBjb3VudClcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHN0YXJ0UmVhY2hlZCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICB0aHJvdHRsZVRpbWUoMjAwKSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zLCB0b3BJdGVtcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDAgJiYgaXRlbXNbMF0ub3JpZ2luYWxJbmRleCA9PT0gdG9wSXRlbXMubGVuZ3RoO1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKCh7IGl0ZW1zIH0pID0+IGl0ZW1zWzBdLmluZGV4KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgcmFuZ2VDaGFuZ2VkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIGZpbHRlcigoeyBpdGVtcyB9KSA9PiBpdGVtcy5sZW5ndGggPiAwKSxcbiAgICAgICAgbWFwKCh7IGl0ZW1zIH0pID0+IHtcbiAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgbGV0IGVuZEluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoaXRlbXNbc3RhcnRJbmRleF0udHlwZSA9PT0gXCJncm91cFwiICYmIHN0YXJ0SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoaXRlbXNbZW5kSW5kZXhdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBlbmRJbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGVuZEluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydEluZGV4OiBpdGVtc1tzdGFydEluZGV4XS5pbmRleCxcbiAgICAgICAgICAgIGVuZEluZGV4OiBpdGVtc1tlbmRJbmRleF0uaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQocmFuZ2VDb21wYXJhdG9yKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHsgbGlzdFN0YXRlLCB0b3BJdGVtc0luZGV4ZXMsIGVuZFJlYWNoZWQsIHN0YXJ0UmVhY2hlZCwgcmFuZ2VDaGFuZ2VkLCBpdGVtc1JlbmRlcmVkLCBpbml0aWFsSXRlbUNvdW50LCAuLi5zdGF0ZUZsYWdzIH07XG4gIH0sXG4gIHR1cChcbiAgICBzaXplU3lzdGVtLFxuICAgIGdyb3VwZWRMaXN0U3lzdGVtLFxuICAgIHNpemVSYW5nZVN5c3RlbSxcbiAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFN5c3RlbSxcbiAgICBzY3JvbGxUb0luZGV4U3lzdGVtLFxuICAgIHN0YXRlRmxhZ3NTeXN0ZW0sXG4gICAgcHJvcHNSZWFkeVN5c3RlbSxcbiAgICByZWNhbGNTeXN0ZW1cbiAgKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IGluaXRpYWxJdGVtQ291bnRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBzaXplcywgZmlyc3RJdGVtSW5kZXgsIGRhdGEsIGdhcCB9LCB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4IH0sIHsgaW5pdGlhbEl0ZW1Db3VudCwgbGlzdFN0YXRlIH0sIHsgZGlkTW91bnQgfV0pID0+IHtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxJdGVtQ291bnQpLFxuICAgICAgICBmaWx0ZXIoKFssIGNvdW50XSkgPT4gY291bnQgIT09IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCwgc2l6ZXMsIGZpcnN0SXRlbUluZGV4LCBnYXAsIGRhdGEpLFxuICAgICAgICBtYXAoKFtbLCBjb3VudF0sIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4VmFsdWUsIHNpemVzMiwgZmlyc3RJdGVtSW5kZXgyLCBnYXAyLCBkYXRhMiA9IFtdXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBidWlsZExpc3RTdGF0ZUZyb21JdGVtQ291bnQoY291bnQsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4VmFsdWUsIHNpemVzMiwgZmlyc3RJdGVtSW5kZXgyLCBnYXAyLCBkYXRhMik7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgbGlzdFN0YXRlXG4gICAgKTtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFN5c3RlbSwgbGlzdFN0YXRlU3lzdGVtLCBwcm9wc1JlYWR5U3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IHNjcm9sbFNlZWtTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBzY3JvbGxWZWxvY2l0eSB9XSkgPT4ge1xuICAgIGNvbnN0IGlzU2Vla2luZyA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25zdCByYW5nZUNoYW5nZWQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbiA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsVmVsb2NpdHksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNjcm9sbFNlZWtDb25maWd1cmF0aW9uLCBpc1NlZWtpbmcsIHJhbmdlQ2hhbmdlZCksXG4gICAgICAgIGZpbHRlcigoW18sIGNvbmZpZ10pID0+ICEhY29uZmlnKSxcbiAgICAgICAgbWFwKChbc3BlZWQsIGNvbmZpZywgaXNTZWVraW5nMiwgcmFuZ2VdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBleGl0LCBlbnRlciB9ID0gY29uZmlnO1xuICAgICAgICAgIGlmIChpc1NlZWtpbmcyKSB7XG4gICAgICAgICAgICBpZiAoZXhpdChzcGVlZCwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudGVyKHNwZWVkLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc1NlZWtpbmcyO1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKSxcbiAgICAgIGlzU2Vla2luZ1xuICAgICk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShjb21iaW5lTGF0ZXN0KGlzU2Vla2luZywgc2Nyb2xsVmVsb2NpdHksIHJhbmdlQ2hhbmdlZCksIHdpdGhMYXRlc3RGcm9tKHNjcm9sbFNlZWtDb25maWd1cmF0aW9uKSksXG4gICAgICAoW1tpc1NlZWtpbmcyLCB2ZWxvY2l0eSwgcmFuZ2VdLCBjb25maWddKSA9PiBpc1NlZWtpbmcyICYmIGNvbmZpZyAmJiBjb25maWcuY2hhbmdlICYmIGNvbmZpZy5jaGFuZ2UodmVsb2NpdHksIHJhbmdlKVxuICAgICk7XG4gICAgcmV0dXJuIHsgaXNTZWVraW5nLCBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbiwgc2Nyb2xsVmVsb2NpdHksIHNjcm9sbFNlZWtSYW5nZUNoYW5nZWQ6IHJhbmdlQ2hhbmdlZCB9O1xuICB9LFxuICB0dXAoc3RhdGVGbGFnc1N5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCB0b3BJdGVtQ291bnRTeXN0ZW0gPSBzeXN0ZW0oKFt7IHRvcEl0ZW1zSW5kZXhlcyB9XSkgPT4ge1xuICBjb25zdCB0b3BJdGVtQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgdG9wSXRlbUNvdW50LFxuICAgICAgZmlsdGVyKChsZW5ndGgpID0+IGxlbmd0aCA+IDApLFxuICAgICAgbWFwKChsZW5ndGgpID0+IEFycmF5LmZyb20oeyBsZW5ndGggfSkubWFwKChfLCBpbmRleCkgPT4gaW5kZXgpKVxuICAgICksXG4gICAgdG9wSXRlbXNJbmRleGVzXG4gICk7XG4gIHJldHVybiB7IHRvcEl0ZW1Db3VudCB9O1xufSwgdHVwKGxpc3RTdGF0ZVN5c3RlbSkpO1xuY29uc3QgdG90YWxMaXN0SGVpZ2h0U3lzdGVtID0gc3lzdGVtKFxuICAoW3sgZm9vdGVySGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZpeGVkSGVhZGVySGVpZ2h0LCBmaXhlZEZvb3RlckhlaWdodCB9LCB7IGxpc3RTdGF0ZSB9XSkgPT4ge1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodENoYW5nZWQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCB0b3RhbExpc3RIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChmb290ZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZpeGVkSGVhZGVySGVpZ2h0LCBsaXN0U3RhdGUpLFxuICAgICAgICBtYXAoKFtmb290ZXJIZWlnaHQyLCBmaXhlZEZvb3RlckhlaWdodDIsIGhlYWRlckhlaWdodDIsIGZpeGVkSGVhZGVySGVpZ2h0MiwgbGlzdFN0YXRlMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gZm9vdGVySGVpZ2h0MiArIGZpeGVkRm9vdGVySGVpZ2h0MiArIGhlYWRlckhlaWdodDIgKyBmaXhlZEhlYWRlckhlaWdodDIgKyBsaXN0U3RhdGUyLm9mZnNldEJvdHRvbSArIGxpc3RTdGF0ZTIuYm90dG9tO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbm5lY3QoZHVjKHRvdGFsTGlzdEhlaWdodCksIHRvdGFsTGlzdEhlaWdodENoYW5nZWQpO1xuICAgIHJldHVybiB7IHRvdGFsTGlzdEhlaWdodCwgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBzaW1wbGVNZW1vaXplKGZ1bmMpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gZnVuYygpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuY29uc3QgaXNNb2JpbGVTYWZhcmkgPSBzaW1wbGVNZW1vaXplKCgpID0+IHtcbiAgcmV0dXJuIC9pUChhZHxvZHxob25lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1dlYktpdC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59KTtcbmNvbnN0IHVwd2FyZFNjcm9sbEZpeFN5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICB7IHNjcm9sbEJ5LCBzY3JvbGxUb3AsIGRldmlhdGlvbiwgc2Nyb2xsaW5nSW5Qcm9ncmVzcyB9LFxuICAgIHsgaXNTY3JvbGxpbmcsIGlzQXRCb3R0b20sIHNjcm9sbERpcmVjdGlvbiwgbGFzdEp1bXBEdWVUb0l0ZW1SZXNpemUgfSxcbiAgICB7IGxpc3RTdGF0ZSB9LFxuICAgIHsgYmVmb3JlVW5zaGlmdFdpdGgsIHNoaWZ0V2l0aE9mZnNldCwgc2l6ZXMsIGdhcCB9LFxuICAgIHsgbG9nIH0sXG4gICAgeyByZWNhbGNJblByb2dyZXNzIH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IGRldmlhdGlvbk9mZnNldCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZSksXG4gICAgICAgIHNjYW4oXG4gICAgICAgICAgKFssIHByZXZJdGVtcywgcHJldlRvdGFsQ291bnQsIHByZXZUb3RhbEhlaWdodF0sIFt7IGl0ZW1zLCB0b3RhbENvdW50LCBib3R0b20sIG9mZnNldEJvdHRvbSB9LCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZTJdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IGJvdHRvbSArIG9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgIGxldCBuZXdEZXYgPSAwO1xuICAgICAgICAgICAgaWYgKHByZXZUb3RhbENvdW50ID09PSB0b3RhbENvdW50KSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2SXRlbXMubGVuZ3RoID4gMCAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXRTdGFydCA9IGl0ZW1zWzBdLm9yaWdpbmFsSW5kZXggPT09IDAgJiYgcHJldkl0ZW1zWzBdLm9yaWdpbmFsSW5kZXggPT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFhdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICBuZXdEZXYgPSB0b3RhbEhlaWdodCAtIHByZXZUb3RhbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdEZXYgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGV2ICs9IGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbmV3RGV2LCBpdGVtcywgdG90YWxDb3VudCwgdG90YWxIZWlnaHRdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgWzAsIFtdLCAwLCAwXVxuICAgICAgICApLFxuICAgICAgICBmaWx0ZXIoKFthbW91bnRdKSA9PiBhbW91bnQgIT09IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzY3JvbGxUb3AsIHNjcm9sbERpcmVjdGlvbiwgc2Nyb2xsaW5nSW5Qcm9ncmVzcywgaXNBdEJvdHRvbSwgbG9nLCByZWNhbGNJblByb2dyZXNzKSxcbiAgICAgICAgZmlsdGVyKChbLCBzY3JvbGxUb3AyLCBzY3JvbGxEaXJlY3Rpb24yLCBzY3JvbGxpbmdJblByb2dyZXNzMiwgLCAsIHJlY2FsY0luUHJvZ3Jlc3MyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiAhcmVjYWxjSW5Qcm9ncmVzczIgJiYgIXNjcm9sbGluZ0luUHJvZ3Jlc3MyICYmIHNjcm9sbFRvcDIgIT09IDAgJiYgc2Nyb2xsRGlyZWN0aW9uMiA9PT0gVVA7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKFtbYW1vdW50XSwgLCAsICwgLCBsb2cyXSkgPT4ge1xuICAgICAgICAgIGxvZzIoXCJVcHdhcmQgc2Nyb2xsaW5nIGNvbXBlbnNhdGlvblwiLCB7IGFtb3VudCB9LCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICAgIGZ1bmN0aW9uIHNjcm9sbEJ5V2l0aChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIHB1Ymxpc2goc2Nyb2xsQnksIHsgdG9wOiAtb2Zmc2V0LCBiZWhhdmlvcjogXCJhdXRvXCIgfSk7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCAwKTtcbiAgICAgICAgcHVibGlzaChzY3JvbGxCeSwgeyB0b3A6IC1vZmZzZXQsIGJlaGF2aW9yOiBcImF1dG9cIiB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKHBpcGUoZGV2aWF0aW9uT2Zmc2V0LCB3aXRoTGF0ZXN0RnJvbShkZXZpYXRpb24sIGlzU2Nyb2xsaW5nKSksIChbb2Zmc2V0LCBkZXZpYXRpb25BbW91bnQsIGlzU2Nyb2xsaW5nMl0pID0+IHtcbiAgICAgIGlmIChpc1Njcm9sbGluZzIgJiYgaXNNb2JpbGVTYWZhcmkoKSkge1xuICAgICAgICBwdWJsaXNoKGRldmlhdGlvbiwgZGV2aWF0aW9uQW1vdW50IC0gb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbEJ5V2l0aCgtb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoaXNTY3JvbGxpbmcsIGZhbHNlKSwgZGV2aWF0aW9uLCByZWNhbGNJblByb2dyZXNzKSxcbiAgICAgICAgZmlsdGVyKChbaXMsIGRldmlhdGlvbjIsIHJlY2FsY10pID0+ICFpcyAmJiAhcmVjYWxjICYmIGRldmlhdGlvbjIgIT09IDApLFxuICAgICAgICBtYXAoKFtfLCBkZXZpYXRpb24yXSkgPT4gZGV2aWF0aW9uMiksXG4gICAgICAgIHRocm90dGxlVGltZSgxKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbEJ5V2l0aFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNoaWZ0V2l0aE9mZnNldCxcbiAgICAgICAgbWFwKChvZmZzZXQpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB0b3A6IC1vZmZzZXQgfTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBzY3JvbGxCeVxuICAgICk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgYmVmb3JlVW5zaGlmdFdpdGgsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzLCBnYXApLFxuICAgICAgICBtYXAoKFtvZmZzZXQsIHsgbGFzdFNpemU6IGRlZmF1bHRJdGVtU2l6ZSwgZ3JvdXBJbmRpY2VzLCBzaXplVHJlZSB9LCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGZ1bmN0aW9uIGdldEl0ZW1PZmZzZXQoaXRlbUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUNvdW50ICogKGRlZmF1bHRJdGVtU2l6ZSArIGdhcDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ3JvdXBJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEl0ZW1PZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFtb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0R3JvdXBTaXplID0gZmluZChzaXplVHJlZSwgMCk7XG4gICAgICAgICAgICBsZXQgcmVjb2duaXplZE9mZnNldEl0ZW1zID0gMDtcbiAgICAgICAgICAgIGxldCBncm91cEluZGV4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvZ25pemVkT2Zmc2V0SXRlbXMgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcmVjb2duaXplZE9mZnNldEl0ZW1zKys7XG4gICAgICAgICAgICAgIGFtb3VudCArPSBkZWZhdWx0R3JvdXBTaXplO1xuICAgICAgICAgICAgICBsZXQgZ3JvdXBJdGVtQ291bnQgPSBncm91cEluZGljZXMubGVuZ3RoID09PSBncm91cEluZGV4ICsgMSA/IEluZmluaXR5IDogZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXggKyAxXSAtIGdyb3VwSW5kaWNlc1tncm91cEluZGV4XSAtIDE7XG4gICAgICAgICAgICAgIGlmIChyZWNvZ25pemVkT2Zmc2V0SXRlbXMgKyBncm91cEl0ZW1Db3VudCA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGFtb3VudCAtPSBkZWZhdWx0R3JvdXBTaXplO1xuICAgICAgICAgICAgICAgIGdyb3VwSXRlbUNvdW50ID0gb2Zmc2V0IC0gcmVjb2duaXplZE9mZnNldEl0ZW1zICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWNvZ25pemVkT2Zmc2V0SXRlbXMgKz0gZ3JvdXBJdGVtQ291bnQ7XG4gICAgICAgICAgICAgIGFtb3VudCArPSBnZXRJdGVtT2Zmc2V0KGdyb3VwSXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgKG9mZnNldCkgPT4ge1xuICAgICAgICBwdWJsaXNoKGRldmlhdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbEJ5LCB7IHRvcDogb2Zmc2V0IH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBwdWJsaXNoKGRldmlhdGlvbiwgMCk7XG4gICAgICAgICAgICBwdWJsaXNoKHJlY2FsY0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZXZpYXRpb24gfTtcbiAgfSxcbiAgdHVwKGRvbUlPU3lzdGVtLCBzdGF0ZUZsYWdzU3lzdGVtLCBsaXN0U3RhdGVTeXN0ZW0sIHNpemVTeXN0ZW0sIGxvZ2dlclN5c3RlbSwgcmVjYWxjU3lzdGVtKVxuKTtcbmNvbnN0IGluaXRpYWxTY3JvbGxUb3BTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBkaWRNb3VudCB9LCB7IHNjcm9sbFRvIH0sIHsgbGlzdFN0YXRlIH1dKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFNjcm9sbFRvcCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsU2Nyb2xsVG9wKSxcbiAgICAgICAgZmlsdGVyKChbLCBvZmZzZXRdKSA9PiBvZmZzZXQgIT09IDApLFxuICAgICAgICBtYXAoKFssIG9mZnNldF0pID0+ICh7IHRvcDogb2Zmc2V0IH0pKVxuICAgICAgKSxcbiAgICAgIChsb2NhdGlvbikgPT4ge1xuICAgICAgICBoYW5kbGVOZXh0KFxuICAgICAgICAgIHBpcGUoXG4gICAgICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgICAgICBza2lwKDEpLFxuICAgICAgICAgICAgZmlsdGVyKChzdGF0ZSkgPT4gc3RhdGUuaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICApLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsVG8sIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsU2Nyb2xsVG9wXG4gICAgfTtcbiAgfSxcbiAgdHVwKHByb3BzUmVhZHlTeXN0ZW0sIGRvbUlPU3lzdGVtLCBsaXN0U3RhdGVTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgYWxpZ25Ub0JvdHRvbVN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IHZpZXdwb3J0SGVpZ2h0IH0sIHsgdG90YWxMaXN0SGVpZ2h0IH1dKSA9PiB7XG4gICAgY29uc3QgYWxpZ25Ub0JvdHRvbSA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25zdCBwYWRkaW5nVG9wQWRkaXRpb24gPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChhbGlnblRvQm90dG9tLCB2aWV3cG9ydEhlaWdodCwgdG90YWxMaXN0SGVpZ2h0KSxcbiAgICAgICAgZmlsdGVyKChbZW5hYmxlZF0pID0+IGVuYWJsZWQpLFxuICAgICAgICBtYXAoKFssIHZpZXdwb3J0SGVpZ2h0MiwgdG90YWxMaXN0SGVpZ2h0Ml0pID0+IHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdmlld3BvcnRIZWlnaHQyIC0gdG90YWxMaXN0SGVpZ2h0Mik7XG4gICAgICAgIH0pLFxuICAgICAgICB0aHJvdHRsZVRpbWUoMCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4geyBhbGlnblRvQm90dG9tLCBwYWRkaW5nVG9wQWRkaXRpb24gfTtcbiAgfSxcbiAgdHVwKGRvbUlPU3lzdGVtLCB0b3RhbExpc3RIZWlnaHRTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3Qgd2luZG93U2Nyb2xsZXJTeXN0ZW0gPSBzeXN0ZW0oKFt7IHNjcm9sbFRvLCBzY3JvbGxDb250YWluZXJTdGF0ZSB9XSkgPT4ge1xuICBjb25zdCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSA9IHN0cmVhbSgpO1xuICBjb25zdCB3aW5kb3dWaWV3cG9ydFJlY3QgPSBzdHJlYW0oKTtcbiAgY29uc3Qgd2luZG93U2Nyb2xsVG8gPSBzdHJlYW0oKTtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSBzdGF0ZWZ1bFN0cmVhbSh2b2lkIDApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBjb21iaW5lTGF0ZXN0KHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCB3aW5kb3dWaWV3cG9ydFJlY3QpLFxuICAgICAgbWFwKChbeyB2aWV3cG9ydEhlaWdodCwgc2Nyb2xsVG9wOiB3aW5kb3dTY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9LCB7IG9mZnNldFRvcCB9XSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNjcm9sbFRvcDogTWF0aC5tYXgoMCwgd2luZG93U2Nyb2xsVG9wIC0gb2Zmc2V0VG9wKSxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKSxcbiAgICBzY3JvbGxDb250YWluZXJTdGF0ZVxuICApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHdpbmRvd1ZpZXdwb3J0UmVjdCksXG4gICAgICBtYXAoKFtzY3JvbGxUbzIsIHsgb2Zmc2V0VG9wIH1dKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2Nyb2xsVG8yLFxuICAgICAgICAgIHRvcDogc2Nyb2xsVG8yLnRvcCArIG9mZnNldFRvcFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApLFxuICAgIHdpbmRvd1Njcm9sbFRvXG4gICk7XG4gIHJldHVybiB7XG4gICAgLy8gY29uZmlnXG4gICAgdXNlV2luZG93U2Nyb2xsLFxuICAgIGN1c3RvbVNjcm9sbFBhcmVudCxcbiAgICAvLyBpbnB1dFxuICAgIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLFxuICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCxcbiAgICAvLyBzaWduYWxzXG4gICAgd2luZG93U2Nyb2xsVG9cbiAgfTtcbn0sIHR1cChkb21JT1N5c3RlbSkpO1xuY29uc3QgZGVmYXVsdENhbGN1bGF0ZVZpZXdMb2NhdGlvbiA9ICh7XG4gIGl0ZW1Ub3A6IGl0ZW1Ub3AyLFxuICBpdGVtQm90dG9tLFxuICB2aWV3cG9ydFRvcCxcbiAgdmlld3BvcnRCb3R0b20sXG4gIGxvY2F0aW9uUGFyYW1zOiB7IGJlaGF2aW9yLCBhbGlnbiwgLi4ucmVzdCB9XG59KSA9PiB7XG4gIGlmIChpdGVtVG9wMiA8IHZpZXdwb3J0VG9wKSB7XG4gICAgcmV0dXJuIHsgLi4ucmVzdCwgYmVoYXZpb3IsIGFsaWduOiBhbGlnbiAhPSBudWxsID8gYWxpZ24gOiBcInN0YXJ0XCIgfTtcbiAgfVxuICBpZiAoaXRlbUJvdHRvbSA+IHZpZXdwb3J0Qm90dG9tKSB7XG4gICAgcmV0dXJuIHsgLi4ucmVzdCwgYmVoYXZpb3IsIGFsaWduOiBhbGlnbiAhPSBudWxsID8gYWxpZ24gOiBcImVuZFwiIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3Qgc2Nyb2xsSW50b1ZpZXdTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgdG90YWxDb3VudCwgZ2FwIH0sXG4gICAgeyBzY3JvbGxUb3AsIHZpZXdwb3J0SGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZpeGVkSGVhZGVySGVpZ2h0LCBmaXhlZEZvb3RlckhlaWdodCwgc2Nyb2xsaW5nSW5Qcm9ncmVzcyB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleCB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBzY3JvbGxJbnRvVmlldyA9IHN0cmVhbSgpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIHZpZXdwb3J0SGVpZ2h0LCB0b3RhbENvdW50LCBoZWFkZXJIZWlnaHQsIGZpeGVkSGVhZGVySGVpZ2h0LCBmaXhlZEZvb3RlckhlaWdodCwgc2Nyb2xsVG9wKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZ2FwKSxcbiAgICAgICAgbWFwKChbW3ZpZXdMb2NhdGlvbiwgc2l6ZXMyLCB2aWV3cG9ydEhlaWdodDIsIHRvdGFsQ291bnQyLCBoZWFkZXJIZWlnaHQyLCBmaXhlZEhlYWRlckhlaWdodDIsIGZpeGVkRm9vdGVySGVpZ2h0Miwgc2Nyb2xsVG9wMl0sIGdhcDJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCBiZWhhdmlvciwgYWxpZ24sIGNhbGN1bGF0ZVZpZXdMb2NhdGlvbiA9IGRlZmF1bHRDYWxjdWxhdGVWaWV3TG9jYXRpb24sIC4uLnJlc3QgfSA9IHZpZXdMb2NhdGlvbjtcbiAgICAgICAgICBjb25zdCBhY3R1YWxJbmRleCA9IG9yaWdpbmFsSW5kZXhGcm9tTG9jYXRpb24odmlld0xvY2F0aW9uLCBzaXplczIsIHRvdGFsQ291bnQyIC0gMSk7XG4gICAgICAgICAgY29uc3QgaXRlbVRvcDIgPSBvZmZzZXRPZihhY3R1YWxJbmRleCwgc2l6ZXMyLm9mZnNldFRyZWUsIGdhcDIpICsgaGVhZGVySGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MjtcbiAgICAgICAgICBjb25zdCBpdGVtQm90dG9tID0gaXRlbVRvcDIgKyBmaW5kTWF4S2V5VmFsdWUoc2l6ZXMyLnNpemVUcmVlLCBhY3R1YWxJbmRleClbMV07XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRUb3AgPSBzY3JvbGxUb3AyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0Qm90dG9tID0gc2Nyb2xsVG9wMiArIHZpZXdwb3J0SGVpZ2h0MiAtIGZpeGVkRm9vdGVySGVpZ2h0MjtcbiAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGNhbGN1bGF0ZVZpZXdMb2NhdGlvbih7XG4gICAgICAgICAgICBpdGVtVG9wOiBpdGVtVG9wMixcbiAgICAgICAgICAgIGl0ZW1Cb3R0b20sXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCxcbiAgICAgICAgICAgIHZpZXdwb3J0Qm90dG9tLFxuICAgICAgICAgICAgbG9jYXRpb25QYXJhbXM6IHsgYmVoYXZpb3IsIGFsaWduLCAuLi5yZXN0IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIGRvbmUgJiYgaGFuZGxlTmV4dChcbiAgICAgICAgICAgICAgcGlwZShcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmdJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlID09PSBmYWxzZSksXG4gICAgICAgICAgICAgICAgLy8gc2tpcHMgdGhlIGluaXRpYWwgcHVibGlzaCBvZiBmYWxzZSwgYW5kIHRoZSBjbGVhbnVwIGNhbGwuXG4gICAgICAgICAgICAgICAgLy8gYnV0IGlmIHNjcm9sbGluZ0luUHJvZ3Jlc3MgaXMgdHJ1ZSwgd2Ugc2tpcCB0aGUgaW5pdGlhbCBwdWJsaXNoLlxuICAgICAgICAgICAgICAgIHNraXAoZ2V0VmFsdWUoc2Nyb2xsaW5nSW5Qcm9ncmVzcykgPyAxIDogMilcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZG9uZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSBudWxsKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbFRvSW5kZXhcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxJbnRvVmlld1xuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgc2Nyb2xsVG9JbmRleFN5c3RlbSwgbGlzdFN0YXRlU3lzdGVtLCBsb2dnZXJTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3Qgc3RhdGVMb2FkU3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgc2l6ZXMsIHNpemVSYW5nZXMgfSxcbiAgICB7IHNjcm9sbFRvcCB9LFxuICAgIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggfSxcbiAgICB7IGRpZE1vdW50IH0sXG4gICAgeyB1c2VXaW5kb3dTY3JvbGwsIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCB3aW5kb3dWaWV3cG9ydFJlY3QgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgZ2V0U3RhdGUgPSBzdHJlYW0oKTtcbiAgICBjb25zdCByZXN0b3JlU3RhdGVGcm9tID0gc3RhdGVmdWxTdHJlYW0odm9pZCAwKTtcbiAgICBjb25zdCBzdGF0ZWZ1bFdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gICAgY29uc3Qgc3RhdGVmdWxXaW5kb3dWaWV3cG9ydFJlY3QgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgICBjb25uZWN0KHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCBzdGF0ZWZ1bFdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlKTtcbiAgICBjb25uZWN0KHdpbmRvd1ZpZXdwb3J0UmVjdCwgc3RhdGVmdWxXaW5kb3dWaWV3cG9ydFJlY3QpO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoZ2V0U3RhdGUsIHdpdGhMYXRlc3RGcm9tKHNpemVzLCBzY3JvbGxUb3AsIHVzZVdpbmRvd1Njcm9sbCwgc3RhdGVmdWxXaW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSwgc3RhdGVmdWxXaW5kb3dWaWV3cG9ydFJlY3QpKSxcbiAgICAgIChbY2FsbGJhY2ssIHNpemVzMiwgc2Nyb2xsVG9wMiwgdXNlV2luZG93U2Nyb2xsMiwgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUyLCB3aW5kb3dWaWV3cG9ydFJlY3QyXSkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZXMgPSBzaXplVHJlZVRvUmFuZ2VzKHNpemVzMi5zaXplVHJlZSk7XG4gICAgICAgIGlmICh1c2VXaW5kb3dTY3JvbGwyICYmIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlMiAhPT0gbnVsbCAmJiB3aW5kb3dWaWV3cG9ydFJlY3QyICE9PSBudWxsKSB7XG4gICAgICAgICAgc2Nyb2xsVG9wMiA9IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlMi5zY3JvbGxUb3AgLSB3aW5kb3dWaWV3cG9ydFJlY3QyLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayh7IHJhbmdlcywgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgY29ubmVjdChwaXBlKHJlc3RvcmVTdGF0ZUZyb20sIGZpbHRlcihpc0RlZmluZWQpLCBtYXAobG9jYXRpb25Gcm9tU25hcHNob3QpKSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20ocmVzdG9yZVN0YXRlRnJvbSksXG4gICAgICAgIGZpbHRlcigoWywgc3RhdGVdKSA9PiBzdGF0ZSAhPT0gdm9pZCAwKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgbWFwKChbLCBzbmFwc2hvdF0pID0+IHtcbiAgICAgICAgICByZXR1cm4gc25hcHNob3QucmFuZ2VzO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVSYW5nZXNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb21cbiAgICB9O1xuICB9LFxuICB0dXAoc2l6ZVN5c3RlbSwgZG9tSU9TeXN0ZW0sIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLCBwcm9wc1JlYWR5U3lzdGVtLCB3aW5kb3dTY3JvbGxlclN5c3RlbSlcbik7XG5mdW5jdGlvbiBsb2NhdGlvbkZyb21TbmFwc2hvdChzbmFwc2hvdCkge1xuICByZXR1cm4geyBvZmZzZXQ6IHNuYXBzaG90LnNjcm9sbFRvcCwgaW5kZXg6IDAsIGFsaWduOiBcInN0YXJ0XCIgfTtcbn1cbmNvbnN0IGZlYXR1cmVHcm91cDFTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgc2l6ZVJhbmdlLFxuICAgIGluaXRpYWxJdGVtQ291bnQsXG4gICAgcHJvcHNSZWFkeSxcbiAgICBzY3JvbGxTZWVrLFxuICAgIHRvdGFsTGlzdEhlaWdodCxcbiAgICBpbml0aWFsU2Nyb2xsVG9wU3lzdGVtMixcbiAgICBhbGlnblRvQm90dG9tLFxuICAgIHdpbmRvd1Njcm9sbGVyLFxuICAgIHNjcm9sbEludG9WaWV3LFxuICAgIGxvZ2dlclxuICBdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNpemVSYW5nZSxcbiAgICAgIC4uLmluaXRpYWxJdGVtQ291bnQsXG4gICAgICAuLi5wcm9wc1JlYWR5LFxuICAgICAgLi4uc2Nyb2xsU2VlayxcbiAgICAgIC4uLnRvdGFsTGlzdEhlaWdodCxcbiAgICAgIC4uLmluaXRpYWxTY3JvbGxUb3BTeXN0ZW0yLFxuICAgICAgLi4uYWxpZ25Ub0JvdHRvbSxcbiAgICAgIC4uLndpbmRvd1Njcm9sbGVyLFxuICAgICAgLi4uc2Nyb2xsSW50b1ZpZXcsXG4gICAgICAuLi5sb2dnZXJcbiAgICB9O1xuICB9LFxuICB0dXAoXG4gICAgc2l6ZVJhbmdlU3lzdGVtLFxuICAgIGluaXRpYWxJdGVtQ291bnRTeXN0ZW0sXG4gICAgcHJvcHNSZWFkeVN5c3RlbSxcbiAgICBzY3JvbGxTZWVrU3lzdGVtLFxuICAgIHRvdGFsTGlzdEhlaWdodFN5c3RlbSxcbiAgICBpbml0aWFsU2Nyb2xsVG9wU3lzdGVtLFxuICAgIGFsaWduVG9Cb3R0b21TeXN0ZW0sXG4gICAgd2luZG93U2Nyb2xsZXJTeXN0ZW0sXG4gICAgc2Nyb2xsSW50b1ZpZXdTeXN0ZW0sXG4gICAgbG9nZ2VyU3lzdGVtXG4gIClcbik7XG5jb25zdCBsaXN0U3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHtcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICBzaXplUmFuZ2VzLFxuICAgICAgZml4ZWRJdGVtU2l6ZSxcbiAgICAgIGRlZmF1bHRJdGVtU2l6ZSxcbiAgICAgIHRyYWNrSXRlbVNpemVzLFxuICAgICAgaXRlbVNpemUsXG4gICAgICBkYXRhLFxuICAgICAgZmlyc3RJdGVtSW5kZXgsXG4gICAgICBncm91cEluZGljZXMsXG4gICAgICBzdGF0ZWZ1bFRvdGFsQ291bnQsXG4gICAgICBnYXAsXG4gICAgICBzaXplc1xuICAgIH0sXG4gICAgeyBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtIH0sXG4gICAgZG9tSU8sXG4gICAgc3RhdGVMb2FkLFxuICAgIGZvbGxvd091dHB1dCxcbiAgICB7IGxpc3RTdGF0ZSwgdG9wSXRlbXNJbmRleGVzLCAuLi5mbGFncyB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleCB9LFxuICAgIF8sXG4gICAgeyB0b3BJdGVtQ291bnQgfSxcbiAgICB7IGdyb3VwQ291bnRzIH0sXG4gICAgZmVhdHVyZUdyb3VwMVxuICBdKSA9PiB7XG4gICAgY29ubmVjdChmbGFncy5yYW5nZUNoYW5nZWQsIGZlYXR1cmVHcm91cDEuc2Nyb2xsU2Vla1JhbmdlQ2hhbmdlZCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGZlYXR1cmVHcm91cDEud2luZG93Vmlld3BvcnRSZWN0LFxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS52aXNpYmxlSGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIGRvbUlPLnZpZXdwb3J0SGVpZ2h0XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaW5wdXRcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICBkYXRhLFxuICAgICAgZmlyc3RJdGVtSW5kZXgsXG4gICAgICBzaXplUmFuZ2VzLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsXG4gICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sXG4gICAgICB0b3BJdGVtc0luZGV4ZXMsXG4gICAgICB0b3BJdGVtQ291bnQsXG4gICAgICBncm91cENvdW50cyxcbiAgICAgIGZpeGVkSXRlbUhlaWdodDogZml4ZWRJdGVtU2l6ZSxcbiAgICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBkZWZhdWx0SXRlbVNpemUsXG4gICAgICBnYXAsXG4gICAgICAuLi5mb2xsb3dPdXRwdXQsXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudCxcbiAgICAgIGxpc3RTdGF0ZSxcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICB0cmFja0l0ZW1TaXplcyxcbiAgICAgIGl0ZW1TaXplLFxuICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgLy8gZXhwb3J0ZWQgZnJvbSBzdGF0ZUZsYWdzU3lzdGVtXG4gICAgICAuLi5mbGFncyxcbiAgICAgIC8vIHRoZSBiYWcgb2YgSU8gZnJvbSBmZWF0dXJlR3JvdXAxU3lzdGVtXG4gICAgICAuLi5mZWF0dXJlR3JvdXAxLFxuICAgICAgLi4uZG9tSU8sXG4gICAgICBzaXplcyxcbiAgICAgIC4uLnN0YXRlTG9hZFxuICAgIH07XG4gIH0sXG4gIHR1cChcbiAgICBzaXplU3lzdGVtLFxuICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLFxuICAgIGRvbUlPU3lzdGVtLFxuICAgIHN0YXRlTG9hZFN5c3RlbSxcbiAgICBmb2xsb3dPdXRwdXRTeXN0ZW0sXG4gICAgbGlzdFN0YXRlU3lzdGVtLFxuICAgIHNjcm9sbFRvSW5kZXhTeXN0ZW0sXG4gICAgdXB3YXJkU2Nyb2xsRml4U3lzdGVtLFxuICAgIHRvcEl0ZW1Db3VudFN5c3RlbSxcbiAgICBncm91cGVkTGlzdFN5c3RlbSxcbiAgICBmZWF0dXJlR3JvdXAxU3lzdGVtXG4gIClcbik7XG5jb25zdCBXRUJLSVRfU1RJQ0tZID0gXCItd2Via2l0LXN0aWNreVwiO1xuY29uc3QgU1RJQ0tZID0gXCJzdGlja3lcIjtcbmNvbnN0IHBvc2l0aW9uU3RpY2t5Q3NzVmFsdWUgPSBzaW1wbGVNZW1vaXplKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBTVElDS1k7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG5vZGUuc3R5bGUucG9zaXRpb24gPSBXRUJLSVRfU1RJQ0tZO1xuICByZXR1cm4gbm9kZS5zdHlsZS5wb3NpdGlvbiA9PT0gV0VCS0lUX1NUSUNLWSA/IFdFQktJVF9TVElDS1kgOiBTVElDS1k7XG59KTtcbmZ1bmN0aW9uIHVzZVdpbmRvd1ZpZXdwb3J0UmVjdFJlZihjYWxsYmFjaywgY3VzdG9tU2Nyb2xsUGFyZW50KSB7XG4gIGNvbnN0IHZpZXdwb3J0SW5mbyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FsY3VsYXRlSW5mbyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCAhZWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB2aXNpYmxlV2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgbGV0IHZpc2libGVIZWlnaHQsIG9mZnNldFRvcDtcbiAgICAgIGlmIChjdXN0b21TY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50UmVjdCA9IGN1c3RvbVNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZGVsdGFUb3AgPSByZWN0LnRvcCAtIGN1c3RvbVNjcm9sbFBhcmVudFJlY3QudG9wO1xuICAgICAgICB2aXNpYmxlSGVpZ2h0ID0gY3VzdG9tU2Nyb2xsUGFyZW50UmVjdC5oZWlnaHQgLSBNYXRoLm1heCgwLCBkZWx0YVRvcCk7XG4gICAgICAgIG9mZnNldFRvcCA9IGRlbHRhVG9wICsgY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpc2libGVIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgICAgIG9mZnNldFRvcCA9IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgfVxuICAgICAgdmlld3BvcnRJbmZvLmN1cnJlbnQgPSB7XG4gICAgICAgIG9mZnNldFRvcCxcbiAgICAgICAgdmlzaWJsZUhlaWdodCxcbiAgICAgICAgdmlzaWJsZVdpZHRoXG4gICAgICB9O1xuICAgICAgY2FsbGJhY2sodmlld3BvcnRJbmZvLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgW2NhbGxiYWNrLCBjdXN0b21TY3JvbGxQYXJlbnRdXG4gICk7XG4gIGNvbnN0IHsgY2FsbGJhY2tSZWYsIHJlZiB9ID0gdXNlU2l6ZVdpdGhFbFJlZihjYWxjdWxhdGVJbmZvKTtcbiAgY29uc3Qgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNhbGN1bGF0ZUluZm8ocmVmLmN1cnJlbnQpO1xuICB9LCBbY2FsY3VsYXRlSW5mbywgcmVmXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1c3RvbVNjcm9sbFBhcmVudCkge1xuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGN1c3RvbVNjcm9sbFBhcmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXN0b21TY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoY3VzdG9tU2Nyb2xsUGFyZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyLCBjdXN0b21TY3JvbGxQYXJlbnRdKTtcbiAgcmV0dXJuIGNhbGxiYWNrUmVmO1xufVxuY29uc3QgVmlydHVvc29Nb2NrQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmNvbnN0IFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbGlzdENvbXBvbmVudFByb3BzU3lzdGVtID0gLyogQF9fUFVSRV9fICovIHN5c3RlbSgoKSA9PiB7XG4gIGNvbnN0IGl0ZW1Db250ZW50ID0gc3RhdGVmdWxTdHJlYW0oKGluZGV4KSA9PiBgSXRlbSAke2luZGV4fWApO1xuICBjb25zdCBjb250ZXh0ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gIGNvbnN0IGdyb3VwQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKChpbmRleCkgPT4gYEdyb3VwICR7aW5kZXh9YCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSBzdGF0ZWZ1bFN0cmVhbShcImRpdlwiKTtcbiAgY29uc3Qgc2Nyb2xsZXJSZWYgPSBzdGF0ZWZ1bFN0cmVhbShub29wKTtcbiAgY29uc3QgZGlzdGluY3RQcm9wID0gKHByb3BOYW1lLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICBtYXAoKGNvbXBvbmVudHMyKSA9PiBjb21wb25lbnRzMltwcm9wTmFtZV0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0LFxuICAgIGl0ZW1Db250ZW50LFxuICAgIGdyb3VwQ29udGVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGNvbXB1dGVJdGVtS2V5LFxuICAgIGhlYWRlckZvb3RlclRhZyxcbiAgICBzY3JvbGxlclJlZixcbiAgICBGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkhlYWRlclwiKSxcbiAgICBUb3BJdGVtTGlzdENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVG9wSXRlbUxpc3RcIiksXG4gICAgTGlzdENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiTGlzdFwiLCBcImRpdlwiKSxcbiAgICBJdGVtQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJJdGVtXCIsIFwiZGl2XCIpLFxuICAgIEdyb3VwQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJHcm91cFwiLCBcImRpdlwiKSxcbiAgICBTY3JvbGxlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgRW1wdHlQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiRW1wdHlQbGFjZWhvbGRlclwiKSxcbiAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXI6IGRpc3RpbmN0UHJvcChcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKVxuICB9O1xufSk7XG5jb25zdCBjb21iaW5lZFN5c3RlbSQyID0gLyogQF9fUFVSRV9fICovIHN5c3RlbSgoW2xpc3RTeXN0ZW0yLCBwcm9wc1N5c3RlbV0pID0+IHtcbiAgcmV0dXJuIHsgLi4ubGlzdFN5c3RlbTIsIC4uLnByb3BzU3lzdGVtIH07XG59LCB0dXAobGlzdFN5c3RlbSwgbGlzdENvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyJDEgPSAoeyBoZWlnaHQgfSkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyBoZWlnaHQgfSB9KTtcbmNvbnN0IEdST1VQX1NUWUxFID0geyBwb3NpdGlvbjogcG9zaXRpb25TdGlja3lDc3NWYWx1ZSgpLCB6SW5kZXg6IDEsIG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiB9O1xuY29uc3QgSVRFTV9TVFlMRSQxID0geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfTtcbmNvbnN0IEl0ZW1zJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0l0ZW1zKHsgc2hvd1RvcExpc3QgPSBmYWxzZSB9KSB7XG4gIGNvbnN0IGxpc3RTdGF0ZSA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwibGlzdFN0YXRlXCIpO1xuICBjb25zdCBzaXplUmFuZ2VzID0gdXNlUHVibGlzaGVyJDIoXCJzaXplUmFuZ2VzXCIpO1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSB1c2VFbWl0dGVyVmFsdWUkMihcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIkMihcIndpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlXCIpO1xuICBjb25zdCBfc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA9IHVzZVB1Ymxpc2hlciQyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA6IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrO1xuICBjb25zdCBpdGVtQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiaXRlbUNvbnRlbnRcIik7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIGNvbnN0IGdyb3VwQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiZ3JvdXBDb250ZW50XCIpO1xuICBjb25zdCB0cmFja0l0ZW1TaXplcyA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwidHJhY2tJdGVtU2l6ZXNcIik7XG4gIGNvbnN0IGl0ZW1TaXplID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpdGVtU2l6ZVwiKTtcbiAgY29uc3QgbG9nID0gdXNlRW1pdHRlclZhbHVlJDIoXCJsb2dcIik7XG4gIGNvbnN0IGxpc3RHYXAgPSB1c2VQdWJsaXNoZXIkMihcImdhcFwiKTtcbiAgY29uc3QgeyBjYWxsYmFja1JlZiB9ID0gdXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzKFxuICAgIHNpemVSYW5nZXMsXG4gICAgaXRlbVNpemUsXG4gICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgc2hvd1RvcExpc3QgPyBub29wIDogc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICBsb2csXG4gICAgbGlzdEdhcCxcbiAgICBjdXN0b21TY3JvbGxQYXJlbnRcbiAgKTtcbiAgY29uc3QgW2RldmlhdGlvbiwgc2V0RGV2aWF0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICB1c2VFbWl0dGVyJDIoXCJkZXZpYXRpb25cIiwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKGRldmlhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHNldERldmlhdGlvbih2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgRW1wdHlQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiRW1wdHlQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlJDIoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIikgfHwgRGVmYXVsdFNjcm9sbFNlZWtQbGFjZWhvbGRlciQxO1xuICBjb25zdCBMaXN0Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJMaXN0Q29tcG9uZW50XCIpO1xuICBjb25zdCBJdGVtQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJJdGVtQ29tcG9uZW50XCIpO1xuICBjb25zdCBHcm91cENvbXBvbmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiR3JvdXBDb21wb25lbnRcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjb21wdXRlSXRlbUtleVwiKTtcbiAgY29uc3QgaXNTZWVraW5nID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpc1NlZWtpbmdcIik7XG4gIGNvbnN0IGhhc0dyb3VwczIgPSB1c2VFbWl0dGVyVmFsdWUkMihcImdyb3VwSW5kaWNlc1wiKS5sZW5ndGggPiAwO1xuICBjb25zdCBwYWRkaW5nVG9wQWRkaXRpb24gPSB1c2VFbWl0dGVyVmFsdWUkMihcInBhZGRpbmdUb3BBZGRpdGlvblwiKTtcbiAgY29uc3Qgc2Nyb2xsZWRUb0luaXRpYWxJdGVtID0gdXNlRW1pdHRlclZhbHVlJDIoXCJzY3JvbGxlZFRvSW5pdGlhbEl0ZW1cIik7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gc2hvd1RvcExpc3QgPyB7fSA6IHtcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIHBhZGRpbmdUb3A6IGxpc3RTdGF0ZS5vZmZzZXRUb3AgKyBwYWRkaW5nVG9wQWRkaXRpb24sXG4gICAgcGFkZGluZ0JvdHRvbTogbGlzdFN0YXRlLm9mZnNldEJvdHRvbSxcbiAgICBtYXJnaW5Ub3A6IGRldmlhdGlvbixcbiAgICAuLi5zY3JvbGxlZFRvSW5pdGlhbEl0ZW0gPyB7fSA6IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9XG4gIH07XG4gIGlmICghc2hvd1RvcExpc3QgJiYgbGlzdFN0YXRlLnRvdGFsQ291bnQgPT09IDAgJiYgRW1wdHlQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVtcHR5UGxhY2Vob2xkZXIsIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEVtcHR5UGxhY2Vob2xkZXIsIGNvbnRleHQpKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBMaXN0Q29tcG9uZW50LFxuICAgIHtcbiAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KExpc3RDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgcmVmOiBjYWxsYmFja1JlZixcbiAgICAgIHN0eWxlOiBjb250YWluZXJTdHlsZSxcbiAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IHNob3dUb3BMaXN0ID8gXCJ2aXJ0dW9zby10b3AtaXRlbS1saXN0XCIgOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiXG4gICAgfSxcbiAgICAoc2hvd1RvcExpc3QgPyBsaXN0U3RhdGUudG9wSXRlbXMgOiBsaXN0U3RhdGUuaXRlbXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBpdGVtLm9yaWdpbmFsSW5kZXg7XG4gICAgICBjb25zdCBrZXkgPSBjb21wdXRlSXRlbUtleShpbmRleCArIGxpc3RTdGF0ZS5maXJzdEl0ZW1JbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc1NlZWtpbmcpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLCB7XG4gICAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLCBjb250ZXh0KSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgaGVpZ2h0OiBpdGVtLnNpemUsXG4gICAgICAgICAgdHlwZTogaXRlbS50eXBlIHx8IFwiaXRlbVwiLFxuICAgICAgICAgIC4uLml0ZW0udHlwZSA9PT0gXCJncm91cFwiID8ge30gOiB7IGdyb3VwSW5kZXg6IGl0ZW0uZ3JvdXBJbmRleCB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEdyb3VwQ29tcG9uZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEdyb3VwQ29tcG9uZW50LCBjb250ZXh0KSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgICAgIFwiZGF0YS1rbm93bi1zaXplXCI6IGl0ZW0uc2l6ZSxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWluZGV4XCI6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICBzdHlsZTogR1JPVVBfU1RZTEVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdyb3VwQ29udGVudChpdGVtLmluZGV4LCBjb250ZXh0KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgSXRlbUNvbXBvbmVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChJdGVtQ29tcG9uZW50LCBjb250ZXh0KSxcbiAgICAgICAgICAgIC4uLml0ZW1Qcm9wSWZOb3REb21FbGVtZW50KEl0ZW1Db21wb25lbnQsIGl0ZW0uZGF0YSksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBcImRhdGEtaW5kZXhcIjogaW5kZXgsXG4gICAgICAgICAgICBcImRhdGEta25vd24tc2l6ZVwiOiBpdGVtLnNpemUsXG4gICAgICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBpdGVtLmluZGV4LFxuICAgICAgICAgICAgXCJkYXRhLWl0ZW0tZ3JvdXAtaW5kZXhcIjogaXRlbS5ncm91cEluZGV4LFxuICAgICAgICAgICAgc3R5bGU6IElURU1fU1RZTEUkMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzR3JvdXBzMiA/IGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZ3JvdXBJbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KSA6IGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufSk7XG5jb25zdCBzY3JvbGxlclN0eWxlID0ge1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6IFwidG91Y2hcIlxufTtcbmNvbnN0IHZpZXdwb3J0U3R5bGUgPSB7XG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdG9wOiAwXG59O1xuY29uc3QgdG9wSXRlbUxpc3RTdHlsZSA9IHtcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogcG9zaXRpb25TdGlja3lDc3NWYWx1ZSgpLFxuICB0b3A6IDAsXG4gIHpJbmRleDogMVxufTtcbmZ1bmN0aW9uIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBjb250ZXh0IH07XG59XG5mdW5jdGlvbiBpdGVtUHJvcElmTm90RG9tRWxlbWVudChlbGVtZW50LCBpdGVtKSB7XG4gIHJldHVybiB7IGl0ZW06IHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiID8gdm9pZCAwIDogaXRlbSB9O1xufVxuY29uc3QgSGVhZGVyJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0hlYWRlcigpIHtcbiAgY29uc3QgSGVhZGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiSGVhZGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMihcImhlYWRlckhlaWdodFwiKTtcbiAgY29uc3QgaGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDIoXCJoZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoKGVsKSA9PiBoZWFkZXJIZWlnaHQoY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSkpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjb250ZXh0XCIpO1xuICByZXR1cm4gSGVhZGVyMiA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoaGVhZGVyRm9vdGVyVGFnLCB7IHJlZiB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlcjIsIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEhlYWRlcjIsIGNvbnRleHQpKSkgOiBudWxsO1xufSk7XG5jb25zdCBGb290ZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvRm9vdGVyKCkge1xuICBjb25zdCBGb290ZXIyID0gdXNlRW1pdHRlclZhbHVlJDIoXCJGb290ZXJDb21wb25lbnRcIik7XG4gIGNvbnN0IGZvb3RlckhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwiZm9vdGVySGVpZ2h0XCIpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSB1c2VFbWl0dGVyVmFsdWUkMihcImhlYWRlckZvb3RlclRhZ1wiKTtcbiAgY29uc3QgcmVmID0gdXNlU2l6ZSgoZWwpID0+IGZvb3RlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIHJldHVybiBGb290ZXIyID8gUmVhY3QuY3JlYXRlRWxlbWVudChoZWFkZXJGb290ZXJUYWcsIHsgcmVmIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vdGVyMiwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoRm9vdGVyMiwgY29udGV4dCkpKSA6IG51bGw7XG59KTtcbmZ1bmN0aW9uIGJ1aWxkU2Nyb2xsZXIoeyB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlcjIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIyLCB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZTIgfSkge1xuICBjb25zdCBTY3JvbGxlcjIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvU2Nyb2xsZXIoeyBzdHlsZSwgY2hpbGRyZW4sIC4uLnByb3BzIH0pIHtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyMihcInNjcm9sbENvbnRhaW5lclN0YXRlXCIpO1xuICAgIGNvbnN0IFNjcm9sbGVyQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlMihcIlNjcm9sbGVyQ29tcG9uZW50XCIpO1xuICAgIGNvbnN0IHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQgPSB1c2VQdWJsaXNoZXIyKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKTtcbiAgICBjb25zdCBzY3JvbGxlclJlZkNhbGxiYWNrID0gdXNlRW1pdHRlclZhbHVlMihcInNjcm9sbGVyUmVmXCIpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiY29udGV4dFwiKTtcbiAgICBjb25zdCB7IHNjcm9sbGVyUmVmLCBzY3JvbGxCeUNhbGxiYWNrLCBzY3JvbGxUb0NhbGxiYWNrIH0gPSB1c2VTY3JvbGxUb3AoXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIFNjcm9sbGVyQ29tcG9uZW50LFxuICAgICAgc2Nyb2xsZXJSZWZDYWxsYmFja1xuICAgICk7XG4gICAgdXNlRW1pdHRlcjIoXCJzY3JvbGxUb1wiLCBzY3JvbGxUb0NhbGxiYWNrKTtcbiAgICB1c2VFbWl0dGVyMihcInNjcm9sbEJ5XCIsIHNjcm9sbEJ5Q2FsbGJhY2spO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU2Nyb2xsZXJDb21wb25lbnQsXG4gICAgICB7XG4gICAgICAgIHJlZjogc2Nyb2xsZXJSZWYsXG4gICAgICAgIHN0eWxlOiB7IC4uLnNjcm9sbGVyU3R5bGUsIC4uLnN0eWxlIH0sXG4gICAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwidmlydHVvc28tc2Nyb2xsZXJcIixcbiAgICAgICAgXCJkYXRhLXZpcnR1b3NvLXNjcm9sbGVyXCI6IHRydWUsXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoU2Nyb2xsZXJDb21wb25lbnQsIGNvbnRleHQpXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFNjcm9sbGVyMjtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2luZG93U2Nyb2xsZXIoeyB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlcjIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIyLCB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZTIgfSkge1xuICBjb25zdCBTY3JvbGxlcjIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvV2luZG93U2Nyb2xsZXIoeyBzdHlsZSwgY2hpbGRyZW4sIC4uLnByb3BzIH0pIHtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyMihcIndpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlXCIpO1xuICAgIGNvbnN0IFNjcm9sbGVyQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlMihcIlNjcm9sbGVyQ29tcG9uZW50XCIpO1xuICAgIGNvbnN0IHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQgPSB1c2VQdWJsaXNoZXIyKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKTtcbiAgICBjb25zdCB0b3RhbExpc3RIZWlnaHQgPSB1c2VFbWl0dGVyVmFsdWUyKFwidG90YWxMaXN0SGVpZ2h0XCIpO1xuICAgIGNvbnN0IGRldmlhdGlvbiA9IHVzZUVtaXR0ZXJWYWx1ZTIoXCJkZXZpYXRpb25cIik7XG4gICAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlMihcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlMihcImNvbnRleHRcIik7XG4gICAgY29uc3QgeyBzY3JvbGxlclJlZiwgc2Nyb2xsQnlDYWxsYmFjaywgc2Nyb2xsVG9DYWxsYmFjayB9ID0gdXNlU2Nyb2xsVG9wKFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsXG4gICAgICBTY3JvbGxlckNvbXBvbmVudCxcbiAgICAgIG5vb3AsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnRcbiAgICApO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMSgoKSA9PiB7XG4gICAgICBzY3JvbGxlclJlZi5jdXJyZW50ID0gY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50IDogd2luZG93O1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2Nyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sIFtzY3JvbGxlclJlZiwgY3VzdG9tU2Nyb2xsUGFyZW50XSk7XG4gICAgdXNlRW1pdHRlcjIoXCJ3aW5kb3dTY3JvbGxUb1wiLCBzY3JvbGxUb0NhbGxiYWNrKTtcbiAgICB1c2VFbWl0dGVyMihcInNjcm9sbEJ5XCIsIHNjcm9sbEJ5Q2FsbGJhY2spO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU2Nyb2xsZXJDb21wb25lbnQsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsIC4uLnN0eWxlLCAuLi50b3RhbExpc3RIZWlnaHQgIT09IDAgPyB7IGhlaWdodDogdG90YWxMaXN0SGVpZ2h0ICsgZGV2aWF0aW9uIH0gOiB7fSB9LFxuICAgICAgICBcImRhdGEtdmlydHVvc28tc2Nyb2xsZXJcIjogdHJ1ZSxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbGVyQ29tcG9uZW50LCBjb250ZXh0KVxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBTY3JvbGxlcjI7XG59XG5jb25zdCBWaWV3cG9ydCQyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvTW9ja0NvbnRleHQpO1xuICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwidmlld3BvcnRIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkSXRlbUhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVNpemUoY29tcG9zZSh2aWV3cG9ydEhlaWdodCwgKGVsKSA9PiBjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgdmlld3BvcnRIZWlnaHQoY3R4LnZpZXdwb3J0SGVpZ2h0KTtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgfVxuICB9LCBbY3R4LCB2aWV3cG9ydEhlaWdodCwgZml4ZWRJdGVtSGVpZ2h0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB2aWV3cG9ydFN0eWxlLCByZWY6IHZpZXdwb3J0UmVmLCBcImRhdGEtdmlld3BvcnQtdHlwZVwiOiBcImVsZW1lbnRcIiB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgV2luZG93Vmlld3BvcnQkMiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgY3R4ID0gUmVhY3QudXNlQ29udGV4dChWaXJ0dW9zb01vY2tDb250ZXh0KTtcbiAgY29uc3Qgd2luZG93Vmlld3BvcnRSZWN0ID0gdXNlUHVibGlzaGVyJDIoXCJ3aW5kb3dWaWV3cG9ydFJlY3RcIik7XG4gIGNvbnN0IGZpeGVkSXRlbUhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VXaW5kb3dWaWV3cG9ydFJlY3RSZWYod2luZG93Vmlld3BvcnRSZWN0LCBjdXN0b21TY3JvbGxQYXJlbnQpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3QoeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGN0eC52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiAxMDAgfSk7XG4gICAgfVxuICB9LCBbY3R4LCB3aW5kb3dWaWV3cG9ydFJlY3QsIGZpeGVkSXRlbUhlaWdodF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHZpZXdwb3J0UmVmLCBzdHlsZTogdmlld3BvcnRTdHlsZSwgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJ3aW5kb3dcIiB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgVG9wSXRlbUxpc3RDb250YWluZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFRvcEl0ZW1MaXN0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJUb3BJdGVtTGlzdENvbXBvbmVudFwiKTtcbiAgY29uc3QgaGVhZGVySGVpZ2h0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJoZWFkZXJIZWlnaHRcIik7XG4gIGNvbnN0IHN0eWxlID0geyAuLi50b3BJdGVtTGlzdFN0eWxlLCBtYXJnaW5Ub3A6IGAke2hlYWRlckhlaWdodH1weGAgfTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wSXRlbUxpc3QgfHwgXCJkaXZcIiwgeyBzdHlsZSwgY29udGV4dCB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgTGlzdFJvb3QgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb1Jvb3QocHJvcHMpIHtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlJDIoXCJ1c2VXaW5kb3dTY3JvbGxcIik7XG4gIGNvbnN0IHNob3dUb3BMaXN0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJ0b3BJdGVtc0luZGV4ZXNcIikubGVuZ3RoID4gMDtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IFRoZVNjcm9sbGVyID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1Njcm9sbGVyJDIgOiBTY3JvbGxlciQyO1xuICBjb25zdCBUaGVWaWV3cG9ydCA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dWaWV3cG9ydCQyIDogVmlld3BvcnQkMjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFRoZVNjcm9sbGVyLCB7IC4uLnByb3BzIH0sIHNob3dUb3BMaXN0ICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFRvcEl0ZW1MaXN0Q29udGFpbmVyLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChJdGVtcyQxLCB7IHNob3dUb3BMaXN0OiB0cnVlIH0pKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlVmlld3BvcnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciQxLCBudWxsKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSXRlbXMkMSwgbnVsbCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEZvb3RlciQxLCBudWxsKSkpO1xufSk7XG5jb25zdCB7XG4gIENvbXBvbmVudDogTGlzdCxcbiAgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMixcbiAgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMixcbiAgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQyXG59ID0gLyogQF9fUFVSRV9fICovIHN5c3RlbVRvQ29tcG9uZW50KFxuICBjb21iaW5lZFN5c3RlbSQyLFxuICB7XG4gICAgcmVxdWlyZWQ6IHt9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIGNvbnRleHQ6IFwiY29udGV4dFwiLFxuICAgICAgZm9sbG93T3V0cHV0OiBcImZvbGxvd091dHB1dFwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiaXRlbUNvbnRlbnRcIixcbiAgICAgIGdyb3VwQ29udGVudDogXCJncm91cENvbnRlbnRcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICB0b3RhbENvdW50OiBcInRvdGFsQ291bnRcIixcbiAgICAgIGdyb3VwQ291bnRzOiBcImdyb3VwQ291bnRzXCIsXG4gICAgICB0b3BJdGVtQ291bnQ6IFwidG9wSXRlbUNvdW50XCIsXG4gICAgICBmaXJzdEl0ZW1JbmRleDogXCJmaXJzdEl0ZW1JbmRleFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgYXRCb3R0b21UaHJlc2hvbGQ6IFwiYXRCb3R0b21UaHJlc2hvbGRcIixcbiAgICAgIGF0VG9wVGhyZXNob2xkOiBcImF0VG9wVGhyZXNob2xkXCIsXG4gICAgICBjb21wdXRlSXRlbUtleTogXCJjb21wdXRlSXRlbUtleVwiLFxuICAgICAgZGVmYXVsdEl0ZW1IZWlnaHQ6IFwiZGVmYXVsdEl0ZW1IZWlnaHRcIixcbiAgICAgIGZpeGVkSXRlbUhlaWdodDogXCJmaXhlZEl0ZW1IZWlnaHRcIixcbiAgICAgIGl0ZW1TaXplOiBcIml0ZW1TaXplXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgaGVhZGVyRm9vdGVyVGFnOiBcImhlYWRlckZvb3RlclRhZ1wiLFxuICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxTY3JvbGxUb3A6IFwiaW5pdGlhbFNjcm9sbFRvcFwiLFxuICAgICAgYWxpZ25Ub0JvdHRvbTogXCJhbGlnblRvQm90dG9tXCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCIsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQ6IFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIsXG4gICAgICBzY3JvbGxlclJlZjogXCJzY3JvbGxlclJlZlwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIlxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgc2Nyb2xsVG9JbmRleDogXCJzY3JvbGxUb0luZGV4XCIsXG4gICAgICBzY3JvbGxJbnRvVmlldzogXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbEJ5OiBcInNjcm9sbEJ5XCIsXG4gICAgICBhdXRvc2Nyb2xsVG9Cb3R0b206IFwiYXV0b3Njcm9sbFRvQm90dG9tXCIsXG4gICAgICBnZXRTdGF0ZTogXCJnZXRTdGF0ZVwiXG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgIGlzU2Nyb2xsaW5nOiBcImlzU2Nyb2xsaW5nXCIsXG4gICAgICBlbmRSZWFjaGVkOiBcImVuZFJlYWNoZWRcIixcbiAgICAgIHN0YXJ0UmVhY2hlZDogXCJzdGFydFJlYWNoZWRcIixcbiAgICAgIHJhbmdlQ2hhbmdlZDogXCJyYW5nZUNoYW5nZWRcIixcbiAgICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2U6IFwiYXRCb3R0b21TdGF0ZUNoYW5nZVwiLFxuICAgICAgYXRUb3BTdGF0ZUNoYW5nZTogXCJhdFRvcFN0YXRlQ2hhbmdlXCIsXG4gICAgICB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBcInRvdGFsTGlzdEhlaWdodENoYW5nZWRcIixcbiAgICAgIGl0ZW1zUmVuZGVyZWQ6IFwiaXRlbXNSZW5kZXJlZFwiLFxuICAgICAgZ3JvdXBJbmRpY2VzOiBcImdyb3VwSW5kaWNlc1wiXG4gICAgfVxuICB9LFxuICBMaXN0Um9vdFxuKTtcbmNvbnN0IFNjcm9sbGVyJDIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMiB9KTtcbmNvbnN0IFdpbmRvd1Njcm9sbGVyJDIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMiB9KTtcbmNvbnN0IFZpcnR1b3NvID0gTGlzdDtcbmNvbnN0IEdyb3VwZWRWaXJ0dW9zbyA9IExpc3Q7XG5jb25zdCBJTklUSUFMX0dSSURfU1RBVEUgPSB7XG4gIGl0ZW1zOiBbXSxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBpdGVtSGVpZ2h0OiAwLFxuICBpdGVtV2lkdGg6IDBcbn07XG5jb25zdCBQUk9CRV9HUklEX1NUQVRFID0ge1xuICBpdGVtczogW3sgaW5kZXg6IDAgfV0sXG4gIG9mZnNldEJvdHRvbTogMCxcbiAgb2Zmc2V0VG9wOiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgaXRlbUhlaWdodDogMCxcbiAgaXRlbVdpZHRoOiAwXG59O1xuY29uc3QgeyByb3VuZCwgY2VpbCwgZmxvb3IsIG1pbiwgbWF4IH0gPSBNYXRoO1xuZnVuY3Rpb24gYnVpbGRQcm9iZUdyaWRTdGF0ZShpdGVtcykge1xuICByZXR1cm4ge1xuICAgIC4uLlBST0JFX0dSSURfU1RBVEUsXG4gICAgaXRlbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSXRlbXMoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDEgfSkubWFwKChfLCBpKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSBkYXRhID09PSBudWxsID8gbnVsbCA6IGRhdGFbaSArIHN0YXJ0SW5kZXhdO1xuICAgIHJldHVybiB7IGluZGV4OiBpICsgc3RhcnRJbmRleCwgZGF0YTogZGF0YUl0ZW0gfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnYXBDb21wYXJhdG9yKHByZXYsIG5leHQpIHtcbiAgcmV0dXJuIHByZXYgJiYgcHJldi5jb2x1bW4gPT09IG5leHQuY29sdW1uICYmIHByZXYucm93ID09PSBuZXh0LnJvdztcbn1cbmZ1bmN0aW9uIGRpbWVuc2lvbkNvbXBhcmF0b3IocHJldiwgbmV4dCkge1xuICByZXR1cm4gcHJldiAmJiBwcmV2LndpZHRoID09PSBuZXh0LndpZHRoICYmIHByZXYuaGVpZ2h0ID09PSBuZXh0LmhlaWdodDtcbn1cbmNvbnN0IGdyaWRTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKFxuICAoW1xuICAgIHsgb3ZlcnNjYW4sIHZpc2libGVSYW5nZSwgbGlzdEJvdW5kYXJ5IH0sXG4gICAgeyBzY3JvbGxUb3AsIHZpZXdwb3J0SGVpZ2h0LCBzY3JvbGxCeSwgc2Nyb2xsVG8sIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsIHNjcm9sbENvbnRhaW5lclN0YXRlLCBmb290ZXJIZWlnaHQsIGhlYWRlckhlaWdodCB9LFxuICAgIHN0YXRlRmxhZ3MsXG4gICAgc2Nyb2xsU2VlayxcbiAgICB7IHByb3BzUmVhZHksIGRpZE1vdW50IH0sXG4gICAgeyB3aW5kb3dWaWV3cG9ydFJlY3QsIHVzZVdpbmRvd1Njcm9sbCwgY3VzdG9tU2Nyb2xsUGFyZW50LCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSwgd2luZG93U2Nyb2xsVG8gfSxcbiAgICBsb2dcbiAgXSkgPT4ge1xuICAgIGNvbnN0IHRvdGFsQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBpbml0aWFsSXRlbUNvdW50ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZ3JpZFN0YXRlID0gc3RhdGVmdWxTdHJlYW0oSU5JVElBTF9HUklEX1NUQVRFKTtcbiAgICBjb25zdCB2aWV3cG9ydERpbWVuc2lvbnMgPSBzdGF0ZWZ1bFN0cmVhbSh7IGhlaWdodDogMCwgd2lkdGg6IDAgfSk7XG4gICAgY29uc3QgaXRlbURpbWVuc2lvbnMgPSBzdGF0ZWZ1bFN0cmVhbSh7IGhlaWdodDogMCwgd2lkdGg6IDAgfSk7XG4gICAgY29uc3Qgc2Nyb2xsVG9JbmRleCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IGRldmlhdGlvbiA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGRhdGEgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgICBjb25zdCBnYXAgPSBzdGF0ZWZ1bFN0cmVhbSh7IHJvdzogMCwgY29sdW1uOiAwIH0pO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHJlc3RvcmVTdGF0ZUZyb20gPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbnN0IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc2Nyb2xsZWRUb0luaXRpYWxJdGVtID0gc3RhdGVmdWxTdHJlYW0odHJ1ZSk7XG4gICAgY29uc3Qgc2Nyb2xsU2NoZWR1bGVkID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCksXG4gICAgICAgIGZpbHRlcigoW18sIGxvY2F0aW9uXSkgPT4gISFsb2NhdGlvbilcbiAgICAgICksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHB1Ymxpc2goc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBmYWxzZSk7XG4gICAgICAgIHB1Ymxpc2goaW5pdGlhbEl0ZW1Db3VudCwgMCk7XG4gICAgICB9XG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGRpZE1vdW50LCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIGl0ZW1EaW1lbnNpb25zLCB2aWV3cG9ydERpbWVuc2lvbnMsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBzY3JvbGxTY2hlZHVsZWQpLFxuICAgICAgICBmaWx0ZXIoKFtkaWRNb3VudDIsIHNjcm9sbGVkVG9Jbml0aWFsSXRlbTIsIGl0ZW1EaW1lbnNpb25zMiwgdmlld3BvcnREaW1lbnNpb25zMiwgLCBzY3JvbGxTY2hlZHVsZWQyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBkaWRNb3VudDIgJiYgIXNjcm9sbGVkVG9Jbml0aWFsSXRlbTIgJiYgaXRlbURpbWVuc2lvbnMyLmhlaWdodCAhPT0gMCAmJiB2aWV3cG9ydERpbWVuc2lvbnMyLmhlaWdodCAhPT0gMCAmJiAhc2Nyb2xsU2NoZWR1bGVkMjtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICAoWywgLCAsICwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyXSkgPT4ge1xuICAgICAgICBwdWJsaXNoKHNjcm9sbFNjaGVkdWxlZCwgdHJ1ZSk7XG4gICAgICAgIHNraXBGcmFtZXMoMSwgKCkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsVG9JbmRleCwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZU5leHQocGlwZShzY3JvbGxUb3ApLCAoKSA9PiB7XG4gICAgICAgICAgcHVibGlzaChsaXN0Qm91bmRhcnksIFswLCAwXSk7XG4gICAgICAgICAgcHVibGlzaChzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICByZXN0b3JlU3RhdGVGcm9tLFxuICAgICAgICBmaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLnNjcm9sbFRvcCA+IDApLFxuICAgICAgICBtYXBUbygwKVxuICAgICAgKSxcbiAgICAgIGluaXRpYWxJdGVtQ291bnRcbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShyZXN0b3JlU3RhdGVGcm9tKSxcbiAgICAgICAgZmlsdGVyKChbLCBzbmFwc2hvdF0pID0+IHNuYXBzaG90ICE9PSB2b2lkIDAgJiYgc25hcHNob3QgIT09IG51bGwpXG4gICAgICApLFxuICAgICAgKFssIHNuYXBzaG90XSkgPT4ge1xuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1Ymxpc2godmlld3BvcnREaW1lbnNpb25zLCBzbmFwc2hvdC52aWV3cG9ydCksIHB1Ymxpc2goaXRlbURpbWVuc2lvbnMsIHNuYXBzaG90ID09IG51bGwgPyB2b2lkIDAgOiBzbmFwc2hvdC5pdGVtKTtcbiAgICAgICAgcHVibGlzaChnYXAsIHNuYXBzaG90LmdhcCk7XG4gICAgICAgIGlmIChzbmFwc2hvdC5zY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgICAgcHVibGlzaChzdGF0ZVJlc3RvcmVJblByb2dyZXNzLCB0cnVlKTtcbiAgICAgICAgICBoYW5kbGVOZXh0KHBpcGUoc2Nyb2xsVG9wLCBza2lwKDEpKSwgKF92YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcHVibGlzaChzdGF0ZVJlc3RvcmVJblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHVibGlzaChzY3JvbGxUbywgeyB0b3A6IHNuYXBzaG90LnNjcm9sbFRvcCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHZpZXdwb3J0RGltZW5zaW9ucyxcbiAgICAgICAgbWFwKCh7IGhlaWdodCB9KSA9PiBoZWlnaHQpXG4gICAgICApLFxuICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgIGR1Yyh2aWV3cG9ydERpbWVuc2lvbnMsIGRpbWVuc2lvbkNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1YyhpdGVtRGltZW5zaW9ucywgZGltZW5zaW9uQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKGdhcCwgKHByZXYsIG5leHQpID0+IHByZXYgJiYgcHJldi5jb2x1bW4gPT09IG5leHQuY29sdW1uICYmIHByZXYucm93ID09PSBuZXh0LnJvdyksXG4gICAgICAgICAgZHVjKHNjcm9sbFRvcClcbiAgICAgICAgKSxcbiAgICAgICAgbWFwKChbdmlld3BvcnQsIGl0ZW0sIGdhcDIsIHNjcm9sbFRvcDJdKSA9PiAoe1xuICAgICAgICAgIHZpZXdwb3J0LFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgZ2FwOiBnYXAyLFxuICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wMlxuICAgICAgICB9KSlcbiAgICAgICksXG4gICAgICBzdGF0ZUNoYW5nZWRcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgIGR1Yyh0b3RhbENvdW50KSxcbiAgICAgICAgICB2aXNpYmxlUmFuZ2UsXG4gICAgICAgICAgZHVjKGdhcCwgZ2FwQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKGl0ZW1EaW1lbnNpb25zLCBkaW1lbnNpb25Db21wYXJhdG9yKSxcbiAgICAgICAgICBkdWModmlld3BvcnREaW1lbnNpb25zLCBkaW1lbnNpb25Db21wYXJhdG9yKSxcbiAgICAgICAgICBkdWMoZGF0YSksXG4gICAgICAgICAgZHVjKGluaXRpYWxJdGVtQ291bnQpLFxuICAgICAgICAgIGR1YyhzdGF0ZVJlc3RvcmVJblByb2dyZXNzKSxcbiAgICAgICAgICBkdWMoc2Nyb2xsZWRUb0luaXRpYWxJdGVtKSxcbiAgICAgICAgICBkdWMoaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpXG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoWywgLCAsICwgLCAsICwgc3RhdGVSZXN0b3JlSW5Qcm9ncmVzczJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZVJlc3RvcmVJblByb2dyZXNzMjtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgdG90YWxDb3VudDIsXG4gICAgICAgICAgICBbc3RhcnRPZmZzZXQsIGVuZE9mZnNldF0sXG4gICAgICAgICAgICBnYXAyLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHZpZXdwb3J0LFxuICAgICAgICAgICAgZGF0YTIsXG4gICAgICAgICAgICBpbml0aWFsSXRlbUNvdW50MixcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbTIsXG4gICAgICAgICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDJcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJvdzogcm93R2FwLCBjb2x1bW46IGNvbHVtbkdhcCB9ID0gZ2FwMjtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0OiBpdGVtSGVpZ2h0LCB3aWR0aDogaXRlbVdpZHRoIH0gPSBpdGVtO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogdmlld3BvcnRXaWR0aCB9ID0gdmlld3BvcnQ7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEl0ZW1Db3VudDIgPT09IDAgJiYgKHRvdGFsQ291bnQyID09PSAwIHx8IHZpZXdwb3J0V2lkdGggPT09IDApKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJTklUSUFMX0dSSURfU1RBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXgyID0gZ2V0SW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIoaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyLCB0b3RhbENvdW50Mik7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4MiA9IHN0YXJ0SW5kZXgyID09PSAwID8gTWF0aC5tYXgoaW5pdGlhbEl0ZW1Db3VudDIgLSAxLCAwKSA6IHN0YXJ0SW5kZXgyO1xuICAgICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9iZUdyaWRTdGF0ZShidWlsZEl0ZW1zKHN0YXJ0SW5kZXgyLCBlbmRJbmRleDIsIGRhdGEyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZXJSb3cgPSBpdGVtc1BlclJvdyh2aWV3cG9ydFdpZHRoLCBpdGVtV2lkdGgsIGNvbHVtbkdhcCk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleDtcbiAgICAgICAgICAgIGlmICghc2Nyb2xsZWRUb0luaXRpYWxJdGVtMikge1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwICYmIGluaXRpYWxJdGVtQ291bnQyID4gMCkge1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBpbml0aWFsSXRlbUNvdW50MiAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gcGVyUm93ICogZmxvb3IoKHN0YXJ0T2Zmc2V0ICsgcm93R2FwKSAvIChpdGVtSGVpZ2h0ICsgcm93R2FwKSk7XG4gICAgICAgICAgICAgIGVuZEluZGV4ID0gcGVyUm93ICogY2VpbCgoZW5kT2Zmc2V0ICsgcm93R2FwKSAvIChpdGVtSGVpZ2h0ICsgcm93R2FwKSkgLSAxO1xuICAgICAgICAgICAgICBlbmRJbmRleCA9IG1pbih0b3RhbENvdW50MiAtIDEsIG1heChlbmRJbmRleCwgcGVyUm93IC0gMSkpO1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gbWluKGVuZEluZGV4LCBtYXgoMCwgc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBidWlsZEl0ZW1zKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkYXRhMik7XG4gICAgICAgICAgICBjb25zdCB7IHRvcCwgYm90dG9tIH0gPSBncmlkTGF5b3V0KHZpZXdwb3J0LCBnYXAyLCBpdGVtLCBpdGVtcyk7XG4gICAgICAgICAgICBjb25zdCByb3dDb3VudCA9IGNlaWwodG90YWxDb3VudDIgLyBwZXJSb3cpO1xuICAgICAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSByb3dDb3VudCAqIGl0ZW1IZWlnaHQgKyAocm93Q291bnQgLSAxKSAqIHJvd0dhcDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJvdHRvbSA9IHRvdGFsSGVpZ2h0IC0gYm90dG9tO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXMsIG9mZnNldFRvcDogdG9wLCBvZmZzZXRCb3R0b20sIHRvcCwgYm90dG9tLCBpdGVtSGVpZ2h0LCBpdGVtV2lkdGggfTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBncmlkU3RhdGVcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkYXRhLFxuICAgICAgICBmaWx0ZXIoKGRhdGEyKSA9PiBkYXRhMiAhPT0gbnVsbCksXG4gICAgICAgIG1hcCgoZGF0YTIpID0+IGRhdGEyLmxlbmd0aClcbiAgICAgICksXG4gICAgICB0b3RhbENvdW50XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdCh2aWV3cG9ydERpbWVuc2lvbnMsIGl0ZW1EaW1lbnNpb25zLCBncmlkU3RhdGUsIGdhcCksXG4gICAgICAgIGZpbHRlcigoW3ZpZXdwb3J0RGltZW5zaW9uczIsIGl0ZW1EaW1lbnNpb25zMiwgeyBpdGVtcyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBpdGVtcy5sZW5ndGggPiAwICYmIGl0ZW1EaW1lbnNpb25zMi5oZWlnaHQgIT09IDAgJiYgdmlld3BvcnREaW1lbnNpb25zMi5oZWlnaHQgIT09IDA7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKFt2aWV3cG9ydERpbWVuc2lvbnMyLCBpdGVtRGltZW5zaW9uczIsIHsgaXRlbXMgfSwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRvcCwgYm90dG9tIH0gPSBncmlkTGF5b3V0KHZpZXdwb3J0RGltZW5zaW9uczIsIGdhcDIsIGl0ZW1EaW1lbnNpb25zMiwgaXRlbXMpO1xuICAgICAgICAgIHJldHVybiBbdG9wLCBib3R0b21dO1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQodHVwbGVDb21wYXJhdG9yKVxuICAgICAgKSxcbiAgICAgIGxpc3RCb3VuZGFyeVxuICAgICk7XG4gICAgY29uc3QgaGFzU2Nyb2xsZWQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaGFzU2Nyb2xsZWQpLFxuICAgICAgICBtYXAoKFtzY3JvbGxUb3AyLCBoYXNTY3JvbGxlZDJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGhhc1Njcm9sbGVkMiB8fCBzY3JvbGxUb3AyICE9PSAwO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGhhc1Njcm9sbGVkXG4gICAgKTtcbiAgICBjb25zdCBlbmRSZWFjaGVkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBkdWMoZ3JpZFN0YXRlKSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zIH0pID0+IGl0ZW1zLmxlbmd0aCA+IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbSh0b3RhbENvdW50LCBoYXNTY3JvbGxlZCksXG4gICAgICAgIGZpbHRlcigoW3sgaXRlbXMgfSwgdG90YWxDb3VudDIsIGhhc1Njcm9sbGVkMl0pID0+IGhhc1Njcm9sbGVkMiAmJiBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5pbmRleCA9PT0gdG90YWxDb3VudDIgLSAxKSxcbiAgICAgICAgbWFwKChbLCB0b3RhbENvdW50Ml0pID0+IHRvdGFsQ291bnQyIC0gMSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHN0YXJ0UmVhY2hlZCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgZHVjKGdyaWRTdGF0ZSksXG4gICAgICAgIGZpbHRlcigoeyBpdGVtcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDAgJiYgaXRlbXNbMF0uaW5kZXggPT09IDA7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICBtYXBUbygwKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgcmFuZ2VDaGFuZ2VkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBkdWMoZ3JpZFN0YXRlKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc3RhdGVSZXN0b3JlSW5Qcm9ncmVzcyksXG4gICAgICAgIGZpbHRlcigoW3sgaXRlbXMgfSwgc3RhdGVSZXN0b3JlSW5Qcm9ncmVzczJdKSA9PiBpdGVtcy5sZW5ndGggPiAwICYmICFzdGF0ZVJlc3RvcmVJblByb2dyZXNzMiksXG4gICAgICAgIG1hcCgoW3sgaXRlbXMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRJbmRleDogaXRlbXNbMF0uaW5kZXgsXG4gICAgICAgICAgICBlbmRJbmRleDogaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0uaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQocmFuZ2VDb21wYXJhdG9yKSxcbiAgICAgICAgdGhyb3R0bGVUaW1lKDApXG4gICAgICApXG4gICAgKTtcbiAgICBjb25uZWN0KHJhbmdlQ2hhbmdlZCwgc2Nyb2xsU2Vlay5zY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20odmlld3BvcnREaW1lbnNpb25zLCBpdGVtRGltZW5zaW9ucywgdG90YWxDb3VudCwgZ2FwKSxcbiAgICAgICAgbWFwKChbbG9jYXRpb24sIHZpZXdwb3J0RGltZW5zaW9uczIsIGl0ZW1EaW1lbnNpb25zMiwgdG90YWxDb3VudDIsIGdhcDJdKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsTG9jYXRpb24gPSBub3JtYWxpemVJbmRleExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgICBjb25zdCB7IGFsaWduLCBiZWhhdmlvciwgb2Zmc2V0IH0gPSBub3JtYWxMb2NhdGlvbjtcbiAgICAgICAgICBsZXQgaW5kZXggPSBub3JtYWxMb2NhdGlvbi5pbmRleDtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IFwiTEFTVFwiKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRvdGFsQ291bnQyIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXggPSBtYXgoMCwgaW5kZXgsIG1pbih0b3RhbENvdW50MiAtIDEsIGluZGV4KSk7XG4gICAgICAgICAgbGV0IHRvcCA9IGl0ZW1Ub3Aodmlld3BvcnREaW1lbnNpb25zMiwgZ2FwMiwgaXRlbURpbWVuc2lvbnMyLCBpbmRleCk7XG4gICAgICAgICAgaWYgKGFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICB0b3AgPSByb3VuZCh0b3AgLSB2aWV3cG9ydERpbWVuc2lvbnMyLmhlaWdodCArIGl0ZW1EaW1lbnNpb25zMi5oZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgIHRvcCA9IHJvdW5kKHRvcCAtIHZpZXdwb3J0RGltZW5zaW9uczIuaGVpZ2h0IC8gMiArIGl0ZW1EaW1lbnNpb25zMi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgdG9wICs9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgdG9wLCBiZWhhdmlvciB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNjcm9sbFRvXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbExpc3RIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgZ3JpZFN0YXRlLFxuICAgICAgICBtYXAoKGdyaWRTdGF0ZTIpID0+IHtcbiAgICAgICAgICByZXR1cm4gZ3JpZFN0YXRlMi5vZmZzZXRCb3R0b20gKyBncmlkU3RhdGUyLmJvdHRvbTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgd2luZG93Vmlld3BvcnRSZWN0LFxuICAgICAgICBtYXAoKHZpZXdwb3J0SW5mbykgPT4gKHsgd2lkdGg6IHZpZXdwb3J0SW5mby52aXNpYmxlV2lkdGgsIGhlaWdodDogdmlld3BvcnRJbmZvLnZpc2libGVIZWlnaHQgfSkpXG4gICAgICApLFxuICAgICAgdmlld3BvcnREaW1lbnNpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaW5wdXRcbiAgICAgIGRhdGEsXG4gICAgICB0b3RhbENvdW50LFxuICAgICAgdmlld3BvcnREaW1lbnNpb25zLFxuICAgICAgaXRlbURpbWVuc2lvbnMsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBvdmVyc2NhbixcbiAgICAgIHNjcm9sbEJ5LFxuICAgICAgc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxUb0luZGV4LFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCxcbiAgICAgIHdpbmRvd1Njcm9sbFRvLFxuICAgICAgdXNlV2luZG93U2Nyb2xsLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50LFxuICAgICAgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICBkZXZpYXRpb24sXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIGZvb3RlckhlaWdodCxcbiAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgIGluaXRpYWxJdGVtQ291bnQsXG4gICAgICBnYXAsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tLFxuICAgICAgLi4uc2Nyb2xsU2VlayxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBncmlkU3RhdGUsXG4gICAgICB0b3RhbExpc3RIZWlnaHQsXG4gICAgICAuLi5zdGF0ZUZsYWdzLFxuICAgICAgc3RhcnRSZWFjaGVkLFxuICAgICAgZW5kUmVhY2hlZCxcbiAgICAgIHJhbmdlQ2hhbmdlZCxcbiAgICAgIHN0YXRlQ2hhbmdlZCxcbiAgICAgIHByb3BzUmVhZHksXG4gICAgICBzdGF0ZVJlc3RvcmVJblByb2dyZXNzLFxuICAgICAgLi4ubG9nXG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVSYW5nZVN5c3RlbSwgZG9tSU9TeXN0ZW0sIHN0YXRlRmxhZ3NTeXN0ZW0sIHNjcm9sbFNlZWtTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0sIHdpbmRvd1Njcm9sbGVyU3lzdGVtLCBsb2dnZXJTeXN0ZW0pXG4pO1xuZnVuY3Rpb24gZ3JpZExheW91dCh2aWV3cG9ydCwgZ2FwLCBpdGVtLCBpdGVtcykge1xuICBjb25zdCB7IGhlaWdodDogaXRlbUhlaWdodCB9ID0gaXRlbTtcbiAgaWYgKGl0ZW1IZWlnaHQgPT09IHZvaWQgMCB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICB9XG4gIGNvbnN0IHRvcCA9IGl0ZW1Ub3Aodmlld3BvcnQsIGdhcCwgaXRlbSwgaXRlbXNbMF0uaW5kZXgpO1xuICBjb25zdCBib3R0b20gPSBpdGVtVG9wKHZpZXdwb3J0LCBnYXAsIGl0ZW0sIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmluZGV4KSArIGl0ZW1IZWlnaHQ7XG4gIHJldHVybiB7IHRvcCwgYm90dG9tIH07XG59XG5mdW5jdGlvbiBpdGVtVG9wKHZpZXdwb3J0LCBnYXAsIGl0ZW0sIGluZGV4KSB7XG4gIGNvbnN0IHBlclJvdyA9IGl0ZW1zUGVyUm93KHZpZXdwb3J0LndpZHRoLCBpdGVtLndpZHRoLCBnYXAuY29sdW1uKTtcbiAgY29uc3Qgcm93Q291bnQgPSBmbG9vcihpbmRleCAvIHBlclJvdyk7XG4gIGNvbnN0IHRvcCA9IHJvd0NvdW50ICogaXRlbS5oZWlnaHQgKyBtYXgoMCwgcm93Q291bnQgLSAxKSAqIGdhcC5yb3c7XG4gIHJldHVybiB0b3AgPiAwID8gdG9wICsgZ2FwLnJvdyA6IHRvcDtcbn1cbmZ1bmN0aW9uIGl0ZW1zUGVyUm93KHZpZXdwb3J0V2lkdGgsIGl0ZW1XaWR0aCwgZ2FwKSB7XG4gIHJldHVybiBtYXgoMSwgZmxvb3IoKHZpZXdwb3J0V2lkdGggKyBnYXApIC8gKGZsb29yKGl0ZW1XaWR0aCkgKyBnYXApKSk7XG59XG5jb25zdCBncmlkQ29tcG9uZW50UHJvcHNTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKCgpID0+IHtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbSgoaW5kZXgpID0+IGBJdGVtICR7aW5kZXh9YCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbnRleHQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgaXRlbUNsYXNzTmFtZSA9IHN0YXRlZnVsU3RyZWFtKFwidmlydHVvc28tZ3JpZC1pdGVtXCIpO1xuICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gc3RhdGVmdWxTdHJlYW0oXCJ2aXJ0dW9zby1ncmlkLWxpc3RcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSBzdGF0ZWZ1bFN0cmVhbShcImRpdlwiKTtcbiAgY29uc3Qgc2Nyb2xsZXJSZWYgPSBzdGF0ZWZ1bFN0cmVhbShub29wKTtcbiAgY29uc3QgZGlzdGluY3RQcm9wID0gKHByb3BOYW1lLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICBtYXAoKGNvbXBvbmVudHMyKSA9PiBjb21wb25lbnRzMltwcm9wTmFtZV0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0LFxuICAgIGl0ZW1Db250ZW50LFxuICAgIGNvbXBvbmVudHMsXG4gICAgY29tcHV0ZUl0ZW1LZXksXG4gICAgaXRlbUNsYXNzTmFtZSxcbiAgICBsaXN0Q2xhc3NOYW1lLFxuICAgIGhlYWRlckZvb3RlclRhZyxcbiAgICBzY3JvbGxlclJlZixcbiAgICBGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkhlYWRlclwiKSxcbiAgICBMaXN0Q29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJMaXN0XCIsIFwiZGl2XCIpLFxuICAgIEl0ZW1Db21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlNjcm9sbGVyXCIsIFwiZGl2XCIpLFxuICAgIFNjcm9sbFNlZWtQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIsIFwiZGl2XCIpXG4gIH07XG59KTtcbmNvbnN0IGNvbWJpbmVkU3lzdGVtJDEgPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKChbZ3JpZFN5c3RlbTIsIGdyaWRDb21wb25lbnRQcm9wc1N5c3RlbTJdKSA9PiB7XG4gIHJldHVybiB7IC4uLmdyaWRTeXN0ZW0yLCAuLi5ncmlkQ29tcG9uZW50UHJvcHNTeXN0ZW0yIH07XG59LCB0dXAoZ3JpZFN5c3RlbSwgZ3JpZENvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBHcmlkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBHcmlkSXRlbXMyKCkge1xuICBjb25zdCBncmlkU3RhdGUgPSB1c2VFbWl0dGVyVmFsdWUkMShcImdyaWRTdGF0ZVwiKTtcbiAgY29uc3QgbGlzdENsYXNzTmFtZSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwibGlzdENsYXNzTmFtZVwiKTtcbiAgY29uc3QgaXRlbUNsYXNzTmFtZSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiaXRlbUNsYXNzTmFtZVwiKTtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMShcIml0ZW1Db250ZW50XCIpO1xuICBjb25zdCBjb21wdXRlSXRlbUtleSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29tcHV0ZUl0ZW1LZXlcIik7XG4gIGNvbnN0IGlzU2Vla2luZyA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiaXNTZWVraW5nXCIpO1xuICBjb25zdCBzY3JvbGxIZWlnaHRDYWxsYmFjayA9IHVzZVB1Ymxpc2hlciQxKFwic2Nyb2xsSGVpZ2h0XCIpO1xuICBjb25zdCBJdGVtQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJJdGVtQ29tcG9uZW50XCIpO1xuICBjb25zdCBMaXN0Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJMaXN0Q29tcG9uZW50XCIpO1xuICBjb25zdCBTY3JvbGxTZWVrUGxhY2Vob2xkZXIgPSB1c2VFbWl0dGVyVmFsdWUkMShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29udGV4dFwiKTtcbiAgY29uc3QgaXRlbURpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcIml0ZW1EaW1lbnNpb25zXCIpO1xuICBjb25zdCBncmlkR2FwID0gdXNlUHVibGlzaGVyJDEoXCJnYXBcIik7XG4gIGNvbnN0IGxvZyA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwibG9nXCIpO1xuICBjb25zdCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzID0gdXNlRW1pdHRlclZhbHVlJDEoXCJzdGF0ZVJlc3RvcmVJblByb2dyZXNzXCIpO1xuICBjb25zdCBsaXN0UmVmID0gdXNlU2l6ZSgoZWwpID0+IHtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBlbC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIHNjcm9sbEhlaWdodENhbGxiYWNrKHNjcm9sbEhlaWdodCk7XG4gICAgY29uc3QgZmlyc3RJdGVtID0gZWwuZmlyc3RDaGlsZDtcbiAgICBpZiAoZmlyc3RJdGVtKSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGZpcnN0SXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGl0ZW1EaW1lbnNpb25zKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICB9XG4gICAgZ3JpZEdhcCh7XG4gICAgICByb3c6IHJlc29sdmVHYXBWYWx1ZShcInJvdy1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkucm93R2FwLCBsb2cpLFxuICAgICAgY29sdW1uOiByZXNvbHZlR2FwVmFsdWUoXCJjb2x1bW4tZ2FwXCIsIGdldENvbXB1dGVkU3R5bGUoZWwpLmNvbHVtbkdhcCwgbG9nKVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBMaXN0Q29tcG9uZW50LFxuICAgIHtcbiAgICAgIHJlZjogbGlzdFJlZixcbiAgICAgIGNsYXNzTmFtZTogbGlzdENsYXNzTmFtZSxcbiAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KExpc3RDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgc3R5bGU6IHsgcGFkZGluZ1RvcDogZ3JpZFN0YXRlLm9mZnNldFRvcCwgcGFkZGluZ0JvdHRvbTogZ3JpZFN0YXRlLm9mZnNldEJvdHRvbSB9LFxuICAgICAgXCJkYXRhLXRlc3QtaWRcIjogXCJ2aXJ0dW9zby1pdGVtLWxpc3RcIlxuICAgIH0sXG4gICAgZ3JpZFN0YXRlLml0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gY29tcHV0ZUl0ZW1LZXkoaXRlbS5pbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpc1NlZWtpbmcgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwge1xuICAgICAgICBrZXksXG4gICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwgY29udGV4dCksXG4gICAgICAgIGluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgICBoZWlnaHQ6IGdyaWRTdGF0ZS5pdGVtSGVpZ2h0LFxuICAgICAgICB3aWR0aDogZ3JpZFN0YXRlLml0ZW1XaWR0aFxuICAgICAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBJdGVtQ29tcG9uZW50LFxuICAgICAgICB7IC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEl0ZW1Db21wb25lbnQsIGNvbnRleHQpLCBjbGFzc05hbWU6IGl0ZW1DbGFzc05hbWUsIFwiZGF0YS1pbmRleFwiOiBpdGVtLmluZGV4LCBrZXkgfSxcbiAgICAgICAgaXRlbUNvbnRlbnQoaXRlbS5pbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufSk7XG5jb25zdCBIZWFkZXIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvSGVhZGVyMigpIHtcbiAgY29uc3QgSGVhZGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiSGVhZGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMShcImhlYWRlckhlaWdodFwiKTtcbiAgY29uc3QgaGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDEoXCJoZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoKGVsKSA9PiBoZWFkZXJIZWlnaHQoY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSkpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjb250ZXh0XCIpO1xuICByZXR1cm4gSGVhZGVyMiA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoaGVhZGVyRm9vdGVyVGFnLCB7IHJlZiB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlcjIsIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEhlYWRlcjIsIGNvbnRleHQpKSkgOiBudWxsO1xufSk7XG5jb25zdCBGb290ZXIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvR3JpZEZvb3RlcigpIHtcbiAgY29uc3QgRm9vdGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiRm9vdGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBmb290ZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMShcImZvb3RlckhlaWdodFwiKTtcbiAgY29uc3QgaGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDEoXCJoZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoKGVsKSA9PiBmb290ZXJIZWlnaHQoY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSkpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjb250ZXh0XCIpO1xuICByZXR1cm4gRm9vdGVyMiA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoaGVhZGVyRm9vdGVyVGFnLCB7IHJlZiB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEZvb3RlcjIsIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEZvb3RlcjIsIGNvbnRleHQpKSkgOiBudWxsO1xufSk7XG5jb25zdCBWaWV3cG9ydCQxID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0KTtcbiAgY29uc3QgaXRlbURpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcIml0ZW1EaW1lbnNpb25zXCIpO1xuICBjb25zdCB2aWV3cG9ydERpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcInZpZXdwb3J0RGltZW5zaW9uc1wiKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VTaXplKChlbCkgPT4ge1xuICAgIHZpZXdwb3J0RGltZW5zaW9ucyhlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHZpZXdwb3J0RGltZW5zaW9ucyh7IGhlaWdodDogY3R4LnZpZXdwb3J0SGVpZ2h0LCB3aWR0aDogY3R4LnZpZXdwb3J0V2lkdGggfSk7XG4gICAgICBpdGVtRGltZW5zaW9ucyh7IGhlaWdodDogY3R4Lml0ZW1IZWlnaHQsIHdpZHRoOiBjdHguaXRlbVdpZHRoIH0pO1xuICAgIH1cbiAgfSwgW2N0eCwgdmlld3BvcnREaW1lbnNpb25zLCBpdGVtRGltZW5zaW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogdmlld3BvcnRTdHlsZSwgcmVmOiB2aWV3cG9ydFJlZiB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgV2luZG93Vmlld3BvcnQkMSA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgY3R4ID0gUmVhY3QudXNlQ29udGV4dChWaXJ0dW9zb0dyaWRNb2NrQ29udGV4dCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHVzZVB1Ymxpc2hlciQxKFwid2luZG93Vmlld3BvcnRSZWN0XCIpO1xuICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHVzZVB1Ymxpc2hlciQxKFwiaXRlbURpbWVuc2lvbnNcIik7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVdpbmRvd1ZpZXdwb3J0UmVjdFJlZih3aW5kb3dWaWV3cG9ydFJlY3QsIGN1c3RvbVNjcm9sbFBhcmVudCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgaXRlbURpbWVuc2lvbnMoeyBoZWlnaHQ6IGN0eC5pdGVtSGVpZ2h0LCB3aWR0aDogY3R4Lml0ZW1XaWR0aCB9KTtcbiAgICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCh7IG9mZnNldFRvcDogMCwgdmlzaWJsZUhlaWdodDogY3R4LnZpZXdwb3J0SGVpZ2h0LCB2aXNpYmxlV2lkdGg6IGN0eC52aWV3cG9ydFdpZHRoIH0pO1xuICAgIH1cbiAgfSwgW2N0eCwgd2luZG93Vmlld3BvcnRSZWN0LCBpdGVtRGltZW5zaW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHZpZXdwb3J0UmVmLCBzdHlsZTogdmlld3BvcnRTdHlsZSB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgR3JpZFJvb3QgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBHcmlkUm9vdDIoeyAuLi5wcm9wcyB9KSB7XG4gIGNvbnN0IHVzZVdpbmRvd1Njcm9sbCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwidXNlV2luZG93U2Nyb2xsXCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMShcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgY29uc3QgVGhlU2Nyb2xsZXIgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gV2luZG93U2Nyb2xsZXIkMSA6IFNjcm9sbGVyJDE7XG4gIGNvbnN0IFRoZVZpZXdwb3J0ID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1ZpZXdwb3J0JDEgOiBWaWV3cG9ydCQxO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlU2Nyb2xsZXIsIHsgLi4ucHJvcHMgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlVmlld3BvcnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciwgbnVsbCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEdyaWRJdGVtcywgbnVsbCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEZvb3RlciwgbnVsbCkpKTtcbn0pO1xuY29uc3Qge1xuICBDb21wb25lbnQ6IEdyaWQsXG4gIHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDEsXG4gIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDEsXG4gIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMVxufSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW1Ub0NvbXBvbmVudChcbiAgY29tYmluZWRTeXN0ZW0kMSxcbiAge1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICBjb250ZXh0OiBcImNvbnRleHRcIixcbiAgICAgIHRvdGFsQ291bnQ6IFwidG90YWxDb3VudFwiLFxuICAgICAgb3ZlcnNjYW46IFwib3ZlcnNjYW5cIixcbiAgICAgIGl0ZW1Db250ZW50OiBcIml0ZW1Db250ZW50XCIsXG4gICAgICBjb21wb25lbnRzOiBcImNvbXBvbmVudHNcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb246IFwic2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb25cIixcbiAgICAgIGhlYWRlckZvb3RlclRhZzogXCJoZWFkZXJGb290ZXJUYWdcIixcbiAgICAgIGxpc3RDbGFzc05hbWU6IFwibGlzdENsYXNzTmFtZVwiLFxuICAgICAgaXRlbUNsYXNzTmFtZTogXCJpdGVtQ2xhc3NOYW1lXCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCIsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQ6IFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIsXG4gICAgICBzY3JvbGxlclJlZjogXCJzY3JvbGxlclJlZlwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb206IFwicmVzdG9yZVN0YXRlRnJvbVwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIlxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbEJ5OiBcInNjcm9sbEJ5XCIsXG4gICAgICBzY3JvbGxUb0luZGV4OiBcInNjcm9sbFRvSW5kZXhcIlxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICBpc1Njcm9sbGluZzogXCJpc1Njcm9sbGluZ1wiLFxuICAgICAgZW5kUmVhY2hlZDogXCJlbmRSZWFjaGVkXCIsXG4gICAgICBzdGFydFJlYWNoZWQ6IFwic3RhcnRSZWFjaGVkXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlOiBcImF0Qm90dG9tU3RhdGVDaGFuZ2VcIixcbiAgICAgIGF0VG9wU3RhdGVDaGFuZ2U6IFwiYXRUb3BTdGF0ZUNoYW5nZVwiLFxuICAgICAgc3RhdGVDaGFuZ2VkOiBcInN0YXRlQ2hhbmdlZFwiXG4gICAgfVxuICB9LFxuICBHcmlkUm9vdFxuKTtcbmNvbnN0IFNjcm9sbGVyJDEgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDEsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDEsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMSB9KTtcbmNvbnN0IFdpbmRvd1Njcm9sbGVyJDEgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDEsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDEsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMSB9KTtcbmZ1bmN0aW9uIHJlc29sdmVHYXBWYWx1ZShwcm9wZXJ0eSwgdmFsdWUsIGxvZykge1xuICBpZiAodmFsdWUgIT09IFwibm9ybWFsXCIgJiYgISh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuZW5kc1dpdGgoXCJweFwiKSkpIHtcbiAgICBsb2coYCR7cHJvcGVydHl9IHdhcyBub3QgcmVzb2x2ZWQgdG8gcGl4ZWwgdmFsdWUgY29ycmVjdGx5YCwgdmFsdWUsIExvZ0xldmVsLldBUk4pO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJub3JtYWxcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBwYXJzZUludCh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBcIjBcIiwgMTApO1xufVxuY29uc3QgVmlydHVvc29HcmlkID0gR3JpZDtcbmNvbnN0IHRhYmxlQ29tcG9uZW50UHJvcHNTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKCgpID0+IHtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbSgoaW5kZXgpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCwgXCJJdGVtICRcIiwgaW5kZXgpKTtcbiAgY29uc3QgY29udGV4dCA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICBjb25zdCBmaXhlZEhlYWRlckNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgZml4ZWRGb290ZXJDb250ZW50ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBzY3JvbGxlclJlZiA9IHN0YXRlZnVsU3RyZWFtKG5vb3ApO1xuICBjb25zdCBkaXN0aW5jdFByb3AgPSAocHJvcE5hbWUsIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgICByZXR1cm4gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgIG1hcCgoY29tcG9uZW50czIpID0+IGNvbXBvbmVudHMyW3Byb3BOYW1lXSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWVcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQsXG4gICAgaXRlbUNvbnRlbnQsXG4gICAgZml4ZWRIZWFkZXJDb250ZW50LFxuICAgIGZpeGVkRm9vdGVyQ29udGVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGNvbXB1dGVJdGVtS2V5LFxuICAgIHNjcm9sbGVyUmVmLFxuICAgIFRhYmxlQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJUYWJsZVwiLCBcInRhYmxlXCIpLFxuICAgIFRhYmxlSGVhZENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVIZWFkXCIsIFwidGhlYWRcIiksXG4gICAgVGFibGVGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlRhYmxlRm9vdFwiLCBcInRmb290XCIpLFxuICAgIFRhYmxlQm9keUNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVCb2R5XCIsIFwidGJvZHlcIiksXG4gICAgVGFibGVSb3dDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlRhYmxlUm93XCIsIFwidHJcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlNjcm9sbGVyXCIsIFwiZGl2XCIpLFxuICAgIEVtcHR5UGxhY2Vob2xkZXI6IGRpc3RpbmN0UHJvcChcIkVtcHR5UGxhY2Vob2xkZXJcIiksXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBkaXN0aW5jdFByb3AoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIiksXG4gICAgRmlsbGVyUm93OiBkaXN0aW5jdFByb3AoXCJGaWxsZXJSb3dcIilcbiAgfTtcbn0pO1xuY29uc3QgY29tYmluZWRTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKChbbGlzdFN5c3RlbTIsIHByb3BzU3lzdGVtXSkgPT4ge1xuICByZXR1cm4geyAuLi5saXN0U3lzdGVtMiwgLi4ucHJvcHNTeXN0ZW0gfTtcbn0sIHR1cChsaXN0U3lzdGVtLCB0YWJsZUNvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyID0gKHsgaGVpZ2h0IH0pID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHN0eWxlOiB7IGhlaWdodCB9IH0pKTtcbmNvbnN0IERlZmF1bHRGaWxsZXJSb3cgPSAoeyBoZWlnaHQgfSkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgc3R5bGU6IHsgaGVpZ2h0LCBwYWRkaW5nOiAwLCBib3JkZXI6IDAgfSB9KSk7XG5jb25zdCBJVEVNX1NUWUxFID0geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfTtcbmNvbnN0IEl0ZW1zID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29JdGVtczIoKSB7XG4gIGNvbnN0IGxpc3RTdGF0ZSA9IHVzZUVtaXR0ZXJWYWx1ZShcImxpc3RTdGF0ZVwiKTtcbiAgY29uc3Qgc2l6ZVJhbmdlcyA9IHVzZVB1Ymxpc2hlcihcInNpemVSYW5nZXNcIik7XG4gIGNvbnN0IHVzZVdpbmRvd1Njcm9sbCA9IHVzZUVtaXR0ZXJWYWx1ZShcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA6IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrO1xuICBjb25zdCBpdGVtQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcIml0ZW1Db250ZW50XCIpO1xuICBjb25zdCB0cmFja0l0ZW1TaXplcyA9IHVzZUVtaXR0ZXJWYWx1ZShcInRyYWNrSXRlbVNpemVzXCIpO1xuICBjb25zdCBpdGVtU2l6ZSA9IHVzZUVtaXR0ZXJWYWx1ZShcIml0ZW1TaXplXCIpO1xuICBjb25zdCBsb2cgPSB1c2VFbWl0dGVyVmFsdWUoXCJsb2dcIik7XG4gIGNvbnN0IHsgY2FsbGJhY2tSZWYsIHJlZiB9ID0gdXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzKFxuICAgIHNpemVSYW5nZXMsXG4gICAgaXRlbVNpemUsXG4gICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICBsb2csXG4gICAgdm9pZCAwLFxuICAgIGN1c3RvbVNjcm9sbFBhcmVudFxuICApO1xuICBjb25zdCBbZGV2aWF0aW9uLCBzZXREZXZpYXRpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIHVzZUVtaXR0ZXIoXCJkZXZpYXRpb25cIiwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKGRldmlhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHJlZi5jdXJyZW50LnN0eWxlLm1hcmdpblRvcCA9IGAke3ZhbHVlfXB4YDtcbiAgICAgIHNldERldmlhdGlvbih2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgRW1wdHlQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZShcIkVtcHR5UGxhY2Vob2xkZXJcIik7XG4gIGNvbnN0IFNjcm9sbFNlZWtQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSB8fCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyO1xuICBjb25zdCBGaWxsZXJSb3cgPSB1c2VFbWl0dGVyVmFsdWUoXCJGaWxsZXJSb3dcIikgfHwgRGVmYXVsdEZpbGxlclJvdztcbiAgY29uc3QgVGFibGVCb2R5Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiVGFibGVCb2R5Q29tcG9uZW50XCIpO1xuICBjb25zdCBUYWJsZVJvd0NvbXBvbmVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlUm93Q29tcG9uZW50XCIpO1xuICBjb25zdCBjb21wdXRlSXRlbUtleSA9IHVzZUVtaXR0ZXJWYWx1ZShcImNvbXB1dGVJdGVtS2V5XCIpO1xuICBjb25zdCBpc1NlZWtpbmcgPSB1c2VFbWl0dGVyVmFsdWUoXCJpc1NlZWtpbmdcIik7XG4gIGNvbnN0IHBhZGRpbmdUb3BBZGRpdGlvbiA9IHVzZUVtaXR0ZXJWYWx1ZShcInBhZGRpbmdUb3BBZGRpdGlvblwiKTtcbiAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSB1c2VFbWl0dGVyVmFsdWUoXCJmaXJzdEl0ZW1JbmRleFwiKTtcbiAgY29uc3Qgc3RhdGVmdWxUb3RhbENvdW50ID0gdXNlRW1pdHRlclZhbHVlKFwic3RhdGVmdWxUb3RhbENvdW50XCIpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlKFwiY29udGV4dFwiKTtcbiAgaWYgKHN0YXRlZnVsVG90YWxDb3VudCA9PT0gMCAmJiBFbXB0eVBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW1wdHlQbGFjZWhvbGRlciwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoRW1wdHlQbGFjZWhvbGRlciwgY29udGV4dCkpO1xuICB9XG4gIGNvbnN0IHBhZGRpbmdUb3AgPSBsaXN0U3RhdGUub2Zmc2V0VG9wICsgcGFkZGluZ1RvcEFkZGl0aW9uICsgZGV2aWF0aW9uO1xuICBjb25zdCBwYWRkaW5nQm90dG9tID0gbGlzdFN0YXRlLm9mZnNldEJvdHRvbTtcbiAgY29uc3QgcGFkZGluZ1RvcEVsID0gcGFkZGluZ1RvcCA+IDAgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChGaWxsZXJSb3csIHsgaGVpZ2h0OiBwYWRkaW5nVG9wLCBrZXk6IFwicGFkZGluZy10b3BcIiwgY29udGV4dCB9KSA6IG51bGw7XG4gIGNvbnN0IHBhZGRpbmdCb3R0b21FbCA9IHBhZGRpbmdCb3R0b20gPiAwID8gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmlsbGVyUm93LCB7IGhlaWdodDogcGFkZGluZ0JvdHRvbSwga2V5OiBcInBhZGRpbmctYm90dG9tXCIsIGNvbnRleHQgfSkgOiBudWxsO1xuICBjb25zdCBpdGVtcyA9IGxpc3RTdGF0ZS5pdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGl0ZW0ub3JpZ2luYWxJbmRleDtcbiAgICBjb25zdCBrZXkgPSBjb21wdXRlSXRlbUtleShpbmRleCArIGZpcnN0SXRlbUluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpO1xuICAgIGlmIChpc1NlZWtpbmcpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwge1xuICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChTY3JvbGxTZWVrUGxhY2Vob2xkZXIsIGNvbnRleHQpLFxuICAgICAgICBrZXksXG4gICAgICAgIGluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgICBoZWlnaHQ6IGl0ZW0uc2l6ZSxcbiAgICAgICAgdHlwZTogaXRlbS50eXBlIHx8IFwiaXRlbVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBUYWJsZVJvd0NvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGFibGVSb3dDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAuLi5pdGVtUHJvcElmTm90RG9tRWxlbWVudChUYWJsZVJvd0NvbXBvbmVudCwgaXRlbS5kYXRhKSxcbiAgICAgICAga2V5LFxuICAgICAgICBcImRhdGEtaW5kZXhcIjogaW5kZXgsXG4gICAgICAgIFwiZGF0YS1rbm93bi1zaXplXCI6IGl0ZW0uc2l6ZSxcbiAgICAgICAgXCJkYXRhLWl0ZW0taW5kZXhcIjogaXRlbS5pbmRleCxcbiAgICAgICAgc3R5bGU6IElURU1fU1RZTEVcbiAgICAgIH0sXG4gICAgICBpdGVtQ29udGVudChpdGVtLmluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFRhYmxlQm9keUNvbXBvbmVudCxcbiAgICB7IHJlZjogY2FsbGJhY2tSZWYsIFwiZGF0YS10ZXN0LWlkXCI6IFwidmlydHVvc28taXRlbS1saXN0XCIsIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFRhYmxlQm9keUNvbXBvbmVudCwgY29udGV4dCkgfSxcbiAgICBbcGFkZGluZ1RvcEVsLCAuLi5pdGVtcywgcGFkZGluZ0JvdHRvbUVsXVxuICApO1xufSk7XG5jb25zdCBWaWV3cG9ydCA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgY3R4ID0gUmVhY3QudXNlQ29udGV4dChWaXJ0dW9zb01vY2tDb250ZXh0KTtcbiAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB1c2VQdWJsaXNoZXIoXCJ2aWV3cG9ydEhlaWdodFwiKTtcbiAgY29uc3QgZml4ZWRJdGVtSGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVNpemUoY29tcG9zZSh2aWV3cG9ydEhlaWdodCwgKGVsKSA9PiBjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgdmlld3BvcnRIZWlnaHQoY3R4LnZpZXdwb3J0SGVpZ2h0KTtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgfVxuICB9LCBbY3R4LCB2aWV3cG9ydEhlaWdodCwgZml4ZWRJdGVtSGVpZ2h0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB2aWV3cG9ydFN0eWxlLCByZWY6IHZpZXdwb3J0UmVmLCBcImRhdGEtdmlld3BvcnQtdHlwZVwiOiBcImVsZW1lbnRcIiB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgV2luZG93Vmlld3BvcnQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29Nb2NrQ29udGV4dCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHVzZVB1Ymxpc2hlcihcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKTtcbiAgY29uc3QgZml4ZWRJdGVtSGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlV2luZG93Vmlld3BvcnRSZWN0UmVmKHdpbmRvd1ZpZXdwb3J0UmVjdCwgY3VzdG9tU2Nyb2xsUGFyZW50KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBmaXhlZEl0ZW1IZWlnaHQoY3R4Lml0ZW1IZWlnaHQpO1xuICAgICAgd2luZG93Vmlld3BvcnRSZWN0KHsgb2Zmc2V0VG9wOiAwLCB2aXNpYmxlSGVpZ2h0OiBjdHgudmlld3BvcnRIZWlnaHQsIHZpc2libGVXaWR0aDogMTAwIH0pO1xuICAgIH1cbiAgfSwgW2N0eCwgd2luZG93Vmlld3BvcnRSZWN0LCBmaXhlZEl0ZW1IZWlnaHRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB2aWV3cG9ydFJlZiwgc3R5bGU6IHZpZXdwb3J0U3R5bGUsIFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwid2luZG93XCIgfSwgY2hpbGRyZW4pO1xufTtcbmNvbnN0IFRhYmxlUm9vdCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIFRhYmxlVmlydHVvc29Sb290KHByb3BzKSB7XG4gIGNvbnN0IHVzZVdpbmRvd1Njcm9sbCA9IHVzZUVtaXR0ZXJWYWx1ZShcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCBmaXhlZEhlYWRlckhlaWdodCA9IHVzZVB1Ymxpc2hlcihcImZpeGVkSGVhZGVySGVpZ2h0XCIpO1xuICBjb25zdCBmaXhlZEZvb3RlckhlaWdodCA9IHVzZVB1Ymxpc2hlcihcImZpeGVkRm9vdGVySGVpZ2h0XCIpO1xuICBjb25zdCBmaXhlZEhlYWRlckNvbnRlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJmaXhlZEhlYWRlckNvbnRlbnRcIik7XG4gIGNvbnN0IGZpeGVkRm9vdGVyQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcImZpeGVkRm9vdGVyQ29udGVudFwiKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZShcImNvbnRleHRcIik7XG4gIGNvbnN0IHRoZWFkUmVmID0gdXNlU2l6ZShjb21wb3NlKGZpeGVkSGVhZGVySGVpZ2h0LCAoZWwpID0+IGNvcnJlY3RJdGVtU2l6ZShlbCwgXCJoZWlnaHRcIikpKTtcbiAgY29uc3QgdGZvb3RSZWYgPSB1c2VTaXplKGNvbXBvc2UoZml4ZWRGb290ZXJIZWlnaHQsIChlbCkgPT4gY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSkpO1xuICBjb25zdCBUaGVTY3JvbGxlciA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dTY3JvbGxlciA6IFNjcm9sbGVyO1xuICBjb25zdCBUaGVWaWV3cG9ydCA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dWaWV3cG9ydCA6IFZpZXdwb3J0O1xuICBjb25zdCBUaGVUYWJsZSA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlQ29tcG9uZW50XCIpO1xuICBjb25zdCBUaGVUSGVhZCA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlSGVhZENvbXBvbmVudFwiKTtcbiAgY29uc3QgVGhlVEZvb3QgPSB1c2VFbWl0dGVyVmFsdWUoXCJUYWJsZUZvb3RlckNvbXBvbmVudFwiKTtcbiAgY29uc3QgdGhlSGVhZCA9IGZpeGVkSGVhZGVyQ29udGVudCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgVGhlVEhlYWQsXG4gICAge1xuICAgICAga2V5OiBcIlRhYmxlSGVhZFwiLFxuICAgICAgc3R5bGU6IHsgekluZGV4OiAyLCBwb3NpdGlvbjogXCJzdGlja3lcIiwgdG9wOiAwIH0sXG4gICAgICByZWY6IHRoZWFkUmVmLFxuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGhlVEhlYWQsIGNvbnRleHQpXG4gICAgfSxcbiAgICBmaXhlZEhlYWRlckNvbnRlbnQoKVxuICApIDogbnVsbDtcbiAgY29uc3QgdGhlRm9vdCA9IGZpeGVkRm9vdGVyQ29udGVudCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgVGhlVEZvb3QsXG4gICAge1xuICAgICAga2V5OiBcIlRhYmxlRm9vdFwiLFxuICAgICAgc3R5bGU6IHsgekluZGV4OiAxLCBwb3NpdGlvbjogXCJzdGlja3lcIiwgYm90dG9tOiAwIH0sXG4gICAgICByZWY6IHRmb290UmVmLFxuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGhlVEZvb3QsIGNvbnRleHQpXG4gICAgfSxcbiAgICBmaXhlZEZvb3RlckNvbnRlbnQoKVxuICApIDogbnVsbDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFRoZVNjcm9sbGVyLCB7IC4uLnByb3BzIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFRoZVZpZXdwb3J0LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFRoZVRhYmxlLFxuICAgIHsgc3R5bGU6IHsgYm9yZGVyU3BhY2luZzogMCwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFRoZVRhYmxlLCBjb250ZXh0KSB9LFxuICAgIFt0aGVIZWFkLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChJdGVtcywgeyBrZXk6IFwiVGFibGVCb2R5XCIgfSksIHRoZUZvb3RdXG4gICkpKTtcbn0pO1xuY29uc3Qge1xuICBDb21wb25lbnQ6IFRhYmxlLFxuICB1c2VQdWJsaXNoZXIsXG4gIHVzZUVtaXR0ZXJWYWx1ZSxcbiAgdXNlRW1pdHRlclxufSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW1Ub0NvbXBvbmVudChcbiAgY29tYmluZWRTeXN0ZW0sXG4gIHtcbiAgICByZXF1aXJlZDoge30sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb206IFwicmVzdG9yZVN0YXRlRnJvbVwiLFxuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICBmb2xsb3dPdXRwdXQ6IFwiZm9sbG93T3V0cHV0XCIsXG4gICAgICBmaXJzdEl0ZW1JbmRleDogXCJmaXJzdEl0ZW1JbmRleFwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiaXRlbUNvbnRlbnRcIixcbiAgICAgIGZpeGVkSGVhZGVyQ29udGVudDogXCJmaXhlZEhlYWRlckNvbnRlbnRcIixcbiAgICAgIGZpeGVkRm9vdGVyQ29udGVudDogXCJmaXhlZEZvb3RlckNvbnRlbnRcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICB0b3RhbENvdW50OiBcInRvdGFsQ291bnRcIixcbiAgICAgIHRvcEl0ZW1Db3VudDogXCJ0b3BJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBcImluaXRpYWxUb3BNb3N0SXRlbUluZGV4XCIsXG4gICAgICBjb21wb25lbnRzOiBcImNvbXBvbmVudHNcIixcbiAgICAgIGdyb3VwQ291bnRzOiBcImdyb3VwQ291bnRzXCIsXG4gICAgICBhdEJvdHRvbVRocmVzaG9sZDogXCJhdEJvdHRvbVRocmVzaG9sZFwiLFxuICAgICAgYXRUb3BUaHJlc2hvbGQ6IFwiYXRUb3BUaHJlc2hvbGRcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBkZWZhdWx0SXRlbUhlaWdodDogXCJkZWZhdWx0SXRlbUhlaWdodFwiLFxuICAgICAgZml4ZWRJdGVtSGVpZ2h0OiBcImZpeGVkSXRlbUhlaWdodFwiLFxuICAgICAgaXRlbVNpemU6IFwiaXRlbVNpemVcIixcbiAgICAgIHNjcm9sbFNlZWtDb25maWd1cmF0aW9uOiBcInNjcm9sbFNlZWtDb25maWd1cmF0aW9uXCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFNjcm9sbFRvcDogXCJpbml0aWFsU2Nyb2xsVG9wXCIsXG4gICAgICBhbGlnblRvQm90dG9tOiBcImFsaWduVG9Cb3R0b21cIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBsb2dMZXZlbDogXCJsb2dMZXZlbFwiXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzY3JvbGxUb0luZGV4OiBcInNjcm9sbFRvSW5kZXhcIixcbiAgICAgIHNjcm9sbEludG9WaWV3OiBcInNjcm9sbEludG9WaWV3XCIsXG4gICAgICBzY3JvbGxUbzogXCJzY3JvbGxUb1wiLFxuICAgICAgc2Nyb2xsQnk6IFwic2Nyb2xsQnlcIixcbiAgICAgIGdldFN0YXRlOiBcImdldFN0YXRlXCJcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgaXNTY3JvbGxpbmc6IFwiaXNTY3JvbGxpbmdcIixcbiAgICAgIGVuZFJlYWNoZWQ6IFwiZW5kUmVhY2hlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiBcInJhbmdlQ2hhbmdlZFwiLFxuICAgICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogXCJhdEJvdHRvbVN0YXRlQ2hhbmdlXCIsXG4gICAgICBhdFRvcFN0YXRlQ2hhbmdlOiBcImF0VG9wU3RhdGVDaGFuZ2VcIixcbiAgICAgIHRvdGFsTGlzdEhlaWdodENoYW5nZWQ6IFwidG90YWxMaXN0SGVpZ2h0Q2hhbmdlZFwiLFxuICAgICAgaXRlbXNSZW5kZXJlZDogXCJpdGVtc1JlbmRlcmVkXCIsXG4gICAgICBncm91cEluZGljZXM6IFwiZ3JvdXBJbmRpY2VzXCJcbiAgICB9XG4gIH0sXG4gIFRhYmxlUm9vdFxuKTtcbmNvbnN0IFNjcm9sbGVyID0gLyogQF9fUFVSRV9fICovIGJ1aWxkU2Nyb2xsZXIoeyB1c2VQdWJsaXNoZXIsIHVzZUVtaXR0ZXJWYWx1ZSwgdXNlRW1pdHRlciB9KTtcbmNvbnN0IFdpbmRvd1Njcm9sbGVyID0gLyogQF9fUFVSRV9fICovIGJ1aWxkV2luZG93U2Nyb2xsZXIoeyB1c2VQdWJsaXNoZXIsIHVzZUVtaXR0ZXJWYWx1ZSwgdXNlRW1pdHRlciB9KTtcbmNvbnN0IFRhYmxlVmlydHVvc28gPSBUYWJsZTtcbmV4cG9ydCB7XG4gIEdyb3VwZWRWaXJ0dW9zbyxcbiAgTG9nTGV2ZWwsXG4gIFRhYmxlVmlydHVvc28sXG4gIFZpcnR1b3NvLFxuICBWaXJ0dW9zb0dyaWQsXG4gIFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0LFxuICBWaXJ0dW9zb01vY2tDb250ZXh0XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUmVhY3RET00iLCJQVUJMSVNIIiwiU1VCU0NSSUJFIiwiUkVTRVQiLCJWQUxVRSIsImNvbXBvc2UiLCJhIiwiYiIsImFyZyIsInRocnVzaCIsInByb2MiLCJjdXJyeTJ0bzEiLCJhcmcxIiwiYXJnMiIsImN1cnJ5MXRvMCIsInRhcCIsInR1cCIsImFyZ3MiLCJjYWxsIiwiYWx3YXlzIiwidmFsdWUiLCJqb2luUHJvYyIsInByb2NzIiwibWFwIiwiaXNEZWZpbmVkIiwibm9vcCIsInN1YnNjcmliZSIsImVtaXR0ZXIiLCJzdWJzY3JpcHRpb24iLCJwdWJsaXNoIiwicHVibGlzaGVyIiwicmVzZXQiLCJnZXRWYWx1ZSIsImRlcG90IiwiY29ubmVjdCIsImhhbmRsZU5leHQiLCJ1bnN1YiIsInN0cmVhbSIsInN1YnNjcmlwdGlvbnMiLCJhY3Rpb24iLCJzcGxpY2UiLCJsZW5ndGgiLCJwdXNoIiwiaW5kZXhPZiIsInNsaWNlIiwiZm9yRWFjaCIsIkVycm9yIiwic3RhdGVmdWxTdHJlYW0iLCJpbml0aWFsIiwiaW5uZXJTdWJqZWN0IiwiZXZlbnRIYW5kbGVyIiwiY3VycmVudFN1YnNjcmlwdGlvbiIsImNsZWFudXAiLCJzdHJlYW1Gcm9tRW1pdHRlciIsInN0cmVhbTIiLCJzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyIiwiY29tYmluZU9wZXJhdG9ycyIsIm9wZXJhdG9ycyIsInN1YnNjcmliZXIiLCJyZWR1Y2VSaWdodCIsInBpcGUiLCJzb3VyY2UiLCJwcm9qZWN0IiwiZGVmYXVsdENvbXBhcmF0b3IiLCJwcmV2aW91cyIsIm5leHQiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsImNvbXBhcmF0b3IiLCJjdXJyZW50IiwiZG9uZSIsImZpbHRlciIsInByZWRpY2F0ZSIsIm1hcFRvIiwic2NhbiIsInNjYW5uZXIiLCJza2lwIiwidGltZXMiLCJ0aHJvdHRsZVRpbWUiLCJpbnRlcnZhbCIsImN1cnJlbnRWYWx1ZSIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZGVib3VuY2VUaW1lIiwiY2xlYXJUaW1lb3V0Iiwid2l0aExhdGVzdEZyb20iLCJzb3VyY2VzIiwidmFsdWVzIiwiQXJyYXkiLCJjYWxsZWQiLCJwZW5kaW5nQ2FsbCIsImFsbENhbGxlZCIsIk1hdGgiLCJwb3ciLCJpbmRleCIsImJpdCIsInByZXZDYWxsZWQiLCJjYWxsMiIsImNvbmNhdCIsIm1lcmdlIiwiZHVjIiwiY29tYmluZUxhdGVzdCIsImVtaXR0ZXJzIiwic3lzdGVtIiwiY29uc3RydWN0b3IiLCJkZXBlbmRlbmNpZXMiLCJzaW5nbGV0b24iLCJpZCIsIlN5bWJvbCIsImluaXQiLCJzeXN0ZW1TcGVjIiwic2luZ2xldG9ucyIsIk1hcCIsIl9pbml0IiwiaWQyIiwiaGFzIiwiZ2V0Iiwic3lzdGVtMiIsImUiLCJzZXQiLCJvbWl0Iiwia2V5cyIsIm9iaiIsInJlc3VsdCIsImlkeCIsImxlbiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMiIsImRvY3VtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0Iiwic3lzdGVtVG9Db21wb25lbnQiLCJtYXAyIiwiUm9vdCIsInJlcXVpcmVkUHJvcE5hbWVzIiwiT2JqZWN0IiwicmVxdWlyZWQiLCJvcHRpb25hbFByb3BOYW1lcyIsIm9wdGlvbmFsIiwibWV0aG9kTmFtZXMiLCJtZXRob2RzIiwiZXZlbnROYW1lcyIsImV2ZW50cyIsIkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiYXBwbHlQcm9wc1RvU3lzdGVtIiwicHJvcHMiLCJyZXF1aXJlZFByb3BOYW1lIiwib3B0aW9uYWxQcm9wTmFtZSIsImJ1aWxkTWV0aG9kcyIsInJlZHVjZSIsImFjYyIsIm1ldGhvZE5hbWUiLCJidWlsZEV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsImV2ZW50TmFtZSIsIkNvbXBvbmVudCIsImZvcndhcmRSZWYiLCJwcm9wc1dpdGhDaGlsZHJlbiIsInJlZiIsImNoaWxkcmVuIiwidXNlU3RhdGUiLCJzeXN0ZW0yMiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VQdWJsaXNoZXIyIiwia2V5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRW1pdHRlclZhbHVlMiIsInNldFZhbHVlIiwidXNlRW1pdHRlcjIiLCJjYWxsYmFjayIsImNvbnRleHQiLCJ1c2VQdWJsaXNoZXIiLCJ1c2VFbWl0dGVyVmFsdWUiLCJ1c2VFbWl0dGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMSIsIkxvZ0xldmVsIiwiTG9nTGV2ZWwyIiwiQ09OU09MRV9NRVRIT0RfTUFQIiwiZ2V0R2xvYmFsVGhpcyIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJsb2dnZXJTeXN0ZW0iLCJsb2dMZXZlbCIsImxvZyIsImxhYmVsIiwibWVzc2FnZSIsImxldmVsIiwiX2EiLCJjdXJyZW50TGV2ZWwiLCJjb25zb2xlIiwidXNlU2l6ZVdpdGhFbFJlZiIsImVuYWJsZWQiLCJ1c2VSZWYiLCJjYWxsYmFja1JlZiIsIl9lbCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZXIiLCJ1c2VNZW1vIiwiZW50cmllcyIsImVsZW1lbnQiLCJ0YXJnZXQiLCJvZmZzZXRQYXJlbnQiLCJlbFJlZiIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJ1c2VTaXplIiwidXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzIiwiaXRlbVNpemUiLCJzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrIiwiZ2FwIiwiY3VzdG9tU2Nyb2xsUGFyZW50IiwibWVtb2VkQ2FsbGJhY2siLCJlbCIsInJhbmdlcyIsImdldENoYW5nZWRDaGlsZFNpemVzIiwic2Nyb2xsYWJsZUVsZW1lbnQiLCJwYXJlbnRFbGVtZW50IiwiZGF0YXNldCIsIndpbmRvd1Njcm9sbGluZyIsImxhc3RFbGVtZW50Q2hpbGQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbEhlaWdodCIsInZpZXdwb3J0SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJtYXgiLCJyZXNvbHZlR2FwVmFsdWUkMSIsImdldENvbXB1dGVkU3R5bGUiLCJyb3dHYXAiLCJmaWVsZCIsInJlc3VsdHMiLCJpIiwiY2hpbGQiLCJpdGVtIiwicGFyc2VJbnQiLCJrbm93blNpemUiLCJwYXJzZUZsb2F0Iiwic2l6ZSIsIkVSUk9SIiwibGFzdFJlc3VsdCIsImVuZEluZGV4Iiwic3RhcnRJbmRleCIsInByb3BlcnR5IiwiZW5kc1dpdGgiLCJXQVJOIiwiY29ycmVjdEl0ZW1TaXplIiwiZGltZW5zaW9uIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJhcHByb3hpbWF0ZWx5RXF1YWwiLCJudW0xIiwibnVtMiIsImFicyIsInVzZVNjcm9sbFRvcCIsInNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQiLCJzY3JvbGxlckVsZW1lbnQiLCJzY3JvbGxlclJlZkNhbGxiYWNrIiwic2Nyb2xsZXJSZWYiLCJzY3JvbGxUb3BUYXJnZXQiLCJ0aW1lb3V0UmVmIiwiaGFuZGxlciIsImV2Iiwid2luZG93U2Nyb2xsIiwic3VwcHJlc3NGbHVzaFN5bmMiLCJmbHVzaFN5bmMiLCJsb2NhbFJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNjcm9sbFRvQ2FsbGJhY2siLCJsb2NhdGlvbiIsInNjcm9sbGVyRWxlbWVudDIiLCJpc1Ntb290aCIsImJlaGF2aW9yIiwibWF4U2Nyb2xsVG9wIiwidG9wIiwiY2VpbCIsIm1pbiIsInNjcm9sbFRvIiwic2Nyb2xsQnlDYWxsYmFjayIsInNjcm9sbEJ5IiwiZG9tSU9TeXN0ZW0iLCJzY3JvbGxDb250YWluZXJTdGF0ZSIsImRldmlhdGlvbiIsInN0YXRlZnVsU2Nyb2xsVG9wIiwiaGVhZGVySGVpZ2h0IiwiZml4ZWRIZWFkZXJIZWlnaHQiLCJmaXhlZEZvb3RlckhlaWdodCIsImZvb3RlckhlaWdodCIsInNjcm9sbGluZ0luUHJvZ3Jlc3MiLCJzY3JvbGxUb3AyIiwic2Nyb2xsSGVpZ2h0MiIsIk5JTF9OT0RFIiwibHZsIiwibmV3QUFOb2RlIiwiayIsInYiLCJsIiwiciIsImVtcHR5Iiwibm9kZSIsIm5ld1RyZWUiLCJyZW1vdmUiLCJsYXN0S2V5IiwibGFzdFZhbHVlIiwibGFzdCIsImFkanVzdCIsImNsb25lIiwiZGVsZXRlTGFzdCIsImZpbmQiLCJmaW5kTWF4S2V5VmFsdWUiLCJJbmZpbml0eSIsIk51bWJlciIsImluc2VydCIsInJlYmFsYW5jZSIsIndhbGtXaXRoaW4iLCJzdGFydCIsImVuZCIsIndhbGsiLCJpc1NpbmdsZSIsInNwbGl0Iiwic2tldyIsInJsIiwicmx2bCIsInJhbmdlc1dpdGhpbiIsImFkanVzdGVkU3RhcnQiLCJ0b1JhbmdlcyIsImFycmF5VG9SYW5nZXMiLCJpdGVtcyIsInBhcnNlciIsIm5leHRJbmRleCIsIm5leHRWYWx1ZSIsIm5vZGVzIiwiZmluZEluZGV4T2ZDbG9zZXN0U21hbGxlck9yRXF1YWwiLCJmbG9vciIsIm1hdGNoIiwiam9pbiIsImZpbmRDbG9zZXN0U21hbGxlck9yRXF1YWwiLCJmaW5kUmFuZ2UiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJyZWNhbGNTeXN0ZW0iLCJyZWNhbGNJblByb2dyZXNzIiwicmFuZ2VJbmNsdWRlcyIsInJlZlJhbmdlIiwicmFuZ2UiLCJhZmZlY3RlZEdyb3VwQ291bnQiLCJvZmZzZXQiLCJncm91cEluZGljZXMiLCJyZWNvZ25pemVkT2Zmc2V0SXRlbXMiLCJncm91cEluZGV4Iiwib2Zmc2V0SXNFeGFjdCIsImluc2VydFJhbmdlcyIsInNpemVUcmVlIiwic3luY1N0YXJ0Iiwib3ZlcmxhcHBpbmdSYW5nZXMiLCJzb21lIiwiZmlyc3RQYXNzRG9uZSIsInNob3VsZEluc2VydCIsInJhbmdlU3RhcnQiLCJyYW5nZUVuZCIsInJhbmdlVmFsdWUiLCJpbml0aWFsU2l6ZVN0YXRlIiwib2Zmc2V0VHJlZSIsImdyb3VwT2Zmc2V0VHJlZSIsImxhc3RJbmRleCIsImxhc3RPZmZzZXQiLCJsYXN0U2l6ZSIsImluZGV4Q29tcGFyYXRvciIsIml0ZW1JbmRleCIsIm9mZnNldENvbXBhcmF0b3IiLCJpdGVtT2Zmc2V0Iiwib2Zmc2V0UG9pbnRQYXJzZXIiLCJwb2ludCIsInJhbmdlc1dpdGhpbk9mZnNldHMiLCJ0cmVlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJtaW5TdGFydEluZGV4IiwiY3JlYXRlT2Zmc2V0VHJlZSIsInByZXZPZmZzZXRUcmVlIiwicHJldkluZGV4IiwicHJldlNpemUiLCJwcmV2T2Zmc2V0Iiwib2Zmc2V0SW5mbyIsImt2Iiwic3RhcnRJbmRleDIiLCJpbmRleE9mZnNldCIsImFPZmZzZXQiLCJzaXplU3RhdGVSZWR1Y2VyIiwic3RhdGUiLCJERUJVRyIsIm5ld1NpemVUcmVlIiwiZ3JvdXBTaXplIiwibmV3T2Zmc2V0VHJlZSIsIm9mZnNldE9mIiwiaXRlbUNvdW50IiwiaXNHcm91cExvY2F0aW9uIiwib3JpZ2luYWxJbmRleEZyb21Mb2NhdGlvbiIsInNpemVzIiwibnVtZXJpY0luZGV4Iiwib3JpZ2luYWxJbmRleEZyb21JdGVtSW5kZXgiLCJoYXNHcm91cHMiLCJncm91cE9mZnNldCIsInNpemVUcmVlVG9SYW5nZXMiLCJzaXplQXJyYXkiLCJuZXh0U2l6ZSIsIlNJWkVfTUFQIiwib2Zmc2V0V2lkdGgiLCJzaXplU3lzdGVtIiwic2l6ZVJhbmdlcyIsInRvdGFsQ291bnQiLCJzdGF0ZWZ1bFRvdGFsQ291bnQiLCJ1bnNoaWZ0V2l0aCIsInNoaWZ0V2l0aCIsImZpcnN0SXRlbUluZGV4IiwiZml4ZWRJdGVtU2l6ZSIsImRlZmF1bHRJdGVtU2l6ZSIsImRhdGEiLCJwcmV2R3JvdXBJbmRpY2VzIiwicHJldiIsImN1cnIiLCJpbmRleGVzIiwiZ3JvdXBJbmRpY2VzMiIsInNpemVzMiIsImdhcDIiLCJ0b3RhbENvdW50MiIsInRyYWNrSXRlbVNpemVzIiwibGlzdFJlZnJlc2giLCJvbGRTaXplcyIsIl8iLCJuZXdTaXplcyIsImNoYW5nZWQiLCJkaWZmIiwidmFsIiwicHJldkdyb3VwSW5kaWNlc1ZhbHVlIiwibG9nMiIsImJlZm9yZVVuc2hpZnRXaXRoIiwidW5zaGlmdFdpdGgyIiwiZ3JvdXBlZE1vZGUiLCJpbml0aWFsUmFuZ2VzIiwiZGVmYXVsdFNpemUiLCJmaXJzdEdyb3VwU2l6ZSIsInByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCIsInRoZUdyb3VwSW5kZXgiLCJncm91cEl0ZW1Db3VudCIsInNpemVUcmVlS1YiLCJmaXJzdEdyb3VwSXNFeHBhbmRlZCIsInNoaWZ0Iiwic2hpZnRXaXRoT2Zmc2V0Iiwic2hpZnRXaXRoMiIsIm5ld0ZpcnN0SXRlbUluZGV4IiwicmVtb3ZlZEl0ZW1zQ291bnQiLCJhR3JvdXBJc1NocnVuayIsIm5leHRJdGVtU2l6ZSIsIlNVUFBPUlRTX1NDUk9MTF9UT19PUFRJT05TIiwic3R5bGUiLCJub3JtYWxpemVJbmRleExvY2F0aW9uIiwiYWxpZ24iLCJzY3JvbGxUb0luZGV4U3lzdGVtIiwic2Nyb2xsVG9JbmRleCIsInRvcExpc3RIZWlnaHQiLCJ1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCIsImNsZWFydFRpbWVvdXRSZWYiLCJ1bnN1YnNjcmliZUxpc3RSZWZyZXNoIiwidmlld3BvcnRIZWlnaHQyIiwidG9wTGlzdEhlaWdodDIiLCJoZWFkZXJIZWlnaHQyIiwiZm9vdGVySGVpZ2h0MiIsImZpeGVkSGVhZGVySGVpZ2h0MiIsImZpeGVkRm9vdGVySGVpZ2h0MiIsIm5vcm1hbExvY2F0aW9uIiwicmV0cnkiLCJsaXN0Q2hhbmdlZCIsIndhdGNoQ2hhbmdlc0ZvciIsImxpbWl0IiwiVVAiLCJET1dOIiwiTk9ORSQxIiwiSU5JVElBTF9CT1RUT01fU1RBVEUiLCJhdEJvdHRvbSIsIm5vdEF0Qm90dG9tQmVjYXVzZSIsIm9mZnNldEJvdHRvbSIsIkRFRkFVTFRfQVRfVE9QX1RIUkVTSE9MRCIsInN0YXRlRmxhZ3NTeXN0ZW0iLCJpc0F0Qm90dG9tIiwiaXNBdFRvcCIsImF0Qm90dG9tU3RhdGVDaGFuZ2UiLCJhdFRvcFN0YXRlQ2hhbmdlIiwiYXRCb3R0b21UaHJlc2hvbGQiLCJhdFRvcFRocmVzaG9sZCIsImlzU2Nyb2xsaW5nIiwiaXNTY3JvbGxpbmdCeSIsImF0VG9wVGhyZXNob2xkMiIsImF0Qm90dG9tU3RhdGUiLCJfaGVhZGVySGVpZ2h0IiwiX2Zvb3RlckhlaWdodCIsImF0Qm90dG9tVGhyZXNob2xkMiIsImlzQXRCb3R0b20yIiwiYXRCb3R0b21CZWNhdXNlIiwic2Nyb2xsVG9wRGVsdGEiLCJsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZSIsImp1bXAiLCJzY3JvbGxEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJwcmV2U2Nyb2xsVG9wIiwic2Nyb2xsVmVsb2NpdHkiLCJpc1Njcm9sbGluZzIiLCJwcm9wc1JlYWR5U3lzdGVtIiwicHJvcHNSZWFkeSIsImRpZE1vdW50IiwicmVhZHkiLCJza2lwRnJhbWVzIiwiZnJhbWVDb3VudCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldEluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyIiwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0iLCJzY3JvbGxlZFRvSW5pdGlhbEl0ZW0iLCJpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCIsInNjcm9sbFNjaGVkdWxlZCIsImRpZE1vdW50MiIsInNjcm9sbGVkVG9Jbml0aWFsSXRlbTIiLCJkZWZhdWx0SXRlbVNpemUyIiwic2Nyb2xsU2NoZWR1bGVkMiIsImluaXRpYWxUb3BNb3N0SXRlbUluZGV4MiIsIm5vcm1hbGl6ZUZvbGxvd091dHB1dCIsImZvbGxvdyIsImJlaGF2aW9yRnJvbUZvbGxvd091dHB1dCIsImZvbGxvd091dHB1dFN5c3RlbSIsImZvbGxvd091dHB1dCIsImF1dG9zY3JvbGxUb0JvdHRvbSIsInBlbmRpbmdTY3JvbGxIYW5kbGUiLCJzY3JvbGxUb0JvdHRvbSIsImZvbGxvd091dHB1dEJlaGF2aW9yIiwiZm9sbG93T3V0cHV0MiIsInNjcm9sbGluZ0luUHJvZ3Jlc3MyIiwic2hvdWxkRm9sbG93IiwidHJhcE5leHRTaXplSW5jcmVhc2UiLCJjYW5jZWwiLCJyZWZyZXNoZWQiLCJncm91cENvdW50c1RvSW5kaWNlc0FuZENvdW50IiwiY291bnRzIiwiZ3JvdXBDb3VudCIsImdyb3VwZWRMaXN0U3lzdGVtIiwiZ3JvdXBDb3VudHMiLCJ0b3BJdGVtc0luZGV4ZXMiLCJncm91cEluZGljZXNBbmRDb3VudCIsInR1cGxlQ29tcGFyYXRvciIsInJhbmdlQ29tcGFyYXRvciIsIlRPUCIsIkJPVFRPTSIsIk5PTkUiLCJnZXRPdmVyc2NhbiIsIm92ZXJzY2FuIiwibWFpbiIsInJldmVyc2UiLCJnZXRWaWV3cG9ydEluY3JlYXNlIiwic2l6ZVJhbmdlU3lzdGVtIiwibGlzdEJvdW5kYXJ5IiwiaW5jcmVhc2VWaWV3cG9ydEJ5IiwidmlzaWJsZVJhbmdlIiwibGlzdFRvcCIsImxpc3RCb3R0b20iLCJvdmVyc2NhbjIiLCJkZXZpYXRpb24yIiwiaW5jcmVhc2VWaWV3cG9ydEJ5MiIsInN0aWNreUhlYWRlckhlaWdodCIsImhlYWRlclZpc2libGUiLCJ0b3BWaWV3cG9ydEFkZGl0aW9uIiwiYm90dG9tVmlld3BvcnRBZGRpdGlvbiIsInByb2JlSXRlbVNldCIsIkVNUFRZX0xJU1RfU1RBVEUiLCJ0b3BJdGVtcyIsIm9mZnNldFRvcCIsImJvdHRvbSIsInRyYW5zcG9zZUl0ZW1zIiwib3JpZ2luYWxJbmRleCIsInRyYW5zcG9zZWRJdGVtcyIsImdyb3VwUmFuZ2VzIiwiY3VycmVudFJhbmdlIiwiY3VycmVudEdyb3VwSW5kZXgiLCJ0cmFuc3Bvc2VkSXRlbSIsInR5cGUiLCJidWlsZExpc3RTdGF0ZSIsImxhc3RJdGVtIiwidG90YWwiLCJoZWlnaHQiLCJidWlsZExpc3RTdGF0ZUZyb21JdGVtQ291bnQiLCJpbmNsdWRlZEdyb3Vwc0NvdW50IiwiYWRqdXN0ZWRDb3VudCIsImluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyIiwiZnJvbSIsImxpc3RTdGF0ZVN5c3RlbSIsImdyb3VwZWRMaXN0U3lzdGVtMiIsInJhbmdlVG9wTGlzdEhlaWdodCIsInN0YXRlRmxhZ3MiLCJpbml0aWFsSXRlbUNvdW50IiwiaXRlbXNSZW5kZXJlZCIsImxpc3RTdGF0ZSIsIm1vdW50IiwicmVjYWxjSW5Qcm9ncmVzczIiLCJkYXRhMiIsImRhdGFDaGFuZ2VJblByb2dyZXNzIiwidG9wSXRlbXNJbmRleGVzMiIsImZpcnN0SXRlbUluZGV4MiIsInNpemVzVmFsdWUiLCJpbml0aWFsSXRlbUNvdW50VmFsdWUiLCJyYW5nZVN0YXJ0SW5kZXgiLCJyYW5nZUVuZEluZGV4Iiwib2Zmc2V0UG9pbnRSYW5nZXMiLCJtYXhJbmRleCIsImVuZFJlYWNoZWQiLCJjb3VudCIsInN0YXJ0UmVhY2hlZCIsInJhbmdlQ2hhbmdlZCIsImluaXRpYWxJdGVtQ291bnRTeXN0ZW0iLCJpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFZhbHVlIiwic2Nyb2xsU2Vla1N5c3RlbSIsImlzU2Vla2luZyIsInNjcm9sbFNlZWtDb25maWd1cmF0aW9uIiwiY29uZmlnIiwic3BlZWQiLCJpc1NlZWtpbmcyIiwiZXhpdCIsImVudGVyIiwidmVsb2NpdHkiLCJjaGFuZ2UiLCJzY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkIiwidG9wSXRlbUNvdW50U3lzdGVtIiwidG9wSXRlbUNvdW50IiwidG90YWxMaXN0SGVpZ2h0U3lzdGVtIiwidG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCIsInRvdGFsTGlzdEhlaWdodCIsImxpc3RTdGF0ZTIiLCJzaW1wbGVNZW1vaXplIiwiZnVuYyIsImlzTW9iaWxlU2FmYXJpIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVwd2FyZFNjcm9sbEZpeFN5c3RlbSIsImRldmlhdGlvbk9mZnNldCIsInByZXZJdGVtcyIsInByZXZUb3RhbENvdW50IiwicHJldlRvdGFsSGVpZ2h0IiwibGFzdEp1bXBEdWVUb0l0ZW1SZXNpemUyIiwidG90YWxIZWlnaHQiLCJuZXdEZXYiLCJhdFN0YXJ0IiwiYW1vdW50Iiwic2Nyb2xsRGlyZWN0aW9uMiIsInNjcm9sbEJ5V2l0aCIsImRldmlhdGlvbkFtb3VudCIsImlzIiwicmVjYWxjIiwiZ2V0SXRlbU9mZnNldCIsImRlZmF1bHRHcm91cFNpemUiLCJpbml0aWFsU2Nyb2xsVG9wU3lzdGVtIiwiaW5pdGlhbFNjcm9sbFRvcCIsImFsaWduVG9Cb3R0b21TeXN0ZW0iLCJhbGlnblRvQm90dG9tIiwicGFkZGluZ1RvcEFkZGl0aW9uIiwidG90YWxMaXN0SGVpZ2h0MiIsIndpbmRvd1Njcm9sbGVyU3lzdGVtIiwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUiLCJ3aW5kb3dWaWV3cG9ydFJlY3QiLCJ3aW5kb3dTY3JvbGxUbyIsInVzZVdpbmRvd1Njcm9sbCIsIndpbmRvd1Njcm9sbFRvcCIsInNjcm9sbFRvMiIsImRlZmF1bHRDYWxjdWxhdGVWaWV3TG9jYXRpb24iLCJpdGVtVG9wIiwiaXRlbVRvcDIiLCJpdGVtQm90dG9tIiwidmlld3BvcnRUb3AiLCJ2aWV3cG9ydEJvdHRvbSIsImxvY2F0aW9uUGFyYW1zIiwicmVzdCIsInNjcm9sbEludG9WaWV3U3lzdGVtIiwic2Nyb2xsSW50b1ZpZXciLCJ2aWV3TG9jYXRpb24iLCJjYWxjdWxhdGVWaWV3TG9jYXRpb24iLCJhY3R1YWxJbmRleCIsInN0YXRlTG9hZFN5c3RlbSIsImdldFN0YXRlIiwicmVzdG9yZVN0YXRlRnJvbSIsInN0YXRlZnVsV2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUiLCJzdGF0ZWZ1bFdpbmRvd1ZpZXdwb3J0UmVjdCIsInVzZVdpbmRvd1Njcm9sbDIiLCJ3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZTIiLCJ3aW5kb3dWaWV3cG9ydFJlY3QyIiwibG9jYXRpb25Gcm9tU25hcHNob3QiLCJzbmFwc2hvdCIsImZlYXR1cmVHcm91cDFTeXN0ZW0iLCJzaXplUmFuZ2UiLCJzY3JvbGxTZWVrIiwiaW5pdGlhbFNjcm9sbFRvcFN5c3RlbTIiLCJ3aW5kb3dTY3JvbGxlciIsImxvZ2dlciIsImxpc3RTeXN0ZW0iLCJkb21JTyIsInN0YXRlTG9hZCIsImZsYWdzIiwiZmVhdHVyZUdyb3VwMSIsInZpc2libGVIZWlnaHQiLCJmaXhlZEl0ZW1IZWlnaHQiLCJkZWZhdWx0SXRlbUhlaWdodCIsIldFQktJVF9TVElDS1kiLCJTVElDS1kiLCJwb3NpdGlvblN0aWNreUNzc1ZhbHVlIiwicG9zaXRpb24iLCJ1c2VXaW5kb3dWaWV3cG9ydFJlY3RSZWYiLCJ2aWV3cG9ydEluZm8iLCJjYWxjdWxhdGVJbmZvIiwicmVjdCIsInZpc2libGVXaWR0aCIsIndpZHRoIiwiY3VzdG9tU2Nyb2xsUGFyZW50UmVjdCIsImRlbHRhVG9wIiwic2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyIiwiVmlydHVvc29Nb2NrQ29udGV4dCIsIlZpcnR1b3NvR3JpZE1vY2tDb250ZXh0IiwiaWRlbnRpdHkiLCJsaXN0Q29tcG9uZW50UHJvcHNTeXN0ZW0iLCJpdGVtQ29udGVudCIsImdyb3VwQ29udGVudCIsImNvbXBvbmVudHMiLCJjb21wdXRlSXRlbUtleSIsImhlYWRlckZvb3RlclRhZyIsImRpc3RpbmN0UHJvcCIsInByb3BOYW1lIiwiZGVmYXVsdFZhbHVlIiwiY29tcG9uZW50czIiLCJGb290ZXJDb21wb25lbnQiLCJIZWFkZXJDb21wb25lbnQiLCJUb3BJdGVtTGlzdENvbXBvbmVudCIsIkxpc3RDb21wb25lbnQiLCJJdGVtQ29tcG9uZW50IiwiR3JvdXBDb21wb25lbnQiLCJTY3JvbGxlckNvbXBvbmVudCIsIkVtcHR5UGxhY2Vob2xkZXIiLCJTY3JvbGxTZWVrUGxhY2Vob2xkZXIiLCJjb21iaW5lZFN5c3RlbSQyIiwibGlzdFN5c3RlbTIiLCJwcm9wc1N5c3RlbSIsIkRlZmF1bHRTY3JvbGxTZWVrUGxhY2Vob2xkZXIkMSIsIkdST1VQX1NUWUxFIiwiekluZGV4Iiwib3ZlcmZsb3dBbmNob3IiLCJJVEVNX1NUWUxFJDEiLCJJdGVtcyQxIiwibWVtbyIsIlZpcnR1b3NvSXRlbXMiLCJzaG93VG9wTGlzdCIsInVzZUVtaXR0ZXJWYWx1ZSQyIiwidXNlUHVibGlzaGVyJDIiLCJ3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrIiwiX3Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2siLCJsaXN0R2FwIiwic2V0RGV2aWF0aW9uIiwidXNlRW1pdHRlciQyIiwiaGFzR3JvdXBzMiIsImNvbnRhaW5lclN0eWxlIiwiYm94U2l6aW5nIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJtYXJnaW5Ub3AiLCJ2aXNpYmlsaXR5IiwiY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQiLCJpdGVtUHJvcElmTm90RG9tRWxlbWVudCIsInNjcm9sbGVyU3R5bGUiLCJvdXRsaW5lIiwib3ZlcmZsb3dZIiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJ2aWV3cG9ydFN0eWxlIiwidG9wSXRlbUxpc3RTdHlsZSIsIkhlYWRlciQxIiwiVmlydHVvc29IZWFkZXIiLCJIZWFkZXIyIiwiRm9vdGVyJDEiLCJWaXJ0dW9zb0Zvb3RlciIsIkZvb3RlcjIiLCJidWlsZFNjcm9sbGVyIiwiU2Nyb2xsZXIyIiwiVmlydHVvc29TY3JvbGxlciIsInRhYkluZGV4IiwiYnVpbGRXaW5kb3dTY3JvbGxlciIsIlZpcnR1b3NvV2luZG93U2Nyb2xsZXIiLCJWaWV3cG9ydCQyIiwiY3R4Iiwidmlld3BvcnRSZWYiLCJpdGVtSGVpZ2h0IiwiV2luZG93Vmlld3BvcnQkMiIsIlRvcEl0ZW1MaXN0Q29udGFpbmVyIiwiVG9wSXRlbUxpc3QiLCJMaXN0Um9vdCIsIlZpcnR1b3NvUm9vdCIsIlRoZVNjcm9sbGVyIiwiV2luZG93U2Nyb2xsZXIkMiIsIlNjcm9sbGVyJDIiLCJUaGVWaWV3cG9ydCIsIkxpc3QiLCJWaXJ0dW9zbyIsIkdyb3VwZWRWaXJ0dW9zbyIsIklOSVRJQUxfR1JJRF9TVEFURSIsIml0ZW1XaWR0aCIsIlBST0JFX0dSSURfU1RBVEUiLCJidWlsZFByb2JlR3JpZFN0YXRlIiwiYnVpbGRJdGVtcyIsImRhdGFJdGVtIiwiZ2FwQ29tcGFyYXRvciIsImNvbHVtbiIsInJvdyIsImRpbWVuc2lvbkNvbXBhcmF0b3IiLCJncmlkU3lzdGVtIiwiZ3JpZFN0YXRlIiwidmlld3BvcnREaW1lbnNpb25zIiwiaXRlbURpbWVuc2lvbnMiLCJzdGF0ZUNoYW5nZWQiLCJzdGF0ZVJlc3RvcmVJblByb2dyZXNzIiwiaXRlbURpbWVuc2lvbnMyIiwidmlld3BvcnREaW1lbnNpb25zMiIsInZpZXdwb3J0IiwiX3ZhbHVlIiwic3RhdGVSZXN0b3JlSW5Qcm9ncmVzczIiLCJpbml0aWFsSXRlbUNvdW50MiIsImNvbHVtbkdhcCIsInZpZXdwb3J0V2lkdGgiLCJlbmRJbmRleDIiLCJwZXJSb3ciLCJpdGVtc1BlclJvdyIsImdyaWRMYXlvdXQiLCJyb3dDb3VudCIsImhhc1Njcm9sbGVkIiwiaGFzU2Nyb2xsZWQyIiwiZ3JpZFN0YXRlMiIsImdyaWRDb21wb25lbnRQcm9wc1N5c3RlbSIsIml0ZW1DbGFzc05hbWUiLCJsaXN0Q2xhc3NOYW1lIiwiY29tYmluZWRTeXN0ZW0kMSIsImdyaWRTeXN0ZW0yIiwiZ3JpZENvbXBvbmVudFByb3BzU3lzdGVtMiIsIkdyaWRJdGVtcyIsIkdyaWRJdGVtczIiLCJ1c2VFbWl0dGVyVmFsdWUkMSIsInNjcm9sbEhlaWdodENhbGxiYWNrIiwidXNlUHVibGlzaGVyJDEiLCJncmlkR2FwIiwibGlzdFJlZiIsImZpcnN0SXRlbSIsImZpcnN0Q2hpbGQiLCJyZXNvbHZlR2FwVmFsdWUiLCJjbGFzc05hbWUiLCJIZWFkZXIiLCJWaXJ0dW9zb0hlYWRlcjIiLCJGb290ZXIiLCJWaXJ0dW9zb0dyaWRGb290ZXIiLCJWaWV3cG9ydCQxIiwiV2luZG93Vmlld3BvcnQkMSIsIkdyaWRSb290IiwiR3JpZFJvb3QyIiwiV2luZG93U2Nyb2xsZXIkMSIsIlNjcm9sbGVyJDEiLCJHcmlkIiwidXNlRW1pdHRlciQxIiwiVmlydHVvc29HcmlkIiwidGFibGVDb21wb25lbnRQcm9wc1N5c3RlbSIsImZpeGVkSGVhZGVyQ29udGVudCIsImZpeGVkRm9vdGVyQ29udGVudCIsIlRhYmxlQ29tcG9uZW50IiwiVGFibGVIZWFkQ29tcG9uZW50IiwiVGFibGVGb290ZXJDb21wb25lbnQiLCJUYWJsZUJvZHlDb21wb25lbnQiLCJUYWJsZVJvd0NvbXBvbmVudCIsIkZpbGxlclJvdyIsImNvbWJpbmVkU3lzdGVtIiwiRGVmYXVsdFNjcm9sbFNlZWtQbGFjZWhvbGRlciIsIkRlZmF1bHRGaWxsZXJSb3ciLCJwYWRkaW5nIiwiYm9yZGVyIiwiSVRFTV9TVFlMRSIsIkl0ZW1zIiwiVmlydHVvc29JdGVtczIiLCJwYWRkaW5nVG9wRWwiLCJwYWRkaW5nQm90dG9tRWwiLCJWaWV3cG9ydCIsIldpbmRvd1ZpZXdwb3J0IiwiVGFibGVSb290IiwiVGFibGVWaXJ0dW9zb1Jvb3QiLCJ0aGVhZFJlZiIsInRmb290UmVmIiwiV2luZG93U2Nyb2xsZXIiLCJTY3JvbGxlciIsIlRoZVRhYmxlIiwiVGhlVEhlYWQiLCJUaGVURm9vdCIsInRoZUhlYWQiLCJ0aGVGb290IiwiYm9yZGVyU3BhY2luZyIsIlRhYmxlIiwiVGFibGVWaXJ0dW9zbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtuoso/dist/index.mjs\n");

/***/ })

};
;