"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.es.js":
/*!********************************************!*\
  !*** ./node_modules/canvg/lib/index.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   \"default\": () => (/* binding */ Canvg),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n/* harmony import */ var core_js_modules_es_array_reverse_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var { DOMParser: DOMParserFallback } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage (url) {\n            return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n                var response = yield fetch(url);\n                var blob = yield response.blob();\n                var img = yield createImageBitmap(blob);\n                return img;\n            })();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var { DOMParser: DOMParser1, canvas, fetch: fetch1 } = _ref;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nclass Property {\n    constructor(document1, name, value){\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    static empty(document1) {\n        return new Property(document1, \"EMPTY\", \"\");\n    }\n    split() {\n        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n        var { document: document1, name } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document1, name, value));\n    }\n    hasValue(zeroIsValue) {\n        var { value } = this;\n        return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n    }\n    isString(regexp) {\n        var { value } = this;\n        var result = typeof value === \"string\";\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        var asString = this.getString();\n        switch(true){\n            case asString.endsWith(\"px\"):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === \"undefined\") {\n                return 0;\n            }\n            return parseFloat(def);\n        }\n        var { value } = this;\n        var n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100.0;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        var color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96.0; // TODO: compute?\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(axisOrIsFontSize) {\n        var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        var { viewPort } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n            case this.isString(/vh$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2.0;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    var n = this.getNumber();\n                    if (processPercent && n < 1.0) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180.0);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200.0);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180.0);\n        }\n    }\n    getDefinition() {\n        var asString = this.getString();\n        var name = /#([^)'\"]+)/.exec(asString);\n        if (name) {\n            name = name[1];\n        }\n        if (!name) {\n            name = asString;\n        }\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        var def = this.getDefinition();\n        if (!def) {\n            return null;\n        } // gradient\n        if (typeof def.createGradient === \"function\") {\n            return def.createGradient(this.document.ctx, element, opacity);\n        } // pattern\n        if (typeof def.createPattern === \"function\") {\n            if (def.getHrefAttribute().hasValue()) {\n                var patternTransform = def.getAttribute(\"patternTransform\");\n                def = def.getHrefAttribute().getDefinition();\n                if (patternTransform.hasValue()) {\n                    def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                }\n            }\n            return def.createPattern(this.document.ctx, element, opacity);\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        return Property.textBaselineMapping[this.getString()];\n    }\n    addOpacity(opacity) {\n        var value = this.getColor();\n        var len = value.length;\n        var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n        for(var i = 0; i < len; i++){\n            if (value[i] === \",\") {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            var color = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n}\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n    constructor(){\n        this.viewPorts = [];\n    }\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getCurrent() {\n        var { viewPorts } = this;\n        return viewPorts[viewPorts.length - 1];\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === \"number\") {\n            return d;\n        }\n        if (d === \"x\") {\n            return this.width;\n        }\n        if (d === \"y\") {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n}\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    static parse(point) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        var points = toNumbers(path);\n        var len = points.length;\n        var pathPoints = [];\n        for(var i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        var { x, y } = this;\n        var xp = x * transform[0] + y * transform[2] + transform[4];\n        var yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n}\nclass Mouse {\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        var { screen, onClick, onMouseMove } = this;\n        var canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        var canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        var { screen: document1, events, eventElements } = this;\n        var { style } = document1.ctx.canvas;\n        if (style) {\n            style.cursor = \"\";\n        }\n        events.forEach((_ref, i)=>{\n            var { run } = _ref;\n            var element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        }); // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref2, i)=>{\n            var { x, y } = _ref2;\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref3, i)=>{\n            var { x, y } = _ref3;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        var { window: window1, ctx } = this.screen;\n        var point = new Point(x, y);\n        var element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window1.scrollX) {\n            point.x += window1.scrollX;\n        }\n        if (window1.scrollY) {\n            point.y += window1.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onclick\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onmousemove\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n}\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nclass Screen {\n    constructor(ctx){\n        var { fetch: fetch1 = defaultFetch$1, window: window1 = defaultWindow } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        var isReadyLock = this.waits.every((_)=>_());\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 4;\n    }\n    setViewBox(_ref) {\n        var { document: document1, ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX = 0, minY = 0, refX, refY, clip = false, clipX = 0, clipY = 0 } = _ref;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n        var align = aspectRatioAlign || \"xMidYMid\";\n        var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n        var scaleX = width / desiredWidth;\n        var scaleY = height / desiredHeight;\n        var scaleMin = Math.min(scaleX, scaleY);\n        var scaleMax = Math.max(scaleX, scaleY);\n        var finalDesiredWidth = desiredWidth;\n        var finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === \"meet\") {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === \"slice\") {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        var refXProp = new Property(document1, \"refX\", refX);\n        var refYProp = new Property(document1, \"refY\", refY);\n        var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n        }\n        if (clip) {\n            var scaledClipX = scaleMin * clipX;\n            var scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n            var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n            var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n            var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n            if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n            }\n            if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n            }\n            if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        } // scale\n        switch(true){\n            case align === \"none\":\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === \"meet\":\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === \"slice\":\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        } // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        var { enableRedraw = false, ignoreMouse = false, ignoreAnimation = false, ignoreDimensions = false, ignoreClear = false, forceRedraw, scaleWidth, scaleHeight, offsetX, offsetY } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { FRAMERATE, mouse } = this;\n        var frameDuration = 1000 / FRAMERATE;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        var now = Date.now();\n        var then = now;\n        var delta = 0;\n        var tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_11__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            var { frameDuration } = this;\n            var shouldUpdate = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate, false);\n            if (shouldUpdate) {\n                return true;\n            }\n        } // need update from redraw?\n        if (typeof forceRedraw === \"function\" && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        } // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        var { CLIENT_WIDTH, CLIENT_HEIGHT, viewPort, ctx, isFirstRender } = this;\n        var canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        } else {\n            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n        }\n        var widthStyle = element.getStyle(\"width\");\n        var heightStyle = element.getStyle(\"height\");\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels(\"x\");\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels(\"y\");\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        var cWidth = canvas.clientWidth || canvas.width;\n        var cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels(\"x\");\n            cHeight = heightStyle.getPixels(\"y\");\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === \"number\") {\n            element.getAttribute(\"x\", true).setValue(offsetX);\n        }\n        if (typeof offsetY === \"number\") {\n            element.getAttribute(\"y\", true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n            var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n            var xRatio = 0;\n            var yRatio = 0;\n            if (typeof scaleWidth === \"number\") {\n                var _widthStyle = element.getStyle(\"width\");\n                if (_widthStyle.hasValue()) {\n                    xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                } else if (!isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === \"number\") {\n                var _heightStyle = element.getStyle(\"height\");\n                if (_heightStyle.hasValue()) {\n                    yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                } else if (!isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute(\"width\", true).setValue(scaleWidth);\n            element.getAttribute(\"height\", true).setValue(scaleHeight);\n            var transformStyle = element.getStyle(\"transform\", true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n        } // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar { defaultFetch } = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n    constructor(){\n        var { fetch: fetch1 = defaultFetch, DOMParser: DOMParser1 = DefaultDOMParser } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    parse(resource) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            if (resource.startsWith(\"<\")) {\n                return _this.parseFromString(resource);\n            }\n            return _this.load(resource);\n        })();\n    }\n    parseFromString(xml) {\n        var parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n        }\n    }\n    checkDocument(document1) {\n        var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n        if (parserError) {\n            throw new Error(parserError.textContent);\n        }\n        return document1;\n    }\n    load(url) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var response = yield _this2.fetch(url);\n            var xml = yield response.text();\n            return _this2.parseFromString(xml);\n        })();\n    }\n}\nclass Translate {\n    constructor(_, point){\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    apply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(x || 0.0, y || 0.0);\n    }\n    unapply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0.0,\n            y || 0.0\n        ]);\n    }\n}\nclass Rotate {\n    constructor(document1, rotate, transformOrigin){\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    apply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(-1.0 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { cx, cy, angle } = this;\n        var rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0.0,\n            cy || 0.0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0.0,\n            -cy || 0.0 // -this.p.y\n        ]);\n    }\n}\nclass Scale {\n    constructor(_, scale, transformOrigin){\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(1.0 / x, 1.0 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.scale;\n        point.applyTransform([\n            x || 0.0,\n            0,\n            0,\n            y || 0.0,\n            0,\n            0\n        ]);\n    }\n}\nclass Matrix {\n    constructor(_, matrix, transformOrigin){\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { originX, originY, matrix } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { originX, originY, matrix } = this;\n        var a = matrix[0];\n        var b = matrix[2];\n        var c = matrix[4];\n        var d = matrix[1];\n        var e = matrix[3];\n        var f = matrix[5];\n        var g = 0.0;\n        var h = 0.0;\n        var i = 1.0;\n        var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n}\nclass Skew extends Matrix {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skew\";\n        this.angle = null;\n        this.angle = new Property(document1, \"angle\", skew);\n    }\n}\nclass SkewX extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewX\";\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\nclass SkewY extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewY\";\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var [type, value] = transform.split(\"(\");\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nclass Transform {\n    constructor(document1, transform, transformOrigin){\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach((transform)=>{\n            if (transform === \"none\") {\n                return;\n            }\n            var [type, value] = parseTransform(transform);\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n    static fromElement(document1, element) {\n        var transformStyle = element.getStyle(\"transform\", false, true);\n        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n        var transformOrigin = [\n            transformOriginXProperty,\n            transformOriginYProperty\n        ];\n        if (transformStyle.hasValue()) {\n            return new Transform(document1, transformStyle.getString(), transformOrigin);\n        }\n        return null;\n    }\n    apply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].apply(ctx);\n        }\n    }\n    unapply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = len - 1; i >= 0; i--){\n            transforms[i].unapply(ctx);\n        }\n    }\n    applyToPoint(point) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].applyToPoint(point);\n        }\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nclass Element {\n    constructor(document1, node){\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map((_)=>_.trim());\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                var [name, value] = style.split(\":\").map((_)=>_.trim());\n                this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var { definitions } = document1;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    getAttribute(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            var _attr = new Property(this.document, name, \"\");\n            this.attributes[name] = _attr;\n            return _attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        for(var key in this.attributes){\n            if (key === \"href\" || key.endsWith(\":href\")) {\n                return this.attributes[key];\n            }\n        }\n        return Property.empty(this.document);\n    }\n    getStyle(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        var attr = this.getAttribute(name);\n        if (attr !== null && attr !== void 0 && attr.hasValue()) {\n            this.styles[name] = attr; // move up to me to cache\n            return attr;\n        }\n        if (!skipAncestors) {\n            var { parent } = this;\n            if (parent) {\n                var parentStyle = parent.getStyle(name);\n                if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            var _style = new Property(this.document, name, \"\");\n            this.styles[name] = _style;\n            return _style;\n        }\n        return style || Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle(\"mask\").hasValue()) {\n            // mask\n            var mask = this.getStyle(\"mask\").getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n            // filter\n            var filter = this.getStyle(\"filter\").getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {}\n    applyEffects(ctx) {\n        // transform\n        var transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        } // clip\n        var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n        if (clipPathStyleProp.hasValue()) {\n            var clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {}\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var _node$getAttribute;\n        var { node } = this;\n        if (typeof node.matches === \"function\") {\n            return node.matches(selector);\n        }\n        var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n        if (!styleClasses || styleClasses === \"\") {\n            return false;\n        }\n        return styleClasses.split(\" \").some((styleClass)=>\".\".concat(styleClass) === selector);\n    }\n    addStylesFromStyleDefinition() {\n        var { styles, stylesSpecificity } = this.document;\n        for(var selector in styles){\n            if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                var style = styles[selector];\n                var specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(var name in style){\n                        var existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === \"undefined\") {\n                            existingSpecificity = \"000\";\n                        }\n                        if (specificity >= existingSpecificity) {\n                            this.styles[name] = style[name];\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        var toRestore = ignoreStyles.reduce((toRestore, name)=>{\n            var styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            var value = styleProp.getString();\n            styleProp.setValue(\"\");\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((_ref)=>{\n            var [name, value] = _ref;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var _this$parent;\n        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n    }\n}\nElement.ignoreChildTypes = [\n    \"title\"\n];\nclass UnknownElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n    }\n}\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nclass Font {\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    static parse() {\n        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var inherit = arguments.length > 1 ? arguments[1] : undefined;\n        var fontStyle = \"\";\n        var fontVariant = \"\";\n        var fontWeight = \"\";\n        var fontSize = \"\";\n        var fontFamily = \"\";\n        var parts = compressSpaces(font).trim().split(\" \");\n        var set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== \"inherit\") {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== \"inherit\") {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== \"inherit\") {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== \"inherit\") {\n                        [fontSize] = part.split(\"/\");\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== \"inherit\") {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            prepareFontFamily(this.fontFamily)\n        ].join(\" \").trim();\n    }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n    constructor(){\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== \"undefined\") {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== \"undefined\") {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, null);\n    }\n    addY(y) {\n        this.addPoint(null, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        var { x1, y1, x2, y2 } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        var b = 6 * p0 - 12 * p1 + 6 * p2;\n        var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        var c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        var { x1, y1, x2, y2 } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n}\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData {\n    constructor(path){\n        super(path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        this.control = null;\n        this.start = null;\n        this.current = null;\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        var { i, commands } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        var command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n        var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n        var point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        var previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        } // reflect point\n        var { current: { x: cx, y: cy }, control: { x: ox, y: oy } } = this;\n        var point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            var { x, y } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        var { points, angles } = this; // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        var { angles } = this;\n        var len = angles.length;\n        for(var i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(var j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n}\nclass RenderedElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.modifiedEmSizeStack = false;\n    }\n    calculateOpacity() {\n        var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var element = this;\n        while(element){\n            var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!fromMeasure) {\n            // causes stack overflow when measuring text with gradients\n            // fill\n            var fillStyleProp = this.getStyle(\"fill\");\n            var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n            var strokeStyleProp = this.getStyle(\"stroke\");\n            var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n            if (fillStyleProp.isUrlDefinition()) {\n                var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === \"currentColor\") {\n                    fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _fillStyle = fillStyleProp.getColor();\n                if (_fillStyle !== \"inherit\") {\n                    ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = _fillStyle2;\n            } // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === \"currentColor\") {\n                    strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _strokeStyle = strokeStyleProp.getString();\n                if (_strokeStyle !== \"inherit\") {\n                    ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = _strokeStyle2;\n            }\n            var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n            if (strokeWidthStyleProp.hasValue()) {\n                var newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n            var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n            var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n            var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            } // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            // \t// ?\n            // \tctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== \"undefined\") {\n                    ctx.setLineDash(gaps);\n                } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                var offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== \"undefined\") {\n                    ctx.lineDashOffset = offset;\n                } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        } // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== \"undefined\") {\n            var fontStyleProp = this.getStyle(\"font\");\n            var fontStyleStyleProp = this.getStyle(\"font-style\");\n            var fontVariantStyleProp = this.getStyle(\"font-variant\");\n            var fontWeightStyleProp = this.getStyle(\"font-weight\");\n            var fontSizeStyleProp = this.getStyle(\"font-size\");\n            var fontFamilyStyleProp = this.getStyle(\"font-family\");\n            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx); // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n}\nclass PathElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"path\";\n        this.pathParser = null;\n        this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n    }\n    path(ctx) {\n        var { pathParser } = this;\n        var boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_) {\n        return this.path();\n    }\n    getMarkers() {\n        var { pathParser } = this;\n        var points = pathParser.getMarkerPoints();\n        var angles = pathParser.getMarkerAngles();\n        var markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]);\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n        if (ctx.fillStyle !== \"\") {\n            if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== \"\") {\n            if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        var markers = this.getMarkers();\n        if (markers) {\n            var markersLastIndex = markers.length - 1;\n            var markerStartStyleProp = this.getStyle(\"marker-start\");\n            var markerMidStyleProp = this.getStyle(\"marker-mid\");\n            var markerEndStyleProp = this.getStyle(\"marker-end\");\n            if (markerStartStyleProp.isUrlDefinition()) {\n                var marker = markerStartStyleProp.getDefinition();\n                var [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                var _marker = markerMidStyleProp.getDefinition();\n                for(var i = 1; i < markersLastIndex; i++){\n                    var [_point, _angle] = markers[i];\n                    _marker.render(ctx, _point, _angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                var _marker2 = markerEndStyleProp.getDefinition();\n                var [_point2, _angle2] = markers[markersLastIndex];\n                _marker2.render(ctx, _point2, _angle2);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        var point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { point } = PathElement.pathM(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathL(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathH(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathV(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getPoint(\"x1\", \"y1\");\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getReflectedControlPoint();\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        var { current, command } = pathParser;\n        var { rX, rY, xRot, lArcFlag, sweepFlag } = command;\n        var xAxisRotation = xRot * (Math.PI / 180.0);\n        var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n        var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        } // cx', cy'\n        var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n        var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n        var a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]); // θ1\n        // angle delta\n        var u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        var v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        var ad = vectorsAngle(u, v); // Δθ\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { currentPoint, rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser); // for markers\n        var dir = 1 - sweepFlag ? 1.0 : -1.0;\n        var ah = a1 + dir * (ad / 2.0);\n        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            var r = rX > rY ? rX : rY;\n            var sx = rX > rY ? 1 : rX / rY;\n            var sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n}\nclass GlyphElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"glyph\";\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        this.unicode = this.getAttribute(\"unicode\").getString();\n        this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n    }\n}\nclass TextElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = \"text\";\n        this.x = 0;\n        this.y = 0;\n        this.measureCache = -1;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== \"text\") {\n            return this.getTElementBoundingBox(ctx);\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        var boundingBox = null; // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        var { document: document1, parent } = this;\n        var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n        var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        var fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        var char = text[i];\n        var glyph = null;\n        if (font.isArabic) {\n            var len = text.length;\n            var prevChar = text[i - 1];\n            var nextChar = text[i + 1];\n            var arabicForm = \"isolated\";\n            if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"terminal\";\n            }\n            if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"medial\";\n            }\n            if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                arabicForm = \"initial\";\n            }\n            if (typeof font.glyphs[char] !== \"undefined\") {\n                // NEED TEST\n                var maybeGlyph = font.glyphs[char];\n                glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n            }\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromNode(node) {\n        var textNode = node || this.node;\n        var childNodes = Array.from(textNode.parentNode.childNodes);\n        var index = childNodes.indexOf(textNode);\n        var lastIndex = childNodes.length - 1;\n        var text = compressSpaces(// || textNode.text\n        textNode.textContent || \"\");\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== \"text\") {\n            this.renderTElementChildren(ctx);\n            return;\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx); // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        var { mouse } = this.document.screen; // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        var { document: document1, parent } = this;\n        var renderText = this.getText();\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var { unitsPerEm } = customFont.fontFace;\n            var ctxFont = Font.parse(document1.ctx.font);\n            var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n            var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n            var scale = fontSize / unitsPerEm;\n            var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                var lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, .4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, -.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        var { x, y } = this; // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        // \tif (ctx.strokeStyle) {\n        // \t\tctx.strokeText(renderText, x, y);\n        // \t}\n        // \tif (ctx.fillStyle) {\n        // \t\tctx.fillText(renderText, x, y);\n        // \t}\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        } // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        var firstElement = this.leafTexts[this.textChunkStart];\n        var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n        var isRTL = false; // we treat RTL like LTR\n        var shift = 0;\n        if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        } // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (typeof child.measureText !== \"function\") {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        var xAttr = child.getAttribute(\"x\");\n        var yAttr = child.getAttribute(\"y\");\n        var dxAttr = child.getAttribute(\"dx\");\n        var dyAttr = child.getAttribute(\"dy\");\n        var customFont = child.getStyle(\"font-family\").getDefinition();\n        var isRTL = Boolean(customFont) && customFont.isRTL;\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute(\"x\"));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute(\"y\"));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n            }\n        }\n        var width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels(\"x\");\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels(\"x\");\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels(\"x\");\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels(\"y\");\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels(\"y\");\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels(\"y\");\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y; // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i) {\n        var child = parent.children[i]; // not a text node?\n        if (typeof child.getBoundingBox !== \"function\") {\n            return null;\n        }\n        var boundingBox = child.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return null;\n        }\n        child.children.forEach((_, i)=>{\n            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n            boundingBox.addBoundingBox(childBoundingBox);\n        });\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        var { measureCache } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        var renderText = this.getText();\n        var measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        var { parent } = this;\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var fontSize = this.getFontSize();\n            var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            var _measure = 0;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    _measure += dx[i];\n                }\n            }\n            return _measure;\n        }\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        var { width: measure } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\r\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\r\n   * are only inherited from a parent to its first child.\r\n   * @param name - The attribute name.\r\n   * @returns The attribute value or null.\r\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        var current = this;\n        while(current instanceof TextElement && current.isFirstChild()){\n            var parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getValue(\"0\");\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n}\nclass TSpanElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = \"tspan\"; // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n    }\n    getText() {\n        return this.text;\n    }\n}\nclass TextNode extends TSpanElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"textNode\";\n    }\n}\nclass SVGElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.root = false;\n    }\n    setContext(ctx) {\n        var _this$node$parentNode;\n        var { document: document1 } = this;\n        var { screen, window: window1 } = document1;\n        var canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n            ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n            var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                document1.emSize = document1.rootEmSize;\n            }\n        } // create new view port\n        if (!this.getAttribute(\"x\").hasValue()) {\n            this.getAttribute(\"x\", true).setValue(0);\n        }\n        if (!this.getAttribute(\"y\").hasValue()) {\n            this.getAttribute(\"y\", true).setValue(0);\n        }\n        var { width, height } = screen.viewPort;\n        if (!this.getStyle(\"width\").hasValue()) {\n            this.getStyle(\"width\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"height\").hasValue()) {\n            this.getStyle(\"height\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"color\").hasValue()) {\n            this.getStyle(\"color\", true).setValue(\"black\");\n        }\n        var refXAttr = this.getAttribute(\"refX\");\n        var refYAttr = this.getAttribute(\"refY\");\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n        var minX = 0;\n        var minY = 0;\n        var clipX = 0;\n        var clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle(\"width\").getPixels(\"x\");\n            height = this.getStyle(\"height\").getPixels(\"y\");\n            if (this.type === \"marker\") {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n            this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document1.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var widthAttr = this.getAttribute(\"width\", true);\n        var heightAttr = this.getAttribute(\"height\", true);\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var styleAttr = this.getAttribute(\"style\");\n        var originWidth = widthAttr.getNumber(0);\n        var originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === \"string\") {\n                this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n            } else {\n                var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            var widthStyle = this.getStyle(\"width\");\n            var heightStyle = this.getStyle(\"height\");\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n}\nclass RectElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"rect\";\n    }\n    path(ctx) {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n        var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n        var rxAttr = this.getAttribute(\"rx\");\n        var ryAttr = this.getAttribute(\"ry\");\n        var rx = rxAttr.getPixels(\"x\");\n        var ry = ryAttr.getPixels(\"y\");\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2.0);\n        ry = Math.min(ry, height / 2.0);\n        if (ctx) {\n            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath(); // always start the path so we don't fill prior paths\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass CircleElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"circle\";\n    }\n    path(ctx) {\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        var r = this.getAttribute(\"r\").getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass EllipseElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"ellipse\";\n    }\n    path(ctx) {\n        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n        var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass LineElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"line\";\n    }\n    getPoints() {\n        return [\n            new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n            new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n        ];\n    }\n    path(ctx) {\n        var [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        var [p0, p1] = this.getPoints();\n        var a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n}\nclass PolylineElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"polyline\";\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n    }\n    path(ctx) {\n        var { points } = this;\n        var [{ x: x0, y: y0 }] = points;\n        var boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((_ref)=>{\n            var { x, y } = _ref;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        var { points } = this;\n        var lastIndex = points.length - 1;\n        var markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n}\nclass PolygonElement extends PolylineElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"polygon\";\n    }\n    path(ctx) {\n        var boundingBox = super.path(ctx);\n        var [{ x, y }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n}\nclass PatternElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"pattern\";\n    }\n    createPattern(ctx, _, parentOpacityProp) {\n        var width = this.getStyle(\"width\").getPixels(\"x\", true);\n        var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n        var patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n        patternSvg.children = this.children;\n        var patternCanvas = this.document.createCanvas(width, height);\n        var patternCtx = patternCanvas.getContext(\"2d\");\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles[\"fill-opacity\"] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, \"fill-opacity\");\n        } // render 3x3 grid so when we transform there's no white space on edges\n        for(var x = -1; x <= 1; x++){\n            for(var y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n        return pattern;\n    }\n}\nclass MarkerElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"marker\";\n    }\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        var { x, y } = point;\n        var orient = this.getAttribute(\"orient\").getString(\"auto\");\n        var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n        ctx.translate(x, y);\n        if (orient === \"auto\") {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save(); // render me using a temporary svg element\n        var markerSvg = new SVGElement(this.document, null);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n        markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n        markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n        markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n        markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n        markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n        markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === \"auto\") {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n}\nclass DefsElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"defs\";\n    }\n    render() {}\n}\nclass GElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"g\";\n    }\n    getBoundingBox(ctx) {\n        var boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n}\nclass GradientElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        this.stops = [];\n        var { stops, children } = this;\n        children.forEach((child)=>{\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n    }\n    getGradientUnits() {\n        return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        var { stops } = stopsContainer;\n        var gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute(\"gradientTransform\").hasValue()) {\n            // render as transformed pattern on temporary canvas\n            var { document: document1 } = this;\n            var { MAX_VIRTUAL_PIXELS, viewPort } = document1.screen;\n            var [rootView] = viewPort.viewPorts;\n            var rect = new RectElement(document1, null);\n            rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n            var group = new GElement(document1, null);\n            group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n            group.children = [\n                rect\n            ];\n            var patternSvg = new SVGElement(document1, null);\n            patternSvg.attributes.x = new Property(document1, \"x\", 0);\n            patternSvg.attributes.y = new Property(document1, \"y\", 0);\n            patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n            patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n            var patternCtx = patternCanvas.getContext(\"2d\");\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            var colorProp = new Property(this.document, \"color\", color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n}\nclass LinearGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"linearGradient\";\n        this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n            this.getAttribute(\"x1\", true).setValue(0);\n            this.getAttribute(\"y1\", true).setValue(0);\n            this.getAttribute(\"x2\", true).setValue(1);\n            this.getAttribute(\"y2\", true).setValue(0);\n        }\n        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n        var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n}\nclass RadialGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"radialGradient\";\n        this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"cx\").hasValue()) {\n            this.getAttribute(\"cx\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"cy\").hasValue()) {\n            this.getAttribute(\"cy\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"r\").hasValue()) {\n            this.getAttribute(\"r\", true).setValue(\"50%\");\n        }\n        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n        var fx = cx;\n        var fy = cy;\n        if (this.getAttribute(\"fx\").hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n        }\n        if (this.getAttribute(\"fy\").hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n        }\n        var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n        var fr = this.getAttribute(\"fr\").getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n}\nclass StopElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = this.getStyle(\"stop-opacity\");\n        var stopColor = this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\nclass AnimateElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"animate\";\n        this.duration = 0;\n        this.initialValue = null;\n        this.initialUnits = \"\";\n        this.removed = false;\n        this.frozen = false;\n        document1.screen.animations.push(this);\n        this.begin = this.getAttribute(\"begin\").getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n        this.from = this.getAttribute(\"from\");\n        this.to = this.getAttribute(\"to\");\n        this.values = new Property(document1, \"values\", null);\n        var valuesAttr = this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n    }\n    getProperty() {\n        var attributeType = this.getAttribute(\"attributeType\").getString();\n        var attributeName = this.getAttribute(\"attributeName\").getString();\n        if (attributeType === \"CSS\") {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        var { initialUnits } = this;\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === \"%\") {\n            newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        var { parent } = this;\n        var prop = this.getProperty(); // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        } // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n            if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                this.duration = 0;\n            } else if (fill === \"freeze\" && !this.frozen) {\n                this.frozen = true;\n                parent.animationFrozen = true;\n                parent.animationFrozenValue = prop.getString();\n            } else if (fill === \"remove\" && !this.removed) {\n                this.removed = true;\n                prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta; // if we're past the begin time\n        var updated = false;\n        if (this.begin < this.duration) {\n            var newValue = this.calcValue(); // tween\n            var typeAttr = this.getAttribute(\"type\");\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                var type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        var { document: document1, values } = this;\n        var result = {\n            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n        };\n        if (values.hasValue()) {\n            var p = result.progress * (values.getValue().length - 1);\n            var lb = Math.floor(p);\n            var ub = Math.ceil(p);\n            result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n            result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n            result.progress = (p - lb) / (ub - lb);\n        } else {\n            result.from = this.from;\n            result.to = this.to;\n        }\n        return result;\n    }\n}\nclass AnimateColorElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateColor\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress();\n        var colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(from.getColor());\n        var colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute(\"from\").getColor();\n    }\n}\nclass AnimateTransformElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateTransform\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var transformFrom = toNumbers(from.getString());\n        var transformTo = toNumbers(to.getString());\n        var newValue = transformFrom.map((from, i)=>{\n            var to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(\" \");\n        return newValue;\n    }\n}\nclass FontElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font\";\n        this.glyphs = {};\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        var { definitions } = document1;\n        var { children } = this;\n        for (var child of children){\n            switch(child.type){\n                case \"font-face\":\n                    {\n                        this.fontFace = child;\n                        var fontFamilyStyle = child.getStyle(\"font-family\");\n                        if (fontFamilyStyle.hasValue()) {\n                            definitions[fontFamilyStyle.getString()] = this;\n                        }\n                        break;\n                    }\n                case \"missing-glyph\":\n                    this.missingGlyph = child;\n                    break;\n                case \"glyph\":\n                    {\n                        var glyph = child;\n                        if (glyph.arabicForm) {\n                            this.isRTL = true;\n                            this.isArabic = true;\n                            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n                                this.glyphs[glyph.unicode] = {};\n                            }\n                            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                        } else {\n                            this.glyphs[glyph.unicode] = glyph;\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n    render() {}\n}\nclass FontFaceElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font-face\";\n        this.ascent = this.getAttribute(\"ascent\").getNumber();\n        this.descent = this.getAttribute(\"descent\").getNumber();\n        this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n    }\n}\nclass MissingGlyphElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"missing-glyph\";\n        this.horizAdvX = 0;\n    }\n}\nclass TRefElement extends TextElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"tref\";\n    }\n    getText() {\n        var element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            var firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return \"\";\n    }\n}\nclass AElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"a\";\n        var { childNodes } = node;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3);\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n    }\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            var { document: document1, x, y } = this;\n            var { mouse } = document1.screen;\n            var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            var g = new GElement(this.document, null);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        var { window: window1 } = this.document;\n        if (window1) {\n            window1.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        var ctx = this.document.ctx;\n        ctx.canvas.style.cursor = \"pointer\";\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nclass TextPathElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"textPath\";\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        var { dataArray } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((_ref)=>{\n            var { type, points } = _ref;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        var r = rx > ry ? rx : ry;\n                        var scaleX = rx > ry ? 1 : rx / ry;\n                        var scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n        var fontSize = this.getFontSize();\n        var { glyphInfo } = this;\n        var fill = ctx.fillStyle;\n        if (textDecoration === \"underline\") {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            var { p0, p1, rotation, text: partialText } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === \"underline\") {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            } // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        // \tctx.strokeStyle = 'red';\n        // else\n        // \tctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === \"underline\") {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        var offset = inputOffset;\n        var glyphWidth = this.measureText(ctx, c);\n        if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        var splineStep = this.textHeight / 20;\n        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        var segment = {\n            p0,\n            p1\n        };\n        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            var dyY = Math.cos(-rotation) * dy;\n            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            });\n            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            });\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        var { measuresCache } = this;\n        var targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        var measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        var renderText = this.getText();\n        var chars = renderText.split(\"\");\n        var spacesNumber = renderText.split(\" \").length - 1;\n        var dx = this.parent.getAttribute(\"dx\").split().map((_)=>_.getPixels(\"x\"));\n        var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n        var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n        var thisSpacing = this.getStyle(\"letter-spacing\");\n        var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n        var letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        } // fill letter-spacing cache\n        var letterSpacingCache = [];\n        var textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(var i = 0; i < textLen; i++){\n            letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n        }\n        var dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0, 0);\n        var textWidth = this.measureText(ctx);\n        var textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        var fullPathWidth = this.getPathLength();\n        var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n        var offset = 0;\n        if (anchor === \"middle\" || anchor === \"center\") {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === \"end\" || anchor === \"right\") {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            var { offset: nextOffset, segment, rotation } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            } // const width = this.getLineLength(\n            // \tsegment.p0.x,\n            // \tsegment.p0.y,\n            // \tsegment.p1.x,\n            // \tsegment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            // \tkern + width / 2.0,\n            // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1; // reset path length\n        if (!path) {\n            return [];\n        }\n        var pathCommands = [];\n        var { pathParser } = path;\n        pathParser.reset(); // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            var { current } = pathParser;\n            var startX = current ? current.x : 0;\n            var startY = current ? current.y : 0;\n            var command = pathParser.next();\n            var nextCommandType = command.type;\n            var points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        var { x, y } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        var { x, y } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        var { x, y } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        var { x, y } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        var { rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        var len = 0;\n        var p1 = null;\n        var p2 = null;\n        var t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0.0;\n                    var start = points[4]; // 4 = theta\n                    var dTheta = points[5]; // 5 = dTheta\n                    var end = points[4] + dTheta;\n                    var inc = Math.PI / 180.0; // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        // clockwise\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        // counter-clockwise\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n        var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n        var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        var run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt = null;\n        if (p2x === p1x) {\n            // vertical line\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            var ix = 0;\n            var iy = 0;\n            var len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        var fullLen = this.getPathLength();\n        var cumulativePathLength = 0;\n        var p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        var { dataArray } = this;\n        for (var command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            var delta = distance - cumulativePathLength;\n            var currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        var start = command.points[4]; // 4 = theta\n                        var dTheta = command.points[5]; // 5 = dTheta\n                        var end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length, 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    buildEquidistantCache(inputStep, inputPrecision) {\n        var fullLen = this.getPathLength();\n        var precision = inputPrecision || 0.25; // accuracy vs performance\n        var step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            }; // Calculate points\n            var s = 0;\n            for(var l = 0; l <= fullLen; l += precision){\n                var p0 = this.getPointOnPath(l);\n                var p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"image\";\n        this.loaded = false;\n        var href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n        this.isSvg = isSvg;\n    }\n    loadImage(href) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var image = yield _this.document.createImage(href);\n                _this.image = image;\n            } catch (err) {\n                console.error('Error while loading image \"'.concat(href, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n    loadSvg(href) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var match = dataUriRegex.exec(href);\n            if (match) {\n                var data = match[5];\n                if (match[4] === \"base64\") {\n                    _this2.image = atob(data);\n                } else {\n                    _this2.image = decodeURIComponent(data);\n                }\n            } else {\n                try {\n                    var response = yield _this2.document.fetch(href);\n                    var svg = yield response.text();\n                    _this2.image = svg;\n                } catch (err) {\n                    console.error('Error while loading image \"'.concat(href, '\":'), err);\n                }\n            }\n            _this2.loaded = true;\n        })();\n    }\n    renderChildren(ctx) {\n        var { document: document1, image, loaded } = this;\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (this.isSvg) {\n            var subDocument = document1.canvg.forkString(ctx, this.image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            subDocument.document.documentElement.parent = this;\n            void subDocument.render();\n        } else {\n            var _image = this.image;\n            document1.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                width,\n                desiredWidth: _image.width,\n                height,\n                desiredHeight: _image.height\n            });\n            if (this.loaded) {\n                if (typeof _image.complete === \"undefined\" || _image.complete) {\n                    ctx.drawImage(_image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n}\nclass SymbolElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"symbol\";\n    }\n    render(_) {}\n}\nclass SVGFontLoader {\n    constructor(document1){\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    load(fontFamily, url) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var { document: document1 } = _this;\n                var svgDocument = yield document1.canvg.parser.load(url);\n                var fonts = svgDocument.getElementsByTagName(\"font\");\n                Array.from(fonts).forEach((fontNode)=>{\n                    var font = document1.createElement(fontNode);\n                    document1.definitions[fontFamily] = font;\n                });\n            } catch (err) {\n                console.error('Error while loading font \"'.concat(url, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n}\nclass StyleElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map((_)=>_.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach((_)=>{\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach((_)=>{\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"use\";\n    }\n    setContext(ctx) {\n        super.setContext(ctx);\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels(\"x\"), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels(\"y\"));\n        }\n    }\n    path(ctx) {\n        var { element } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        var { document: document1, element } = this;\n        if (element) {\n            var tempSvg = element;\n            if (element.type === \"symbol\") {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document1, null);\n                tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                tempSvg.children = element.children; // element is still the parent of the children\n                element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n            }\n            if (tempSvg.type === \"svg\") {\n                var widthStyle = this.getStyle(\"width\", false, true);\n                var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                }\n            }\n            var oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        var { element } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        var { document: document1, element } = this;\n        return Transform.fromElement(document1, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feColorMatrix\";\n        var matrix = toNumbers(this.getAttribute(\"values\").getString());\n        switch(this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n    }\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        var { includeOpacity, matrix } = this;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        for(var y = 0; y < height; y++){\n            for(var x = 0; x < width; x++){\n                var r = imGet(srcData.data, x, y, width, height, 0);\n                var g = imGet(srcData.data, x, y, width, height, 1);\n                var b = imGet(srcData.data, x, y, width, height, 2);\n                var a = imGet(srcData.data, x, y, width, height, 3);\n                var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n}\nclass MaskElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"mask\";\n    }\n    apply(ctx, element) {\n        var { document: document1 } = this; // render as temp svg\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!width && !height) {\n            var boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        var maskCanvas = document1.createCanvas(x + width, y + height);\n        var maskCtx = maskCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document1, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: \"type\",\n                    value: \"luminanceToAlpha\"\n                },\n                {\n                    nodeName: \"includeOpacity\",\n                    value: \"true\"\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        var tmpCanvas = document1.createCanvas(x + width, y + height);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = \"destination-in\";\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n        ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nvar noop = ()=>{};\nclass ClipPathElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"clipPath\";\n    }\n    apply(ctx) {\n        var { document: document1 } = this;\n        var contextProto = Reflect.getPrototypeOf(ctx);\n        var { beginPath, closePath } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (typeof child.path === \"undefined\") {\n                return;\n            }\n            var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n            if (!transform) {\n                transform = Transform.fromElement(document1, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {}\n}\nclass FilterElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"filter\";\n    }\n    apply(ctx, element) {\n        // render as temp svg\n        var { document: document1, children } = this;\n        var boundingBox = element.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return;\n        }\n        var px = 0;\n        var py = 0;\n        children.forEach((child)=>{\n            var efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        var width = Math.floor(boundingBox.width);\n        var height = Math.floor(boundingBox.height);\n        var tmpCanvasWidth = width + 2 * px;\n        var tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx); // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === \"function\") {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        }); // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nclass FeDropShadowElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feDropShadow\";\n        this.addStylesFromStyleDefinition();\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeMorphologyElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feMorphology\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeCompositeElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feComposite\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeGaussianBlurElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feGaussianBlur\";\n        this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n    apply(ctx, x, y, width, height) {\n        var { document: document1, blurRadius } = this;\n        var body = document1.window ? document1.window.document.body : null;\n        var canvas = ctx.canvas; // StackBlur requires canvas be on document\n        canvas.id = document1.getUniqueId();\n        if (body) {\n            canvas.style.display = \"none\";\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n}\nclass TitleElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"title\";\n    }\n}\nclass DescElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"desc\";\n    }\n}\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*(src) {\n        var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var image = document.createElement(\"img\");\n        if (anonymousCrossOrigin) {\n            image.crossOrigin = \"Anonymous\";\n        }\n        return new Promise((resolve, reject)=>{\n            image.onload = ()=>{\n                resolve(image);\n            };\n            image.onerror = (_event, _source, _lineno, _colno, error)=>{\n                reject(error);\n            };\n            image.src = src;\n        });\n    });\n    return _createImage.apply(this, arguments);\n}\nclass Document {\n    constructor(canvg){\n        var { rootEmSize = 12, emSize = 12, createCanvas = Document.createCanvas, createImage = Document.createImage, anonymousCrossOrigin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.canvg = canvg;\n        this.definitions = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(createImage, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === \"boolean\") {\n            return (source, forceAnonymousCrossOrigin)=>createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n        }\n        return createImage;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        var { emSizeStack } = this;\n        return emSizeStack[emSizeStack.length - 1];\n    }\n    set emSize(value) {\n        var { emSizeStack } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        var { emSizeStack } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded);\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded);\n    }\n    createDocumentElement(document1) {\n        var documentElement = this.createElement(document1.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n        var ElementType = Document.elementTypes[elementType];\n        if (typeof ElementType !== \"undefined\") {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox(_objectSpread$1({\n            document: this\n        }, config));\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ class Canvg {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ constructor(ctx, svg){\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static from(ctx, svg) {\n        var _arguments = arguments;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n            var parser = new Parser(options);\n            var svgDocument = yield parser.parse(svg);\n            return new Canvg(ctx, svgDocument, options);\n        })();\n    }\n    /**\r\n   * Create Canvg instance from SVG source string.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static fromString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var parser = new Parser(options);\n        var svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ fork(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ forkString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Document is ready promise.\r\n   * @returns Ready promise.\r\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\r\n   * Document is ready value.\r\n   * @returns Is ready or not.\r\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\r\n   * Render only first frame, ignoring animations and mouse.\r\n   * @param options - Rendering options.\r\n   */ render() {\n        var _arguments2 = arguments, _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n            _this.start(_objectSpread({\n                enableRedraw: true,\n                ignoreAnimation: true,\n                ignoreMouse: true\n            }, options));\n            yield _this.ready();\n            _this.stop();\n        })();\n    }\n    /**\r\n   * Start rendering.\r\n   * @param options - Render options.\r\n   */ start() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var { documentElement, screen, options: baseOptions } = this;\n        screen.start(documentElement, _objectSpread(_objectSpread({\n            enableRedraw: true\n        }, baseOptions), options));\n    }\n    /**\r\n   * Stop rendering.\r\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n}\n //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaUM7QUFDNUI7QUFDRTtBQUNJO0FBQ0o7QUFDVztBQUNXO0FBQ3hCO0FBQ0k7QUFDSjtBQUNKO0FBQ0c7QUFDWDtBQUNjO0FBQ0M7QUFDRjtBQUNGO0FBQ0s7QUFDRjtBQUU5Qzs7Ozs7Q0FLQyxHQUNELFNBQVNNO0lBQ1AsSUFBSSxFQUNGQyxXQUFXQyxpQkFBaUIsRUFDN0IsR0FBR0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJRyxTQUFTO1FBQ1hDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQVdDO1FBRVhRLGNBQWFDLEtBQUssRUFBRUMsTUFBTTtZQUN4QixPQUFPLElBQUlDLGdCQUFnQkYsT0FBT0M7UUFDcEM7UUFFQUUsYUFBWUMsR0FBRztZQUNiLE9BQU9yQixvRUFBaUJBLENBQUM7Z0JBQ3ZCLElBQUlzQixXQUFXLE1BQU1DLE1BQU1GO2dCQUMzQixJQUFJRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7Z0JBQzlCLElBQUlDLE1BQU0sTUFBTUMsa0JBQWtCRjtnQkFDbEMsT0FBT0M7WUFDVDtRQUNGO0lBRUY7SUFFQSxJQUFJLE9BQU9sQixjQUFjLGVBQWUsT0FBT0Msc0JBQXNCLGFBQWE7UUFDaEZtQixRQUFRQyxjQUFjLENBQUNoQixRQUFRO0lBQ2pDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUIsS0FBS0MsSUFBSTtJQUNoQixJQUFJLEVBQ0Z2QixXQUFBQSxVQUFTLEVBQ1R3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LGNBQWM7WUFDeER4dUIsY0FBYztRQUNoQixHQUFHK3VCLGNBQWNMO0lBQ25CO0lBQ0E7O0dBRUMsR0FHRHIwQixPQUFPO1FBQ0wsSUFBSSxDQUFDakUsTUFBTSxDQUFDaUUsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBR0QwZixPQUFPaHJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJaXJCLHNCQUFzQnpyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJLENBQUN5NUIsZUFBZSxDQUFDak8sTUFBTSxDQUFDaHJCLE9BQU9DLFFBQVFnckI7SUFDN0M7QUFFRjtBQUUwb0MsQ0FDMW9DLDR0UkFBNHRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlnbWEvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzPzBkZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyc7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyc7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGguanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzJztcbmltcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSAncmFmJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzJztcbmltcG9ydCBSR0JDb2xvciBmcm9tICdyZ2Jjb2xvcic7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZS5qcyc7XG5pbXBvcnQgeyBTVkdQYXRoRGF0YSB9IGZyb20gJ3N2Zy1wYXRoZGF0YSc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzJztcbmltcG9ydCB7IGNhbnZhc1JHQkEgfSBmcm9tICdzdGFja2JsdXItY2FudmFzJztcblxuLyoqXHJcbiAqIE9wdGlvbnMgcHJlc2V0IGZvciBgT2Zmc2NyZWVuQ2FudmFzYC5cclxuICogQHBhcmFtIGNvbmZpZyAtIFByZXNldCByZXF1aXJlbWVudHMuXHJcbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG9mZnNjcmVlbigpIHtcbiAgdmFyIHtcbiAgICBET01QYXJzZXI6IERPTVBhcnNlckZhbGxiYWNrXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgcHJlc2V0ID0ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayxcblxuICAgIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlSW1hZ2UodXJsKSB7XG4gICAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsKTtcbiAgICAgICAgdmFyIGJsb2IgPSB5aWVsZCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIHZhciBpbWcgPSB5aWVsZCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgcmV0dXJuIGltZztcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBET01QYXJzZXJGYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHByZXNldCwgJ0RPTVBhcnNlcicpO1xuICB9XG5cbiAgcmV0dXJuIHByZXNldDtcbn1cblxuLyoqXHJcbiAqIE9wdGlvbnMgcHJlc2V0IGZvciBgbm9kZS1jYW52YXNgLlxyXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cclxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXHJcbiAqIEBwYXJhbSBjb25maWcuY2FudmFzIC0gYG5vZGUtY2FudmFzYCBleHBvcnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLmZldGNoIC0gV0hBVFdHLWNvbXBhdGlibGUgYGZldGNoYCBmdW5jdGlvbi5cclxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cclxuICovXG5mdW5jdGlvbiBub2RlKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBET01QYXJzZXIsXG4gICAgY2FudmFzLFxuICAgIGZldGNoXG4gIH0gPSBfcmVmO1xuICByZXR1cm4ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyLFxuICAgIGZldGNoLFxuICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICBjcmVhdGVJbWFnZTogY2FudmFzLmxvYWRJbWFnZVxuICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0b2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG5cdG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcclxuICogSFRNTC1zYWZlIGNvbXByZXNzIHdoaXRlLXNwYWNlcy5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBjb21wcmVzcy5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/IVxcdTMwMDApXFxzKy9nbSwgJyAnKTtcbn1cbi8qKlxyXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxuIFxcdF0rLywgJycpO1xufVxuLyoqXHJcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxuIFxcdF0rJC8sICcnKTtcbn1cbi8qKlxyXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cclxuICogQHBhcmFtIHN0ciAtIE51bWJlcnMgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBOdW1iZXJzIGFycmF5LlxyXG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICB2YXIgbWF0Y2hlcyA9IChzdHIgfHwgJycpLm1hdGNoKC8tPyhcXGQrKD86XFwuXFxkKig/OltlRV1bKy1dP1xcZCspPyk/fFxcLlxcZCspKD89XFxEfCQpL2dtKSB8fCBbXTtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhcnNlRmxvYXQpO1xufSAvLyBNaWNyb3NvZnQgRWRnZSBmaXhcblxudmFyIGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhdHRyaWJ1dGUgbmFtZS5cclxuICogQHBhcmFtIG5hbWUgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG4vKipcclxuICogUGFyc2UgZXh0ZXJuYWwgVVJMLlxyXG4gKiBAcGFyYW0gdXJsIC0gQ1NTIHVybCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsVXJsKHVybCkge1xuICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgZG91YmxlIHF1b3RlcyBbM11cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIHYgICAgICAgICBubyBxdW90ZXMgWzRdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICB2YXIgdXJsTWF0Y2ggPSAvdXJsXFwoKCcoW14nXSspJ3xcIihbXlwiXSspXCJ8KFteJ1wiKV0rKSlcXCkvLmV4ZWModXJsKSB8fCBbXTtcbiAgcmV0dXJuIHVybE1hdGNoWzJdIHx8IHVybE1hdGNoWzNdIHx8IHVybE1hdGNoWzRdO1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybSBmbG9hdHMgdG8gaW50ZWdlcnMgaW4gcmdiIGNvbG9ycy5cclxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGNvbG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFjb2xvci5zdGFydHNXaXRoKCdyZ2InKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZhciByZ2JQYXJ0cyA9IDM7XG4gIHZhciBub3JtYWxpemVkQ29sb3IgPSBjb2xvci5yZXBsYWNlKC9cXGQrKFxcLlxcZCspPy9nLCAobnVtLCBpc0Zsb2F0KSA9PiByZ2JQYXJ0cy0tICYmIGlzRmxvYXQgPyBTdHJpbmcoTWF0aC5yb3VuZChwYXJzZUZsb2F0KG51bSkpKSA6IG51bSk7XG4gIHJldHVybiBub3JtYWxpemVkQ29sb3I7XG59XG5cbi8vIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tlZWdhbnN0cmVldC9zcGVjaWZpY2l0eS9ibG9iL21hc3Rlci9zcGVjaWZpY2l0eS5qc1xudmFyIGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xudmFyIGlkUmVnZXggPSAvKCNbXlxccys+fi5bOl0rKS9nO1xudmFyIGNsYXNzUmVnZXggPSAvKFxcLlteXFxzKz5+Lls6XSspL2c7XG52YXIgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG52YXIgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCA9IC8oOltcXHctXStcXChbXildKlxcKSkvZ2k7XG52YXIgcHNldWRvQ2xhc3NSZWdleCA9IC8oOlteXFxzKz5+Lls6XSspL2c7XG52YXIgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuXG5mdW5jdGlvbiBmaW5kU2VsZWN0b3JNYXRjaChzZWxlY3RvciwgcmVnZXgpIHtcbiAgdmFyIG1hdGNoZXMgPSByZWdleC5leGVjKHNlbGVjdG9yKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW3NlbGVjdG9yLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbc2VsZWN0b3IucmVwbGFjZShyZWdleCwgJyAnKSwgbWF0Y2hlcy5sZW5ndGhdO1xufVxuLyoqXHJcbiAqIE1lYXN1cmUgc2VsZWN0b3Igc3BlY2lmaWNpdHkuXHJcbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXHJcbiAqIEByZXR1cm5zIFNwZWNpZmljaXR5LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gIHZhciBzcGVjaWZpY2l0eSA9IFswLCAwLCAwXTtcbiAgdmFyIGN1cnJlbnRTZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLzpub3RcXCgoW14pXSopXFwpL2csICcgICAgICQxICcpLnJlcGxhY2UoL3tbXFxzXFxTXSovZ20sICcgJyk7XG4gIHZhciBkZWx0YSA9IDA7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgYXR0cmlidXRlUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMF0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgY2xhc3NSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0VsZW1lbnRSZWdleCk7XG4gIHNwZWNpZmljaXR5WzJdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9DbGFzc1JlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIGN1cnJlbnRTZWxlY3RvciA9IGN1cnJlbnRTZWxlY3Rvci5yZXBsYWNlKC9bKlxccys+fl0vZywgJyAnKS5yZXBsYWNlKC9bIy5dL2csICcgJyk7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgZWxlbWVudFJlZ2V4KTsgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuXG4gIHNwZWNpZmljaXR5WzJdICs9IGRlbHRhO1xuICByZXR1cm4gc3BlY2lmaWNpdHkuam9pbignJyk7XG59XG5cbnZhciBQU0VVRE9fWkVSTyA9IC4wMDAwMDAwMTtcbi8qKlxyXG4gKiBWZWN0b3IgbWFnbml0dWRlLlxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yTWFnbml0dWRlKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbn1cbi8qKlxyXG4gKiBSYXRpbyBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxyXG4gKiBAcGFyYW0gdVxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc1JhdGlvKHUsIHYpIHtcbiAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2ZWN0b3JNYWduaXR1ZGUodSkgKiB2ZWN0b3JNYWduaXR1ZGUodikpO1xufVxuLyoqXHJcbiAqIEFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAqIEBwYXJhbSB1XHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JzQW5nbGUodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZlY3RvcnNSYXRpbyh1LCB2KSk7XG59XG5mdW5jdGlvbiBDQjEodCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gQ0IyKHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjModCkge1xuICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIENCNCh0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjEodCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBRQjIodCkge1xuICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIzKHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuXG5jbGFzcyBQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZW1wdHkoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnRU1QVFknLCAnJyk7XG4gIH1cblxuICBzcGxpdCgpIHtcbiAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBjb21wcmVzc1NwYWNlcyh0aGlzLmdldFN0cmluZygpKS50cmltKCkuc3BsaXQoc2VwYXJhdG9yKS5tYXAodmFsdWUgPT4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICB9XG5cbiAgaGFzVmFsdWUoemVyb0lzVmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnICYmICh6ZXJvSXNWYWx1ZSB8fCB2YWx1ZSAhPT0gMCkgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlzU3RyaW5nKHJlZ2V4cCkge1xuICAgIHZhciB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlZ2V4cCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhwLnRlc3QodmFsdWUpO1xuICB9XG5cbiAgaXNVcmxEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3RyaW5nKC9edXJsXFwoLyk7XG4gIH1cblxuICBpc1BpeGVscygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICBjYXNlIC9eWzAtOV0rJC8udGVzdChhc1N0cmluZyk6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRWYWx1ZShkZWYpIHtcbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgZ2V0TnVtYmVyKGRlZikge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGRlZik7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICBuIC89IDEwMC4wO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgZ2V0U3RyaW5nKGRlZikge1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKGRlZik7XG4gIH1cblxuICBnZXRDb2xvcihkZWYpIHtcbiAgICB2YXIgY29sb3IgPSB0aGlzLmdldFN0cmluZyhkZWYpO1xuXG4gICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG5cbiAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICBjb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgICB0aGlzLnZhbHVlID0gY29sb3I7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgZ2V0RHBpKCkge1xuICAgIHJldHVybiA5Ni4wOyAvLyBUT0RPOiBjb21wdXRlP1xuICB9XG5cbiAgZ2V0UmVtKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LnJvb3RFbVNpemU7XG4gIH1cblxuICBnZXRFbSgpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5lbVNpemU7XG4gIH1cblxuICBnZXRVbml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmcoKS5yZXBsYWNlKC9bMC05Li1dL2csICcnKTtcbiAgfVxuXG4gIGdldFBpeGVscyhheGlzT3JJc0ZvbnRTaXplKSB7XG4gICAgdmFyIHByb2Nlc3NQZXJjZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgW2F4aXMsIGlzRm9udFNpemVdID0gdHlwZW9mIGF4aXNPcklzRm9udFNpemUgPT09ICdib29sZWFuJyA/IFt1bmRlZmluZWQsIGF4aXNPcklzRm9udFNpemVdIDogW2F4aXNPcklzRm9udFNpemVdO1xuICAgIHZhciB7XG4gICAgICB2aWV3UG9ydFxuICAgIH0gPSB0aGlzLmRvY3VtZW50LnNjcmVlbjtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92bWluJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5taW4odmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIE1hdGgubWF4KHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3Z3JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92aCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5Jyk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0UmVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKSAvIDIuMDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9weCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHQkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxLjAgLyA3Mi4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wYyQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxNTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpIC8gMi41NDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpIC8gMjUuNDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9pbiQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZShheGlzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgICAgIGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gbiAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0TWlsbGlzZWNvbmRzKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0cmluZygvbXMkLykpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogMTAwMDtcbiAgfVxuXG4gIGdldFJhZGlhbnMoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZ3JhZCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMC4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yYWQkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgIH1cbiAgfVxuXG4gIGdldERlZmluaXRpb24oKSB7XG4gICAgdmFyIGFzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcbiAgICB2YXIgbmFtZSA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgbmFtZSA9IG5hbWVbMV07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBuYW1lID0gYXNTdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnNbbmFtZV07XG4gIH1cblxuICBnZXRGaWxsU3R5bGVEZWZpbml0aW9uKGVsZW1lbnQsIG9wYWNpdHkpIHtcbiAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoIWRlZikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBncmFkaWVudFxuXG5cbiAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVHcmFkaWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGRlZi5jcmVhdGVHcmFkaWVudCh0aGlzLmRvY3VtZW50LmN0eCwgZWxlbWVudCwgb3BhY2l0eSk7XG4gICAgfSAvLyBwYXR0ZXJuXG5cblxuICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZVBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5UcmFuc2Zvcm0gPSBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgIGRlZiA9IGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJywgdHJ1ZSkuc2V0VmFsdWUocGF0dGVyblRyYW5zZm9ybS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZi5jcmVhdGVQYXR0ZXJuKHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFRleHRCYXNlbGluZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmdbdGhpcy5nZXRTdHJpbmcoKV07XG4gIH1cblxuICBhZGRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgY29tbWFzID0gMDsgLy8gU2ltdWxhdGUgb2xkIFJHQkNvbG9yIHZlcnNpb24sIHdoaWNoIGNhbid0IHBhcnNlIHJnYmEuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICcsJykge1xuICAgICAgICBjb21tYXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hcyA9PT0gMykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3BhY2l0eS5oYXNWYWx1ZSgpICYmIHRoaXMuaXNTdHJpbmcoKSAmJiBjb21tYXMgIT09IDMpIHtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBSR0JDb2xvcih2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICBjb2xvci5hbHBoYSA9IG9wYWNpdHkuZ2V0TnVtYmVyKCk7XG4gICAgICAgIHZhbHVlID0gY29sb3IudG9SR0JBKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgfVxuXG59XG5Qcm9wZXJ0eS50ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xuICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICdiZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICdjZW50cmFsJzogJ21pZGRsZScsXG4gICdhZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ2lkZW9ncmFwaGljJzogJ2lkZW9ncmFwaGljJyxcbiAgJ2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXG4gICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAnbWF0aGVtYXRpY2FsJzogJ2FscGhhYmV0aWMnXG59O1xuXG5jbGFzcyBWaWV3UG9ydCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLnZpZXdQb3J0cyA9IFtdO1xuICB9XG5cbiAgc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy52aWV3UG9ydHMucHVzaCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgcmVtb3ZlQ3VycmVudCgpIHtcbiAgICB0aGlzLnZpZXdQb3J0cy5wb3AoKTtcbiAgfVxuXG4gIGdldEN1cnJlbnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHZpZXdQb3J0c1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB2aWV3UG9ydHNbdmlld1BvcnRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnQoKS53aWR0aDtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLmhlaWdodDtcbiAgfVxuXG4gIGNvbXB1dGVTaXplKGQpIHtcbiAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gJ3knKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0LCAyKSkgLyBNYXRoLnNxcnQoMik7XG4gIH1cblxufVxuXG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2UocG9pbnQpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IGRlZmF1bHRWYWx1ZV0gPSB0b051bWJlcnMocG9pbnQpO1xuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VTY2FsZShzY2FsZSkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIFt4ID0gZGVmYXVsdFZhbHVlLCB5ID0geF0gPSB0b051bWJlcnMoc2NhbGUpO1xuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VQYXRoKHBhdGgpIHtcbiAgICB2YXIgcG9pbnRzID0gdG9OdW1iZXJzKHBhdGgpO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBwYXRoUG9pbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICBwYXRoUG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoUG9pbnRzO1xuICB9XG5cbiAgYW5nbGVUbyhwb2ludCkge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50LnkgLSB0aGlzLnksIHBvaW50LnggLSB0aGlzLngpO1xuICB9XG5cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHhwID0geCAqIHRyYW5zZm9ybVswXSArIHkgKiB0cmFuc2Zvcm1bMl0gKyB0cmFuc2Zvcm1bNF07XG4gICAgdmFyIHlwID0geCAqIHRyYW5zZm9ybVsxXSArIHkgKiB0cmFuc2Zvcm1bM10gKyB0cmFuc2Zvcm1bNV07XG4gICAgdGhpcy54ID0geHA7XG4gICAgdGhpcy55ID0geXA7XG4gIH1cblxufVxuXG5jbGFzcyBNb3VzZSB7XG4gIGNvbnN0cnVjdG9yKHNjcmVlbikge1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcblxuICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaXNXb3JraW5nKCkge1xuICAgIHJldHVybiB0aGlzLndvcmtpbmc7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy53b3JraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHNjcmVlbixcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBvbk1vdXNlTW92ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBzY3JlZW4uY3R4LmNhbnZhcztcbiAgICBjYW52YXMub25jbGljayA9IG9uQ2xpY2s7XG4gICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gb25Nb3VzZU1vdmU7XG4gICAgdGhpcy53b3JraW5nID0gdHJ1ZTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5zY3JlZW4uY3R4LmNhbnZhcztcbiAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICBjYW52YXMub25jbGljayA9IG51bGw7XG4gICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgfVxuXG4gIGhhc0V2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy53b3JraW5nICYmIHRoaXMuZXZlbnRzLmxlbmd0aCA+IDA7XG4gIH1cblxuICBydW5FdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2NyZWVuOiBkb2N1bWVudCxcbiAgICAgIGV2ZW50cyxcbiAgICAgIGV2ZW50RWxlbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZG9jdW1lbnQuY3R4LmNhbnZhcztcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgfVxuXG4gICAgZXZlbnRzLmZvckVhY2goKF9yZWYsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJ1blxuICAgICAgfSA9IF9yZWY7XG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50RWxlbWVudHNbaV07XG5cbiAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIHJ1bihlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgfVxuICAgIH0pOyAvLyBkb25lIHJ1bm5pbmcsIGNsZWFyXG5cbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICB9XG5cbiAgY2hlY2tQYXRoKGVsZW1lbnQsIGN0eCkge1xuICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFjdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGV2ZW50cy5mb3JFYWNoKChfcmVmMiwgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWYyO1xuXG4gICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgY3R4LmlzUG9pbnRJblBhdGggJiYgY3R4LmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjaGVja0JvdW5kaW5nQm94KGVsZW1lbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGV2ZW50cyxcbiAgICAgIGV2ZW50RWxlbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICBldmVudHMuZm9yRWFjaCgoX3JlZjMsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBfcmVmMztcblxuICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGJvdW5kaW5nQm94LmlzUG9pbnRJbkJveCh4LCB5KSkge1xuICAgICAgICBldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcFhZKHgsIHkpIHtcbiAgICB2YXIge1xuICAgICAgd2luZG93LFxuICAgICAgY3R4XG4gICAgfSA9IHRoaXMuc2NyZWVuO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICB2YXIgZWxlbWVudCA9IGN0eC5jYW52YXM7XG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgcG9pbnQueCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICBwb2ludC55IC09IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuc2Nyb2xsWCkge1xuICAgICAgcG9pbnQueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LnNjcm9sbFkpIHtcbiAgICAgIHBvaW50LnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgb25DbGljayhldmVudCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ29uY2xpY2snLFxuICAgICAgeCxcbiAgICAgIHksXG5cbiAgICAgIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25DbGljaykge1xuICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uQ2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ29ubW91c2Vtb3ZlJyxcbiAgICAgIHgsXG4gICAgICB5LFxuXG4gICAgICBydW4oZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxufVxuXG52YXIgZGVmYXVsdFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBkZWZhdWx0RmV0Y2gkMSA9IHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgPyBmZXRjaC5iaW5kKHVuZGVmaW5lZCkgLy8gYGZldGNoYCBkZXBlbmRzIG9uIGNvbnRleHQ6IGBzb21lT2JqZWN0LmZldGNoKC4uLilgIHdpbGwgdGhyb3cgZXJyb3IuXG46IG51bGw7XG5jbGFzcyBTY3JlZW4ge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMSxcbiAgICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLkZSQU1FUkFURSA9IDMwO1xuICAgIHRoaXMuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG4gICAgdGhpcy5DTElFTlRfV0lEVEggPSA4MDA7XG4gICAgdGhpcy5DTElFTlRfSEVJR0hUID0gNjAwO1xuICAgIHRoaXMudmlld1BvcnQgPSBuZXcgVmlld1BvcnQoKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlKHRoaXMpO1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgIHRoaXMud2FpdHMgPSBbXTtcbiAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICB9XG5cbiAgd2FpdChjaGVja2VyKSB7XG4gICAgdGhpcy53YWl0cy5wdXNoKGNoZWNrZXIpO1xuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgaWYgKCF0aGlzLnJlYWR5UHJvbWlzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlYWR5UHJvbWlzZTtcbiAgfVxuXG4gIGlzUmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeUxvY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1JlYWR5TG9jayA9IHRoaXMud2FpdHMuZXZlcnkoXyA9PiBfKCkpO1xuXG4gICAgaWYgKGlzUmVhZHlMb2NrKSB7XG4gICAgICB0aGlzLndhaXRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnJlc29sdmVSZWFkeSkge1xuICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBpc1JlYWR5TG9jaztcbiAgICByZXR1cm4gaXNSZWFkeUxvY2s7XG4gIH1cblxuICBzZXREZWZhdWx0cyhjdHgpIHtcbiAgICAvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDQ7XG4gIH1cblxuICBzZXRWaWV3Qm94KF9yZWYpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBjdHgsXG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVzaXJlZFdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZGVzaXJlZEhlaWdodCxcbiAgICAgIG1pblggPSAwLFxuICAgICAgbWluWSA9IDAsXG4gICAgICByZWZYLFxuICAgICAgcmVmWSxcbiAgICAgIGNsaXAgPSBmYWxzZSxcbiAgICAgIGNsaXBYID0gMCxcbiAgICAgIGNsaXBZID0gMFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIGFzcGVjdCByYXRpbyAtIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlXG4gICAgdmFyIGNsZWFuQXNwZWN0UmF0aW8gPSBjb21wcmVzc1NwYWNlcyhhc3BlY3RSYXRpbykucmVwbGFjZSgvXmRlZmVyXFxzLywgJycpOyAvLyBpZ25vcmUgZGVmZXJcblxuICAgIHZhciBbYXNwZWN0UmF0aW9BbGlnbiwgYXNwZWN0UmF0aW9NZWV0T3JTbGljZV0gPSBjbGVhbkFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgdmFyIGFsaWduID0gYXNwZWN0UmF0aW9BbGlnbiB8fCAneE1pZFlNaWQnO1xuICAgIHZhciBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgfHwgJ21lZXQnOyAvLyBjYWxjdWxhdGUgc2NhbGVcblxuICAgIHZhciBzY2FsZVggPSB3aWR0aCAvIGRlc2lyZWRXaWR0aDtcbiAgICB2YXIgc2NhbGVZID0gaGVpZ2h0IC8gZGVzaXJlZEhlaWdodDtcbiAgICB2YXIgc2NhbGVNaW4gPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgdmFyIHNjYWxlTWF4ID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgIHZhciBmaW5hbERlc2lyZWRXaWR0aCA9IGRlc2lyZWRXaWR0aDtcbiAgICB2YXIgZmluYWxEZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcblxuICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICBmaW5hbERlc2lyZWRXaWR0aCAqPSBzY2FsZU1pbjtcbiAgICAgIGZpbmFsRGVzaXJlZEhlaWdodCAqPSBzY2FsZU1pbjtcbiAgICB9XG5cbiAgICBpZiAobWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWF4O1xuICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWF4O1xuICAgIH1cblxuICAgIHZhciByZWZYUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlgnLCByZWZYKTtcbiAgICB2YXIgcmVmWVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZZJywgcmVmWSk7XG4gICAgdmFyIGhhc1JlZnMgPSByZWZYUHJvcC5oYXNWYWx1ZSgpICYmIHJlZllQcm9wLmhhc1ZhbHVlKCk7XG5cbiAgICBpZiAoaGFzUmVmcykge1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtc2NhbGVNaW4gKiByZWZYUHJvcC5nZXRQaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWVByb3AuZ2V0UGl4ZWxzKCd5JykpO1xuICAgIH1cblxuICAgIGlmIChjbGlwKSB7XG4gICAgICB2YXIgc2NhbGVkQ2xpcFggPSBzY2FsZU1pbiAqIGNsaXBYO1xuICAgICAgdmFyIHNjYWxlZENsaXBZID0gc2NhbGVNaW4gKiBjbGlwWTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oc2NhbGVkQ2xpcFgsIHNjYWxlZENsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGgsIHNjYWxlZENsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHNjYWxlZENsaXBYLCBoZWlnaHQpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1JlZnMpIHtcbiAgICAgIHZhciBpc01lZXRNaW5ZID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVZO1xuICAgICAgdmFyIGlzU2xpY2VNYXhZID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWTtcbiAgICAgIHZhciBpc01lZXRNaW5YID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVYO1xuICAgICAgdmFyIGlzU2xpY2VNYXhYID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWDtcblxuICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNaWQnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIuMCAtIGZpbmFsRGVzaXJlZFdpZHRoIC8gMi4wLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWlkJykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC8gMi4wIC0gZmluYWxEZXNpcmVkSGVpZ2h0IC8gMi4wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNYXgnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAtIGZpbmFsRGVzaXJlZFdpZHRoLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWF4JykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC0gZmluYWxEZXNpcmVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IC8vIHNjYWxlXG5cblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBhbGlnbiA9PT0gJ25vbmUnOlxuICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnOlxuICAgICAgICBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbWVldE9yU2xpY2UgPT09ICdzbGljZSc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIHRyYW5zbGF0ZVxuXG5cbiAgICBjdHgudHJhbnNsYXRlKC1taW5YLCAtbWluWSk7XG4gIH1cblxuICBzdGFydChlbGVtZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGVuYWJsZVJlZHJhdyA9IGZhbHNlLFxuICAgICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFuaW1hdGlvbiA9IGZhbHNlLFxuICAgICAgaWdub3JlRGltZW5zaW9ucyA9IGZhbHNlLFxuICAgICAgaWdub3JlQ2xlYXIgPSBmYWxzZSxcbiAgICAgIGZvcmNlUmVkcmF3LFxuICAgICAgc2NhbGVXaWR0aCxcbiAgICAgIHNjYWxlSGVpZ2h0LFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgRlJBTUVSQVRFLFxuICAgICAgbW91c2VcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBGUkFNRVJBVEU7XG4gICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gZnJhbWVEdXJhdGlvbjtcbiAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlUmVhZHkgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cblxuICAgIGlmICghZW5hYmxlUmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHRoZW4gPSBub3c7XG4gICAgdmFyIGRlbHRhID0gMDtcblxuICAgIHZhciB0aWNrID0gKCkgPT4ge1xuICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGRlbHRhID0gbm93IC0gdGhlbjtcblxuICAgICAgaWYgKGRlbHRhID49IGZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgdGhlbiA9IG5vdyAtIGRlbHRhICUgZnJhbWVEdXJhdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIG1vdXNlLnJ1bkV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICB9O1xuXG4gICAgaWYgKCFpZ25vcmVNb3VzZSkge1xuICAgICAgbW91c2Uuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZS5jYW5jZWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZS5zdG9wKCk7XG4gIH1cblxuICBzaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykge1xuICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICBpZiAoIWlnbm9yZUFuaW1hdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgZnJhbWVEdXJhdGlvblxuICAgICAgfSA9IHRoaXM7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gdGhpcy5hbmltYXRpb25zLnJlZHVjZSgoc2hvdWxkVXBkYXRlLCBhbmltYXRpb24pID0+IGFuaW1hdGlvbi51cGRhdGUoZnJhbWVEdXJhdGlvbikgfHwgc2hvdWxkVXBkYXRlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cblxuXG4gICAgaWYgKHR5cGVvZiBmb3JjZVJlZHJhdyA9PT0gJ2Z1bmN0aW9uJyAmJiBmb3JjZVJlZHJhdygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeUxvY2sgJiYgdGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG5cblxuICAgIGlmICh0aGlzLm1vdXNlLmhhc0V2ZW50cygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIHtcbiAgICAgIENMSUVOVF9XSURUSCxcbiAgICAgIENMSUVOVF9IRUlHSFQsXG4gICAgICB2aWV3UG9ydCxcbiAgICAgIGN0eCxcbiAgICAgIGlzRmlyc3RSZW5kZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICB2aWV3UG9ydC5jbGVhcigpO1xuXG4gICAgaWYgKGNhbnZhcy53aWR0aCAmJiBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoQ0xJRU5UX1dJRFRILCBDTElFTlRfSEVJR0hUKTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgdmFyIGhlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoIWlnbm9yZURpbWVuc2lvbnMgJiYgKGlzRmlyc3RSZW5kZXIgfHwgdHlwZW9mIHNjYWxlV2lkdGggIT09ICdudW1iZXInICYmIHR5cGVvZiBzY2FsZUhlaWdodCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgICBpZiAoY2FudmFzLnN0eWxlKSB7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoY2FudmFzLndpZHRoLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgICBpZiAoY2FudmFzLnN0eWxlKSB7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhcy5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY1dpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoIHx8IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgY0hlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQgfHwgY2FudmFzLmhlaWdodDtcblxuICAgIGlmIChpZ25vcmVEaW1lbnNpb25zICYmIHdpZHRoU3R5bGUuaGFzVmFsdWUoKSAmJiBoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICBjV2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuICAgICAgY0hlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0WCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRZID09PSAnbnVtYmVyJykge1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRZKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInIHx8IHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB2aWV3Qm94ID0gdG9OdW1iZXJzKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIHhSYXRpbyA9IDA7XG4gICAgICB2YXIgeVJhdGlvID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgX3dpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuXG4gICAgICAgIGlmIChfd2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgeFJhdGlvID0gX3dpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4JykgLyBzY2FsZVdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzJdKSkge1xuICAgICAgICAgIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzY2FsZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBfaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgICAgICBpZiAoX2hlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB5UmF0aW8gPSBfaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5JykgLyBzY2FsZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmlld0JveFszXSkpIHtcbiAgICAgICAgICB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF4UmF0aW8pIHtcbiAgICAgICAgeFJhdGlvID0geVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXlSYXRpbykge1xuICAgICAgICB5UmF0aW8gPSB4UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKHNjYWxlV2lkdGgpO1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnNldFZhbHVlKHNjYWxlSGVpZ2h0KTtcbiAgICAgIHZhciB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIHRydWUsIHRydWUpO1xuICAgICAgdHJhbnNmb3JtU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQodHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIFwiIHNjYWxlKFwiKS5jb25jYXQoMS4wIC8geFJhdGlvLCBcIiwgXCIpLmNvbmNhdCgxLjAgLyB5UmF0aW8sIFwiKVwiKSk7XG4gICAgfSAvLyBjbGVhciBhbmQgcmVuZGVyXG5cblxuICAgIGlmICghaWdub3JlQ2xlYXIpIHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY1dpZHRoLCBjSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbmRlcihjdHgpO1xuXG4gICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG59XG5TY3JlZW4uZGVmYXVsdFdpbmRvdyA9IGRlZmF1bHRXaW5kb3c7XG5TY3JlZW4uZGVmYXVsdEZldGNoID0gZGVmYXVsdEZldGNoJDE7XG5cbnZhciB7XG4gIGRlZmF1bHRGZXRjaFxufSA9IFNjcmVlbjtcbnZhciBEZWZhdWx0RE9NUGFyc2VyID0gdHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBET01QYXJzZXIgOiBudWxsO1xuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHtcbiAgICAgIGZldGNoID0gZGVmYXVsdEZldGNoLFxuICAgICAgRE9NUGFyc2VyID0gRGVmYXVsdERPTVBhcnNlclxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB0aGlzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbiAgfVxuXG4gIHBhcnNlKHJlc291cmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHJlc291cmNlLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgICByZXR1cm4gX3RoaXMucGFyc2VGcm9tU3RyaW5nKHJlc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmxvYWQocmVzb3VyY2UpO1xuICAgIH0pKCk7XG4gIH1cblxuICBwYXJzZUZyb21TdHJpbmcoeG1sKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzLkRPTVBhcnNlcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQocGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICdpbWFnZS9zdmcreG1sJykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJykpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICB2YXIgcGFyc2VyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcblxuICAgIGlmIChwYXJzZXJFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlckVycm9yLnRleHRDb250ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBsb2FkKHVybCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBfdGhpczIuZmV0Y2godXJsKTtcbiAgICAgIHZhciB4bWwgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gX3RoaXMyLnBhcnNlRnJvbVN0cmluZyh4bWwpO1xuICAgIH0pKCk7XG4gIH1cblxufVxuXG5jbGFzcyBUcmFuc2xhdGUge1xuICBjb25zdHJ1Y3RvcihfLCBwb2ludCkge1xuICAgIHRoaXMudHlwZSA9ICd0cmFuc2xhdGUnO1xuICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgIHRoaXMucG9pbnQgPSBQb2ludC5wYXJzZShwb2ludCk7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wb2ludDtcbiAgICBjdHgudHJhbnNsYXRlKHggfHwgMC4wLCB5IHx8IDAuMCk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnBvaW50O1xuICAgIGN0eC50cmFuc2xhdGUoLTEuMCAqIHggfHwgMC4wLCAtMS4wICogeSB8fCAwLjApO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMucG9pbnQ7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHggfHwgMC4wLCB5IHx8IDAuMF0pO1xuICB9XG5cbn1cblxuY2xhc3MgUm90YXRlIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHJvdGF0ZSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy50eXBlID0gJ3JvdGF0ZSc7XG4gICAgdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHRoaXMuY3ggPSAwO1xuICAgIHRoaXMuY3kgPSAwO1xuICAgIHZhciBudW1iZXJzID0gdG9OdW1iZXJzKHJvdGF0ZSk7XG4gICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgbnVtYmVyc1swXSk7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB0aGlzLmN4ID0gbnVtYmVyc1sxXSB8fCAwO1xuICAgIHRoaXMuY3kgPSBudW1iZXJzWzJdIHx8IDA7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgucm90YXRlKGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBhbmdsZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5yb3RhdGUoLTEuMCAqIGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIGFuZ2xlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJhZCA9IGFuZ2xlLmdldFJhZGlhbnMoKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgY3ggfHwgMC4wLCBjeSB8fCAwLjAgLy8gdGhpcy5wLnlcbiAgICBdKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbTWF0aC5jb3MocmFkKSwgTWF0aC5zaW4ocmFkKSwgLU1hdGguc2luKHJhZCksIE1hdGguY29zKHJhZCksIDAsIDBdKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLWN4IHx8IDAuMCwgLWN5IHx8IDAuMCAvLyAtdGhpcy5wLnlcbiAgICBdKTtcbiAgfVxuXG59XG5cbmNsYXNzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoXywgc2NhbGUsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMudHlwZSA9ICdzY2FsZSc7XG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHZhciBzY2FsZVNpemUgPSBQb2ludC5wYXJzZVNjYWxlKHNjYWxlKTsgLy8gV29ya2Fyb3VuZCBmb3Igbm9kZS1jYW52YXNcblxuICAgIGlmIChzY2FsZVNpemUueCA9PT0gMCB8fCBzY2FsZVNpemUueSA9PT0gMCkge1xuICAgICAgc2NhbGVTaXplLnggPSBQU0VVRE9fWkVSTztcbiAgICAgIHNjYWxlU2l6ZS55ID0gUFNFVURPX1pFUk87XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlU2l6ZTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0sXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnNjYWxlKHgsIHkgfHwgeCk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBzY2FsZToge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpbllcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5zY2FsZSgxLjAgLyB4LCAxLjAgLyB5IHx8IHgpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMuc2NhbGU7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW3ggfHwgMC4wLCAwLCAwLCB5IHx8IDAuMCwgMCwgMF0pO1xuICB9XG5cbn1cblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoXywgbWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLnR5cGUgPSAnbWF0cml4JztcbiAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgIHRoaXMub3JpZ2luWCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5ZID0gbnVsbDtcbiAgICB0aGlzLm1hdHJpeCA9IHRvTnVtYmVycyhtYXRyaXgpO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBtYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIG1hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBhID0gbWF0cml4WzBdO1xuICAgIHZhciBiID0gbWF0cml4WzJdO1xuICAgIHZhciBjID0gbWF0cml4WzRdO1xuICAgIHZhciBkID0gbWF0cml4WzFdO1xuICAgIHZhciBlID0gbWF0cml4WzNdO1xuICAgIHZhciBmID0gbWF0cml4WzVdO1xuICAgIHZhciBnID0gMC4wO1xuICAgIHZhciBoID0gMC4wO1xuICAgIHZhciBpID0gMS4wO1xuICAgIHZhciBkZXQgPSAxIC8gKGEgKiAoZSAqIGkgLSBmICogaCkgLSBiICogKGQgKiBpIC0gZiAqIGcpICsgYyAqIChkICogaCAtIGUgKiBnKSk7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgudHJhbnNmb3JtKGRldCAqIChlICogaSAtIGYgKiBoKSwgZGV0ICogKGYgKiBnIC0gZCAqIGkpLCBkZXQgKiAoYyAqIGggLSBiICogaSksIGRldCAqIChhICogaSAtIGMgKiBnKSwgZGV0ICogKGIgKiBmIC0gYyAqIGUpLCBkZXQgKiAoYyAqIGQgLSBhICogZikpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0odGhpcy5tYXRyaXgpO1xuICB9XG5cbn1cblxuY2xhc3MgU2tldyBleHRlbmRzIE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB0aGlzLnR5cGUgPSAnc2tldyc7XG4gICAgdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgc2tldyk7XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3WCBleHRlbmRzIFNrZXcge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgdGhpcy50eXBlID0gJ3NrZXdYJztcbiAgICB0aGlzLm1hdHJpeCA9IFsxLCAwLCBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksIDEsIDAsIDBdO1xuICB9XG5cbn1cblxuY2xhc3MgU2tld1kgZXh0ZW5kcyBTa2V3IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHRoaXMudHlwZSA9ICdza2V3WSc7XG4gICAgdGhpcy5tYXRyaXggPSBbMSwgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRyYW5zZm9ybSkudHJpbSgpLnJlcGxhY2UoL1xcKShbYS16QS1aXSkvZywgJykgJDEnKS5yZXBsYWNlKC9cXCkoXFxzPyxcXHM/KS9nLCAnKSAnKS5zcGxpdCgvXFxzKD89W2Etel0pLyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICB2YXIgW3R5cGUsIHZhbHVlXSA9IHRyYW5zZm9ybS5zcGxpdCgnKCcpO1xuICByZXR1cm4gW3R5cGUudHJpbSgpLCB2YWx1ZS50cmltKCkucmVwbGFjZSgnKScsICcnKV07XG59XG5cbmNsYXNzIFRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0pO1xuICAgIGRhdGEuZm9yRWFjaCh0cmFuc2Zvcm0gPT4ge1xuICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFt0eXBlLCB2YWx1ZV0gPSBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgdmFyIFRyYW5zZm9ybVR5cGUgPSBUcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgVHJhbnNmb3JtVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2gobmV3IFRyYW5zZm9ybVR5cGUodGhpcy5kb2N1bWVudCwgdmFsdWUsIHRyYW5zZm9ybU9yaWdpbikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGZyb21FbGVtZW50KGRvY3VtZW50LCBlbGVtZW50KSB7XG4gICAgdmFyIHRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpO1xuICAgIHZhciBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkgPSB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHldID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5zcGxpdCgpO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHldO1xuXG4gICAgaWYgKHRyYW5zZm9ybVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKGRvY3VtZW50LCB0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB0cmFuc2Zvcm1zXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHRyYW5zZm9ybXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYW5zZm9ybXNbaV0udW5hcHBseShjdHgpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBhcHBseVRvUG9pbnQgdW51c2VkIC4uLiByZW1vdmU/XG5cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgdHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybXNbaV0uYXBwbHlUb1BvaW50KHBvaW50KTtcbiAgICB9XG4gIH1cblxufVxuVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzID0ge1xuICB0cmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgcm90YXRlOiBSb3RhdGUsXG4gIHNjYWxlOiBTY2FsZSxcbiAgbWF0cml4OiBNYXRyaXgsXG4gIHNrZXdYOiBTa2V3WCxcbiAgc2tld1k6IFNrZXdZXG59O1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICB2YXIgY2FwdHVyZVRleHROb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gY2FwdHVyZVRleHROb2RlcztcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHkgPSB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSAnJztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIEVMRU1FTlRfTk9ERVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYWRkIGF0dHJpYnV0ZXNcblxuXG4gICAgQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0cmlidXRlID0+IHtcbiAgICAgIHZhciBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpOyAvLyBhZGQgaW5saW5lIHN0eWxlc1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5nZXRTdHJpbmcoKS5zcGxpdCgnOycpLm1hcChfID0+IF8udHJpbSgpKTtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBbbmFtZSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAoXyA9PiBfLnRyaW0oKSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZGVmaW5pdGlvbnNcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIGlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7IC8vIGFkZCBpZFxuXG4gICAgaWYgKGlkLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldKSB7XG4gICAgICAgIGRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUpOyAvLyBFTEVNRU5UX05PREVcbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZVRleHROb2RlcyAmJiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gNCkpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGROb2RlKTtcblxuICAgICAgICBpZiAodGV4dE5vZGUuZ2V0VGV4dCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKHRleHROb2RlKTsgLy8gVEVYVF9OT0RFXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgdmFyIGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIGlmICghYXR0ciAmJiBjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgdmFyIF9hdHRyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gX2F0dHI7XG4gICAgICByZXR1cm4gX2F0dHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHIgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gIH1cblxuICBnZXRIcmVmQXR0cmlidXRlKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJyB8fCBrZXkuZW5kc1dpdGgoJzpocmVmJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIGdldFN0eWxlKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBza2lwQW5jZXN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlc1tuYW1lXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICBpZiAoYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSB2b2lkIDAgJiYgYXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IGF0dHI7IC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuXG4gICAgaWYgKCFza2lwQW5jZXN0b3JzKSB7XG4gICAgICB2YXIge1xuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZShuYW1lKTtcblxuICAgICAgICBpZiAocGFyZW50U3R5bGUgIT09IG51bGwgJiYgcGFyZW50U3R5bGUgIT09IHZvaWQgMCAmJiBwYXJlbnRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICB2YXIgX3N0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBfc3R5bGU7XG4gICAgICByZXR1cm4gX3N0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZSB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIHJlbmRlcihjdHgpIHtcbiAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgLy8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXG4gICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ2Rpc3BsYXknKS5nZXRTdHJpbmcoKSA9PT0gJ25vbmUnIHx8IHRoaXMuZ2V0U3R5bGUoJ3Zpc2liaWxpdHknKS5nZXRTdHJpbmcoKSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBtYXNrXG4gICAgICB2YXIgbWFzayA9IHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgIG1hc2suYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldFZhbHVlKCdub25lJykgIT09ICdub25lJykge1xuICAgICAgLy8gZmlsdGVyXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgIGZpbHRlci5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIHNldENvbnRleHQoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbiAgYXBwbHlFZmZlY3RzKGN0eCkge1xuICAgIC8vIHRyYW5zZm9ybVxuICAgIHZhciB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQodGhpcy5kb2N1bWVudCwgdGhpcyk7XG5cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICB9IC8vIGNsaXBcblxuXG4gICAgdmFyIGNsaXBQYXRoU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpO1xuXG4gICAgaWYgKGNsaXBQYXRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcFBhdGhTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICBjbGlwLmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDb250ZXh0KF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5yZW5kZXIoY3R4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZENoaWxkKGNoaWxkTm9kZSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgPyBjaGlsZE5vZGUgOiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgaWYgKCFFbGVtZW50Lmlnbm9yZUNoaWxkVHlwZXMuaW5jbHVkZXMoY2hpbGQudHlwZSkpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgbWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTtcblxuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIG5vZGUubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlQ2xhc3NlcyA9IChfbm9kZSRnZXRBdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRnZXRBdHRyaWJ1dGUuY2FsbChub2RlLCAnY2xhc3MnKTtcblxuICAgIGlmICghc3R5bGVDbGFzc2VzIHx8IHN0eWxlQ2xhc3NlcyA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVDbGFzc2VzLnNwbGl0KCcgJykuc29tZShzdHlsZUNsYXNzID0+IFwiLlwiLmNvbmNhdChzdHlsZUNsYXNzKSA9PT0gc2VsZWN0b3IpO1xuICB9XG5cbiAgYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIge1xuICAgICAgc3R5bGVzLFxuICAgICAgc3R5bGVzU3BlY2lmaWNpdHlcbiAgICB9ID0gdGhpcy5kb2N1bWVudDtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKCdAJykgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tzZWxlY3Rvcl07XG4gICAgICAgIHZhciBzcGVjaWZpY2l0eSA9IHN0eWxlc1NwZWNpZmljaXR5W3NlbGVjdG9yXTtcblxuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdTcGVjaWZpY2l0eSA9IHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTcGVjaWZpY2l0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdTcGVjaWZpY2l0eSA9ICcwMDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3BlY2lmaWNpdHkgPj0gZXhpc3RpbmdTcGVjaWZpY2l0eSkge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdID0gc3BlY2lmaWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZVN0eWxlcykge1xuICAgIHZhciB0b1Jlc3RvcmUgPSBpZ25vcmVTdHlsZXMucmVkdWNlKCh0b1Jlc3RvcmUsIG5hbWUpID0+IHtcbiAgICAgIHZhciBzdHlsZVByb3AgPSBlbGVtZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICBpZiAoIXN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIHN0eWxlUHJvcC5zZXRWYWx1ZSgnJyk7XG4gICAgICByZXR1cm4gWy4uLnRvUmVzdG9yZSwgW25hbWUsIHZhbHVlXV07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gIH1cblxuICByZXN0b3JlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIHN0eWxlcy5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgdmFyIFtuYW1lLCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgZWxlbWVudC5nZXRTdHlsZShuYW1lLCB0cnVlKS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpc0ZpcnN0Q2hpbGQoKSB7XG4gICAgdmFyIF90aGlzJHBhcmVudDtcblxuICAgIHJldHVybiAoKF90aGlzJHBhcmVudCA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpKSA9PT0gMDtcbiAgfVxuXG59XG5FbGVtZW50Lmlnbm9yZUNoaWxkVHlwZXMgPSBbJ3RpdGxlJ107XG5cbmNsYXNzIFVua25vd25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gd3JhcEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICB2YXIgdHJpbW1lZCA9IGZvbnRGYW1pbHkudHJpbSgpO1xuICByZXR1cm4gL14oJ3xcIikvLnRlc3QodHJpbW1lZCkgPyB0cmltbWVkIDogXCJcXFwiXCIuY29uY2F0KHRyaW1tZWQsIFwiXFxcIlwiKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gZm9udEZhbWlseSA6IGZvbnRGYW1pbHkudHJpbSgpLnNwbGl0KCcsJykubWFwKHdyYXBGb250RmFtaWx5KS5qb2luKCcsJyk7XG59XG4vKipcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtc3R5bGVcclxuICogQHBhcmFtIGZvbnRTdHlsZVxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCBzdHlsZS5cclxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRTdHlsZShmb250U3R5bGUpIHtcbiAgaWYgKCFmb250U3R5bGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGFyZ2V0Rm9udFN0eWxlID0gZm9udFN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFN0eWxlKSB7XG4gICAgY2FzZSAnbm9ybWFsJzpcbiAgICBjYXNlICdpdGFsaWMnOlxuICAgIGNhc2UgJ29ibGlxdWUnOlxuICAgIGNhc2UgJ2luaGVyaXQnOlxuICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eb2JsaXF1ZVxccysoLXwpXFxkK2RlZyQvLnRlc3QodGFyZ2V0Rm9udFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHRcclxuICogQHBhcmFtIGZvbnRXZWlnaHRcclxuICogQHJldHVybnMgQ1NTIGZvbnQgd2VpZ2h0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gIGlmICghZm9udFdlaWdodCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250V2VpZ2h0ID0gZm9udFdlaWdodC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRhcmdldEZvbnRXZWlnaHQpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2JvbGQnOlxuICAgIGNhc2UgJ2xpZ2h0ZXInOlxuICAgIGNhc2UgJ2JvbGRlcic6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eW1xcZC5dKyQvLnRlc3QodGFyZ2V0Rm9udFdlaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5jbGFzcyBGb250IHtcbiAgY29uc3RydWN0b3IoZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpIHtcbiAgICB2YXIgaW5oZXJpdEZvbnQgPSBpbmhlcml0ID8gdHlwZW9mIGluaGVyaXQgPT09ICdzdHJpbmcnID8gRm9udC5wYXJzZShpbmhlcml0KSA6IGluaGVyaXQgOiB7fTtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IGluaGVyaXRGb250LmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplIHx8IGluaGVyaXRGb250LmZvbnRTaXplO1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8IGluaGVyaXRGb250LmZvbnRTdHlsZTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0IHx8IGluaGVyaXRGb250LmZvbnRXZWlnaHQ7XG4gICAgdGhpcy5mb250VmFyaWFudCA9IGZvbnRWYXJpYW50IHx8IGluaGVyaXRGb250LmZvbnRWYXJpYW50O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlKCkge1xuICAgIHZhciBmb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgaW5oZXJpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBmb250U3R5bGUgPSAnJztcbiAgICB2YXIgZm9udFZhcmlhbnQgPSAnJztcbiAgICB2YXIgZm9udFdlaWdodCA9ICcnO1xuICAgIHZhciBmb250U2l6ZSA9ICcnO1xuICAgIHZhciBmb250RmFtaWx5ID0gJyc7XG4gICAgdmFyIHBhcnRzID0gY29tcHJlc3NTcGFjZXMoZm9udCkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgdmFyIHNldCA9IHtcbiAgICAgIGZvbnRTaXplOiBmYWxzZSxcbiAgICAgIGZvbnRTdHlsZTogZmFsc2UsXG4gICAgICBmb250V2VpZ2h0OiBmYWxzZSxcbiAgICAgIGZvbnRWYXJpYW50OiBmYWxzZVxuICAgIH07XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlICFzZXQuZm9udFN0eWxlICYmIEZvbnQuc3R5bGVzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRWYXJpYW50ICYmIEZvbnQudmFyaWFudHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFZhcmlhbnQgPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRXZWlnaHQgJiYgRm9udC53ZWlnaHRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRXZWlnaHQgPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIXNldC5mb250U2l6ZTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBbZm9udFNpemVdID0gcGFydC5zcGxpdCgnLycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250U2l6ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250RmFtaWx5ICs9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGb250KGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBbcHJlcGFyZUZvbnRTdHlsZSh0aGlzLmZvbnRTdHlsZSksIHRoaXMuZm9udFZhcmlhbnQsIHByZXBhcmVGb250V2VpZ2h0KHRoaXMuZm9udFdlaWdodCksIHRoaXMuZm9udFNpemUsIC8vIFdyYXAgZm9udEZhbWlseSBvbmx5IG9uIG5vZGVqcyBhbmQgb25seSBmb3IgY2FudmFzLmN0eFxuICAgIHByZXBhcmVGb250RmFtaWx5KHRoaXMuZm9udEZhbWlseSldLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxufVxuRm9udC5zdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xuRm9udC52YXJpYW50cyA9ICdub3JtYWx8c21hbGwtY2Fwc3xpbmhlcml0JztcbkZvbnQud2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcblxuY2xhc3MgQm91bmRpbmdCb3gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IE51bWJlci5OYU47XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy54MTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLnkxO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICB9XG5cbiAgYWRkUG9pbnQoeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICB0aGlzLngxID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZFgoeCkge1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG4gIH1cblxuICBhZGRZKHkpIHtcbiAgICB0aGlzLmFkZFBvaW50KG51bGwsIHkpO1xuICB9XG5cbiAgYWRkQm91bmRpbmdCb3goYm91bmRpbmdCb3gpIHtcbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IGJvdW5kaW5nQm94O1xuICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gIH1cblxuICBzdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykge1xuICAgIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMykgKiBwMCArIDMgKiBNYXRoLnBvdygxIC0gdCwgMikgKiB0ICogcDEgKyAzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogcDIgKyBNYXRoLnBvdyh0LCAzKSAqIHAzO1xuICB9XG5cbiAgYmV6aWVyQ3VydmVBZGQoZm9yWCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgYiA9IDYgKiBwMCAtIDEyICogcDEgKyA2ICogcDI7XG4gICAgdmFyIGEgPSAtMyAqIHAwICsgOSAqIHAxIC0gOSAqIHAyICsgMyAqIHAzO1xuICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgaWYgKGEgPT09IDApIHtcbiAgICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHQgPSAtYyAvIGI7XG5cbiAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcblxuICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXG4gICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0MiwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZnJvbSBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcblxuXG4gIGFkZEJlemllckN1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgdGhpcy5hZGRQb2ludChwMHgsIHAweSk7XG4gICAgdGhpcy5hZGRQb2ludChwM3gsIHAzeSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZUFkZCh0cnVlLCBwMHgsIHAxeCwgcDJ4LCBwM3gpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQoZmFsc2UsIHAweSwgcDF5LCBwMnksIHAzeSk7XG4gIH1cblxuICBhZGRRdWFkcmF0aWNDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGNwMXggPSBwMHggKyAyIC8gMyAqIChwMXggLSBwMHgpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuXG4gICAgdmFyIGNwMXkgPSBwMHkgKyAyIC8gMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuXG4gICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAocDJ4IC0gcDB4KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgIHZhciBjcDJ5ID0gY3AxeSArIDEgLyAzICogKHAyeSAtIHAweSk7IC8vIENQMiA9IENQMSArIDEvMyAqKFFQMi1RUDApXG5cbiAgICB0aGlzLmFkZEJlemllckN1cnZlKHAweCwgcDB5LCBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LCBwMngsIHAyeSk7XG4gIH1cblxuICBpc1BvaW50SW5Cb3goeCwgeSkge1xuICAgIHZhciB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICB9XG5cbn1cblxuY2xhc3MgUGF0aFBhcnNlciBleHRlbmRzIFNWR1BhdGhEYXRhIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHN1cGVyKHBhdGggLy8gRml4IHNwYWNlcyBhZnRlciBzaWducy5cbiAgICAucmVwbGFjZSgvKFsrXFwtLl0pXFxzKy9nbSwgJyQxJykgLy8gUmVtb3ZlIGludmFsaWQgcGFydC5cbiAgICAucmVwbGFjZSgvW15NbVp6TGxIaFZ2Q2NTc1FxVHRBYWVcXGRcXHMuLCstXS4qL2csICcnKSk7XG4gICAgdGhpcy5jb250cm9sID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5jb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgdGhpcy5pID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaSA9IC0xO1xuICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuYW5nbGVzID0gW107XG4gIH1cblxuICBpc0VuZCgpIHtcbiAgICB2YXIge1xuICAgICAgaSxcbiAgICAgIGNvbW1hbmRzXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGkgPj0gY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzWysrdGhpcy5pXTtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IHRoaXMuY29tbWFuZDtcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIHJldHVybiBjb21tYW5kO1xuICB9XG5cbiAgZ2V0UG9pbnQoKSB7XG4gICAgdmFyIHhQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAneCc7XG4gICAgdmFyIHlQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneSc7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHRoaXMuY29tbWFuZFt4UHJvcF0sIHRoaXMuY29tbWFuZFt5UHJvcF0pO1xuICAgIHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwb2ludCk7XG4gIH1cblxuICBnZXRBc0NvbnRyb2xQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgdGhpcy5jb250cm9sID0gcG9pbnQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgZ2V0QXNDdXJyZW50UG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5nZXRQb2ludCh4UHJvcCwgeVByb3ApO1xuICAgIHRoaXMuY3VycmVudCA9IHBvaW50O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIGdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpIHtcbiAgICB2YXIgcHJldmlvdXNDb21tYW5kID0gdGhpcy5wcmV2aW91c0NvbW1hbmQudHlwZTtcblxuICAgIGlmIChwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLkNVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuU01PT1RIX0NVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuUVVBRF9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9RVUFEX1RPKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH0gLy8gcmVmbGVjdCBwb2ludFxuXG5cbiAgICB2YXIge1xuICAgICAgY3VycmVudDoge1xuICAgICAgICB4OiBjeCxcbiAgICAgICAgeTogY3lcbiAgICAgIH0sXG4gICAgICBjb250cm9sOiB7XG4gICAgICAgIHg6IG94LFxuICAgICAgICB5OiBveVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgyICogY3ggLSBveCwgMiAqIGN5IC0gb3kpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIG1ha2VBYnNvbHV0ZShwb2ludCkge1xuICAgIGlmICh0aGlzLmNvbW1hbmQucmVsYXRpdmUpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBwb2ludC54ICs9IHg7XG4gICAgICBwb2ludC55ICs9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgYWRkTWFya2VyKHBvaW50LCBmcm9tLCBwcmlvclRvKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50cyxcbiAgICAgIGFuZ2xlc1xuICAgIH0gPSB0aGlzOyAvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cblxuICAgIGlmIChwcmlvclRvICYmIGFuZ2xlcy5sZW5ndGggPiAwICYmICFhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5hbmdsZVRvKHByaW9yVG8pO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocG9pbnQsIGZyb20gPyBmcm9tLmFuZ2xlVG8ocG9pbnQpIDogbnVsbCk7XG4gIH1cblxuICBhZGRNYXJrZXJBbmdsZShwb2ludCwgYW5nbGUpIHtcbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB0aGlzLmFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgfVxuXG4gIGdldE1hcmtlclBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gIH1cblxuICBnZXRNYXJrZXJBbmdsZXMoKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuZ2xlc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSBhbmdsZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFhbmdsZXNbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBpZiAoYW5nbGVzW2pdKSB7XG4gICAgICAgICAgICBhbmdsZXNbaV0gPSBhbmdsZXNbal07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGVzO1xuICB9XG5cbn1cblxuY2xhc3MgUmVuZGVyZWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG4gIH1cblxuICBjYWxjdWxhdGVPcGFjaXR5KCkge1xuICAgIHZhciBvcGFjaXR5ID0gMS4wOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvcGFjaXR5U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdvcGFjaXR5JywgZmFsc2UsIHRydWUpOyAvLyBubyBhbmNlc3RvcnMgb24gc3R5bGUgY2FsbFxuXG4gICAgICBpZiAob3BhY2l0eVN0eWxlLmhhc1ZhbHVlKHRydWUpKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gb3BhY2l0eVN0eWxlLmdldE51bWJlcigpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wYWNpdHk7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHZhciBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAvLyBjYXVzZXMgc3RhY2sgb3ZlcmZsb3cgd2hlbiBtZWFzdXJpbmcgdGV4dCB3aXRoIGdyYWRpZW50c1xuICAgICAgLy8gZmlsbFxuICAgICAgdmFyIGZpbGxTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsJyk7XG4gICAgICB2YXIgZmlsbE9wYWNpdHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UnKTtcbiAgICAgIHZhciBzdHJva2VPcGFjaXR5UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1vcGFjaXR5Jyk7XG5cbiAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgZmlsbE9wYWNpdHlTdHlsZVByb3ApO1xuXG4gICAgICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGxTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBpZiAoZmlsbFN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICBmaWxsU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2ZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0Q29sb3IoKTtcblxuICAgICAgICBpZiAoX2ZpbGxTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9maWxsU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IF9maWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxPcGFjaXR5U3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIF9maWxsU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgY3R4LmZpbGxTdHlsZSkuYWRkT3BhY2l0eShmaWxsT3BhY2l0eVN0eWxlUHJvcCkuZ2V0Q29sb3IoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZTI7XG4gICAgICB9IC8vIHN0cm9rZVxuXG5cbiAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgc3Ryb2tlT3BhY2l0eVByb3ApO1xuXG4gICAgICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cm9rZVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCkgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpO1xuXG4gICAgICAgIGlmIChfc3Ryb2tlU3R5bGUgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9zdHJva2VTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogX3N0cm9rZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBfc3Ryb2tlU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpLmFkZE9wYWNpdHkoc3Ryb2tlT3BhY2l0eVByb3ApLmdldFN0cmluZygpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9zdHJva2VTdHlsZTI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VXaWR0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS13aWR0aCcpO1xuXG4gICAgICBpZiAoc3Ryb2tlV2lkdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgbmV3TGluZVdpZHRoID0gc3Ryb2tlV2lkdGhTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAhbmV3TGluZVdpZHRoID8gUFNFVURPX1pFUk8gLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwIChvciBub2RlLWNhbnZhcz8gOi0pXG4gICAgICAgIDogbmV3TGluZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Ryb2tlTGluZWNhcFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lY2FwJyk7XG4gICAgICB2YXIgc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWpvaW4nKTtcbiAgICAgIHZhciBzdHJva2VNaXRlcmxpbWl0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0Jyk7IC8vIE5FRUQgVEVTVFxuICAgICAgLy8gY29uc3QgcG9pbnRPcmRlclN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3BhaW50LW9yZGVyJyk7XG5cbiAgICAgIHZhciBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gICAgICB2YXIgc3Ryb2tlRGFzaG9mZnNldFByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXG4gICAgICBpZiAoc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VNaXRlcmxpbWl0UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gc3Ryb2tlTWl0ZXJsaW1pdFByb3AuZ2V0TnVtYmVyKCk7XG4gICAgICB9IC8vIE5FRUQgVEVTVFxuICAgICAgLy8gaWYgKHBvaW50T3JkZXJTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gXHQvLyA/XG4gICAgICAvLyBcdGN0eC5wYWludE9yZGVyID0gcG9pbnRPcmRlclN0eWxlUHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgLy8gfVxuXG5cbiAgICAgIGlmIChzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuaGFzVmFsdWUoKSAmJiBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkgIT09ICdub25lJykge1xuICAgICAgICB2YXIgZ2FwcyA9IHRvTnVtYmVycyhzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChnYXBzKTtcbiAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzO1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT09ICd1bmRlZmluZWQnICYmICEoZ2Fwcy5sZW5ndGggPT09IDEgJiYgZ2Fwc1swXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZ2FwcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gc3Ryb2tlRGFzaG9mZnNldFByb3AuZ2V0UGl4ZWxzKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdHgubGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5tb3pEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBmb250XG5cblxuICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBmb250U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udCcpO1xuICAgICAgdmFyIGZvbnRTdHlsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKTtcbiAgICAgIHZhciBmb250VmFyaWFudFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtdmFyaWFudCcpO1xuICAgICAgdmFyIGZvbnRXZWlnaHRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXdlaWdodCcpO1xuICAgICAgdmFyIGZvbnRTaXplU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zaXplJyk7XG4gICAgICB2YXIgZm9udEZhbWlseVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgICB2YXIgZm9udCA9IG5ldyBGb250KGZvbnRTdHlsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFZhcmlhbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRXZWlnaHRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRTaXplU3R5bGVQcm9wLmhhc1ZhbHVlKCkgPyBcIlwiLmNvbmNhdChmb250U2l6ZVN0eWxlUHJvcC5nZXRQaXhlbHModHJ1ZSksIFwicHhcIikgOiAnJywgZm9udEZhbWlseVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgRm9udC5wYXJzZShmb250U3R5bGVQcm9wLmdldFN0cmluZygpLCBjdHguZm9udCkpO1xuICAgICAgZm9udFN0eWxlU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFN0eWxlKTtcbiAgICAgIGZvbnRWYXJpYW50U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFZhcmlhbnQpO1xuICAgICAgZm9udFdlaWdodFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRXZWlnaHQpO1xuICAgICAgZm9udFNpemVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U2l6ZSk7XG4gICAgICBmb250RmFtaWx5U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udEZhbWlseSk7XG4gICAgICBjdHguZm9udCA9IGZvbnQudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKGZvbnRTaXplU3R5bGVQcm9wLmlzUGl4ZWxzKCkpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5lbVNpemUgPSBmb250U2l6ZVN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAvLyBlZmZlY3RzXG4gICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpOyAvLyBvcGFjaXR5XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgIGlmICh0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2spIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQucG9wRW1TaXplKCk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUGF0aEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncGF0aCc7XG4gICAgdGhpcy5wYXRoUGFyc2VyID0gbnVsbDtcbiAgICB0aGlzLnBhdGhQYXJzZXIgPSBuZXcgUGF0aFBhcnNlcih0aGlzLmdldEF0dHJpYnV0ZSgnZCcpLmdldFN0cmluZygpKTtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICBwYXRoUGFyc2VyLnJlc2V0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFwYXRoUGFyc2VyLmlzRW5kKCkpIHtcbiAgICAgIHN3aXRjaCAocGF0aFBhcnNlci5uZXh0KCkudHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhNKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEwoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoSChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFYoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhTKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFQoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB0aGlzLnBhdGhBKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIHRoaXMucGF0aFooY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goXykge1xuICAgIHJldHVybiB0aGlzLnBhdGgoKTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcG9pbnRzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICB2YXIgYW5nbGVzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcbiAgICB2YXIgbWFya2VycyA9IHBvaW50cy5tYXAoKHBvaW50LCBpKSA9PiBbcG9pbnQsIGFuZ2xlc1tpXV0pO1xuICAgIHJldHVybiBtYXJrZXJzO1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdGhpcy5wYXRoKGN0eCk7XG4gICAgdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgdmFyIGZpbGxSdWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1ydWxlJyk7XG5cbiAgICBpZiAoY3R4LmZpbGxTdHlsZSAhPT0gJycpIHtcbiAgICAgIGlmIChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoJ2luaGVyaXQnKSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGN0eC5maWxsKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gJycpIHtcbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgndmVjdG9yLWVmZmVjdCcpLmdldFN0cmluZygpID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJykge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcblxuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2Vyc0xhc3RJbmRleCA9IG1hcmtlcnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBtYXJrZXJTdGFydFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1zdGFydCcpO1xuICAgICAgdmFyIG1hcmtlck1pZFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1taWQnKTtcbiAgICAgIHZhciBtYXJrZXJFbmRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItZW5kJyk7XG5cbiAgICAgIGlmIChtYXJrZXJTdGFydFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyU3RhcnRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICB2YXIgW3BvaW50LCBhbmdsZV0gPSBtYXJrZXJzWzBdO1xuICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmtlck1pZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgX21hcmtlciA9IG1hcmtlck1pZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXJrZXJzTGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICB2YXIgW19wb2ludCwgX2FuZ2xlXSA9IG1hcmtlcnNbaV07XG5cbiAgICAgICAgICBfbWFya2VyLnJlbmRlcihjdHgsIF9wb2ludCwgX2FuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyRW5kU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBfbWFya2VyMiA9IG1hcmtlckVuZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgdmFyIFtfcG9pbnQyLCBfYW5nbGUyXSA9IG1hcmtlcnNbbWFya2Vyc0xhc3RJbmRleF07XG5cbiAgICAgICAgX21hcmtlcjIucmVuZGVyKGN0eCwgX3BvaW50MiwgX2FuZ2xlMik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhNKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcGF0aFBhcnNlci5zdGFydCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aE0oY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoTChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoTChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoSChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC54IDogMCkgKyBjb21tYW5kLngsIGN1cnJlbnQueSk7XG4gICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoSChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoVihwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KGN1cnJlbnQueCwgKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnkgOiAwKSArIGNvbW1hbmQueSk7XG4gICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoVihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhWKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoQyhwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldFBvaW50KCd4MScsICd5MScpO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MicsICd5MicpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoQyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFMocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFMoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgcG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhRKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MScsICd5MScpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUXVhZHJhdGljQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFQocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgcGF0aFBhcnNlci5jb250cm9sID0gY29udHJvbFBvaW50O1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFQoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUXVhZHJhdGljQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aEEocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWFuZFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciB7XG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgeFJvdCxcbiAgICAgIGxBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnXG4gICAgfSA9IGNvbW1hbmQ7XG4gICAgdmFyIHhBeGlzUm90YXRpb24gPSB4Um90ICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTsgLy8gQ29udmVyc2lvbiBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgLy8geDEnLCB5MSdcblxuICAgIHZhciBjdXJycCA9IG5ldyBQb2ludChNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnggLSBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLjAsIC1NYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnggLSBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLjApOyAvLyBhZGp1c3QgcmFkaWlcblxuICAgIHZhciBsID0gTWF0aC5wb3coY3VycnAueCwgMikgLyBNYXRoLnBvdyhyWCwgMikgKyBNYXRoLnBvdyhjdXJycC55LCAyKSAvIE1hdGgucG93KHJZLCAyKTtcblxuICAgIGlmIChsID4gMSkge1xuICAgICAgclggKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgclkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgIH0gLy8gY3gnLCBjeSdcblxuXG4gICAgdmFyIHMgPSAobEFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KHJZLCAyKSAtIE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpIC0gTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpIC8gKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpICsgTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpKTtcblxuICAgIGlmIChpc05hTihzKSkge1xuICAgICAgcyA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNwcCA9IG5ldyBQb2ludChzICogclggKiBjdXJycC55IC8gclksIHMgKiAtclkgKiBjdXJycC54IC8gclgpOyAvLyBjeCwgY3lcblxuICAgIHZhciBjZW50cCA9IG5ldyBQb2ludCgoY3VycmVudC54ICsgY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksIChjdXJyZW50LnkgKyBjdXJyZW50UG9pbnQueSkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC54ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueSk7IC8vIGluaXRpYWwgYW5nbGVcblxuICAgIHZhciBhMSA9IHZlY3RvcnNBbmdsZShbMSwgMF0sIFsoY3VycnAueCAtIGNwcC54KSAvIHJYLCAoY3VycnAueSAtIGNwcC55KSAvIHJZXSk7IC8vIM64MVxuICAgIC8vIGFuZ2xlIGRlbHRhXG5cbiAgICB2YXIgdSA9IFsoY3VycnAueCAtIGNwcC54KSAvIHJYLCAoY3VycnAueSAtIGNwcC55KSAvIHJZXTtcbiAgICB2YXIgdiA9IFsoLWN1cnJwLnggLSBjcHAueCkgLyByWCwgKC1jdXJycC55IC0gY3BwLnkpIC8gclldO1xuICAgIHZhciBhZCA9IHZlY3RvcnNBbmdsZSh1LCB2KTsgLy8gzpTOuFxuXG4gICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgYWQgPSBNYXRoLlBJO1xuICAgIH1cblxuICAgIGlmICh2ZWN0b3JzUmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgYWQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50UG9pbnQsXG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGNlbnRwLFxuICAgICAgYTEsXG4gICAgICBhZFxuICAgIH07XG4gIH1cblxuICBwYXRoQShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudFBvaW50LFxuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBjZW50cCxcbiAgICAgIGExLFxuICAgICAgYWRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlcik7IC8vIGZvciBtYXJrZXJzXG5cbiAgICB2YXIgZGlyID0gMSAtIHN3ZWVwRmxhZyA/IDEuMCA6IC0xLjA7XG4gICAgdmFyIGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyLjApO1xuICAgIHZhciBoYWxmV2F5ID0gbmV3IFBvaW50KGNlbnRwLnggKyByWCAqIE1hdGguY29zKGFoKSwgY2VudHAueSArIHJZICogTWF0aC5zaW4oYWgpKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoY3VycmVudFBvaW50LCBhaCAtIGRpciAqIE1hdGguUEkpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7IC8vIFRPRE86IHRoaXMgaXMgdG9vIG5haXZlLCBtYWtlIGl0IGJldHRlclxuXG4gICAgaWYgKGN0eCAmJiAhaXNOYU4oYTEpICYmICFpc05hTihhZCkpIHtcbiAgICAgIHZhciByID0gclggPiByWSA/IHJYIDogclk7XG4gICAgICB2YXIgc3ggPSByWCA+IHJZID8gMSA6IHJYIC8gclk7XG4gICAgICB2YXIgc3kgPSByWCA+IHJZID8gclkgLyByWCA6IDE7XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRwLngsIGNlbnRwLnkpO1xuICAgICAgY3R4LnJvdGF0ZSh4QXhpc1JvdGF0aW9uKTtcbiAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuICAgICAgY3R4LmFyYygwLCAwLCByLCBhMSwgYTEgKyBhZCwgQm9vbGVhbigxIC0gc3dlZXBGbGFnKSk7XG4gICAgICBjdHguc2NhbGUoMSAvIHN4LCAxIC8gc3kpO1xuICAgICAgY3R4LnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XG4gICAgICBjdHgudHJhbnNsYXRlKC1jZW50cC54LCAtY2VudHAueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhaKHBhdGhQYXJzZXIpIHtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwYXRoUGFyc2VyLnN0YXJ0O1xuICB9XG5cbiAgcGF0aFooY3R4LCBib3VuZGluZ0JveCkge1xuICAgIFBhdGhFbGVtZW50LnBhdGhaKHRoaXMucGF0aFBhcnNlcik7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICAvLyBvbmx5IGNsb3NlIHBhdGggaWYgaXQgaXMgbm90IGEgc3RyYWlnaHQgbGluZVxuICAgICAgaWYgKGJvdW5kaW5nQm94LngxICE9PSBib3VuZGluZ0JveC54MiAmJiBib3VuZGluZ0JveC55MSAhPT0gYm91bmRpbmdCb3gueTIpIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIEdseXBoRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2dseXBoJztcbiAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIHRoaXMudW5pY29kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1bmljb2RlJykuZ2V0U3RyaW5nKCk7XG4gICAgdGhpcy5hcmFiaWNGb3JtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FyYWJpYy1mb3JtJykuZ2V0U3RyaW5nKCk7XG4gIH1cblxufVxuXG5jbGFzcyBUZXh0RWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIG5ldy50YXJnZXQgPT09IFRleHRFbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5tZWFzdXJlQ2FjaGUgPSAtMTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBzdXBlci5zZXRDb250ZXh0KGN0eCwgZnJvbU1lYXN1cmUpO1xuICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aGlzLmdldFN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpIHx8IHRoaXMuZ2V0U3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpO1xuXG4gICAgaWYgKHRleHRCYXNlbGluZSkge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICB9XG4gIH1cblxuICBpbml0aWFsaXplQ29vcmRpbmF0ZXMoKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGVhZlRleHRzID0gW107XG4gICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IDA7XG4gICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpO1xuICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBudWxsOyAvLyB0aGVuIGNhbGN1bGF0ZSBib3VuZGluZyBib3hcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdmFyIGNoaWxkQm91bmRpbmdCb3ggPSB0aGlzLmdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0aGlzLCB0aGlzLCBpKTtcblxuICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICBib3VuZGluZ0JveCA9IGNoaWxkQm91bmRpbmdCb3g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRGb250U2l6ZSgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgaW5oZXJpdEZvbnRTaXplID0gRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemU7XG4gICAgdmFyIGZvbnRTaXplID0gcGFyZW50LmdldFN0eWxlKCdmb250LXNpemUnKS5nZXROdW1iZXIoaW5oZXJpdEZvbnRTaXplKTtcbiAgICByZXR1cm4gZm9udFNpemU7XG4gIH1cblxuICBnZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUsIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KTtcbiAgfVxuXG4gIGdldEdseXBoKGZvbnQsIHRleHQsIGkpIHtcbiAgICB2YXIgY2hhciA9IHRleHRbaV07XG4gICAgdmFyIGdseXBoID0gbnVsbDtcblxuICAgIGlmIChmb250LmlzQXJhYmljKSB7XG4gICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICB2YXIgcHJldkNoYXIgPSB0ZXh0W2kgLSAxXTtcbiAgICAgIHZhciBuZXh0Q2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgdmFyIGFyYWJpY0Zvcm0gPSAnaXNvbGF0ZWQnO1xuXG4gICAgICBpZiAoKGkgPT09IDAgfHwgcHJldkNoYXIgPT09ICcgJykgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCAmJiBwcmV2Q2hhciAhPT0gJyAnICYmIChpID09PSBsZW4gLSAxIHx8IG5leHRDaGFyID09PSAnICcpKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZm9udC5nbHlwaHNbY2hhcl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICB2YXIgbWF5YmVHbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgICBnbHlwaCA9IG1heWJlR2x5cGggaW5zdGFuY2VvZiBHbHlwaEVsZW1lbnQgPyBtYXliZUdseXBoIDogbWF5YmVHbHlwaFthcmFiaWNGb3JtXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tjaGFyXTtcbiAgICB9XG5cbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICBnbHlwaCA9IGZvbnQubWlzc2luZ0dseXBoO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0VGV4dEZyb21Ob2RlKG5vZGUpIHtcbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlIHx8IHRoaXMubm9kZTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LmZyb20odGV4dE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgaW5kZXggPSBjaGlsZE5vZGVzLmluZGV4T2YodGV4dE5vZGUpO1xuICAgIHZhciBsYXN0SW5kZXggPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIHRleHQgPSBjb21wcmVzc1NwYWNlcyggLy8gdGV4dE5vZGUudmFsdWVcbiAgICAvLyB8fCB0ZXh0Tm9kZS50ZXh0XG4gICAgdGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICB0ZXh0ID0gdHJpbUxlZnQodGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgIHRleHQgPSB0cmltUmlnaHQodGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIHRoaXMucmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTsgLy8gdGhlbiByZW5kZXJcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZChjdHgsIHRoaXMsIHRoaXMsIGkpO1xuICAgIH0pO1xuICAgIHZhciB7XG4gICAgICBtb3VzZVxuICAgIH0gPSB0aGlzLmRvY3VtZW50LnNjcmVlbjsgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuXG4gICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIHRoaXMuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICB2YXIge1xuICAgICAgICB1bml0c1BlckVtXG4gICAgICB9ID0gY3VzdG9tRm9udC5mb250RmFjZTtcbiAgICAgIHZhciBjdHhGb250ID0gRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCk7XG4gICAgICB2YXIgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihjdHhGb250LmZvbnRTaXplKTtcbiAgICAgIHZhciBmb250U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKS5nZXRTdHJpbmcoY3R4Rm9udC5mb250U3R5bGUpO1xuICAgICAgdmFyIHNjYWxlID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gcmVuZGVyVGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogcmVuZGVyVGV4dDtcbiAgICAgIHZhciBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCAtc2NhbGUpO1xuICAgICAgICB2YXIgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gY3R4LmxpbmVXaWR0aCAqIHVuaXRzUGVyRW0gLyBmb250U2l6ZTtcblxuICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG5cbiAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIC0uNCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGUsIC0xIC8gc2NhbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLngsIC10aGlzLnkpO1xuICAgICAgICB0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIHVuaXRzUGVyRW07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgIHRoaXMueCArPSBkeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7IC8vIE5FRUQgVEVTVFxuICAgIC8vIGlmIChjdHgucGFpbnRPcmRlciA9PT0gJ3N0cm9rZScpIHtcbiAgICAvLyBcdGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAvLyBcdFx0Y3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgLy8gXHR9XG4gICAgLy8gXHRpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgIC8vIFx0XHRjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgLy8gXHR9XG4gICAgLy8gfSBlbHNlIHtcblxuICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICBjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgY3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgfSAvLyB9XG5cbiAgfVxuXG4gIGFwcGx5QW5jaG9yaW5nKCkge1xuICAgIGlmICh0aGlzLnRleHRDaHVua1N0YXJ0ID49IHRoaXMubGVhZlRleHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIFwiQXBwbHkgYW5jaG9yaW5nXCIgcGFydCBvZiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMi90ZXh0Lmh0bWwjVGV4dExheW91dEFsZ29yaXRobS5cbiAgICAvLyBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGFwcGx5IHRoZSBhbmNob3JpbmcgYXMgc29vbiBhcyBhIGNodW5rIGlzIGZpbmlzaGVkLiBUaGlzIHNhdmVzIHNvbWUgZXh0cmEgbG9vcGluZy5cbiAgICAvLyBWZXJ0aWNhbCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQuXG5cblxuICAgIHZhciBmaXJzdEVsZW1lbnQgPSB0aGlzLmxlYWZUZXh0c1t0aGlzLnRleHRDaHVua1N0YXJ0XTtcbiAgICB2YXIgdGV4dEFuY2hvciA9IGZpcnN0RWxlbWVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgdmFyIGlzUlRMID0gZmFsc2U7IC8vIHdlIHRyZWF0IFJUTCBsaWtlIExUUlxuXG4gICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgIGlmICh0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnZW5kJyAmJiBpc1JUTCkge1xuICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtIHRoaXMubWluWDtcbiAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IgPT09ICdlbmQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmIGlzUlRMKSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5tYXhYO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgLyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSB0aGlzLnRleHRDaHVua1N0YXJ0OyBpIDwgdGhpcy5sZWFmVGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubGVhZlRleHRzW2ldLnggKz0gc2hpZnQ7XG4gICAgfSAvLyBzdGFydCBuZXcgY2h1bmtcblxuXG4gICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoO1xuICB9XG5cbiAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5QW5jaG9yaW5nKCk7XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcblxuICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIHRleHRQYXJlbnQuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSBsZWFmcyBhcmUgcmVsZXZhbnRcbiAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSk7XG4gICAgfVxuICB9XG5cbiAgYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcblxuICAgIGlmICh0eXBlb2YgY2hpbGQubWVhc3VyZVRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGNoaWxkLnNldENvbnRleHQoY3R4LCB0cnVlKTtcbiAgICB2YXIgeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICB2YXIgZHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeCcpO1xuICAgIHZhciBkeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R5Jyk7XG4gICAgdmFyIGN1c3RvbUZvbnQgPSBjaGlsZC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgdmFyIGlzUlRMID0gQm9vbGVhbihjdXN0b21Gb250KSAmJiBjdXN0b21Gb250LmlzUlRMO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIC8vIEZpcnN0IGNoaWxkcmVuIGluaGVyaXQgYXR0cmlidXRlcyBmcm9tIHBhcmVudChzKS4gUG9zaXRpb25hbCBhdHRyaWJ1dGVzXG4gICAgICAvLyBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdCdzIGZpcnN0IGNoaWxkLlxuICAgICAgaWYgKCF4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHhBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgneCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHlBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgneScpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBkeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCdkeCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBkeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCdkeScpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBjaGlsZC5tZWFzdXJlVGV4dChjdHgpO1xuXG4gICAgaWYgKGlzUlRMKSB7XG4gICAgICB0ZXh0UGFyZW50LnggLT0gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIGFuIFwieFwiIGF0dHJpYnV0ZSBtYXJrcyB0aGUgc3RhcnQgb2YgYSBuZXcgY2h1bmtcbiAgICAgIHRleHRQYXJlbnQuYXBwbHlBbmNob3JpbmcoKTtcbiAgICAgIGNoaWxkLnggPSB4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNoaWxkLnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGV4dFBhcmVudC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQueCA9IHRleHRQYXJlbnQueDtcbiAgICB9XG5cbiAgICB0ZXh0UGFyZW50LnggPSBjaGlsZC54O1xuXG4gICAgaWYgKCFpc1JUTCkge1xuICAgICAgdGV4dFBhcmVudC54ICs9IHdpZHRoO1xuICAgIH1cblxuICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBjaGlsZC55ID0geUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjaGlsZC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRleHRQYXJlbnQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnkgPSB0ZXh0UGFyZW50Lnk7XG4gICAgfVxuXG4gICAgdGV4dFBhcmVudC55ID0gY2hpbGQueTsgLy8gdXBkYXRlIHRoZSBjdXJyZW50IGNodW5rIGFuZCBpdCdzIGJvdW5kc1xuXG4gICAgdGV4dFBhcmVudC5sZWFmVGV4dHMucHVzaChjaGlsZCk7XG4gICAgdGV4dFBhcmVudC5taW5YID0gTWF0aC5taW4odGV4dFBhcmVudC5taW5YLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgIHRleHRQYXJlbnQubWF4WCA9IE1hdGgubWF4KHRleHRQYXJlbnQubWF4WCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICBjaGlsZC5jbGVhckNvbnRleHQoY3R4KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIGdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07IC8vIG5vdCBhIHRleHQgbm9kZT9cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuZ2V0Qm91bmRpbmdCb3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBib3VuZGluZ0JveCA9IGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IHRleHRQYXJlbnQuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIHJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHRleHRQYXJlbnQucmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgfSk7XG4gIH1cblxuICBtZWFzdXJlVGV4dChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgbWVhc3VyZUNhY2hlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAofm1lYXN1cmVDYWNoZSkge1xuICAgICAgcmV0dXJuIG1lYXN1cmVDYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHJlbmRlclRleHQpO1xuICAgIHRoaXMubWVhc3VyZUNhY2hlID0gbWVhc3VyZTtcbiAgICByZXR1cm4gbWVhc3VyZTtcbiAgfVxuXG4gIG1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCkge1xuICAgIGlmICghdGFyZ2V0VGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoY3VzdG9tRm9udCkge1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gdGFyZ2V0VGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogdGFyZ2V0VGV4dDtcbiAgICAgIHZhciBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBfbWVhc3VyZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgX21lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcblxuICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgX21lYXN1cmUgKz0gZHhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tZWFzdXJlO1xuICAgIH1cblxuICAgIGlmICghY3R4Lm1lYXN1cmVUZXh0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0VGV4dC5sZW5ndGggKiAxMDtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIHRoaXMuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgIHZhciB7XG4gICAgICB3aWR0aDogbWVhc3VyZVxuICAgIH0gPSBjdHgubWVhc3VyZVRleHQodGFyZ2V0VGV4dCk7XG4gICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaGVyaXRzIHBvc2l0aW9uYWwgYXR0cmlidXRlcyBmcm9tIHtAbGluayBUZXh0RWxlbWVudH0gcGFyZW50KHMpLiBBdHRyaWJ1dGVzXHJcbiAgICogYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXRzIGZpcnN0IGNoaWxkLlxyXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lLlxyXG4gICAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb3IgbnVsbC5cclxuICAgKi9cblxuXG4gIGdldEluaGVyaXRlZEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLGNvbnNpc3RlbnQtdGhpc1xuICAgIHZhciBjdXJyZW50ID0gdGhpcztcblxuICAgIHdoaWxlIChjdXJyZW50IGluc3RhbmNlb2YgVGV4dEVsZW1lbnQgJiYgY3VycmVudC5pc0ZpcnN0Q2hpbGQoKSkge1xuICAgICAgdmFyIHBhcmVudEF0dHIgPSBjdXJyZW50LnBhcmVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgIGlmIChwYXJlbnRBdHRyLmhhc1ZhbHVlKHRydWUpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRBdHRyLmdldFZhbHVlKCcwJyk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIFRTcGFuRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVFNwYW5FbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICd0c3Bhbic7IC8vIGlmIHRoaXMgbm9kZSBoYXMgY2hpbGRyZW4sIHRoZW4gdGhleSBvd24gdGhlIHRleHRcblxuICAgIHRoaXMudGV4dCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCA/ICcnIDogdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG59XG5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVFNwYW5FbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndGV4dE5vZGUnO1xuICB9XG5cbn1cblxuY2xhc3MgU1ZHRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3N2Zyc7XG4gICAgdGhpcy5yb290ID0gZmFsc2U7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHZhciBfdGhpcyRub2RlJHBhcmVudE5vZGU7XG5cbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgc2NyZWVuLFxuICAgICAgd2luZG93XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIHNjcmVlbi5zZXREZWZhdWx0cyhjdHgpO1xuXG4gICAgaWYgKGNhbnZhcy5zdHlsZSAmJiB0eXBlb2YgY3R4LmZvbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjdHguZm9udCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNhbnZhcykuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xuICAgICAgdmFyIGZvbnRTaXplUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShjdHguZm9udCkuZm9udFNpemUpO1xuXG4gICAgICBpZiAoZm9udFNpemVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgZG9jdW1lbnQucm9vdEVtU2l6ZSA9IGZvbnRTaXplUHJvcC5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgZG9jdW1lbnQuZW1TaXplID0gZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICAgIH1cbiAgICB9IC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XG5cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneCcsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBzY3JlZW4udmlld1BvcnQ7XG5cbiAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnY29sb3InLCB0cnVlKS5zZXRWYWx1ZSgnYmxhY2snKTtcbiAgICB9XG5cbiAgICB2YXIgcmVmWEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpO1xuICAgIHZhciByZWZZQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJyk7XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICB2YXIgdmlld0JveCA9IHZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkgPyB0b051bWJlcnModmlld0JveEF0dHIuZ2V0U3RyaW5nKCkpIDogbnVsbDtcbiAgICB2YXIgY2xpcCA9ICF0aGlzLnJvb3QgJiYgdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgnaGlkZGVuJykgIT09ICd2aXNpYmxlJztcbiAgICB2YXIgbWluWCA9IDA7XG4gICAgdmFyIG1pblkgPSAwO1xuICAgIHZhciBjbGlwWCA9IDA7XG4gICAgdmFyIGNsaXBZID0gMDtcblxuICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICBtaW5YID0gdmlld0JveFswXTtcbiAgICAgIG1pblkgPSB2aWV3Qm94WzFdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcmtlcicpIHtcbiAgICAgICAgY2xpcFggPSBtaW5YO1xuICAgICAgICBjbGlwWSA9IG1pblk7XG4gICAgICAgIG1pblggPSAwO1xuICAgICAgICBtaW5ZID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTsgLy8gRGVmYXVsdCB2YWx1ZSBvZiB0cmFuc2Zvcm0tb3JpZ2luIGlzIGNlbnRlciBvbmx5IGZvciByb290IFNWRyBlbGVtZW50c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgaWYgKHRoaXMubm9kZSAvLyBpcyBub3QgdGVtcG9yYXJ5IFNWR0VsZW1lbnRcbiAgICAmJiAoIXRoaXMucGFyZW50IHx8ICgoX3RoaXMkbm9kZSRwYXJlbnROb2RlID0gdGhpcy5ub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF90aGlzJG5vZGUkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbm9kZSRwYXJlbnROb2RlLm5vZGVOYW1lKSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSAmJiB0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgdHJ1ZSwgdHJ1ZSkuc2V0VmFsdWUoJzUwJSA1MCUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5zZXRDb250ZXh0KGN0eCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpKTtcblxuICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICB3aWR0aCA9IHZpZXdCb3hbMl07XG4gICAgICBoZWlnaHQgPSB2aWV3Qm94WzNdO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgY3R4LFxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICB3aWR0aDogc2NyZWVuLnZpZXdQb3J0LndpZHRoLFxuICAgICAgZGVzaXJlZFdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogc2NyZWVuLnZpZXdQb3J0LmhlaWdodCxcbiAgICAgIGRlc2lyZWRIZWlnaHQ6IGhlaWdodCxcbiAgICAgIG1pblgsXG4gICAgICBtaW5ZLFxuICAgICAgcmVmWDogcmVmWEF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgIHJlZlk6IHJlZllBdHRyLmdldFZhbHVlKCksXG4gICAgICBjbGlwLFxuICAgICAgY2xpcFgsXG4gICAgICBjbGlwWVxuICAgIH0pO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIHNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gICAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBjbGVhckNvbnRleHQoY3R4KSB7XG4gICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXHJcbiAgICogQHBhcmFtIHdpZHRoXHJcbiAgICogQHBhcmFtIGhlaWdodFxyXG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICovXG5cblxuICByZXNpemUod2lkdGgpIHtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB3aWR0aDtcbiAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIHdpZHRoQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpO1xuICAgIHZhciBoZWlnaHRBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpO1xuICAgIHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgdmFyIHN0eWxlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHZhciBvcmlnaW5XaWR0aCA9IHdpZHRoQXR0ci5nZXROdW1iZXIoMCk7XG4gICAgdmFyIG9yaWdpbkhlaWdodCA9IGhlaWdodEF0dHIuZ2V0TnVtYmVyKDApO1xuXG4gICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0cnVlKS5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyk7XG5cbiAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5nZXRTdHJpbmcoKS5yZXBsYWNlKC9eXFxzKihcXFMuKlxcUylcXHMqJC8sICckMScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpZHRoQXR0ci5zZXRWYWx1ZSh3aWR0aCk7XG4gICAgaGVpZ2h0QXR0ci5zZXRWYWx1ZShoZWlnaHQpO1xuXG4gICAgaWYgKCF2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB2aWV3Qm94QXR0ci5zZXRWYWx1ZShcIjAgMCBcIi5jb25jYXQob3JpZ2luV2lkdGggfHwgd2lkdGgsIFwiIFwiKS5jb25jYXQob3JpZ2luSGVpZ2h0IHx8IGhlaWdodCkpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgdmFyIGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgd2lkdGhTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGhlaWdodFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUmVjdEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3JlY3QnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHJ4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpO1xuICAgIHZhciByeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKTtcbiAgICB2YXIgcnggPSByeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHJ5ID0gcnlBdHRyLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKHJ4QXR0ci5oYXNWYWx1ZSgpICYmICFyeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgcnkgPSByeDtcbiAgICB9XG5cbiAgICBpZiAocnlBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICByeCA9IHJ5O1xuICAgIH1cblxuICAgIHJ4ID0gTWF0aC5taW4ocngsIHdpZHRoIC8gMi4wKTtcbiAgICByeSA9IE1hdGgubWluKHJ5LCBoZWlnaHQgLyAyLjApO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgdmFyIEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTsgLy8gYWx3YXlzIHN0YXJ0IHRoZSBwYXRoIHNvIHdlIGRvbid0IGZpbGwgcHJpb3IgcGF0aHNcblxuICAgICAgaWYgKGhlaWdodCA+IDAgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSwgeCArIHdpZHRoLCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgd2lkdGgsIHkgKyByeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyByeCAtIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHJ4IC0gS0FQUEEgKiByeCwgeSwgeCArIHJ4LCB5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBDaXJjbGVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdjaXJjbGUnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG5cbiAgICBpZiAoY3R4ICYmIHIgPiAwKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKGN4LCBjeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgRWxsaXBzZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2VsbGlwc2UnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgIHZhciByeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciByeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKGN0eCAmJiByeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGN4ICsgcngsIGN5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggKyBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCwgY3kgKyByeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIEtBUFBBICogcngsIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggLSByeCwgY3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCAtIEtBUFBBICogcngsIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgS0FQUEEgKiByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCArIHJ4LCBjeSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbGluZSc7XG4gIH1cblxuICBnZXRQb2ludHMoKSB7XG4gICAgcmV0dXJuIFtuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpKSwgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKSldO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgW3tcbiAgICAgIHg6IHgwLFxuICAgICAgeTogeTBcbiAgICB9LCB7XG4gICAgICB4OiB4MSxcbiAgICAgIHk6IHkxXG4gICAgfV0gPSB0aGlzLmdldFBvaW50cygpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmxpbmVUbyh4MSwgeTEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICB2YXIgW3AwLCBwMV0gPSB0aGlzLmdldFBvaW50cygpO1xuICAgIHZhciBhID0gcDAuYW5nbGVUbyhwMSk7XG4gICAgcmV0dXJuIFtbcDAsIGFdLCBbcDEsIGFdXTtcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlsaW5lRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3BvbHlsaW5lJztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMucG9pbnRzID0gUG9pbnQucGFyc2VQYXRoKHRoaXMuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5nZXRTdHJpbmcoKSk7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgW3tcbiAgICAgIHg6IHgwLFxuICAgICAgeTogeTBcbiAgICB9XSA9IHBvaW50cztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goeDAsIHkwKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICB9XG5cbiAgICBwb2ludHMuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHZhciB7XG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG1hcmtlcnMgPSBbXTtcbiAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcbiAgICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJzLnB1c2goW3BvaW50LCBwb2ludC5hbmdsZVRvKHBvaW50c1tpICsgMV0pXSk7XG4gICAgfSk7XG5cbiAgICBpZiAobWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXJrZXJzLnB1c2goW3BvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXVsxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrZXJzO1xuICB9XG5cbn1cblxuY2xhc3MgUG9seWdvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gc3VwZXIucGF0aChjdHgpO1xuICAgIHZhciBbe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9XSA9IHRoaXMucG9pbnRzO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxufVxuXG5jbGFzcyBQYXR0ZXJuRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgfVxuXG4gIGNyZWF0ZVBhdHRlcm4oY3R4LCBfLCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScsIHRydWUpOyAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcblxuICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuXG4gICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkgJiYgeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgcGF0dGVybkN0eC50cmFuc2xhdGUoeEF0dHIuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSksIHlBdHRyLmdldFBpeGVscygneScsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5zdHlsZXNbJ2ZpbGwtb3BhY2l0eSddID0gcGFyZW50T3BhY2l0eVByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5zdHlsZXMsICdmaWxsLW9wYWNpdHknKTtcbiAgICB9IC8vIHJlbmRlciAzeDMgZ3JpZCBzbyB3aGVuIHdlIHRyYW5zZm9ybSB0aGVyZSdzIG5vIHdoaXRlIHNwYWNlIG9uIGVkZ2VzXG5cblxuICAgIGZvciAodmFyIHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgcGF0dGVybkN0eC5zYXZlKCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd4JywgeCAqIHBhdHRlcm5DYW52YXMud2lkdGgpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAneScsIHkgKiBwYXR0ZXJuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgICBwYXR0ZXJuQ3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICdyZXBlYXQnKTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG59XG5cbmNsYXNzIE1hcmtlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgfVxuXG4gIHJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnQnKS5nZXRTdHJpbmcoJ2F1dG8nKTtcbiAgICB2YXIgbWFya2VyVW5pdHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS5nZXRTdHJpbmcoJ3N0cm9rZVdpZHRoJyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlclVuaXRzID09PSAnc3Ryb2tlV2lkdGgnKSB7XG4gICAgICBjdHguc2NhbGUoY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTsgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG5cbiAgICB2YXIgbWFya2VyU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgbWFya2VyU3ZnLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWScsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ292ZXJmbG93JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuZmlsbCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0Q29sb3IoJ2JsYWNrJykpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnN0cm9rZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpLmdldFZhbHVlKCdub25lJykpO1xuICAgIG1hcmtlclN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgbWFya2VyU3ZnLnJlbmRlcihjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgIGN0eC5zY2FsZSgxIC8gY3R4LmxpbmVXaWR0aCwgMSAvIGN0eC5saW5lV2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG59XG5cbmNsYXNzIERlZnNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2RlZnMnO1xuICB9XG5cbiAgcmVuZGVyKCkgey8vIE5PT1BcbiAgfVxuXG59XG5cbmNsYXNzIEdFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZyc7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbn1cblxuY2xhc3MgR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdCA9IFsnZ3JhZGllbnRVbml0cyddO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB2YXIge1xuICAgICAgc3RvcHMsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSB0aGlzO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdzdG9wJykge1xuICAgICAgICBzdG9wcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEdyYWRpZW50VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykuZ2V0U3RyaW5nKCdvYmplY3RCb3VuZGluZ0JveCcpO1xuICB9XG5cbiAgY3JlYXRlR3JhZGllbnQoY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG4gICAgdmFyIHN0b3BzQ29udGFpbmVyID0gdGhpcztcblxuICAgIGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICBzdG9wc0NvbnRhaW5lciA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgIHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzdG9wc1xuICAgIH0gPSBzdG9wc0NvbnRhaW5lcjtcbiAgICB2YXIgZ3JhZGllbnQgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XG5cbiAgICBpZiAoIWdyYWRpZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS5jb2xvcik7XG4gICAgfVxuXG4gICAgc3RvcHMuZm9yRWFjaChzdG9wID0+IHtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wLmNvbG9yKSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgdmFyIHtcbiAgICAgICAgZG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdmFyIHtcbiAgICAgICAgTUFYX1ZJUlRVQUxfUElYRUxTLFxuICAgICAgICB2aWV3UG9ydFxuICAgICAgfSA9IGRvY3VtZW50LnNjcmVlbjtcbiAgICAgIHZhciBbcm9vdFZpZXddID0gdmlld1BvcnQudmlld1BvcnRzO1xuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdEVsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMuMCk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgdmFyIGdyb3VwID0gbmV3IEdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgIGdyb3VwLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndHJhbnNmb3JtJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgICBncm91cC5jaGlsZHJlbiA9IFtyZWN0XTtcbiAgICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgMCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAwKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gW2dyb3VwXTtcbiAgICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHJvb3RWaWV3LndpZHRoLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICByZXR1cm4gcGF0dGVybkN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH1cblxuICBpbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcikge1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5mb3JFYWNoKGF0dHJpYnV0ZVRvSW5oZXJpdCA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSAmJiBzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCwgdHJ1ZSkuc2V0VmFsdWUoc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBjb2xvcikge1xuICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgY29sb3JQcm9wID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgIHJldHVybiBjb2xvclByb3AuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkuZ2V0Q29sb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lYXJHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnbGluZWFyR3JhZGllbnQnO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd4MScsICd5MScsICd4MicsICd5MicpO1xuICB9XG5cbiAgZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgdmFyIGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgIHZhciBib3VuZGluZ0JveCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KSA6IG51bGw7XG5cbiAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJywgdHJ1ZSkuc2V0VmFsdWUoMSk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTInLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB4MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5Mikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG4gIH1cblxufVxuXG5jbGFzcyBSYWRpYWxHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncmFkaWFsR3JhZGllbnQnO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJyk7XG4gIH1cblxuICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncicsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBmeCA9IGN4O1xuICAgIHZhciBmeSA9IGN5O1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGZ4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuaGFzVmFsdWUoKSkge1xuICAgICAgZnkgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB9XG5cbiAgICB2YXIgciA9IGlzQm91bmRpbmdCb3hVbml0cyA/IChib3VuZGluZ0JveC53aWR0aCArIGJvdW5kaW5nQm94LmhlaWdodCkgLyAyLjAgKiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcbiAgICB2YXIgZnIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnInKS5nZXRQaXhlbHMoKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgZnIsIGN4LCBjeSwgcik7XG4gIH1cblxufVxuXG5jbGFzcyBTdG9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3RvcCc7XG4gICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKS5nZXROdW1iZXIoKSkpO1xuICAgIHZhciBzdG9wT3BhY2l0eSA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgIHZhciBzdG9wQ29sb3IgPSB0aGlzLmdldFN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XG5cbiAgICBpZiAoc3RvcENvbG9yLmdldFN0cmluZygpID09PSAnJykge1xuICAgICAgc3RvcENvbG9yLnNldFZhbHVlKCcjMDAwJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3BPcGFjaXR5Lmhhc1ZhbHVlKCkpIHtcbiAgICAgIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHN0b3BPcGFjaXR5KTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmNvbG9yID0gc3RvcENvbG9yLmdldENvbG9yKCk7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZSc7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gJyc7XG4gICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICBkb2N1bWVudC5zY3JlZW4uYW5pbWF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIHRoaXMuYmVnaW4gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYmVnaW4nKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICB0aGlzLm1heER1cmF0aW9uID0gdGhpcy5iZWdpbiArIHRoaXMuZ2V0QXR0cmlidXRlKCdkdXInKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICB0aGlzLmZyb20gPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xuICAgIHRoaXMudG8gPSB0aGlzLmdldEF0dHJpYnV0ZSgndG8nKTtcbiAgICB0aGlzLnZhbHVlcyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZhbHVlcycsIG51bGwpO1xuICAgIHZhciB2YWx1ZXNBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpO1xuXG4gICAgaWYgKHZhbHVlc0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy52YWx1ZXMuc2V0VmFsdWUodmFsdWVzQXR0ci5nZXRTdHJpbmcoKS5zcGxpdCgnOycpKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9wZXJ0eSgpIHtcbiAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykuZ2V0U3RyaW5nKCk7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLmdldFN0cmluZygpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZVR5cGUgPT09ICdDU1MnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgfVxuXG4gIGNhbGNWYWx1ZSgpIHtcbiAgICB2YXIge1xuICAgICAgaW5pdGlhbFVuaXRzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHByb2dyZXNzLFxuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuICAgIHZhciBuZXdWYWx1ZSA9IGZyb20uZ2V0TnVtYmVyKCkgKyAodG8uZ2V0TnVtYmVyKCkgLSBmcm9tLmdldE51bWJlcigpKSAqIHByb2dyZXNzO1xuXG4gICAgaWYgKGluaXRpYWxVbml0cyA9PT0gJyUnKSB7XG4gICAgICBuZXdWYWx1ZSAqPSAxMDAuMDsgLy8gbnVtVmFsdWUoKSByZXR1cm5zIDAtMSB3aGVyZWFzIHByb3BlcnRpZXMgYXJlIDAtMTAwXG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG5ld1ZhbHVlKS5jb25jYXQoaW5pdGlhbFVuaXRzKTtcbiAgfVxuXG4gIHVwZGF0ZShkZWx0YSkge1xuICAgIHZhciB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydHkoKTsgLy8gc2V0IGluaXRpYWwgdmFsdWVcblxuICAgIGlmICghdGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gcHJvcC5nZXRVbml0cygpO1xuICAgIH0gLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcblxuXG4gICAgaWYgKHRoaXMuZHVyYXRpb24gPiB0aGlzLm1heER1cmF0aW9uKSB7XG4gICAgICB2YXIgZmlsbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0U3RyaW5nKCdyZW1vdmUnKTsgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG5cbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXREdXInKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ3JlbW92ZScgJiYgIXRoaXMucmVtb3ZlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLnNldFZhbHVlKHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPyBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kdXJhdGlvbiArPSBkZWx0YTsgLy8gaWYgd2UncmUgcGFzdCB0aGUgYmVnaW4gdGltZVxuXG4gICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5jYWxjVmFsdWUoKTsgLy8gdHdlZW5cblxuICAgICAgdmFyIHR5cGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgaWYgKHR5cGVBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gZm9yIHRyYW5zZm9ybSwgZXRjLlxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVBdHRyLmdldFN0cmluZygpO1xuICAgICAgICBuZXdWYWx1ZSA9IFwiXCIuY29uY2F0KHR5cGUsIFwiKFwiKS5jb25jYXQobmV3VmFsdWUsIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxuXG4gIGdldFByb2dyZXNzKCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHZhbHVlc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBwcm9ncmVzczogKHRoaXMuZHVyYXRpb24gLSB0aGlzLmJlZ2luKSAvICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5iZWdpbilcbiAgICB9O1xuXG4gICAgaWYgKHZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wcm9ncmVzcyAqICh2YWx1ZXMuZ2V0VmFsdWUoKS5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBsYiA9IE1hdGguZmxvb3IocCk7XG4gICAgICB2YXIgdWIgPSBNYXRoLmNlaWwocCk7XG4gICAgICByZXN1bHQuZnJvbSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2Zyb20nLCBwYXJzZUZsb2F0KHZhbHVlcy5nZXRWYWx1ZSgpW2xiXSkpO1xuICAgICAgcmVzdWx0LnRvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndG8nLCBwYXJzZUZsb2F0KHZhbHVlcy5nZXRWYWx1ZSgpW3ViXSkpO1xuICAgICAgcmVzdWx0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5mcm9tID0gdGhpcy5mcm9tO1xuICAgICAgcmVzdWx0LnRvID0gdGhpcy50bztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZUNvbG9yRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZUNvbG9yJztcbiAgfVxuXG4gIGNhbGNWYWx1ZSgpIHtcbiAgICB2YXIge1xuICAgICAgcHJvZ3Jlc3MsXG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpO1xuICAgIHZhciBjb2xvckZyb20gPSBuZXcgUkdCQ29sb3IoZnJvbS5nZXRDb2xvcigpKTtcbiAgICB2YXIgY29sb3JUbyA9IG5ldyBSR0JDb2xvcih0by5nZXRDb2xvcigpKTtcblxuICAgIGlmIChjb2xvckZyb20ub2sgJiYgY29sb3JUby5vaykge1xuICAgICAgLy8gdHdlZW4gY29sb3IgbGluZWFybHlcbiAgICAgIHZhciByID0gY29sb3JGcm9tLnIgKyAoY29sb3JUby5yIC0gY29sb3JGcm9tLnIpICogcHJvZ3Jlc3M7XG4gICAgICB2YXIgZyA9IGNvbG9yRnJvbS5nICsgKGNvbG9yVG8uZyAtIGNvbG9yRnJvbS5nKSAqIHByb2dyZXNzO1xuICAgICAgdmFyIGIgPSBjb2xvckZyb20uYiArIChjb2xvclRvLmIgLSBjb2xvckZyb20uYikgKiBwcm9ncmVzczsgLy8gPyBhbHBoYVxuXG4gICAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KE1hdGguZmxvb3IociksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoZyksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoYiksIFwiKVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKS5nZXRDb2xvcigpO1xuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQgZXh0ZW5kcyBBbmltYXRlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2FuaW1hdGVUcmFuc2Zvcm0nO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBwcm9ncmVzcyxcbiAgICAgIGZyb20sXG4gICAgICB0b1xuICAgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7IC8vIHR3ZWVuIHZhbHVlIGxpbmVhcmx5XG5cbiAgICB2YXIgdHJhbnNmb3JtRnJvbSA9IHRvTnVtYmVycyhmcm9tLmdldFN0cmluZygpKTtcbiAgICB2YXIgdHJhbnNmb3JtVG8gPSB0b051bWJlcnModG8uZ2V0U3RyaW5nKCkpO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRyYW5zZm9ybUZyb20ubWFwKChmcm9tLCBpKSA9PiB7XG4gICAgICB2YXIgdG8gPSB0cmFuc2Zvcm1Ub1tpXTtcbiAgICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBwcm9ncmVzcztcbiAgICB9KS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9XG5cbn1cblxuY2xhc3MgRm9udEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQnO1xuICAgIHRoaXMuZ2x5cGhzID0ge307XG4gICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICB2YXIge1xuICAgICAgZGVmaW5pdGlvbnNcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHlTdHlsZSA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuXG4gICAgICAgICAgICBpZiAoZm9udEZhbWlseVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNbZm9udEZhbWlseVN0eWxlLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgICAgICB0aGlzLm1pc3NpbmdHbHlwaCA9IGNoaWxkO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2dseXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBjaGlsZDtcblxuICAgICAgICAgICAgaWYgKGdseXBoLmFyYWJpY0Zvcm0pIHtcbiAgICAgICAgICAgICAgdGhpcy5pc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdW2dseXBoLmFyYWJpY0Zvcm1dID0gZ2x5cGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9IGdseXBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgRm9udEZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FzY2VudCcpLmdldE51bWJlcigpO1xuICAgIHRoaXMuZGVzY2VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkZXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy51bml0c1BlckVtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLmdldE51bWJlcigpO1xuICB9XG5cbn1cblxuY2xhc3MgTWlzc2luZ0dseXBoRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWlzc2luZy1nbHlwaCc7XG4gICAgdGhpcy5ob3JpekFkdlggPSAwO1xuICB9XG5cbn1cblxuY2xhc3MgVFJlZkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3RyZWYnO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG5cbiAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdENoaWxkLmdldFRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufVxuXG5jbGFzcyBBRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2EnO1xuICAgIHZhciB7XG4gICAgICBjaGlsZE5vZGVzXG4gICAgfSA9IG5vZGU7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgIHZhciBoYXNUZXh0ID0gY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIEFycmF5LmZyb20oY2hpbGROb2RlcykuZXZlcnkobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSAzKTtcbiAgICB0aGlzLmhhc1RleHQgPSBoYXNUZXh0O1xuICAgIHRoaXMudGV4dCA9IGhhc1RleHQgPyB0aGlzLmdldFRleHRGcm9tTm9kZShmaXJzdENoaWxkKSA6ICcnO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgaWYgKHRoaXMuaGFzVGV4dCkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRleHQgZWxlbWVudFxuICAgICAgc3VwZXIucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgIHZhciB7XG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciB7XG4gICAgICAgIG1vdXNlXG4gICAgICB9ID0gZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgdmFyIGZvbnRTaXplID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZSk7IC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cblxuICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgbmV3IEJvdW5kaW5nQm94KHgsIHkgLSBmb250U2l6ZS5nZXRQaXhlbHMoJ3knKSwgeCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgeSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyByZW5kZXIgYXMgdGVtcG9yYXJ5IGdyb3VwXG4gICAgICB2YXIgZyA9IG5ldyBHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICAgIGcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgZy5wYXJlbnQgPSB0aGlzO1xuICAgICAgZy5yZW5kZXIoY3R4KTtcbiAgICB9XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIHZhciB7XG4gICAgICB3aW5kb3dcbiAgICB9ID0gdGhpcy5kb2N1bWVudDtcblxuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldFN0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlTW92ZSgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5kb2N1bWVudC5jdHg7XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmNsYXNzIFRleHRQYXRoRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RleHRQYXRoJztcbiAgICB0aGlzLnRleHRXaWR0aCA9IDA7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gMDtcbiAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTtcbiAgICB0aGlzLmdseXBoSW5mbyA9IG51bGw7XG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICB0aGlzLm1lYXN1cmVzQ2FjaGUgPSBuZXcgTWFwKFtbJycsIDBdXSk7XG4gICAgdmFyIHBhdGhFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgdGhpcy5kYXRhQXJyYXkgPSB0aGlzLnBhcnNlUGF0aERhdGEocGF0aEVsZW1lbnQpO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZGF0YUFycmF5XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgZGF0YUFycmF5LmZvckVhY2goX3JlZiA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gPSBfcmVmO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXSA9IHBvaW50cztcbiAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcblxuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIEJvb2xlYW4oMSAtIGZzKSk7XG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB0aGlzLnNldFRleHREYXRhKGN0eCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgdGV4dERlY29yYXRpb24gPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1kZWNvcmF0aW9uJykuZ2V0U3RyaW5nKCk7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHZhciB7XG4gICAgICBnbHlwaEluZm9cbiAgICB9ID0gdGhpcztcbiAgICB2YXIgZmlsbCA9IGN0eC5maWxsU3R5bGU7XG5cbiAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgZ2x5cGhJbmZvLmZvckVhY2goKGdseXBoLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBwMCxcbiAgICAgICAgcDEsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICB0ZXh0OiBwYXJ0aWFsVGV4dFxuICAgICAgfSA9IGdseXBoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUocDAueCwgcDAueSk7XG4gICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcblxuICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICBjdHguc3Ryb2tlVGV4dChwYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHAwLngsIHAwLnkgKyBmb250U2l6ZSAvIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55ICsgZm9udFNpemUgLyA1KTtcbiAgICAgIH0gLy8gLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAvL1xuICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgLy8gXHRjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgIC8vIGVsc2VcbiAgICAgIC8vIFx0Y3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgIC8vIGN0eC5tb3ZlVG8ocDAueCwgcDAueSk7XG4gICAgICAvLyBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgfSk7XG5cbiAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldExldHRlclNwYWNpbmdBdCgpIHtcbiAgICB2YXIgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLmxldHRlclNwYWNpbmdDYWNoZVtpZHhdIHx8IDA7XG4gIH1cblxuICBmaW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBpbnB1dE9mZnNldCwgZHksIGMsIGNoYXJJKSB7XG4gICAgdmFyIG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICAgIHZhciBnbHlwaFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgsIGMpO1xuXG4gICAgaWYgKGMgPT09ICcgJyAmJiBhbmNob3IgPT09ICdqdXN0aWZ5JyAmJiB0ZXh0RnVsbFdpZHRoIDwgZnVsbFBhdGhXaWR0aCkge1xuICAgICAgZ2x5cGhXaWR0aCArPSAoZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpIC8gc3BhY2VzTnVtYmVyO1xuICAgIH1cblxuICAgIGlmIChjaGFySSA+IC0xKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nQXQoY2hhckkpO1xuICAgIH1cblxuICAgIHZhciBzcGxpbmVTdGVwID0gdGhpcy50ZXh0SGVpZ2h0IC8gMjA7XG4gICAgdmFyIHAwID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgdmFyIHAxID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCArIGdseXBoV2lkdGgsIHNwbGluZVN0ZXAsIDApO1xuICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgcDAsXG4gICAgICBwMVxuICAgIH07XG4gICAgdmFyIHJvdGF0aW9uID0gcDAgJiYgcDEgPyBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCkgOiAwO1xuXG4gICAgaWYgKGR5KSB7XG4gICAgICB2YXIgZHlYID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgKyByb3RhdGlvbikgKiBkeTtcbiAgICAgIHZhciBkeVkgPSBNYXRoLmNvcygtcm90YXRpb24pICogZHk7XG4gICAgICBzZWdtZW50LnAwID0gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgcDApLCB7fSwge1xuICAgICAgICB4OiBwMC54ICsgZHlYLFxuICAgICAgICB5OiBwMC55ICsgZHlZXG4gICAgICB9KTtcbiAgICAgIHNlZ21lbnQucDEgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwMSksIHt9LCB7XG4gICAgICAgIHg6IHAxLnggKyBkeVgsXG4gICAgICAgIHk6IHAxLnkgKyBkeVlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBnbHlwaFdpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQsXG4gICAgICBzZWdtZW50LFxuICAgICAgcm90YXRpb25cbiAgICB9O1xuICB9XG5cbiAgbWVhc3VyZVRleHQoY3R4LCB0ZXh0KSB7XG4gICAgdmFyIHtcbiAgICAgIG1lYXN1cmVzQ2FjaGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdGFyZ2V0VGV4dCA9IHRleHQgfHwgdGhpcy5nZXRUZXh0KCk7XG5cbiAgICBpZiAobWVhc3VyZXNDYWNoZS5oYXModGFyZ2V0VGV4dCkpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlc0NhY2hlLmdldCh0YXJnZXRUZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgbWVhc3VyZSA9IHRoaXMubWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KTtcbiAgICBtZWFzdXJlc0NhY2hlLnNldCh0YXJnZXRUZXh0LCBtZWFzdXJlKTtcbiAgICByZXR1cm4gbWVhc3VyZTtcbiAgfSAvLyBUaGlzIG1ldGhvZCBzdXBwb3NlcyB3aGF0IGFsbCBjdXN0b20gZm9udHMgYWxyZWFkeSBsb2FkZWQuXG4gIC8vIElmIHNvbWUgZm9udCB3aWxsIGJlIGxvYWRlZCBhZnRlciB0aGlzIG1ldGhvZCBjYWxsLCA8dGV4dFBhdGg+IHdpbGwgbm90IGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cbiAgLy8gWW91IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBtYW51YWxseSB0byB1cGRhdGUgZ2x5cGhzIGNhY2hlLlxuXG5cbiAgc2V0VGV4dERhdGEoY3R4KSB7XG4gICAgaWYgKHRoaXMuZ2x5cGhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgY2hhcnMgPSByZW5kZXJUZXh0LnNwbGl0KCcnKTtcbiAgICB2YXIgc3BhY2VzTnVtYmVyID0gcmVuZGVyVGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgdmFyIGR4ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLnNwbGl0KCkubWFwKF8gPT4gXy5nZXRQaXhlbHMoJ3gnKSk7XG4gICAgdmFyIGR5ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBhbmNob3IgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgdmFyIHRoaXNTcGFjaW5nID0gdGhpcy5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICB2YXIgcGFyZW50U3BhY2luZyA9IHRoaXMucGFyZW50LmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgIGlmICghdGhpc1NwYWNpbmcuaGFzVmFsdWUoKSB8fCB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpID09PSAnaW5oZXJpdCcpIHtcbiAgICAgIGxldHRlclNwYWNpbmcgPSBwYXJlbnRTcGFjaW5nLmdldFBpeGVscygpO1xuICAgIH0gZWxzZSBpZiAodGhpc1NwYWNpbmcuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICdpbml0aWFsJyAmJiB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpICE9PSAndW5zZXQnKSB7XG4gICAgICAgIGxldHRlclNwYWNpbmcgPSB0aGlzU3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgIH1cbiAgICB9IC8vIGZpbGwgbGV0dGVyLXNwYWNpbmcgY2FjaGVcblxuXG4gICAgdmFyIGxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgIHZhciB0ZXh0TGVuID0gcmVuZGVyVGV4dC5sZW5ndGg7XG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBsZXR0ZXJTcGFjaW5nQ2FjaGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMZW47IGkrKykge1xuICAgICAgbGV0dGVyU3BhY2luZ0NhY2hlLnB1c2godHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyA/IGR4W2ldIDogbGV0dGVyU3BhY2luZyk7XG4gICAgfVxuXG4gICAgdmFyIGR4U3VtID0gbGV0dGVyU3BhY2luZ0NhY2hlLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGkgPT09IDAgPyAwIDogYWNjICsgY3VyIHx8IDAsIDApO1xuICAgIHZhciB0ZXh0V2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCk7XG4gICAgdmFyIHRleHRGdWxsV2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGggKyBkeFN1bSwgMCk7XG4gICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHRoaXMuZ2x5cGhJbmZvID0gW107XG4gICAgdmFyIGZ1bGxQYXRoV2lkdGggPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLmdldFN0eWxlKCdzdGFydE9mZnNldCcpLmdldE51bWJlcigwKSAqIGZ1bGxQYXRoV2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAoYW5jaG9yID09PSAnbWlkZGxlJyB8fCBhbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICBvZmZzZXQgPSAtdGV4dEZ1bGxXaWR0aCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvciA9PT0gJ2VuZCcgfHwgYW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZzZXQgPSAtdGV4dEZ1bGxXaWR0aDtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gc3RhcnRPZmZzZXQ7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhciwgaSkgPT4ge1xuICAgICAgLy8gRmluZCBzdWNoIHNlZ21lbnQgd2hhdCBkaXN0YW5jZSBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICB2YXIge1xuICAgICAgICBvZmZzZXQ6IG5leHRPZmZzZXQsXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gdGhpcy5maW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBvZmZzZXQsIGR5LCBjaGFyLCBpKTtcbiAgICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG5cbiAgICAgIGlmICghc2VnbWVudC5wMCB8fCAhc2VnbWVudC5wMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFxuICAgICAgLy8gXHRzZWdtZW50LnAwLngsXG4gICAgICAvLyBcdHNlZ21lbnQucDAueSxcbiAgICAgIC8vIFx0c2VnbWVudC5wMS54LFxuICAgICAgLy8gXHRzZWdtZW50LnAxLnlcbiAgICAgIC8vICk7XG4gICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuICAgICAgLy8gT3IgdXNlIFwiZHhcIiBhdHRyaWJ1dGUgb2YgdGhlIDx0ZXh0PiBub2RlIGFzIGEgbmFpdmUgcmVwbGFjZW1lbnRcbiAgICAgIC8vIGNvbnN0IGtlcm4gPSAwO1xuICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gY29uc3QgbWlkcG9pbnQgPSB0aGlzLmdldFBvaW50T25MaW5lKFxuICAgICAgLy8gXHRrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAvLyBcdHNlZ21lbnQucDAueCwgc2VnbWVudC5wMC55LCBzZWdtZW50LnAxLngsIHNlZ21lbnQucDEueVxuICAgICAgLy8gKTtcblxuXG4gICAgICB0aGlzLmdseXBoSW5mby5wdXNoKHtcbiAgICAgICAgLy8gdHJhbnNwb3NlWDogbWlkcG9pbnQueCxcbiAgICAgICAgLy8gdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgdGV4dDogY2hhcnNbaV0sXG4gICAgICAgIHAwOiBzZWdtZW50LnAwLFxuICAgICAgICBwMTogc2VnbWVudC5wMSxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcGFyc2VQYXRoRGF0YShwYXRoKSB7XG4gICAgdGhpcy5wYXRoTGVuZ3RoID0gLTE7IC8vIHJlc2V0IHBhdGggbGVuZ3RoXG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aENvbW1hbmRzID0gW107XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gcGF0aDtcbiAgICBwYXRoUGFyc2VyLnJlc2V0KCk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgd2hpbGUgKCFwYXRoUGFyc2VyLmlzRW5kKCkpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgdmFyIHN0YXJ0WCA9IGN1cnJlbnQgPyBjdXJyZW50LnggOiAwO1xuICAgICAgdmFyIHN0YXJ0WSA9IGN1cnJlbnQgPyBjdXJyZW50LnkgOiAwO1xuICAgICAgdmFyIGNvbW1hbmQgPSBwYXRoUGFyc2VyLm5leHQoKTtcbiAgICAgIHZhciBuZXh0Q29tbWFuZFR5cGUgPSBjb21tYW5kLnR5cGU7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZC50eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVihwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoUShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICBwb2ludHMgPSB0aGlzLnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIFBhdGhFbGVtZW50LnBhdGhaKHBhdGhQYXJzZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZC50eXBlICE9PSBQYXRoUGFyc2VyLkNMT1NFX1BBVEgpIHtcbiAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IG5leHRDb21tYW5kVHlwZSxcbiAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBuZXh0Q29tbWFuZFR5cGUsIHBvaW50cylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogUGF0aFBhcnNlci5DTE9TRV9QQVRILFxuICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aENvbW1hbmRzO1xuICB9XG5cbiAgcGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICB9XG5cbiAgcGF0aEwocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gIH1cblxuICBwYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEgocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgfVxuXG4gIHBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICB9XG5cbiAgcGF0aEMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgfVxuXG4gIHBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuQ1VSVkVfVE87XG4gIH1cblxuICBwYXRoUShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhRKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgfVxuXG4gIHBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2goY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLlFVQURfVE87XG4gIH1cblxuICBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgY2VudHAsXG4gICAgICBhMSxcbiAgICAgIGFkXG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpO1xuXG4gICAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhZCA+IDApIHtcbiAgICAgIGFkIC09IDIgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYWQgPCAwKSB7XG4gICAgICBhZCArPSAyICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2NlbnRwLngsIGNlbnRwLnksIHJYLCByWSwgYTEsIGFkLCB4QXhpc1JvdGF0aW9uLCBzd2VlcEZsYWddO1xuICB9XG5cbiAgY2FsY0xlbmd0aCh4LCB5LCBjb21tYW5kVHlwZSwgcG9pbnRzKSB7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIHAxID0gbnVsbDtcbiAgICB2YXIgcDIgPSBudWxsO1xuICAgIHZhciB0ID0gMDtcblxuICAgIHN3aXRjaCAoY29tbWFuZFR5cGUpIHtcbiAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lTGVuZ3RoKHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG5cbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG5cbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTsgLy8gNCA9IHRoZXRhXG5cbiAgICAgICAgICB2YXIgZFRoZXRhID0gcG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICB2YXIgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgIHZhciBpbmMgPSBNYXRoLlBJIC8gMTgwLjA7IC8vIDEgZGVncmVlIHJlc29sdXRpb25cblxuICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgIGluYyA9IE1hdGguYWJzKHN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICB9IC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG5cblxuICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcblxuICAgICAgICAgIGlmIChkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICAvLyBjbG9ja3dpc2VcbiAgICAgICAgICAgIGZvciAodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICAgIGZvciAodCA9IHN0YXJ0ICsgaW5jOyB0IDwgZW5kOyB0ICs9IGluYykge1xuICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBlbmQsIDApO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0UG9pbnRPbkxpbmUoZGlzdCwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGZyb21YID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBwMXg7XG4gICAgdmFyIGZyb21ZID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBwMXk7XG4gICAgdmFyIG0gPSAocDJ5IC0gcDF5KSAvIChwMnggLSBwMXggKyBQU0VVRE9fWkVSTyk7XG4gICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcblxuICAgIGlmIChwMnggPCBwMXgpIHtcbiAgICAgIHJ1biAqPSAtMTtcbiAgICB9XG5cbiAgICB2YXIgcmlzZSA9IG0gKiBydW47XG4gICAgdmFyIHB0ID0gbnVsbDtcblxuICAgIGlmIChwMnggPT09IHAxeCkge1xuICAgICAgLy8gdmVydGljYWwgbGluZVxuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGZyb21YLFxuICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgoZnJvbVkgLSBwMXkpIC8gKGZyb21YIC0gcDF4ICsgUFNFVURPX1pFUk8pID09PSBtKSB7XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl4ID0gMDtcbiAgICAgIHZhciBpeSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxeCwgcDF5LCBwMngsIHAyeSk7XG5cbiAgICAgIGlmIChsZW4gPCBQU0VVRE9fWkVSTykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHUgPSAoZnJvbVggLSBwMXgpICogKHAyeCAtIHAxeCkgKyAoZnJvbVkgLSBwMXkpICogKHAyeSAtIHAxeSk7XG4gICAgICB1IC89IGxlbiAqIGxlbjtcbiAgICAgIGl4ID0gcDF4ICsgdSAqIChwMnggLSBwMXgpO1xuICAgICAgaXkgPSBwMXkgKyB1ICogKHAyeSAtIHAxeSk7XG4gICAgICB2YXIgcFJpc2UgPSB0aGlzLmdldExpbmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBpeCwgaXkpO1xuICAgICAgdmFyIHBSdW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLSBwUmlzZSAqIHBSaXNlKTtcbiAgICAgIHJ1biA9IE1hdGguc3FydChwUnVuICogcFJ1biAvICgxICsgbSAqIG0pKTtcblxuICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICBydW4gKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHJpc2UgPSBtICogcnVuO1xuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0O1xuICB9XG5cbiAgZ2V0UG9pbnRPblBhdGgoZGlzdGFuY2UpIHtcbiAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IDA7XG4gICAgdmFyIHAgPSBudWxsO1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgLTAuMDAwMDUgfHwgZGlzdGFuY2UgLSAwLjAwMDA1ID4gZnVsbExlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGRhdGFBcnJheVxuICAgIH0gPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgY29tbWFuZCBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIGlmIChjb21tYW5kICYmIChjb21tYW5kLnBhdGhMZW5ndGggPCAwLjAwMDA1IHx8IGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoICsgMC4wMDAwNSA8IGRpc3RhbmNlKSkge1xuICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArPSBjb21tYW5kLnBhdGhMZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBkaXN0YW5jZSAtIGN1bXVsYXRpdmVQYXRoTGVuZ3RoO1xuICAgICAgdmFyIGN1cnJlbnRUID0gMDtcblxuICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoZGVsdGEsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNvbW1hbmQucG9pbnRzWzRdOyAvLyA0ID0gdGhldGFcblxuICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGNvbW1hbmQucG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICAgIHZhciBlbmQgPSBjb21tYW5kLnBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aCAqIGRUaGV0YTtcblxuICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQgfHwgZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjdXJyZW50VCwgY29tbWFuZC5wb2ludHNbNl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUID4gMSkge1xuICAgICAgICAgICAgY3VycmVudFQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjb21tYW5kLnBvaW50c1s0XSwgY29tbWFuZC5wb2ludHNbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHApIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0TGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuXG4gIGdldFBhdGhMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMucGF0aExlbmd0aCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGF0aExlbmd0aCA9IHRoaXMuZGF0YUFycmF5LnJlZHVjZSgobGVuZ3RoLCBjb21tYW5kKSA9PiBjb21tYW5kLnBhdGhMZW5ndGggPiAwID8gbGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoIDogbGVuZ3RoLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXRoTGVuZ3RoO1xuICB9XG5cbiAgZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICB2YXIgeCA9IHA0eCAqIENCMShwY3QpICsgcDN4ICogQ0IyKHBjdCkgKyBwMnggKiBDQjMocGN0KSArIHAxeCAqIENCNChwY3QpO1xuICAgIHZhciB5ID0gcDR5ICogQ0IxKHBjdCkgKyBwM3kgKiBDQjIocGN0KSArIHAyeSAqIENCMyhwY3QpICsgcDF5ICogQ0I0KHBjdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgdmFyIHggPSBwM3ggKiBRQjEocGN0KSArIHAyeCAqIFFCMihwY3QpICsgcDF4ICogUUIzKHBjdCk7XG4gICAgdmFyIHkgPSBwM3kgKiBRQjEocGN0KSArIHAyeSAqIFFCMihwY3QpICsgcDF5ICogUUIzKHBjdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgdmFyIGNvc1BzaSA9IE1hdGguY29zKHBzaSk7XG4gICAgdmFyIHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgdmFyIHB0ID0ge1xuICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGN4ICsgKHB0LnggKiBjb3NQc2kgLSBwdC55ICogc2luUHNpKSxcbiAgICAgIHk6IGN5ICsgKHB0LnggKiBzaW5Qc2kgKyBwdC55ICogY29zUHNpKVxuICAgIH07XG4gIH0gLy8gVE9ETyBuZWVkIHNvbWUgb3B0aW1pc2F0aW9ucy4gcG9zc2libHkgYnVpbGQgY2FjaGUgb25seSBmb3IgY3VydmVkIHNlZ21lbnRzP1xuXG5cbiAgYnVpbGRFcXVpZGlzdGFudENhY2hlKGlucHV0U3RlcCwgaW5wdXRQcmVjaXNpb24pIHtcbiAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBwcmVjaXNpb24gPSBpbnB1dFByZWNpc2lvbiB8fCAwLjI1OyAvLyBhY2N1cmFjeSB2cyBwZXJmb3JtYW5jZVxuXG4gICAgdmFyIHN0ZXAgPSBpbnB1dFN0ZXAgfHwgZnVsbExlbiAvIDEwMDtcblxuICAgIGlmICghdGhpcy5lcXVpZGlzdGFudENhY2hlIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwICE9PSBzdGVwIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuICAgICAgLy8gUHJlcGFyZSBjYWNoZVxuICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlID0ge1xuICAgICAgICBzdGVwLFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIHBvaW50czogW11cbiAgICAgIH07IC8vIENhbGN1bGF0ZSBwb2ludHNcblxuICAgICAgdmFyIHMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8PSBmdWxsTGVuOyBsICs9IHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLmdldFBvaW50T25QYXRoKGwpO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLmdldFBvaW50T25QYXRoKGwgKyBwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmICghcDAgfHwgIXAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICBpZiAocyA+PSBzdGVwKSB7XG4gICAgICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHg6IHAwLngsXG4gICAgICAgICAgICB5OiBwMC55LFxuICAgICAgICAgICAgZGlzdGFuY2U6IGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzIC09IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKHRhcmdldERpc3RhbmNlLCBzdGVwLCBwcmVjaXNpb24pIHtcbiAgICB0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZShzdGVwLCBwcmVjaXNpb24pO1xuXG4gICAgaWYgKHRhcmdldERpc3RhbmNlIDwgMCB8fCB0YXJnZXREaXN0YW5jZSAtIHRoaXMuZ2V0UGF0aExlbmd0aCgpID4gMC4wMDAwNSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IE1hdGgucm91bmQodGFyZ2V0RGlzdGFuY2UgLyB0aGlzLmdldFBhdGhMZW5ndGgoKSAqICh0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50c1tpZHhdIHx8IG51bGw7XG4gIH1cblxufVxuXG52YXIgZGF0YVVyaVJlZ2V4ID0gL15cXHMqZGF0YTooKFteLyw7XStcXC9bXi8sO10rKSg/OjsoW14sOz1dKz1bXiw7PV0rKSk/KT8oPzo7KGJhc2U2NCkpPywoLiopJC9pO1xuY2xhc3MgSW1hZ2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ltYWdlJztcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7XG5cbiAgICBpZiAoIWhyZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNTdmcgPSBocmVmLmVuZHNXaXRoKCcuc3ZnJykgfHwgL15cXHMqZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3QoaHJlZik7XG4gICAgZG9jdW1lbnQuaW1hZ2VzLnB1c2godGhpcyk7XG5cbiAgICBpZiAoIWlzU3ZnKSB7XG4gICAgICB2b2lkIHRoaXMubG9hZEltYWdlKGhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIHRoaXMubG9hZFN2ZyhocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3ZnID0gaXNTdmc7XG4gIH1cblxuICBsb2FkSW1hZ2UoaHJlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHlpZWxkIF90aGlzLmRvY3VtZW50LmNyZWF0ZUltYWdlKGhyZWYpO1xuICAgICAgICBfdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgbG9hZFN2ZyhocmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBtYXRjaCA9IGRhdGFVcmlSZWdleC5leGVjKGhyZWYpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaFs1XTtcblxuICAgICAgICBpZiAobWF0Y2hbNF0gPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgX3RoaXMyLmltYWdlID0gYXRvYihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0geWllbGQgX3RoaXMyLmRvY3VtZW50LmZldGNoKGhyZWYpO1xuICAgICAgICAgIHZhciBzdmcgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgX3RoaXMyLmltYWdlID0gc3ZnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBpbWFnZSBcXFwiXCIuY29uY2F0KGhyZWYsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMyLmxvYWRlZCA9IHRydWU7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGltYWdlLFxuICAgICAgbG9hZGVkXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmICghbG9hZGVkIHx8ICFpbWFnZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmICh0aGlzLmlzU3ZnKSB7XG4gICAgICB2YXIgc3ViRG9jdW1lbnQgPSBkb2N1bWVudC5jYW52Zy5mb3JrU3RyaW5nKGN0eCwgdGhpcy5pbWFnZSwge1xuICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgc2NhbGVXaWR0aDogd2lkdGgsXG4gICAgICAgIHNjYWxlSGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgc3ViRG9jdW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnBhcmVudCA9IHRoaXM7XG4gICAgICB2b2lkIHN1YkRvY3VtZW50LnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2ltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgICBjdHgsXG4gICAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgZGVzaXJlZFdpZHRoOiBfaW1hZ2Uud2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZGVzaXJlZEhlaWdodDogX2ltYWdlLmhlaWdodFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICBpZiAodHlwZW9mIF9pbWFnZS5jb21wbGV0ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgX2ltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShfaW1hZ2UsIDAsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KCkge1xuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICB9XG5cbn1cblxuY2xhc3MgU3ltYm9sRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3N5bWJvbCc7XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgU1ZHRm9udExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgZG9jdW1lbnQuZm9udHMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIGxvYWQoZm9udEZhbWlseSwgdXJsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBkb2N1bWVudFxuICAgICAgICB9ID0gX3RoaXM7XG4gICAgICAgIHZhciBzdmdEb2N1bWVudCA9IHlpZWxkIGRvY3VtZW50LmNhbnZnLnBhcnNlci5sb2FkKHVybCk7XG4gICAgICAgIHZhciBmb250cyA9IHN2Z0RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XG4gICAgICAgIEFycmF5LmZyb20oZm9udHMpLmZvckVhY2goZm9udE5vZGUgPT4ge1xuICAgICAgICAgIHZhciBmb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChmb250Tm9kZSk7XG4gICAgICAgICAgZG9jdW1lbnQuZGVmaW5pdGlvbnNbZm9udEZhbWlseV0gPSBmb250O1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBmb250IFxcXCJcIi5jb25jYXQodXJsLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxufVxuXG5jbGFzcyBTdHlsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB2YXIgY3NzID0gY29tcHJlc3NTcGFjZXMoQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpIC8vIE5FRUQgVEVTVFxuICAgIC5tYXAoXyA9PiBfLnRleHRDb250ZW50KS5qb2luKCcnKS5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKSAvLyByZW1vdmUgY29tbWVudHNcbiAgICAucmVwbGFjZSgvQGltcG9ydC4qOy9nLCAnJykgLy8gcmVtb3ZlIGltcG9ydHNcbiAgICApO1xuICAgIHZhciBjc3NEZWZzID0gY3NzLnNwbGl0KCd9Jyk7XG4gICAgY3NzRGVmcy5mb3JFYWNoKF8gPT4ge1xuICAgICAgdmFyIGRlZiA9IF8udHJpbSgpO1xuXG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3NQYXJ0cyA9IGRlZi5zcGxpdCgneycpO1xuICAgICAgdmFyIGNzc0NsYXNzZXMgPSBjc3NQYXJ0c1swXS5zcGxpdCgnLCcpO1xuICAgICAgdmFyIGNzc1Byb3BzID0gY3NzUGFydHNbMV0uc3BsaXQoJzsnKTtcbiAgICAgIGNzc0NsYXNzZXMuZm9yRWFjaChfID0+IHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gXy50cmltKCk7XG5cbiAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gfHwge307XG4gICAgICAgIGNzc1Byb3BzLmZvckVhY2goY3NzUHJvcCA9PiB7XG4gICAgICAgICAgdmFyIHByb3AgPSBjc3NQcm9wLmluZGV4T2YoJzonKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGNzc1Byb3Auc3Vic3RyKDAsIHByb3ApLnRyaW0oKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjc3NQcm9wLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcC5sZW5ndGggLSBwcm9wKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5W2Nzc0NsYXNzXSA9IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoY3NzQ2xhc3MpO1xuXG4gICAgICAgIGlmIChjc3NDbGFzcyA9PT0gJ0Bmb250LWZhY2UnKSB7XG4gICAgICAgICAgLy8gICYmICFub2RlRW52XG4gICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwcm9wc1snZm9udC1mYW1pbHknXS5nZXRTdHJpbmcoKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgICB2YXIgc3JjcyA9IHByb3BzLnNyYy5nZXRTdHJpbmcoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNyY3MuZm9yRWFjaChzcmMgPT4ge1xuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCdmb3JtYXQoXCJzdmdcIiknKSA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHVybCA9IHBhcnNlRXh0ZXJuYWxVcmwoc3JjKTtcblxuICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgdm9pZCBuZXcgU1ZHRm9udExvYWRlcihkb2N1bWVudCkubG9hZChmb250RmFtaWx5LCB1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblN0eWxlRWxlbWVudC5wYXJzZUV4dGVybmFsVXJsID0gcGFyc2VFeHRlcm5hbFVybDtcblxuY2xhc3MgVXNlRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3VzZSc7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnKSwgMCk7XG4gICAgfVxuXG4gICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUoMCwgeUF0dHIuZ2V0UGl4ZWxzKCd5JykpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIHRlbXBTdmcgPSBlbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcbiAgICAgICAgdGVtcFN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2aWV3Qm94JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvdmVyZmxvdycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvdmVyZmxvdycpLmdldFN0cmluZygpKTtcbiAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47IC8vIGVsZW1lbnQgaXMgc3RpbGwgdGhlIHBhcmVudCBvZiB0aGUgY2hpbGRyZW5cblxuICAgICAgICBlbGVtZW50LnN0eWxlcy5vcGFjaXR5ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3BhY2l0eScsIHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBTdmcudHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdmFyIHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdmFyIGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgZmFsc2UsIHRydWUpOyAvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXG5cbiAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgd2lkdGhTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBoZWlnaHRTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9sZFBhcmVudCA9IHRlbXBTdmcucGFyZW50O1xuICAgICAgdGVtcFN2Zy5wYXJlbnQgPSB0aGlzO1xuICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgIHRlbXBTdmcucGFyZW50ID0gb2xkUGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGVsZW1lbnRUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlZEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2FjaGVkRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZWRFbGVtZW50O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSkge1xuICByZXR1cm4gaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdO1xufVxuXG5mdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhLCB2YWwpIHtcbiAgaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdID0gdmFsO1xufVxuXG5mdW5jdGlvbiBtKG1hdHJpeCwgaSwgdikge1xuICB2YXIgbWkgPSBtYXRyaXhbaV07XG4gIHJldHVybiBtaSAqIHY7XG59XG5cbmZ1bmN0aW9uIGMoYSwgbTEsIG0yLCBtMykge1xuICByZXR1cm4gbTEgKyBNYXRoLmNvcyhhKSAqIG0yICsgTWF0aC5zaW4oYSkgKiBtMztcbn1cblxuY2xhc3MgRmVDb2xvck1hdHJpeEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlQ29sb3JNYXRyaXgnO1xuICAgIHZhciBtYXRyaXggPSB0b051bWJlcnModGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpLmdldFN0cmluZygpKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS5nZXRTdHJpbmcoJ21hdHJpeCcpKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI2ZlQ29sb3JNYXRyaXhFbGVtZW50XG4gICAgICBjYXNlICdzYXR1cmF0ZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcyA9IG1hdHJpeFswXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIG1hdHJpeCA9IFswLjIxMyArIDAuNzg3ICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgKyAwLjI4NSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyICsgMC45MjggKiBzLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaHVlUm90YXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgbWF0cml4ID0gW2MoYSwgMC4yMTMsIDAuNzg3LCAtMC4yMTMpLCBjKGEsIDAuNzE1LCAtMC43MTUsIC0wLjcxNSksIGMoYSwgMC4wNzIsIC0wLjA3MiwgMC45MjgpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIDAuMTQzKSwgYyhhLCAwLjcxNSwgMC4yODUsIDAuMTQwKSwgYyhhLCAwLjA3MiwgLTAuMDcyLCAtMC4yODMpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIC0wLjc4NyksIGMoYSwgMC43MTUsIC0wLjcxNSwgMC43MTUpLCBjKGEsIDAuMDcyLCAwLjkyOCwgMC4wNzIpLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuICAgICAgICBtYXRyaXggPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSwgMCwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgdGhpcy5pbmNsdWRlT3BhY2l0eSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbmNsdWRlT3BhY2l0eScpLmhhc1ZhbHVlKCk7XG4gIH1cblxuICBhcHBseShjdHgsIF94LCBfeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIC8vIGFzc3VtaW5nIHg9PTAgJiYgeT09MCBmb3Igbm93XG4gICAgdmFyIHtcbiAgICAgIGluY2x1ZGVPcGFjaXR5LFxuICAgICAgbWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHNyY0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcbiAgICAgICAgdmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICB2YXIgYiA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMik7XG4gICAgICAgIHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcbiAgICAgICAgdmFyIG5yID0gbShtYXRyaXgsIDAsIHIpICsgbShtYXRyaXgsIDEsIGcpICsgbShtYXRyaXgsIDIsIGIpICsgbShtYXRyaXgsIDMsIGEpICsgbShtYXRyaXgsIDQsIDEpO1xuICAgICAgICB2YXIgbmcgPSBtKG1hdHJpeCwgNSwgcikgKyBtKG1hdHJpeCwgNiwgZykgKyBtKG1hdHJpeCwgNywgYikgKyBtKG1hdHJpeCwgOCwgYSkgKyBtKG1hdHJpeCwgOSwgMSk7XG4gICAgICAgIHZhciBuYiA9IG0obWF0cml4LCAxMCwgcikgKyBtKG1hdHJpeCwgMTEsIGcpICsgbShtYXRyaXgsIDEyLCBiKSArIG0obWF0cml4LCAxMywgYSkgKyBtKG1hdHJpeCwgMTQsIDEpO1xuICAgICAgICB2YXIgbmEgPSBtKG1hdHJpeCwgMTUsIHIpICsgbShtYXRyaXgsIDE2LCBnKSArIG0obWF0cml4LCAxNywgYikgKyBtKG1hdHJpeCwgMTgsIGEpICsgbShtYXRyaXgsIDE5LCAxKTtcblxuICAgICAgICBpZiAoaW5jbHVkZU9wYWNpdHkpIHtcbiAgICAgICAgICBuciA9IDA7XG4gICAgICAgICAgbmcgPSAwO1xuICAgICAgICAgIG5iID0gMDtcbiAgICAgICAgICBuYSAqPSBhIC8gMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBucik7XG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbmcpO1xuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG5iKTtcbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzLCBuYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICB9XG5cbn1cblxuY2xhc3MgTWFza0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWFzayc7XG4gIH1cblxuICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpczsgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG5cbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgfSk7XG4gICAgICB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54MSk7XG4gICAgICB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55MSk7XG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgIH1cblxuICAgIHZhciBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICB2YXIgbWFza0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyhtYXNrQ3R4KTtcbiAgICB0aGlzLnJlbmRlckNoaWxkcmVuKG1hc2tDdHgpOyAvLyBjb252ZXJ0IG1hc2sgdG8gYWxwaGEgd2l0aCBhIGZha2Ugbm9kZVxuICAgIC8vIFRPRE86IHJlZmFjdG9yIG91dCBhcHBseSBmcm9tIGZlQ29sb3JNYXRyaXhcblxuICAgIG5ldyBGZUNvbG9yTWF0cml4RWxlbWVudChkb2N1bWVudCwge1xuICAgICAgbm9kZVR5cGU6IDEsXG4gICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgIG5vZGVOYW1lOiAndHlwZScsXG4gICAgICAgIHZhbHVlOiAnbHVtaW5hbmNlVG9BbHBoYSdcbiAgICAgIH0sIHtcbiAgICAgICAgbm9kZU5hbWU6ICdpbmNsdWRlT3BhY2l0eScsXG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH1dXG4gICAgfSkuYXBwbHkobWFza0N0eCwgMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7XG4gICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgdG1wQ3R4LmZpbGxTdHlsZSA9IG1hc2tDdHguY3JlYXRlUGF0dGVybihtYXNrQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRtcEN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpOyAvLyByZWFzc2lnbiBtYXNrXG5cbiAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cbk1hc2tFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFsnbWFzaycsICd0cmFuc2Zvcm0nLCAnY2xpcC1wYXRoJ107XG5cbnZhciBub29wID0gKCkgPT4gey8vIE5PT1Bcbn07XG5cbmNsYXNzIENsaXBQYXRoRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdjbGlwUGF0aCc7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY29udGV4dFByb3RvID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihjdHgpO1xuICAgIHZhciB7XG4gICAgICBiZWdpblBhdGgsXG4gICAgICBjbG9zZVBhdGhcbiAgICB9ID0gY3R4O1xuXG4gICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IG5vb3A7XG4gICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gbm9vcDtcbiAgICB9XG5cbiAgICBSZWZsZWN0LmFwcGx5KGJlZ2luUGF0aCwgY3R4LCBbXSk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQucGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdHlwZW9mIGNoaWxkLmVsZW1lbnRUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnID8gY2hpbGQuZWxlbWVudFRyYW5zZm9ybSgpIDogbnVsbDsgLy8gaGFuZGxlIDx1c2UgLz5cblxuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhdGgoY3R4KTtcblxuICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybS51bmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUmVmbGVjdC5hcHBseShjbG9zZVBhdGgsIGN0eCwgW10pO1xuICAgIGN0eC5jbGlwKCk7XG5cbiAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gYmVnaW5QYXRoO1xuICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgRmlsdGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmaWx0ZXInO1xuICB9XG5cbiAgYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHB4ID0gMDtcbiAgICB2YXIgcHkgPSAwO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgdmFyIGVmZCA9IGNoaWxkLmV4dHJhRmlsdGVyRGlzdGFuY2UgfHwgMDtcbiAgICAgIHB4ID0gTWF0aC5tYXgocHgsIGVmZCk7XG4gICAgICBweSA9IE1hdGgubWF4KHB5LCBlZmQpO1xuICAgIH0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgdmFyIHRtcENhbnZhc1dpZHRoID0gd2lkdGggKyAyICogcHg7XG4gICAgdmFyIHRtcENhbnZhc0hlaWdodCA9IGhlaWdodCArIDIgKiBweTtcblxuICAgIGlmICh0bXBDYW52YXNXaWR0aCA8IDEgfHwgdG1wQ2FudmFzSGVpZ2h0IDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54KTtcbiAgICB2YXIgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueSk7XG4gICAgdmFyIGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBGaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyk7XG4gICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgteCArIHB4LCAteSArIHB5KTtcbiAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpOyAvLyBhcHBseSBmaWx0ZXJzXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQuYXBwbHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQuYXBwbHkodG1wQ3R4LCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gcmVuZGVyIG9uIG1lXG5cbiAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCwgeCAtIHB4LCB5IC0gcHksIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbJ2ZpbHRlcicsICd0cmFuc2Zvcm0nLCAnY2xpcC1wYXRoJ107XG5cbmNsYXNzIEZlRHJvcFNoYWRvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlRHJvcFNoYWRvdyc7XG4gICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVNb3JwaG9sb2d5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmZU1vcnBob2xvZ3knO1xuICB9XG5cbiAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgfVxuXG59XG5cbmNsYXNzIEZlQ29tcG9zaXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmZUNvbXBvc2l0ZSc7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVHYXVzc2lhbkJsdXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmZUdhdXNzaWFuQmx1cic7XG4gICAgdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcih0aGlzLmdldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykuZ2V0TnVtYmVyKCkpO1xuICAgIHRoaXMuZXh0cmFGaWx0ZXJEaXN0YW5jZSA9IHRoaXMuYmx1clJhZGl1cztcbiAgfVxuXG4gIGFwcGx5KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGJsdXJSYWRpdXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LndpbmRvdyA/IGRvY3VtZW50LndpbmRvdy5kb2N1bWVudC5ib2R5IDogbnVsbDtcbiAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhczsgLy8gU3RhY2tCbHVyIHJlcXVpcmVzIGNhbnZhcyBiZSBvbiBkb2N1bWVudFxuXG4gICAgY2FudmFzLmlkID0gZG9jdW1lbnQuZ2V0VW5pcXVlSWQoKTtcblxuICAgIGlmIChib2R5KSB7XG4gICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICB9XG5cbiAgICBjYW52YXNSR0JBKGNhbnZhcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgYmx1clJhZGl1cyk7XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgYm9keS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd0aXRsZSc7XG4gIH1cblxufVxuXG5jbGFzcyBEZXNjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdkZXNjJztcbiAgfVxuXG59XG5cbnZhciBlbGVtZW50cyA9IHtcbiAgJ3N2Zyc6IFNWR0VsZW1lbnQsXG4gICdyZWN0JzogUmVjdEVsZW1lbnQsXG4gICdjaXJjbGUnOiBDaXJjbGVFbGVtZW50LFxuICAnZWxsaXBzZSc6IEVsbGlwc2VFbGVtZW50LFxuICAnbGluZSc6IExpbmVFbGVtZW50LFxuICAncG9seWxpbmUnOiBQb2x5bGluZUVsZW1lbnQsXG4gICdwb2x5Z29uJzogUG9seWdvbkVsZW1lbnQsXG4gICdwYXRoJzogUGF0aEVsZW1lbnQsXG4gICdwYXR0ZXJuJzogUGF0dGVybkVsZW1lbnQsXG4gICdtYXJrZXInOiBNYXJrZXJFbGVtZW50LFxuICAnZGVmcyc6IERlZnNFbGVtZW50LFxuICAnbGluZWFyR3JhZGllbnQnOiBMaW5lYXJHcmFkaWVudEVsZW1lbnQsXG4gICdyYWRpYWxHcmFkaWVudCc6IFJhZGlhbEdyYWRpZW50RWxlbWVudCxcbiAgJ3N0b3AnOiBTdG9wRWxlbWVudCxcbiAgJ2FuaW1hdGUnOiBBbmltYXRlRWxlbWVudCxcbiAgJ2FuaW1hdGVDb2xvcic6IEFuaW1hdGVDb2xvckVsZW1lbnQsXG4gICdhbmltYXRlVHJhbnNmb3JtJzogQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsXG4gICdmb250JzogRm9udEVsZW1lbnQsXG4gICdmb250LWZhY2UnOiBGb250RmFjZUVsZW1lbnQsXG4gICdtaXNzaW5nLWdseXBoJzogTWlzc2luZ0dseXBoRWxlbWVudCxcbiAgJ2dseXBoJzogR2x5cGhFbGVtZW50LFxuICAndGV4dCc6IFRleHRFbGVtZW50LFxuICAndHNwYW4nOiBUU3BhbkVsZW1lbnQsXG4gICd0cmVmJzogVFJlZkVsZW1lbnQsXG4gICdhJzogQUVsZW1lbnQsXG4gICd0ZXh0UGF0aCc6IFRleHRQYXRoRWxlbWVudCxcbiAgJ2ltYWdlJzogSW1hZ2VFbGVtZW50LFxuICAnZyc6IEdFbGVtZW50LFxuICAnc3ltYm9sJzogU3ltYm9sRWxlbWVudCxcbiAgJ3N0eWxlJzogU3R5bGVFbGVtZW50LFxuICAndXNlJzogVXNlRWxlbWVudCxcbiAgJ21hc2snOiBNYXNrRWxlbWVudCxcbiAgJ2NsaXBQYXRoJzogQ2xpcFBhdGhFbGVtZW50LFxuICAnZmlsdGVyJzogRmlsdGVyRWxlbWVudCxcbiAgJ2ZlRHJvcFNoYWRvdyc6IEZlRHJvcFNoYWRvd0VsZW1lbnQsXG4gICdmZU1vcnBob2xvZ3knOiBGZU1vcnBob2xvZ3lFbGVtZW50LFxuICAnZmVDb21wb3NpdGUnOiBGZUNvbXBvc2l0ZUVsZW1lbnQsXG4gICdmZUNvbG9yTWF0cml4JzogRmVDb2xvck1hdHJpeEVsZW1lbnQsXG4gICdmZUdhdXNzaWFuQmx1cic6IEZlR2F1c3NpYW5CbHVyRWxlbWVudCxcbiAgJ3RpdGxlJzogVGl0bGVFbGVtZW50LFxuICAnZGVzYyc6IERlc2NFbGVtZW50XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW1hZ2UoX3gpIHtcbiAgcmV0dXJuIF9jcmVhdGVJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlSW1hZ2UoKSB7XG4gIF9jcmVhdGVJbWFnZSA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoc3JjKSB7XG4gICAgdmFyIGFub255bW91c0Nyb3NzT3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgIGlmIChhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgIH07XG5cbiAgICAgIGltYWdlLm9uZXJyb3IgPSAoX2V2ZW50LCBfc291cmNlLCBfbGluZW5vLCBfY29sbm8sIGVycm9yKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoY2FudmcpIHtcbiAgICB2YXIge1xuICAgICAgcm9vdEVtU2l6ZSA9IDEyLFxuICAgICAgZW1TaXplID0gMTIsXG4gICAgICBjcmVhdGVDYW52YXMgPSBEb2N1bWVudC5jcmVhdGVDYW52YXMsXG4gICAgICBjcmVhdGVJbWFnZSA9IERvY3VtZW50LmNyZWF0ZUltYWdlLFxuICAgICAgYW5vbnltb3VzQ3Jvc3NPcmlnaW5cbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmNhbnZnID0gY2Fudmc7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xuICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgdGhpcy5mb250cyA9IFtdO1xuICAgIHRoaXMuZW1TaXplU3RhY2sgPSBbXTtcbiAgICB0aGlzLnVuaXF1ZUlkID0gMDtcbiAgICB0aGlzLnNjcmVlbiA9IGNhbnZnLnNjcmVlbjtcbiAgICB0aGlzLnJvb3RFbVNpemUgPSByb290RW1TaXplO1xuICAgIHRoaXMuZW1TaXplID0gZW1TaXplO1xuICAgIHRoaXMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuICAgIHRoaXMuY3JlYXRlSW1hZ2UgPSB0aGlzLmJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMuc2NyZWVuLndhaXQodGhpcy5pc0ltYWdlc0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNjcmVlbi53YWl0KHRoaXMuaXNGb250c0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICBpZiAodHlwZW9mIGFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiAoc291cmNlLCBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luKSA9PiBjcmVhdGVJbWFnZShzb3VyY2UsIHR5cGVvZiBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicgPyBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luIDogYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVJbWFnZTtcbiAgfVxuXG4gIGdldCB3aW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLndpbmRvdztcbiAgfVxuXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4uZmV0Y2g7XG4gIH1cblxuICBnZXQgY3R4KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5jdHg7XG4gIH1cblxuICBnZXQgZW1TaXplKCkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBlbVNpemVTdGFja1tlbVNpemVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHNldCBlbVNpemUodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZW1TaXplU3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBlbVNpemVTdGFjay5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHBvcEVtU2l6ZSgpIHtcbiAgICB2YXIge1xuICAgICAgZW1TaXplU3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBlbVNpemVTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGdldFVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBcImNhbnZnXCIuY29uY2F0KCsrdGhpcy51bmlxdWVJZCk7XG4gIH1cblxuICBpc0ltYWdlc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXMuZXZlcnkoXyA9PiBfLmxvYWRlZCk7XG4gIH1cblxuICBpc0ZvbnRzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZvbnRzLmV2ZXJ5KF8gPT4gXy5sb2FkZWQpO1xuICB9XG5cbiAgY3JlYXRlRG9jdW1lbnRFbGVtZW50KGRvY3VtZW50KSB7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIGRvY3VtZW50RWxlbWVudC5yb290ID0gdHJ1ZTtcbiAgICBkb2N1bWVudEVsZW1lbnQuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICBjcmVhdGVFbGVtZW50KG5vZGUpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCAnJyk7XG4gICAgdmFyIEVsZW1lbnRUeXBlID0gRG9jdW1lbnQuZWxlbWVudFR5cGVzW2VsZW1lbnRUeXBlXTtcblxuICAgIGlmICh0eXBlb2YgRWxlbWVudFR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnRUeXBlKHRoaXMsIG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVW5rbm93bkVsZW1lbnQodGhpcywgbm9kZSk7XG4gIH1cblxuICBjcmVhdGVUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLCBub2RlKTtcbiAgfVxuXG4gIHNldFZpZXdCb3goY29uZmlnKSB7XG4gICAgdGhpcy5zY3JlZW4uc2V0Vmlld0JveChfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgZG9jdW1lbnQ6IHRoaXNcbiAgICB9LCBjb25maWcpKTtcbiAgfVxuXG59XG5Eb2N1bWVudC5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG5Eb2N1bWVudC5jcmVhdGVJbWFnZSA9IGNyZWF0ZUltYWdlO1xuRG9jdW1lbnQuZWxlbWVudFR5cGVzID0gZWxlbWVudHM7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBTVkcgcmVuZGVyZXIgb24gY2FudmFzLlxyXG4gKi9cblxuY2xhc3MgQ2Fudmcge1xuICAvKipcclxuICAgKiBNYWluIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIERvY3VtZW50LlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBTY3JlZW4oY3R4LCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBkb2N1bWVudCA9IG5ldyBEb2N1bWVudCh0aGlzLCBvcHRpb25zKTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRFbGVtZW50KHN2Zyk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBDYW52ZyBpbnN0YW5jZSBmcm9tIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb20oY3R4LCBzdmcpIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gX2FyZ3VtZW50cy5sZW5ndGggPiAyICYmIF9hcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgdmFyIHN2Z0RvY3VtZW50ID0geWllbGQgcGFyc2VyLnBhcnNlKHN2Zyk7XG4gICAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21TdHJpbmcoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgdmFyIHN2Z0RvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcpO1xuICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBmb3JrKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBDYW52Zy5mcm9tKGN0eCwgc3ZnLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgZm9ya1N0cmluZyhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gQ2FudmcuZnJvbVN0cmluZyhjdHgsIHN2ZywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgcHJvbWlzZS5cclxuICAgKiBAcmV0dXJucyBSZWFkeSBwcm9taXNlLlxyXG4gICAqL1xuXG5cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnJlYWR5KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgdmFsdWUuXHJcbiAgICogQHJldHVybnMgSXMgcmVhZHkgb3Igbm90LlxyXG4gICAqL1xuXG5cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4uaXNSZWFkeSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbmRlciBvbmx5IGZpcnN0IGZyYW1lLCBpZ25vcmluZyBhbmltYXRpb25zIGFuZCBtb3VzZS5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqL1xuXG5cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYXJndW1lbnRzMiA9IGFyZ3VtZW50cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9hcmd1bWVudHMyLmxlbmd0aCA+IDAgJiYgX2FyZ3VtZW50czJbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHMyWzBdIDoge307XG5cbiAgICAgIF90aGlzLnN0YXJ0KF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBlbmFibGVSZWRyYXc6IHRydWUsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgeWllbGQgX3RoaXMucmVhZHkoKTtcblxuICAgICAgX3RoaXMuc3RvcCgpO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyIG9wdGlvbnMuXHJcbiAgICovXG5cblxuICBzdGFydCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNjcmVlbixcbiAgICAgIG9wdGlvbnM6IGJhc2VPcHRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgc2NyZWVuLnN0YXJ0KGRvY3VtZW50RWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZVxuICAgIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3AgcmVuZGVyaW5nLlxyXG4gICAqL1xuXG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnNjcmVlbi5zdG9wKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cclxuICAgKiBAcGFyYW0gd2lkdGhcclxuICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cclxuICAgKi9cblxuXG4gIHJlc2l6ZSh3aWR0aCkge1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5yZXNpemUod2lkdGgsIGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gIH1cblxufVxuXG5leHBvcnQgeyBBRWxlbWVudCwgQW5pbWF0ZUNvbG9yRWxlbWVudCwgQW5pbWF0ZUVsZW1lbnQsIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LCBCb3VuZGluZ0JveCwgQ0IxLCBDQjIsIENCMywgQ0I0LCBDYW52ZywgQ2lyY2xlRWxlbWVudCwgQ2xpcFBhdGhFbGVtZW50LCBEZWZzRWxlbWVudCwgRGVzY0VsZW1lbnQsIERvY3VtZW50LCBFbGVtZW50LCBFbGxpcHNlRWxlbWVudCwgRmVDb2xvck1hdHJpeEVsZW1lbnQsIEZlQ29tcG9zaXRlRWxlbWVudCwgRmVEcm9wU2hhZG93RWxlbWVudCwgRmVHYXVzc2lhbkJsdXJFbGVtZW50LCBGZU1vcnBob2xvZ3lFbGVtZW50LCBGaWx0ZXJFbGVtZW50LCBGb250LCBGb250RWxlbWVudCwgRm9udEZhY2VFbGVtZW50LCBHRWxlbWVudCwgR2x5cGhFbGVtZW50LCBHcmFkaWVudEVsZW1lbnQsIEltYWdlRWxlbWVudCwgTGluZUVsZW1lbnQsIExpbmVhckdyYWRpZW50RWxlbWVudCwgTWFya2VyRWxlbWVudCwgTWFza0VsZW1lbnQsIE1hdHJpeCwgTWlzc2luZ0dseXBoRWxlbWVudCwgTW91c2UsIFBTRVVET19aRVJPLCBQYXJzZXIsIFBhdGhFbGVtZW50LCBQYXRoUGFyc2VyLCBQYXR0ZXJuRWxlbWVudCwgUG9pbnQsIFBvbHlnb25FbGVtZW50LCBQb2x5bGluZUVsZW1lbnQsIFByb3BlcnR5LCBRQjEsIFFCMiwgUUIzLCBSYWRpYWxHcmFkaWVudEVsZW1lbnQsIFJlY3RFbGVtZW50LCBSZW5kZXJlZEVsZW1lbnQsIFJvdGF0ZSwgU1ZHRWxlbWVudCwgU1ZHRm9udExvYWRlciwgU2NhbGUsIFNjcmVlbiwgU2tldywgU2tld1gsIFNrZXdZLCBTdG9wRWxlbWVudCwgU3R5bGVFbGVtZW50LCBTeW1ib2xFbGVtZW50LCBUUmVmRWxlbWVudCwgVFNwYW5FbGVtZW50LCBUZXh0RWxlbWVudCwgVGV4dFBhdGhFbGVtZW50LCBUaXRsZUVsZW1lbnQsIFRyYW5zZm9ybSwgVHJhbnNsYXRlLCBVbmtub3duRWxlbWVudCwgVXNlRWxlbWVudCwgVmlld1BvcnQsIGNvbXByZXNzU3BhY2VzLCBDYW52ZyBhcyBkZWZhdWx0LCBnZXRTZWxlY3RvclNwZWNpZmljaXR5LCBub3JtYWxpemVBdHRyaWJ1dGVOYW1lLCBub3JtYWxpemVDb2xvciwgcGFyc2VFeHRlcm5hbFVybCwgaW5kZXggYXMgcHJlc2V0cywgdG9OdW1iZXJzLCB0cmltTGVmdCwgdHJpbVJpZ2h0LCB2ZWN0b3JNYWduaXR1ZGUsIHZlY3RvcnNBbmdsZSwgdmVjdG9yc1JhdGlvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1WlhNdWFuTWlMQ0p6YjNWeVkyVnpJanBiWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0ZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenNpZlE9PVxuIl0sIm5hbWVzIjpbIl9hc3luY1RvR2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiUkdCQ29sb3IiLCJTVkdQYXRoRGF0YSIsImNhbnZhc1JHQkEiLCJvZmZzY3JlZW4iLCJET01QYXJzZXIiLCJET01QYXJzZXJGYWxsYmFjayIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInByZXNldCIsIndpbmRvdyIsImlnbm9yZUFuaW1hdGlvbiIsImlnbm9yZU1vdXNlIiwiY3JlYXRlQ2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVJbWFnZSIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJibG9iIiwiaW1nIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJub2RlIiwiX3JlZiIsImNhbnZhcyIsImxvYWRJbWFnZSIsImluZGV4IiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY29tcHJlc3NTcGFjZXMiLCJzdHIiLCJyZXBsYWNlIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJ0b051bWJlcnMiLCJtYXRjaGVzIiwibWF0Y2giLCJtYXAiLCJwYXJzZUZsb2F0IiwiYWxsVXBwZXJjYXNlIiwibm9ybWFsaXplQXR0cmlidXRlTmFtZSIsIm5hbWUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJwYXJzZUV4dGVybmFsVXJsIiwidXJsTWF0Y2giLCJleGVjIiwibm9ybWFsaXplQ29sb3IiLCJjb2xvciIsInN0YXJ0c1dpdGgiLCJyZ2JQYXJ0cyIsIm5vcm1hbGl6ZWRDb2xvciIsIm51bSIsImlzRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwicm91bmQiLCJhdHRyaWJ1dGVSZWdleCIsImlkUmVnZXgiLCJjbGFzc1JlZ2V4IiwicHNldWRvRWxlbWVudFJlZ2V4IiwicHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCIsInBzZXVkb0NsYXNzUmVnZXgiLCJlbGVtZW50UmVnZXgiLCJmaW5kU2VsZWN0b3JNYXRjaCIsInNlbGVjdG9yIiwicmVnZXgiLCJnZXRTZWxlY3RvclNwZWNpZmljaXR5Iiwic3BlY2lmaWNpdHkiLCJjdXJyZW50U2VsZWN0b3IiLCJkZWx0YSIsImpvaW4iLCJQU0VVRE9fWkVSTyIsInZlY3Rvck1hZ25pdHVkZSIsInYiLCJzcXJ0IiwicG93IiwidmVjdG9yc1JhdGlvIiwidSIsInZlY3RvcnNBbmdsZSIsImFjb3MiLCJDQjEiLCJ0IiwiQ0IyIiwiQ0IzIiwiQ0I0IiwiUUIxIiwiUUIyIiwiUUIzIiwiUHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsImRvY3VtZW50IiwidmFsdWUiLCJpc05vcm1hbGl6ZWRDb2xvciIsImVtcHR5Iiwic3BsaXQiLCJzZXBhcmF0b3IiLCJnZXRTdHJpbmciLCJ0cmltIiwiaGFzVmFsdWUiLCJ6ZXJvSXNWYWx1ZSIsImlzU3RyaW5nIiwicmVnZXhwIiwicmVzdWx0IiwiaXNVcmxEZWZpbml0aW9uIiwiaXNQaXhlbHMiLCJhc1N0cmluZyIsImVuZHNXaXRoIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImRlZiIsImdldE51bWJlciIsIm4iLCJnZXRDb2xvciIsImdldERwaSIsImdldFJlbSIsInJvb3RFbVNpemUiLCJnZXRFbSIsImVtU2l6ZSIsImdldFVuaXRzIiwiZ2V0UGl4ZWxzIiwiYXhpc09ySXNGb250U2l6ZSIsInByb2Nlc3NQZXJjZW50IiwiYXhpcyIsImlzRm9udFNpemUiLCJ2aWV3UG9ydCIsInNjcmVlbiIsIm1pbiIsImNvbXB1dGVTaXplIiwibWF4IiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0UmFkaWFucyIsIlBJIiwiZ2V0RGVmaW5pdGlvbiIsImRlZmluaXRpb25zIiwiZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbiIsImVsZW1lbnQiLCJvcGFjaXR5IiwiY3JlYXRlR3JhZGllbnQiLCJjdHgiLCJjcmVhdGVQYXR0ZXJuIiwiZ2V0SHJlZkF0dHJpYnV0ZSIsInBhdHRlcm5UcmFuc2Zvcm0iLCJnZXRBdHRyaWJ1dGUiLCJnZXRUZXh0QmFzZWxpbmUiLCJ0ZXh0QmFzZWxpbmVNYXBwaW5nIiwiYWRkT3BhY2l0eSIsImxlbiIsImNvbW1hcyIsImkiLCJvayIsImFscGhhIiwidG9SR0JBIiwiVmlld1BvcnQiLCJ2aWV3UG9ydHMiLCJjbGVhciIsInNldEN1cnJlbnQiLCJwdXNoIiwicmVtb3ZlQ3VycmVudCIsInBvcCIsImdldEN1cnJlbnQiLCJkIiwiUG9pbnQiLCJ4IiwieSIsInBhcnNlIiwicG9pbnQiLCJkZWZhdWx0VmFsdWUiLCJwYXJzZVNjYWxlIiwic2NhbGUiLCJwYXJzZVBhdGgiLCJwYXRoIiwicG9pbnRzIiwicGF0aFBvaW50cyIsImFuZ2xlVG8iLCJhdGFuMiIsImFwcGx5VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwieHAiLCJ5cCIsIk1vdXNlIiwid29ya2luZyIsImV2ZW50cyIsImV2ZW50RWxlbWVudHMiLCJvbkNsaWNrIiwiYmluZCIsIm9uTW91c2VNb3ZlIiwiaXNXb3JraW5nIiwic3RhcnQiLCJvbmNsaWNrIiwib25tb3VzZW1vdmUiLCJzdG9wIiwiaGFzRXZlbnRzIiwicnVuRXZlbnRzIiwic3R5bGUiLCJjdXJzb3IiLCJmb3JFYWNoIiwicnVuIiwicGFyZW50IiwiY2hlY2tQYXRoIiwiX3JlZjIiLCJpc1BvaW50SW5QYXRoIiwiY2hlY2tCb3VuZGluZ0JveCIsImJvdW5kaW5nQm94IiwiX3JlZjMiLCJpc1BvaW50SW5Cb3giLCJtYXBYWSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJzY3JvbGxYIiwic2Nyb2xsWSIsImV2ZW50IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0eXBlIiwiZXZlbnRUYXJnZXQiLCJkZWZhdWx0V2luZG93IiwiZGVmYXVsdEZldGNoJDEiLCJTY3JlZW4iLCJGUkFNRVJBVEUiLCJNQVhfVklSVFVBTF9QSVhFTFMiLCJDTElFTlRfV0lEVEgiLCJDTElFTlRfSEVJR0hUIiwibW91c2UiLCJhbmltYXRpb25zIiwid2FpdHMiLCJmcmFtZUR1cmF0aW9uIiwiaXNSZWFkeUxvY2siLCJpc0ZpcnN0UmVuZGVyIiwiaW50ZXJ2YWxJZCIsIndhaXQiLCJjaGVja2VyIiwicmVhZHkiLCJyZWFkeVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImlzUmVhZHkiLCJldmVyeSIsIl8iLCJyZXNvbHZlUmVhZHkiLCJzZXREZWZhdWx0cyIsInN0cm9rZVN0eWxlIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsInNldFZpZXdCb3giLCJhc3BlY3RSYXRpbyIsImRlc2lyZWRXaWR0aCIsImRlc2lyZWRIZWlnaHQiLCJtaW5YIiwibWluWSIsInJlZlgiLCJyZWZZIiwiY2xpcCIsImNsaXBYIiwiY2xpcFkiLCJjbGVhbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW9BbGlnbiIsImFzcGVjdFJhdGlvTWVldE9yU2xpY2UiLCJhbGlnbiIsIm1lZXRPclNsaWNlIiwic2NhbGVYIiwic2NhbGVZIiwic2NhbGVNaW4iLCJzY2FsZU1heCIsImZpbmFsRGVzaXJlZFdpZHRoIiwiZmluYWxEZXNpcmVkSGVpZ2h0IiwicmVmWFByb3AiLCJyZWZZUHJvcCIsImhhc1JlZnMiLCJ0cmFuc2xhdGUiLCJzY2FsZWRDbGlwWCIsInNjYWxlZENsaXBZIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiaXNNZWV0TWluWSIsImlzU2xpY2VNYXhZIiwiaXNNZWV0TWluWCIsImlzU2xpY2VNYXhYIiwiZW5hYmxlUmVkcmF3IiwiaWdub3JlRGltZW5zaW9ucyIsImlnbm9yZUNsZWFyIiwiZm9yY2VSZWRyYXciLCJzY2FsZVdpZHRoIiwic2NhbGVIZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInJlbmRlciIsIm5vdyIsIkRhdGUiLCJ0aGVuIiwidGljayIsInNob3VsZFVwZGF0ZSIsImNhbmNlbCIsInJlZHVjZSIsImFuaW1hdGlvbiIsInVwZGF0ZSIsIndpZHRoU3R5bGUiLCJnZXRTdHlsZSIsImhlaWdodFN0eWxlIiwiY29uY2F0IiwiY1dpZHRoIiwiY2xpZW50V2lkdGgiLCJjSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwidmlld0JveCIsInhSYXRpbyIsInlSYXRpbyIsIl93aWR0aFN0eWxlIiwiaXNOYU4iLCJfaGVpZ2h0U3R5bGUiLCJ0cmFuc2Zvcm1TdHlsZSIsImNsZWFyUmVjdCIsImRlZmF1bHRGZXRjaCIsIkRlZmF1bHRET01QYXJzZXIiLCJQYXJzZXIiLCJyZXNvdXJjZSIsIl90aGlzIiwicGFyc2VGcm9tU3RyaW5nIiwibG9hZCIsInhtbCIsInBhcnNlciIsImNoZWNrRG9jdW1lbnQiLCJlcnIiLCJwYXJzZXJFcnJvciIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiRXJyb3IiLCJ0ZXh0Q29udGVudCIsIl90aGlzMiIsInRleHQiLCJUcmFuc2xhdGUiLCJhcHBseSIsInVuYXBwbHkiLCJhcHBseVRvUG9pbnQiLCJSb3RhdGUiLCJyb3RhdGUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhbmdsZSIsIm9yaWdpblgiLCJvcmlnaW5ZIiwiY3giLCJjeSIsIm51bWJlcnMiLCJ0eCIsInR5IiwicmFkIiwiY29zIiwic2luIiwiU2NhbGUiLCJzY2FsZVNpemUiLCJNYXRyaXgiLCJtYXRyaXgiLCJhIiwiYiIsImMiLCJlIiwiZiIsImciLCJoIiwiZGV0IiwiU2tldyIsInNrZXciLCJTa2V3WCIsInRhbiIsIlNrZXdZIiwicGFyc2VUcmFuc2Zvcm1zIiwicGFyc2VUcmFuc2Zvcm0iLCJUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1zIiwiZGF0YSIsIlRyYW5zZm9ybVR5cGUiLCJ0cmFuc2Zvcm1UeXBlcyIsImZyb21FbGVtZW50IiwidHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5IiwidHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5Iiwic2tld1giLCJza2V3WSIsIkVsZW1lbnQiLCJjYXB0dXJlVGV4dE5vZGVzIiwiYXR0cmlidXRlcyIsInN0eWxlcyIsInN0eWxlc1NwZWNpZmljaXR5IiwiYW5pbWF0aW9uRnJvemVuIiwiYW5pbWF0aW9uRnJvemVuVmFsdWUiLCJjaGlsZHJlbiIsIm5vZGVUeXBlIiwiQXJyYXkiLCJmcm9tIiwiYXR0cmlidXRlIiwibm9kZU5hbWUiLCJhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uIiwiaWQiLCJjaGlsZE5vZGVzIiwiY2hpbGROb2RlIiwiYWRkQ2hpbGQiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiZ2V0VGV4dCIsImNyZWF0ZUlmTm90RXhpc3RzIiwiYXR0ciIsIl9hdHRyIiwia2V5Iiwic2tpcEFuY2VzdG9ycyIsInBhcmVudFN0eWxlIiwiX3N0eWxlIiwic2F2ZSIsIm1hc2siLCJhcHBseUVmZmVjdHMiLCJmaWx0ZXIiLCJzZXRDb250ZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJjbGVhckNvbnRleHQiLCJyZXN0b3JlIiwiY2xpcFBhdGhTdHlsZVByb3AiLCJjaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJpZ25vcmVDaGlsZFR5cGVzIiwiaW5jbHVkZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJfbm9kZSRnZXRBdHRyaWJ1dGUiLCJzdHlsZUNsYXNzZXMiLCJjYWxsIiwic29tZSIsInN0eWxlQ2xhc3MiLCJleGlzdGluZ1NwZWNpZmljaXR5IiwicmVtb3ZlU3R5bGVzIiwiaWdub3JlU3R5bGVzIiwidG9SZXN0b3JlIiwic3R5bGVQcm9wIiwicmVzdG9yZVN0eWxlcyIsImlzRmlyc3RDaGlsZCIsIl90aGlzJHBhcmVudCIsImluZGV4T2YiLCJVbmtub3duRWxlbWVudCIsIndyYXBGb250RmFtaWx5IiwiZm9udEZhbWlseSIsInRyaW1tZWQiLCJwcmVwYXJlRm9udEZhbWlseSIsInByb2Nlc3MiLCJwcmVwYXJlRm9udFN0eWxlIiwiZm9udFN0eWxlIiwidGFyZ2V0Rm9udFN0eWxlIiwicHJlcGFyZUZvbnRXZWlnaHQiLCJmb250V2VpZ2h0IiwidGFyZ2V0Rm9udFdlaWdodCIsIkZvbnQiLCJmb250VmFyaWFudCIsImZvbnRTaXplIiwiaW5oZXJpdCIsImluaGVyaXRGb250IiwiZm9udCIsInBhcnRzIiwic2V0IiwicGFydCIsInZhcmlhbnRzIiwid2VpZ2h0cyIsInRvU3RyaW5nIiwiQm91bmRpbmdCb3giLCJ4MSIsIk51bWJlciIsIk5hTiIsInkxIiwieDIiLCJ5MiIsImFkZFBvaW50IiwiYWRkWCIsImFkZFkiLCJhZGRCb3VuZGluZ0JveCIsInN1bUN1YmljIiwicDAiLCJwMSIsInAyIiwicDMiLCJiZXppZXJDdXJ2ZUFkZCIsImZvclgiLCJiMmFjIiwidDEiLCJ0MiIsImFkZEJlemllckN1cnZlIiwicDB4IiwicDB5IiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwicDN4IiwicDN5IiwiYWRkUXVhZHJhdGljQ3VydmUiLCJjcDF4IiwiY3AxeSIsImNwMngiLCJjcDJ5IiwiUGF0aFBhcnNlciIsImNvbnRyb2wiLCJjdXJyZW50IiwiY29tbWFuZCIsImNvbW1hbmRzIiwicHJldmlvdXNDb21tYW5kIiwiYW5nbGVzIiwicmVzZXQiLCJpc0VuZCIsIm5leHQiLCJnZXRQb2ludCIsInhQcm9wIiwieVByb3AiLCJtYWtlQWJzb2x1dGUiLCJnZXRBc0NvbnRyb2xQb2ludCIsImdldEFzQ3VycmVudFBvaW50IiwiZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50IiwiQ1VSVkVfVE8iLCJTTU9PVEhfQ1VSVkVfVE8iLCJRVUFEX1RPIiwiU01PT1RIX1FVQURfVE8iLCJveCIsIm95IiwicmVsYXRpdmUiLCJhZGRNYXJrZXIiLCJwcmlvclRvIiwiYWRkTWFya2VyQW5nbGUiLCJnZXRNYXJrZXJQb2ludHMiLCJnZXRNYXJrZXJBbmdsZXMiLCJqIiwiUmVuZGVyZWRFbGVtZW50IiwibW9kaWZpZWRFbVNpemVTdGFjayIsImNhbGN1bGF0ZU9wYWNpdHkiLCJvcGFjaXR5U3R5bGUiLCJmcm9tTWVhc3VyZSIsImZpbGxTdHlsZVByb3AiLCJmaWxsT3BhY2l0eVN0eWxlUHJvcCIsInN0cm9rZVN0eWxlUHJvcCIsInN0cm9rZU9wYWNpdHlQcm9wIiwiZmlsbFN0eWxlIiwiX2ZpbGxTdHlsZSIsIl9maWxsU3R5bGUyIiwiX3N0cm9rZVN0eWxlIiwiX3N0cm9rZVN0eWxlMiIsInN0cm9rZVdpZHRoU3R5bGVQcm9wIiwibmV3TGluZVdpZHRoIiwibGluZVdpZHRoIiwic3Ryb2tlTGluZWNhcFN0eWxlUHJvcCIsInN0cm9rZUxpbmVqb2luU3R5bGVQcm9wIiwic3Ryb2tlTWl0ZXJsaW1pdFByb3AiLCJzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AiLCJzdHJva2VEYXNob2Zmc2V0UHJvcCIsImdhcHMiLCJzZXRMaW5lRGFzaCIsIndlYmtpdExpbmVEYXNoIiwibW96RGFzaCIsIm9mZnNldCIsImxpbmVEYXNoT2Zmc2V0Iiwid2Via2l0TGluZURhc2hPZmZzZXQiLCJtb3pEYXNoT2Zmc2V0IiwiZm9udFN0eWxlUHJvcCIsImZvbnRTdHlsZVN0eWxlUHJvcCIsImZvbnRWYXJpYW50U3R5bGVQcm9wIiwiZm9udFdlaWdodFN0eWxlUHJvcCIsImZvbnRTaXplU3R5bGVQcm9wIiwiZm9udEZhbWlseVN0eWxlUHJvcCIsImdsb2JhbEFscGhhIiwicG9wRW1TaXplIiwiUGF0aEVsZW1lbnQiLCJwYXRoUGFyc2VyIiwiTU9WRV9UTyIsInBhdGhNIiwiTElORV9UTyIsInBhdGhMIiwiSE9SSVpfTElORV9UTyIsInBhdGhIIiwiVkVSVF9MSU5FX1RPIiwicGF0aFYiLCJwYXRoQyIsInBhdGhTIiwicGF0aFEiLCJwYXRoVCIsIkFSQyIsInBhdGhBIiwiQ0xPU0VfUEFUSCIsInBhdGhaIiwiZ2V0Qm91bmRpbmdCb3giLCJnZXRNYXJrZXJzIiwibWFya2VycyIsImZpbGxSdWxlU3R5bGVQcm9wIiwiZmlsbCIsInNldFRyYW5zZm9ybSIsInN0cm9rZSIsIm1hcmtlcnNMYXN0SW5kZXgiLCJtYXJrZXJTdGFydFN0eWxlUHJvcCIsIm1hcmtlck1pZFN0eWxlUHJvcCIsIm1hcmtlckVuZFN0eWxlUHJvcCIsIm1hcmtlciIsIl9tYXJrZXIiLCJfcG9pbnQiLCJfYW5nbGUiLCJfbWFya2VyMiIsIl9wb2ludDIiLCJfYW5nbGUyIiwiY29udHJvbFBvaW50IiwiY3VycmVudFBvaW50IiwiYmV6aWVyQ3VydmVUbyIsInF1YWRyYXRpY0N1cnZlVG8iLCJyWCIsInJZIiwieFJvdCIsImxBcmNGbGFnIiwic3dlZXBGbGFnIiwieEF4aXNSb3RhdGlvbiIsImN1cnJwIiwibCIsInMiLCJjcHAiLCJjZW50cCIsImExIiwiYWQiLCJkaXIiLCJhaCIsImhhbGZXYXkiLCJyIiwic3giLCJzeSIsImFyYyIsIkJvb2xlYW4iLCJHbHlwaEVsZW1lbnQiLCJob3JpekFkdlgiLCJ1bmljb2RlIiwiYXJhYmljRm9ybSIsIlRleHRFbGVtZW50IiwibWVhc3VyZUNhY2hlIiwidGV4dEJhc2VsaW5lIiwiaW5pdGlhbGl6ZUNvb3JkaW5hdGVzIiwibGVhZlRleHRzIiwidGV4dENodW5rU3RhcnQiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1heFgiLCJORUdBVElWRV9JTkZJTklUWSIsImdldFRFbGVtZW50Qm91bmRpbmdCb3giLCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlIiwiY2hpbGRCb3VuZGluZ0JveCIsImdldENoaWxkQm91bmRpbmdCb3giLCJnZXRGb250U2l6ZSIsImluaGVyaXRGb250U2l6ZSIsIm1lYXN1cmVUZXh0IiwiZ2V0R2x5cGgiLCJjaGFyIiwiZ2x5cGgiLCJpc0FyYWJpYyIsInByZXZDaGFyIiwibmV4dENoYXIiLCJnbHlwaHMiLCJtYXliZUdseXBoIiwibWlzc2luZ0dseXBoIiwiZ2V0VGV4dEZyb21Ob2RlIiwicGFyZW50Tm9kZSIsImxhc3RJbmRleCIsInJlbmRlclRFbGVtZW50Q2hpbGRyZW4iLCJyZW5kZXJDaGlsZCIsInJlbmRlclRleHQiLCJjdXN0b21Gb250IiwidW5pdHNQZXJFbSIsImZvbnRGYWNlIiwiY3R4Rm9udCIsImlzUlRMIiwicmV2ZXJzZSIsImR4IiwibHciLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJhcHBseUFuY2hvcmluZyIsImZpcnN0RWxlbWVudCIsInRleHRBbmNob3IiLCJzaGlmdCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlIiwidGV4dFBhcmVudCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXMiLCJ4QXR0ciIsInlBdHRyIiwiZHhBdHRyIiwiZHlBdHRyIiwiZ2V0SW5oZXJpdGVkQXR0cmlidXRlIiwibWVhc3VyZSIsIm1lYXN1cmVUYXJnZXRUZXh0IiwidGFyZ2V0VGV4dCIsIl9tZWFzdXJlIiwicGFyZW50QXR0ciIsIlRTcGFuRWxlbWVudCIsIlRleHROb2RlIiwiU1ZHRWxlbWVudCIsInJvb3QiLCJfdGhpcyRub2RlJHBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImZvbnRTaXplUHJvcCIsInJlZlhBdHRyIiwicmVmWUF0dHIiLCJ2aWV3Qm94QXR0ciIsInJlc2l6ZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJ3aWR0aEF0dHIiLCJoZWlnaHRBdHRyIiwic3R5bGVBdHRyIiwib3JpZ2luV2lkdGgiLCJvcmlnaW5IZWlnaHQiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciIsIlJlY3RFbGVtZW50IiwicnhBdHRyIiwicnlBdHRyIiwicngiLCJyeSIsIktBUFBBIiwiQ2lyY2xlRWxlbWVudCIsIkVsbGlwc2VFbGVtZW50IiwiTGluZUVsZW1lbnQiLCJnZXRQb2ludHMiLCJ4MCIsInkwIiwiUG9seWxpbmVFbGVtZW50IiwiUG9seWdvbkVsZW1lbnQiLCJQYXR0ZXJuRWxlbWVudCIsInBhcmVudE9wYWNpdHlQcm9wIiwicGF0dGVyblN2ZyIsInBhdHRlcm5DYW52YXMiLCJwYXR0ZXJuQ3R4IiwiZ2V0Q29udGV4dCIsInBhdHRlcm4iLCJNYXJrZXJFbGVtZW50Iiwib3JpZW50IiwibWFya2VyVW5pdHMiLCJtYXJrZXJTdmciLCJvdmVyZmxvdyIsIkRlZnNFbGVtZW50IiwiR0VsZW1lbnQiLCJHcmFkaWVudEVsZW1lbnQiLCJhdHRyaWJ1dGVzVG9Jbmhlcml0Iiwic3RvcHMiLCJnZXRHcmFkaWVudFVuaXRzIiwic3RvcHNDb250YWluZXIiLCJpbmhlcml0U3RvcENvbnRhaW5lciIsImdyYWRpZW50IiwiZ2V0R3JhZGllbnQiLCJhZGRQYXJlbnRPcGFjaXR5IiwiYWRkQ29sb3JTdG9wIiwicm9vdFZpZXciLCJyZWN0IiwiZ3JvdXAiLCJhdHRyaWJ1dGVUb0luaGVyaXQiLCJjb2xvclByb3AiLCJMaW5lYXJHcmFkaWVudEVsZW1lbnQiLCJpc0JvdW5kaW5nQm94VW5pdHMiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsIlJhZGlhbEdyYWRpZW50RWxlbWVudCIsImZ4IiwiZnkiLCJmciIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiU3RvcEVsZW1lbnQiLCJzdG9wT3BhY2l0eSIsInN0b3BDb2xvciIsIkFuaW1hdGVFbGVtZW50IiwiZHVyYXRpb24iLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsVW5pdHMiLCJyZW1vdmVkIiwiZnJvemVuIiwiYmVnaW4iLCJtYXhEdXJhdGlvbiIsInRvIiwidmFsdWVzIiwidmFsdWVzQXR0ciIsImdldFByb3BlcnR5IiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZU5hbWUiLCJjYWxjVmFsdWUiLCJwcm9ncmVzcyIsImdldFByb2dyZXNzIiwibmV3VmFsdWUiLCJwcm9wIiwidXBkYXRlZCIsInR5cGVBdHRyIiwicCIsImxiIiwiZmxvb3IiLCJ1YiIsImNlaWwiLCJBbmltYXRlQ29sb3JFbGVtZW50IiwiY29sb3JGcm9tIiwiY29sb3JUbyIsIkFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50IiwidHJhbnNmb3JtRnJvbSIsInRyYW5zZm9ybVRvIiwiRm9udEVsZW1lbnQiLCJmb250RmFtaWx5U3R5bGUiLCJGb250RmFjZUVsZW1lbnQiLCJhc2NlbnQiLCJkZXNjZW50IiwiTWlzc2luZ0dseXBoRWxlbWVudCIsIlRSZWZFbGVtZW50IiwiZmlyc3RDaGlsZCIsIkFFbGVtZW50IiwiaGFzVGV4dCIsIm9wZW4iLCJvd25LZXlzJDIiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQkMiIsInRhcmdldCIsInNvdXJjZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJUZXh0UGF0aEVsZW1lbnQiLCJ0ZXh0V2lkdGgiLCJ0ZXh0SGVpZ2h0IiwicGF0aExlbmd0aCIsImdseXBoSW5mbyIsImxldHRlclNwYWNpbmdDYWNoZSIsIm1lYXN1cmVzQ2FjaGUiLCJNYXAiLCJwYXRoRWxlbWVudCIsImRhdGFBcnJheSIsInBhcnNlUGF0aERhdGEiLCJ0aGV0YSIsImRUaGV0YSIsInBzaSIsImZzIiwic2V0VGV4dERhdGEiLCJ0ZXh0RGVjb3JhdGlvbiIsInJvdGF0aW9uIiwicGFydGlhbFRleHQiLCJnZXRMZXR0ZXJTcGFjaW5nQXQiLCJpZHgiLCJmaW5kU2VnbWVudFRvRml0Q2hhciIsImFuY2hvciIsInRleHRGdWxsV2lkdGgiLCJmdWxsUGF0aFdpZHRoIiwic3BhY2VzTnVtYmVyIiwiaW5wdXRPZmZzZXQiLCJkeSIsImNoYXJJIiwiZ2x5cGhXaWR0aCIsInNwbGluZVN0ZXAiLCJnZXRFcXVpZGlzdGFudFBvaW50T25QYXRoIiwic2VnbWVudCIsImR5WCIsImR5WSIsImhhcyIsImdldCIsImNoYXJzIiwidGhpc1NwYWNpbmciLCJwYXJlbnRTcGFjaW5nIiwibGV0dGVyU3BhY2luZyIsInRleHRMZW4iLCJkeFN1bSIsImFjYyIsImN1ciIsImdldFBhdGhMZW5ndGgiLCJzdGFydE9mZnNldCIsIm5leHRPZmZzZXQiLCJwYXRoQ29tbWFuZHMiLCJzdGFydFgiLCJzdGFydFkiLCJuZXh0Q29tbWFuZFR5cGUiLCJjYWxjTGVuZ3RoIiwiY29tbWFuZFR5cGUiLCJnZXRMaW5lTGVuZ3RoIiwiZ2V0UG9pbnRPbkN1YmljQmV6aWVyIiwiZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllciIsImVuZCIsImluYyIsImFicyIsImdldFBvaW50T25FbGxpcHRpY2FsQXJjIiwiZ2V0UG9pbnRPbkxpbmUiLCJkaXN0IiwiZnJvbVgiLCJmcm9tWSIsIm0iLCJyaXNlIiwicHQiLCJpeCIsIml5IiwicFJpc2UiLCJwUnVuIiwiZ2V0UG9pbnRPblBhdGgiLCJkaXN0YW5jZSIsImZ1bGxMZW4iLCJjdW11bGF0aXZlUGF0aExlbmd0aCIsImN1cnJlbnRUIiwicGN0IiwicDR4IiwicDR5IiwiY29zUHNpIiwic2luUHNpIiwiYnVpbGRFcXVpZGlzdGFudENhY2hlIiwiaW5wdXRTdGVwIiwiaW5wdXRQcmVjaXNpb24iLCJwcmVjaXNpb24iLCJzdGVwIiwiZXF1aWRpc3RhbnRDYWNoZSIsInRhcmdldERpc3RhbmNlIiwiZGF0YVVyaVJlZ2V4IiwiSW1hZ2VFbGVtZW50IiwibG9hZGVkIiwiaHJlZiIsImlzU3ZnIiwiaW1hZ2VzIiwibG9hZFN2ZyIsImltYWdlIiwiY29uc29sZSIsImVycm9yIiwiYXRvYiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN2ZyIsInN1YkRvY3VtZW50IiwiY2FudmciLCJmb3JrU3RyaW5nIiwiZG9jdW1lbnRFbGVtZW50IiwiX2ltYWdlIiwiY29tcGxldGUiLCJkcmF3SW1hZ2UiLCJTeW1ib2xFbGVtZW50IiwiU1ZHRm9udExvYWRlciIsImZvbnRzIiwic3ZnRG9jdW1lbnQiLCJmb250Tm9kZSIsIlN0eWxlRWxlbWVudCIsImNzcyIsImNzc0RlZnMiLCJjc3NQYXJ0cyIsImNzc0NsYXNzZXMiLCJjc3NQcm9wcyIsImNzc0NsYXNzIiwicHJvcHMiLCJjc3NQcm9wIiwic3Vic3RyIiwic3JjcyIsInNyYyIsIlVzZUVsZW1lbnQiLCJ0ZW1wU3ZnIiwib2xkUGFyZW50IiwiZWxlbWVudFRyYW5zZm9ybSIsImNhY2hlZEVsZW1lbnQiLCJpbUdldCIsIl9oZWlnaHQiLCJyZ2JhIiwiaW1TZXQiLCJ2YWwiLCJtaSIsIm0xIiwibTIiLCJtMyIsIkZlQ29sb3JNYXRyaXhFbGVtZW50IiwiaW5jbHVkZU9wYWNpdHkiLCJfeCIsIl95Iiwic3JjRGF0YSIsImdldEltYWdlRGF0YSIsIm5yIiwibmciLCJuYiIsIm5hIiwicHV0SW1hZ2VEYXRhIiwiTWFza0VsZW1lbnQiLCJpZ25vcmVkU3R5bGVzIiwibWFza0NhbnZhcyIsIm1hc2tDdHgiLCJ0bXBDYW52YXMiLCJ0bXBDdHgiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJmaWxsUmVjdCIsIm5vb3AiLCJDbGlwUGF0aEVsZW1lbnQiLCJjb250ZXh0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIkZpbHRlckVsZW1lbnQiLCJweCIsInB5IiwiZWZkIiwiZXh0cmFGaWx0ZXJEaXN0YW5jZSIsInRtcENhbnZhc1dpZHRoIiwidG1wQ2FudmFzSGVpZ2h0IiwiRmVEcm9wU2hhZG93RWxlbWVudCIsIl93aWR0aCIsIkZlTW9ycGhvbG9neUVsZW1lbnQiLCJGZUNvbXBvc2l0ZUVsZW1lbnQiLCJGZUdhdXNzaWFuQmx1ckVsZW1lbnQiLCJibHVyUmFkaXVzIiwiYm9keSIsImdldFVuaXF1ZUlkIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJUaXRsZUVsZW1lbnQiLCJEZXNjRWxlbWVudCIsImVsZW1lbnRzIiwib3duS2V5cyQxIiwiX29iamVjdFNwcmVhZCQxIiwiX2NyZWF0ZUltYWdlIiwiYW5vbnltb3VzQ3Jvc3NPcmlnaW4iLCJjcm9zc09yaWdpbiIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfZXZlbnQiLCJfc291cmNlIiwiX2xpbmVubyIsIl9jb2xubyIsIkRvY3VtZW50IiwiZW1TaXplU3RhY2siLCJ1bmlxdWVJZCIsImJpbmRDcmVhdGVJbWFnZSIsImlzSW1hZ2VzTG9hZGVkIiwiaXNGb250c0xvYWRlZCIsImZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4iLCJjcmVhdGVEb2N1bWVudEVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIkVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGVzIiwiY29uZmlnIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJDYW52ZyIsIm9wdGlvbnMiLCJfYXJndW1lbnRzIiwiZnJvbVN0cmluZyIsImZvcmsiLCJfYXJndW1lbnRzMiIsImJhc2VPcHRpb25zIiwiZGVmYXVsdCIsInByZXNldHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.es.js\n");

/***/ })

};
;